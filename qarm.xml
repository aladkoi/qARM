<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="%Library.TqARM">
<IncludeCode>%qWORD</IncludeCode>
<Modified>0</Modified>
<ProcedureBlock>0</ProcedureBlock>
<Super>%Library.RegisteredObject</Super>
<TimeCreated>66787,41896.784433</TimeCreated>

<Property name="BLOB">
<Type>%Stream</Type>
<Internal/>
</Property>

<Property name="BLOBcs">
<Type>%Integer</Type>
<Internal/>
</Property>

<Property name="NewProperty1">
<Type>%Library.String</Type>
<Internal/>
</Property>

<Method name="Adm">
<Description>
Установка/сброс (Arg1=1/0=W("Zadm")) режима Администратор.
Если Arg1 не задан - переключение.</Description>
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I ..EndOP() Q:$Q "" Q
 I $D(Arg1) Q:W("Zadm")=+Arg1  S W("Zadm")=+Arg1 I 1
 E  S W("Zadm")='W("Zadm")
 I W("Zadm") N err D  G:$G(err) AdmNo ;@dol 25.08.03
 .I $D(qwin("Adm")) S err='qwin("Adm") Q  ;@Dol 21.05.04
 .I $TR($G(^Q(1,"XBase",0,"XBAdm"))," ")'="" Q:" "_^Q(1,"XBase",0,"XBAdm")_" "[(" "_quser_" ")  I '$D(^Q(1,"XUser",quser)) S err=1 Q
 .I $G(qruls)="" D  Q  ;@Dol 20.05.04
 ..I $D(^Q(1,"XUser"))>1 S err='qW.GG("XUser","Xsys",quser) Q
 ..I quser="#" Q  ;$D(^Q(1,"XRuls"))<10,quser="#" Q
 ..S err=1
 .I qW.GG("XUser","XRef",quser)=qruls Q:qW.GG("XUser","Xsys",quser)  S err='qW.GG("XRuls","Xsys",qruls) Q
 .Q:$G(^Q(1,"XUser",quser,"XRulsUsr",qruls,"Xsys"))  S err='qW.GG("XRuls","Xsys",qruls) Q
 ;I 'qW.GG("XUser","Xsys",quser) S Arg1=qW.GG("XUser","XRef",quser) I Arg1'="",'qW.GG("XRuls","Xsys",Arg1) G AdmNo
 D ..Message("Установлен режим: "_$S(W("Zadm"):"Администратор",$G(Vs(qqnump,"Analit")):"Аналитик",1:"Пользователь"),,2)
 D ..wwww("Ztitle")
 I $G(W("Zsform"))#10'=1 D ..wP(qwin_$S($G(W("Zsform"))<100:"",1:".T1")_".TBE","Visible",W("Zadm")) D:$G(W("Zsform"))<100 ..wcrm("P10_10p4",1,"",W("Zadm"),0) D:$G(Vt(qqnump,0))'="" ..wcrm("P7161",1,"",W("Zadm")_","_$G(Vt(qqnump,0))) ;"@dol P7161 - постоянные условия можно сбросить только в режиме Администратор
 D ..MenuView(W("Zadm")!$G(Vs(qqnump,"Analit")),1)
 D ..MenuCre(,1) ;@dol 29.06.04 D:$G(W("Zsform"))'=11 ..MenuCre(,1)
 D ..wipa() ;переинициализация шаблонов
 D ..wcro(),..wcre()
 D qSYS.MenuServ()
 ;отработка меток 30.10.06 @sasa
 I (W("Zadm")'=1),($P($G(Vo(qqnump,-1,856))," ",1)=1) d qARM.wP(qwin_".T2","TabStopClicksOnly",$S(($P(Vo(qqnump,-1,856)," ",3)'=1)!($G(W("Zadm"))=1):0,1:1))
 I (W("Zadm")=1),($P($G(Vo(qqnump,-1,856))," ",1)=1) d qARM.wP(qwin_".T2","TabStopClicksOnly",0)
 Q:$Q "" Q
AdmNo S W("Zadm")=0 D ..Message("Вход в режим Администратор закрыт") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Anal">
<Description>
Вычисление аналитик.
Arg1=0 - по значениям
Arg1=1 - по каждому слову значения.

Управляющие переменные:
Vs(qqnump, 99, "Anal") =0/1 - аналитика по значениям/словам значений
Vs(qqnump, 99, "Anal", 0) =1 - учет пустых значений
Vs(qqnump, 99, "Anal", 1)=порог экземпляров
Vs(qqnump, 99, "Anal", 2)=полное дерево</Description>
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I W("ZBt0") Q:$Q "" Q
 D ..ResetSrt()
 I '$D(Vs(qqnump,12)) D ..Message("Не определен аналитический срез") Q:$Q "" Q
 ;;;@dol 16.05.04 I $D(Vt(qqnump,111)) S %1=$P($G(Vs(qqnump,12))," ",1) I %1'="",$L($$$ObjRef(%1),",")'=1,'$D(Vt(qqnump,111,0,%1)) D ..Message("Первая аналитика должна быть выше поддерева виртуального объекта.") Q:$Q "" Q
 D:..GetPar("X1193") ..Fix("") ;@dol 10.1.04
 I '$D(Arg1) S Arg1=+$G(Vs(qqnump,99,"Anal")) I 1
 E  S Vs(qqnump,99,"Anal")=Arg1 ;D ..MenuAn("A")
 S qqftime=$P($H,",",2)
 D:qW.qAnal($G(Vs(qqnump,99,"Anal",0)),$G(Arg1),,$G(Vs(qqnump,99,"Anal",1)),,$G(Vs(qqnump,99,"Anal",2))) ..Message("Нет значений для заданного порога")
 S qqftime=$P($H,",",2)-qqftime I W("Zadm"),qqftime>3 D ..Message((qqftime\60)_":"_$E(qqftime#60+100,2,3),"Время выполнения")
 I $G(W("Zar"))'="" D qSYS.CreAr(W("Zar"))
 D:$D(qwin(qwin,"o",1,1)) ..wcrm("200_1",1,"",''$D(^Qa($S($G(W("Zar"))="":"A"_qview,1:W("Zar")))))
 D ..MenuAn("A")
 ;вывод вычисленных значений
 N qqo,qqw,qi S qqo="" F  S qqo=$O(Vs(qqnump,12,qqo)) Q:qqo=""  D:$G(Vs(qqnump,4,qqo))
 .S qqw="" F  S qqw=$O(Vs(qqnump,12,qqo,qqw)) Q:qqw=""  D
 ..D ..wM(qwin_".T1","M9",1,0,qqo_" "_qqw)
 ..F qi=5:1:11 S %2=$G(Vs(qqnump,13,0,qqo_" "_qqw_" "_qi)) S:%2'="" %2=%2_": " D ..wP(,"M1",%2_$G(Vs(qqnump,12,qqo,qqw,qi)),"",qi)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Analit">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I ..EndOP() Q:$Q "" Q
 I $G(Vs(qqnump,"Analit"))=-1!($G(W("Zsform"))&($G(W("Zsform"))'=2)&($G(W("Zsform"))<100)) D ..Message("Режим Аналитик запрещен") Q:$Q "" Q  ;если нет кнопки для запуска аналитики
 I $D(Arg1) Q:$G(Vs(qqnump,"Analit"))=+Arg1  S Vs(qqnump,"Analit")=+Arg1 I 1
 E  S Vs(qqnump,"Analit")='$G(Vs(qqnump,"Analit")) D
 .I Vs(qqnump,"Analit") D ..wM(qwin,"ShowTrees",1),..wM(qwin_".T1","SetFocus") Q  ;только объекты
 .I $E($P(..GetPar("X129"),",",3))=0 D:$G(W("Zsform"))'=11 ..wP(qwin_".TBV.b8","Down",1) D ..wM(qwin,"ShowTrees",0) Q  ;D ..wM(qwin,"s1308@") Q  ;только экземпляры
 .D ..wM(qwin,"ShowTrees",2) ;D ..wM(qwin,"s1307@")
 D ..Message("Установлен режим: "_$S(W("Zadm"):"Администратор",$G(Vs(qqnump,"Analit")):"Аналитик",1:"Пользователь"))
 D ..wwww("Ztitle"),..MenuView(W("Zadm")!$G(Vs(qqnump,"Analit")),1),..wcro(),..wcre() Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="AvtoFind">
<Description>
@Dol 20.04.09 Зпуск поиска с добавлением (или уничтожением, если оно там было) текущего понятия в поисковый образ
W("ZaFind",qqo,qqw) - для хранения текущих значений и выделения колонки в qW.gForm( wtwe )
dial=1 - диалогов поиск</Description>
<Internal/>
<FormalSpec>qqo,qqw,qqc,dial,con</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$D(qqo) D  Q:$Q $G(qqo) Q  ;действия для отображения XXXXAFind
 .I $G(qqw)=1 D  S qqo=1 Q  ;заполнение переменных в условии вывода
 ..I qqc=0 S W("Z1")=$P(W("Zcond"),"~",3,255) Q
 ..I qqc="[" S W("Z6")=$TR($P(W("Zcond"),"~",3,255),"[") Q
 ..I qqc=1 S W("Z2")=$P($P(W("Zcond"),"~",3),">>",1),W("Z3")=$P($P(W("Zcond"),"~",3),">>",2) Q
 ..I qqc="N" S W("Z3")=$P($P(W("Zcond"),"~",3),">>",1),W("Z4")=$P($P(W("Zcond"),"~",3),">>",2) Q
 .;возврат значения - вызов поиска
 .D
 ..S qqo=$$$CurObj S:qqcold'[" " qqcold=Vc(qqnumpold,"AA")
 ..S Vs(qqnump,99,"Find",5)=$G(WS(qqnumpold,"Zreg"))
 ..I qqcold[" " s dial="" Q
 ..I qqcold=0 S dial=$G(WS(qqnumpold,"Z1")) Q
 ..I qqcold=1 S dial=$G(WS(qqnumpold,"Z2"))_$S($G(WS(qqnumpold,"Z3"))="":"",1:">>"_$G(WS(qqnumpold,"Z3"))) Q
 ..I qqcold="N" S dial=$G(WS(qqnumpold,"Z4"))_$S($G(WS(qqnumpold,"Z5"))="":"",1:">>"_$G(WS(qqnumpold,"Z5"))) Q
 ..;I qqcold="[" S dial=qW.zChSym($G(WS(qqnumpold,"Z6"))," "," [") S:dial'="" dial="["_dial S:Vs(qqnump,99,"Find",5) dial=$ZCVT(dial,"U") Q
 ..I qqcold="[" S dial="" D:$G(WS(qqnumpold,"Z6"))'=""  Q 
 ...F con=1:1:$L($G(WS(qqnumpold,"Z6"))," ") S $P(dial," ",con)="...$ZCVT(ZZ,""U"")["""_qSYS.dblqw($ZCVT($P($G(WS(qqnumpold,"Z6"))," ",con),"U"))_"""",$P(W("ZaFind",qqo,qqw,2)," ",con)=$P($G(WS(qqnumpold,"Z6"))," ",con)
 .I dial="",'$P(WS(qqnumpold,"Zcond"),"~",2) Q  ;не повтор поиска
 .D qARM.Wait("D qARM.AvtoFind("""_qqo_""","""_qqw_""","""_qqc_""","""_qSYS.dblqw(dial)_""",1)",,"Поиск")
 I '$D(dial)||$G(con) S dial=$$AvtoFindD() D:$G(dial)'="" ..Message(dial) D:$G(dial)'="" AvtoFindDdel K:$G(dial)'="" W("ZaFind",qqo,qqw) D ..wpot(qqo,0),..wpot(qqo,1) Q:$Q dial Q
 S Vo("par",-1)="-"_$S('$D(W("ZaFind",qqo,qqw)):"",1:"Повторный ")_"Поиск по "_..GetName(,qqo,qqw),Vs("par","qqo")=$S(qqw[":":$P(qqw,":",1),1:qqo),Vs("par","qqw")=$S(qqw[":":$P(qqw,":",2),1:qqw) ;@Dol 18.05.09 для развертки
 S dial=$S('($D(W("ZaFind",qqo,qqw))#10):qW.GG(qqo,qqw,qqc),1:$G(W("ZaFind",qqo,qqw,2),W("ZaFind",qqo,qqw))) ;I $G(Vs(qqnump,99,"Find",5)),'$D(W("ZaFind",qqo,qqw)) S dial=$ZCVT(dial,"U")
 N x710 I $D(W("ZaFind",qqo,qqw,1)) S x710=W("ZaFind",qqo,qqw,1) I 1
 E  s x710=$G(Vo(qqnump,qqo,0,$P(W("Zpos",2,"d")," ",3),W("Zpos",2,"x"),10)),x710=$S($TR(x710,0)="":$S(dial=+dial:"N",$L(dial)>20:"[",1:0),$E(x710)=1:1,"MND"[$E(x710):"N",1:0) S W("ZaFind",qqo,qqw,1)=x710 ;I '$D(W("ZaFind",qqo,qqw)),x710="[" S dial=$E(dial,1,20)
 D qARM.Wait("D qARM.OpenWindow(,,,"""_x710_"~"_''$D(W("ZaFind",qqo,qqw))_"~"_qSYS.dblqw(dial)_""",,""XXXXAFind"")") Q:$Q "" Q
AvtoFindD()
 K Vt(qqnump,9,qqo_" "_$P(Vo(qqnump,qqo,11,qqw)," ")) ;сброс образцов в qW.gForm( wtwe )
 I '$D(W("ZaFind",qqo,qqw))||($G(dial)'="") D:$G(dial)'=""&&($D(W("ZaFind",qqo,qqw))#10) AvtoFindDdel S W("ZaFind",qqo,qqw)=$S($G(dial)'="":dial,1:qW.GG(qqo,qqw,qqc)) S:W("ZaFind",qqo,qqw)="" W("ZaFind",qqo,qqw)="=""""" S Vs(qqnump,8,qqo,qqw)=$S($G(Vs(qqnump,8,qqo,qqw))="":W("ZaFind",qqo,qqw),1:Vs(qqnump,8,qqo,qqw)_" {"_W("ZaFind",qqo,qqw)_"}") N qMessage D  Q:$Q $G(qMessage) Q
 .I '$$$ReFind D ..Find(,,,,1) Q
 .;опртимизация - в режиме уточнения поиск только по одному условию
 .N Find,fi M Find=Vs(qqnump,8) S fi="" F  S fi=$O(Vs(qqnump,8,fi)) Q:fi=""  K Vs(qqnump,8,fi) S Vs(qqnump,8,fi)=1
 .M Vs(qqnump,8,qqo,qqw)=Find(qqo,qqw) 
 .D ..Find(,,,,1) K Vs(qqnump,8) M Vs(qqnump,8)=Find
 D AvtoFindDdel
 K W("ZaFind",qqo,qqw) I '$D(Vs(qqnump,8)) D ..RecRel(0) Q:$Q "" Q  ;сброс поиска
 D:0 ..RecRel(0) D qW.gRel(0) S $$$ReFind=0,$$$RelNum=0 D ..Find() Q:$Q "" Q  ;повтор поиска
AvtoFindDdel ;удаление условия
 Q:'$D(Vs(qqnump,8,qqo,qqw))  I Vs(qqnump,8,qqo,qqw)=$G(W("ZaFind",qqo,qqw)) K Vs(qqnump,8,qqo,qqw) Q
 S Vs(qqnump,8,qqo,qqw)=$P(Vs(qqnump,8,qqo,qqw),"{"_$G(W("ZaFind",qqo,qqw))) Q
]]></Implementation>
</Method>

<Method name="ButtonDestr">
<Internal/>
<FormalSpec>qqci0:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(qqci0)="" d qARM.wM(qwin,"DestroyElements",15+32+64+128) K qwin(qwin,"FBUT"),qwin(qwin,"FCBUT") Q:$Q "" Q  ;удаление всех кнопок, рамок, текстов ; а окон
 N qqz S qqz="" F  S qqz=$O(qwin(qwin,"FCBUT",qqz)) Q:qqz=""  I $E(qwin(qwin,"FCBUT",qqz),1,$L(qqci0))=qqci0 D qARM.wM(qwin_".FCBUT"_qqz,"Destroy") K qwin(qwin,"FCBUT",qqz)
 I $D(qwin(qwin,"FBUT")) D qARM.wM(qwin_".FBUT","Destroy") K qwin(qwin,"FBUT") ;флэт-кнопка
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="ChangeMy">
<Internal/>
<FormalSpec>inpold:%Library.String,new:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.Integer</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 S inpold(0)=$G(inpold)
 S:$D(^Q(1,"XUser",qARM("Password"),"XMy"))>0 inpold=qSYS.Encrypt("inpold")
 S:$G(qARM("Password"))'="" old=$G(^Q(1,"XUser",qARM("Password"),"XMy"))
 I old=inpold S new(0)=$G(new),^Q(1,"XUser",qARM("Password"),"XMy")=qSYS.Encrypt("new") Q 1
 q 0
]]></Implementation>
</Method>

<Method name="ChgWin">
<Description>
Действия по смене окна.
Arg1=1 - сброc qqred при смене окна</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 //d qARM.Message($G(W("ZredB")))
 ;I $E(Sender)'="Q"!($P(Sender,".")="Q") D ..Message("Не окно qWORD Sender="""_Sender_""" qwin="""_qwin_""" qqnump="_qqnump) Q 2
 I $E(Sender)'="Q"!($P(Sender,".")="Q") D:$G(W("Zadm")) ..Message("Не окно qWORD Sender="""_Sender_""" qwin="""_qwin_""" qqnump="_qqnump_" ?Wait по Close") Q 1 ;@Dol 16.12.09 было 2 . Сообщение по Adm
 I '$D(qqnump)||(qqnump="P")||(qqnump="Q") S qqnump="" ;@dol 27.04.04
 I $G(W("ZredB")) D ..EditDoc() Q 1
 ;;I qqred'="" D ..EndEdit($G(W(qqred)),0) Q 1 ;@dol 28.06.04 для меню
 ;D qARM.Message("qqwchg="_qqwchg_" qqred="_qqred_" qqnump="_qqnump_" Sender="_Sender)
 I $G(qqwchg)'=""||(qqred'="") S:qqred'="" qqred="" I ..EndOP() Q 1 ;@Dol 11.09.07 qqred'="" ;
 ;@nin 02.12.2005
 N qqnumpnew,flag,qiqo,qiqn
 S qqnumpnew=$E($P(Sender,"."),2,3)
 I qqnump'="",$D(W("Zdomod"))||(..GetPar("x173")'="")||($G(qwin(qwin,"child"))'="") S flag="" D  I flag=1 Q 1
 .Q:$D(qwin(qwin,"parent",qqnumpnew))'=0  ;переход во встроенное окно
 .Q:$G(qwin(qwin,"child"))=qqnumpnew   ;переход в окно-родитель
 .S qiqn=qqnumpnew F  Q:$G(qwin("Q"_qiqn,"child"))=""  S qiqn=$G(qwin("Q"_qiqn,"child"))   ;самый первый родитель новой формы
 .S qiqo=$P(qwin,"Q",2,3) F  Q:$G(qwin("Q"_qiqo,"child"))=""  S qiqo=$G(qwin("Q"_qiqo,"child"))   ;самый первый родитель старой формы
 .Q:qiqo=qiqn  ;переход в пределах одного родителя
 .Q:..GetPar("x173",,,,,qiqo)=""&&'$D(W("Zdomod"))  D:qiqo'=qqnump ..crst(1,qiqo,2) ;@Dol 22.02.06
 .D ..TFormOnClose(qwin,,1) ;необходимо закрыть текущее окно
 .S flag=1  
 ;
 ;I qqnump'="",$D(W("Zdomod"))||(..GetPar("x173")'=""),'$D(qwin(qwin,"parent",$E($P(Sender,"."),2,3))) D ..TFormOnClose(qwin,,1) Q 1 ;необходимо закрыть текущее окно;@Dol 2.07.05 parent
 I '$D(WS($E($P(Sender,"."),2,3),"Zvars")) D ..Message("Нет локальной среды для "_Sender) Q 2
 D:$G(qqnump)'="" ..csav() D ..crst("",$E($P(Sender,"."),2,3),1)  S:$G(Arg1) qqred="" ;@dol 29.06.04 Arg1 ;;;;а если qqred'="" или нужна коррекция
 Q 0
]]></Implementation>
</Method>

<Method name="ClearCache">
<Description>
НЕ ИСПОЛЬЗУЕТСЯ</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[ D:0 ..wM("-qARM","ClearCache") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CloseLog">
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 I $G(qARM("Begin"))'="" N qq S qq=$tr($ZDT($H,8)," :","") S:$L($G(^QLog(quser,$e(qARM("Begin"),1,8))))<32700 ^QLog(quser,$e(qARM("Begin"),1,8))=qARM("ComputerName")_" "_$S($P($G(^QLog(quser,$e(qARM("Begin"),1,8)))," ",2)="":$e(qARM("Begin"),9,14)_":"_$e(qq,9,14),1:$P($G(^QLog(quser,$e(qARM("Begin"),1,8)))," ",2)_"~"_$e(qARM("Begin"),9,14)_":"_$e(qq,9,14)) K ^QLog(quser,qARM("Begin")) Q:$Q "" Q
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CloseLogANK">
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
    N tt,ttt,zddtd,i S tt=""
    IF $G(quser)="" Q
    IF ($D(^Msgg("listonline",$JOB))'=0) D
    .For i=1:1:10 D
    ..S tt=$O(^qLogJournal(quser,tt),-1)
    ..IF $G(tt)'="" S ttt=$G(^qLogJournal(quser,tt,$JOB))
    ..IF $G(ttt)="0" 
    ...S ^qLogJournal(quser,tt,$JOB)=1
    ...S zddtd=$ZDATE($HOROLOG,8)_"_"_$ZTIME($PIECE($HOROLOG,",",2))
    ...S ^qLogJournal(quser,tt,$JOB,"outd")=$P(zddtd,"_")
    ...S ^qLogJournal(quser,tt,$JOB,"outt")=$P(zddtd,"_",2)
    ...K ^Msgg("listonline",$JOB)
    ...Q
    Q
]]></Implementation>
</Method>

<Method name="CloseWindow">
<Description>
Закрытие окна экранной формы Arg1 (qqnump экранной формы).
Никаких действий но закрытию не производится
Самое первое окно закрывать нельзя (qqnump=0).

Закрытие текущего окна также возможно, будет произведено в другом событии.

Работает в развертках-действиях. Например, вызов нового окна с закрытием текущего:
N qqnumpod S qqnumpod=qqnump D qARM.OpenWindow(,,,,,xxx),qARM.CloseWindow(qqnumpold)</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $S($G(qqLastWin):0,1:Arg1=0)||('$D(qwin("Q"_Arg1))) Q:$Q 0 Q  ;нет окна или первое
 i $P($G(Sender),".")="Q"_Arg1 d qARM.wM("Q"_Arg1,"EvClose") q  ; @Dima 20090715 Закрытие текущего окна будет произведено в другом событии
 D ..csav() 
 ;D:$D(qwin("Q"_Arg1,"Timer")) ..wM("Q"_Arg1_".Timer","Destroy") D qARM.wM("Q"_Arg1,"Destroy") K qwin("Q"_Arg1)
 d Close50(Arg1)
 Q:$Q 1 Q
Close50(qqnump) D:$D(qwin("Q"_qqnump,"Timer")) ..wM("Q"_qqnump_".Timer","Destroy")
 D:$D(qwin("Q"_qqnump,"OleD",1)) ..wM(qwin_".T1","VolOleDragDropDisable")
 D:$D(qwin("Q"_qqnump,"OleD",2)) ..wM(qwin_".T2","VolOleDragDropDisable")
 I $D(qwin("Q"_qqnump,"child"))  K qwin("Q"_qwin("Q"_qqnump,"child"),"parent",qqnump) ;@Dol 24.06.05
 I $D(qwin("Q"_qqnump,"parent")) N qpp S qpp="" F  S qpp=$O(qwin("Q"_qqnump,"parent",qpp)) Q:qpp=""  D Close50(qpp) ;@Dol 24.06.05
 D ..wM("Q"_qqnump,"Destroy") K qwin("Q"_qqnump) Q
]]></Implementation>
</Method>

<Method name="ColorDialog">
<Internal/>
<FormalSpec>Sender:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 D ..Value($G(qxecuted),"X") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CopyFileToServer">
<Description>
Копирование файла с клиентской машины в файловую систему сервера.
Возврат - пустая строка, если ошибок нет, или текст ошибки.
Не работает по SSH!!!
@dima 20100827</Description>
<Internal/>
<FormalSpec>Source:%String,Dest:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 n a,glob,res s glob=$NA(^mtempCpF($J)) k @glob
 s res=qARM.wIRT("ReadFile",Source,glob,1)
 q:res'="" res 
 o Dest:("NWK\RAW\"):1
 e  k @glob q "Ошибка открытия целевого файла"
 u Dest
 s a=-1
 f  s a=$O(@glob@(a)) q:a=""  w @glob@(a)
 u $P c Dest
 k @glob
 q ""
]]></Implementation>
</Method>

<Method name="Create">
<Internal/>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    $$$FEvent
    /*
    S qARM=##class(%TqARM).%New()
    S qWEB=##class(%qWEB).%New()
    S qSYS=##class(%qSYS).%New()
    S qW=##class(%qWORD).%New()
    */
    ;@pav 17.11.2010 -> InstSysClass()
    d ..InstSysClass()
    
    K WQ ;???временно (нужно использовать qwin) флаговый масссив созданных  дополнительных окон и меню
    K WS,W,qwin,qprotstr,qqCEKey S qwin=""
    S length=10000 ;@dima 20090428 5000->10000. Больше 16k делать не следует!
    s qARM("NAMESPACE")=$ZU(67,6,$J) ;dima 20100210 исп. в макросе $$$FEvent
    D qSYS.BaseIni()
    q:$G(updfExitFlag) "" ; @dima 20.03.08 немедленный выход по флагу (для обновления файлов при старой версии qARMProj)
    
    ; 20110325 tdv - очистка файлов в рабочей директории по маске "*.xml;*.xsl;*.htm*;*.doc;*.xls;*.od*;*.bmp;*.jp*;*.gif;*.png" 
    ; qqXBPrtKeepDays - количество дней хранения файлов
    I $G(qqXBPrtDelFiles) D qARM.wM("-qARM","DeleteFiles","","",$S(($G(qqXBPrtKeepDays)?1.N)&&(+qqXBPrtKeepDays):+qqXBPrtKeepDays,1:1),1)
    
    ;sas инициализация пользовательских классов и создание пользовательских классов перенесено сюда, чтобы сработало X ^("XBLg") или сформировался ^Q
    I '$D(^Q) D  I $G(qARM("Password"))="" D ..wM("-qARM","Terminate") Q:$Q "" Q  ;начальная установка пустой базы
    .I $G(qARM("Password"))=""!($P($G(qARM("Password"))," ",2)'="#")!($P($G(qARM("Password"))," ",1)="") K qARM("Password") D ..Message("Попытка незаконной начальной установки") Q
    .D qSYS.QView() S ^Q=$H
    .I '$D(^Q(1,"XView",$P(qARM("Password")," "))) S ^Q(1,"XView",$P(qARM("Password")," "),"CxObj",-1,"Xy",0,"Xx",0,"x70")=0 ;создание пустого отображения
    .//I '$D(^oddDEF("User.qUSER")) S ^oddDEF("User.qUSER","spec","name")="User.qUSER",^oddDEF("User.qUSER","spec","super")="%Library.qARM" D Compile^%apiOBJ("User.qUSER") ;Создание и компиляция класса qUSER
    .I '$D(^oddDEF("User.qUSER")) N Xcls S Xcls("User.qUSER",0)="%Library.RegisteredObject",Xcls("User.qUSER",1)="%qWORD" D setClss^%GMan00x7(.Xcls),cmpClss^%GMan00x7(.Xcls) K Xcls ; tdv 14.4.06 Создание и компиляция класса qUSER
    
    I '$D(^oddDEF("User.qUSER")) N Xcls S Xcls("User.qUSER",0)="%Library.RegisteredObject",Xcls("User.qUSER",1)="%qWORD" D setClss^%GMan00x7(.Xcls),cmpClss^%GMan00x7(.Xcls) K Xcls ; Создание и компиляция класса qUSER
    D ..UserClass() ;инициализация пользовательских классов
    
    ;@Sas 20090410 Пароль и журнал регистрации должен быть здесь
    s qqnump=0 
    I $G(qARM("Password"))'="" N error,qqp6 D  I $G(error) Q:$Q "" Q
    .I $G(^Q(1,"XBase",0,"XBLg"))'="" X ^("XBLg") K:$G(error)'=0 qARM("Password") Q:$G(error)'=0  ;@dol 19.05.04
    .S qqp6=qARM("Password") S:$P($G(qARM("Pars",2)),"~")'="" qqp6=$P(qARM("Pars",2),"~")_" "_qqp6 D  K qARM("Password")
    ..I $L(qqp6," ")>1 S quser=$P(qqp6," ",2),qqp6=$P(qqp6," ") Q
    ..S quser=qqp6,qqp6=""
    .S:qW.GG("XBase","XFpw",0) quser=$TR($ZCVT(quser,"U"),"ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ","QWERTYUIOP[]ASDFGHJKL;'ZXCVBNM,.") ;упрощенный пароль
    .I $S(quser="":1,quser="#"&($D(^Q(1,"XUser"))<10):0,quser="U":0,1:'$D(^Q(1,"XUser",quser))) D ..Message("Незарегистрированный пользователь"),..wM("-qARM","Terminate") S error=1 Q
    .I $D(^Q(1,"XUser",quser,"XRulsUsr"))>1 S qruls=$P($G(qARM("Pars",2)),"~",2) I $S(qruls="":1,1:qW.GG("XUser","XRef",quser)'=qruls) D  Q  ;есть несколько ролей и задана неосновная
    ..I qqp6="",qruls="" S qqp6=$S($G(qqp66)'="":qqp66,1:"XXXRulsCh") Q  ;вызов окна выбора Роли
    ..I qruls=""||'$D(^Q(1,"XUser",quser,"XRulsUsr",qruls)) D ..Message($S(qruls="":"Отсутствует",1:"Незарегистрированная")_" роль"),..wM("-qARM","Terminate") S error=1 Q
    ..N i,qq K qARM("Pars",2) F i=2:1:6 D:$G(qARM("Pars",i))=""
    ...S qq=$G(^Q(1,"XUser",quser,"XRulsUsr",qruls,$S(i=2:"XView",1:"Xpar"_i))) I qq'="" S qARM("Pars",i)=qq Q
    ...S qq=qW.GG("XRuls",$S(i=2:"XView",1:"Xpar"_i),qruls) I qq'="" S qARM("Pars",i)=qq Q
    ..S:qqp6="" qqp6=$P($G(qARM("Pars",2)),"~")
    .S:qqp6="" qqp6=qW.GG("XUser","XView",quser) S qruls=qW.GG("XUser","XRef",quser) I qqp6="" S:qruls'="" qqp6=qW.GG("XRuls","XView",qruls) Q:qqp6=""  ;нет отображения
    .S qARM("Pars",2)=qqp6 N i,qq F i=3:1:6 D:$G(qARM("Pars",i))=""
    ..S qq=qW.GG("XUser","Xpar"_i,quser) I qq'="" S qARM("Pars",i)=qq Q
    ..Q:qruls=""  S qq=qW.GG("XRuls","Xpar"_i,qruls) I qq'="" S qARM("Pars",i)=qq Q
    
    N error D  I $G(error) Q:$Q "" Q  ;Запись регистрации
    .I $G(qARM("My"))="%%CANCEL" D ..wM("-qARM","Terminate") S error=1 q
    .I $G(quser)="" S error=1 D ..Message("Не введен пользователь"),..wM("-qARM","Terminate") q
    .I $G(qARM("My"))="%%NEWMY" I $G(quser)="#" D ..Message("Пароль для пользователя # не заводится"),..wM("-qARM","Terminate") S error=1 q
    .I $G(qARM("My"))="%%NEWMY" S error=1 S qARM("Password")=quser d qARM.wC("TNewMy","NEWMYOBJ","Смена пароля пользователя "_quser),qARM.wM(,"Destroy"),..wM("-qARM","Terminate") q
    .I $G(qARM("My"))'="%%NEWMY" i $G(qARM("My"))'="" S qARM("My",0)=$G(qARM("My")) i $G(^Q(1,"XUser",quser,"XMy"))'=qSYS.Encrypt("qARM(""My"")") D ..Message("Неверный пароль"),..wM("-qARM","Terminate") s error=1 q
    .I $G(qARM("My"))'="%%NEWMY" i $D(^Q(1,"XUser",quser,"XMy"))>0 S qARM("My",0)=$G(qARM("My")) i $G(^Q(1,"XUser",quser,"XMy"))'=qSYS.Encrypt("qARM(""My"")") D ..Message("Неверный пароль"),..wM("-qARM","Terminate") s error=1 q
    k qqnump
    
    ;Массив qARM создается при старте клиентской части
    S qqscrfont="8,7,7" ;размер фонта ? нужно где-то брать
    ;
    D ..wM("-qARM","qInit") ;инициализация ТBitmap
    ;
    D ..wC("TBitmap","dBob"),..wM("dBob","LoadFromRes",194) ;зачеркнутый шарик понятий
    D ..wC("TBitmap","bu9"),..wM("bu9","LoadFromRes",$P($G(^Q(1,"XBase",0,"XPbut9"),"R,116"),",",2)) ;@dol 26.09.02 картинка псевдокнопки (было 208)
    D:$G(qqXBf)'="" ..wM("Flg0","LoadFromRes",$P($P(qqXBf," ",1),",",2)),..wM("Flg1","LoadFromRes",$P($P(qqXBf," ",2),",",2)) ;@Dol 16.08.05 ресурсы флага
    ;
    D ..wP("-qARM","ARMEventCacheClass",1) ;1 - устанавливает флаг использвания методов класса (0 - вызов strt^%qg999)
    I '..ProjVerNotOlder(5,11,3,38) D ..Message("Для корректной работы с данной версией системных классов"_$C(13)_"требуется версия qARM.exe не ниже 5.11.3.38 (11.03.2011)") ; @dima
    ;
    /*sas 20090410
    I '$D(^Q) D  I $G(qARM("Password"))="" D ..wM("-qARM","Terminate") Q:$Q "" Q  ;начальная установка пустой базы
    .I $G(qARM("Password"))=""!($P($G(qARM("Password"))," ",2)'="#")!($P($G(qARM("Password"))," ",1)="") K qARM("Password") D ..Message("Попытка незаконной начальной установки") Q
    .D qSYS.QView() S ^Q=$H
    .I '$D(^Q(1,"XView",$P(qARM("Password")," "))) S ^Q(1,"XView",$P(qARM("Password")," "),"CxObj",-1,"Xy",0,"Xx",0,"x70")=0 ;создание пустого отображения
    .//I '$D(^oddDEF("User.qUSER")) S ^oddDEF("User.qUSER","spec","name")="User.qUSER",^oddDEF("User.qUSER","spec","super")="%Library.qARM" D Compile^%apiOBJ("User.qUSER") ;Создание и компиляция класса qUSER
    .I '$D(^oddDEF("User.qUSER")) N Xcls S Xcls("User.qUSER",0)="%Library.RegisteredObject",Xcls("User.qUSER",1)="%qWORD" D setClss^%GMan00x7(.Xcls),cmpClss^%GMan00x7(.Xcls) K Xcls ; tdv 14.4.06 Создание и компиляция класса qUSER
    //I $ZV'["GT.M",'$D(^oddDEF("User.qUSER")) S ^oddDEF("User.qUSER","spec","name")="User.qUSER",^oddDEF("User.qUSER","spec","super")="%Library.qARM" D Compile^%apiOBJ("User.qUSER") ;@Ninel 23.07.04 Создание и компиляция класса qUSER
    
    I '$D(^oddDEF("User.qUSER")) N Xcls S Xcls("User.qUSER",0)="%Library.RegisteredObject",Xcls("User.qUSER",1)="%qWORD" D setClss^%GMan00x7(.Xcls),cmpClss^%GMan00x7(.Xcls) K Xcls ; tdv 14.4.06 Создание и компиляция класса qUSER
    ;
    D ..UserClass() ;@Dol 20.04.05 инициализация пользовательских классов
    */
    ;Проверка обновлений
    N qqLasT I $G(^Q(1,"XView","XXXX"),1)'=$G(^%QView) S qqLasT=$ZD(+$G(^Q(1,"XView","XXXX")),8) D qSYS.QView(,1) S ^Q(1,"XView","XXXX","Rnote")=qqLasT ;предыдущее обновление
    ;
    I $E($P($G(qARM("Password"))," "),4,255)["qq" D  Q:$Q "" Q
    .N qqp6 S qqp6=$G(qARM("Password")) S:$G(qARM("Pars",2))'="" qqp6=qARM("Pars",2)_" "_qqp6 S quser=$P(qqp6," ",2) K qARM("Password")
    .D qWEB.Query($P(qqp6," "),,,,,,1)
    I $E($G(qARM("Password")),1,4)="%GOF" S %1=$E(qARM("Password"),5,1000),%1=qSYS.SaveMas($P(%1,";"),$P(%1,";",2)) D:%1'="" ..Message(%1) D ..wM("-qARM","Terminate") Q:$Q "" Q  ;копирование массивов
    ;
    ;I $G(qARM("Pars",9))'="" X qARM("Pars",9) I $G(qqend)=1 Q:$Q "" Q  ;@dol 7.10.04 сразу выход ;;;действие по запуску приложения (если будет qqend=1 - окно не запускать)
 
    S:$G(^Q(1,"XBase",0,"XFJrn")) qJRN=1 ;включение журналирования
    
    ;запуск синхронизации
    S %1=$G(^Q(1,"XBase",0,"XFSendJrn")),%2=$G(^Q(1,"XBase",0,"XFResivJrn")) I %1!%2 S %3=qSYS.SynJrn(%1,%2) ; misuno 20080806 D:%3'="" qARM.Message(%3,"Синхронизация")
    ;
    
    ; @dima 09.09.04
    ;I $G(qARM("GateWay"))="127.0.0.1" d
    ;.n d,i,dd s d="|TCP|" f i=7000:1:65000 s dd=d_i o dd:(::::32767):0 i  c:0 dd q  ;o %qGWd:(::::32767) o dd::0
    ;.i  D ..wM("-qARM","GateWayRun",$P($P(qARM("CntStr"),":",2),"["),i) s %qGWdp=i
    ;.e  D ..Message("GateWay не запущен")
    I $G(qARM("GateWay"))="127.0.0.1" d
    .i '($ZV["GT.M") d
    ..n d,i,dd s d="|TCP|" f i=7000:1:65000 s dd=d_i x "o dd:(::::32767:16384):0" i  c:0 dd q  ;o %qGWd:(::::32767) o dd::0
    ..i  D ..wM("-qARM","GateWayRun",$P($P(qARM("CntStr"),":",2),"["),i) s %qGWdp=i,%qGWd=dd
    ..e  D ..Message("GateWay не запущен")
    .i ($ZV["GT.M") d
    ..n i s %qGWd="GWS$"_$J,%qGPri=$IO f i=7000:1:65000 o %qGWd:(ZLISTEN=i_":TCP":ATTACH="server":ZBFSIZE=32767:ZFF=$C(12)):0:"SOCKET" i  q
    ..i  D ..wM("-qARM","GateWayRun",$P($P(qARM("CntStr"),":",2),"["),i) s %qGWdp=i d ..Wait("u %qGWd w /L(1) w /W(15) u %qGPri",1) i 1
    ..e  D ..Message("GateWay не запущен")
  
    ;@Dim 26.10.07 Terminate в Wait, чтобы возможный Wait в Par9 сработал раньше
    ;@Pav Если в par9 действие, работающее с GateWay, то это действие необходимо запускать в Wait
    I $G(qARM("Pars",9))'="" X qARM("Pars",9) I $G(qqend)=1 d qARM.Wait("d qARM.wM(""-qARM"",""Terminate"")") Q:$Q "" Q  ;@dol 7.10.04 сразу выход ;;;действие по запуску приложения (если будет qqend=1 - окно не запускать)
 
    ;;sas 20090408
    I $G(^Q(1,"XBase",0,"XMCrUser"))'="" s qqnump=0 X $G(^Q(1,"XBase",0,"XMCrUser")) k qqnump
    I '$G(qqend),$TR($P($G(qqX155),",",1,2),",08")'="" D ..qARMFont() ;@Dima&Dol 24.07.09
    D:'$G(qqend) qARM.OpenWindow(,0)
    ;вывод системных замечаний по реализации ;@dol 19.03.03 ;;@Dol 10.02.08 - перенесено в проводник
    ;;D:$G(qqLasT)'="" qARM.OpenWindow(,,",,0,1 1 20",qqLasT_" XDocRN1",,"XXXRNw") ;@Dol 24.03.06 XXXRNw сделано на массиве вместо Логического дерева
    ;для инициализации - OLGAS 25.08.03
    i $d(^QSes("mseinit",2)) d qARM.OpenWindow(,,,,,"orgList")
    // пользовательское действие при старте приложения - TDV 11.02.2005
    ;;X $G(^Q(1,"XBase",0,"XMCrUser"))
    Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="DoPaObj">
<Description>
Действие  в контексте объекта-предка Obj текущего объекта. Объект должен существовать в отображении.
Возврашает 1, если действие выполнилось (найден предок), иначе - 0.
Предназначено для использования в постдействиях (X5240).

Mod="X" - выполнение str по Xcute
Mod="W" - перевывод списка понятий (через пробел) str. Элемент списка:
qqw - код понятия;
qqw=выражение - присвоить результат выражения;
qqw=@ - присвоить значение по умолчанию.
Если происходит присваивание, то автоматическая коррекция.</Description>
<Internal/>
<FormalSpec>Obj:%Library.String,Mod:%Library.String,Str:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqo,qqc,qqcurobj,qqci,qqcii,end S end=0,qqcurobj=$$$CurObj,qqci=Vc(qqnump)
 F qqcii=$L(qqci):-2:2 S qqo=Vc(qqnump,$E(qqci,1,qqcii),0) I qqo=Obj S end=1,$$$CurObj=qqo,Vc(qqnump)=$E(qqci,1,qqcii),qqc=Vc(qqnump,Vc(qqnump)) D  Q
 .I Mod="X" X Str Q
 .I Mod="W" D  Q
 ..N qqw,qqwi,do,qqwlist,qqwlistc S (qqwlistc,qqwlist)="" F  D  Q:Str=""
 ...F qqwi=1:1:$L(Str," ") Q:$L($P(Str," ",1,qqwi),"""")#2
 ...S do=$P(Str," ",1,qqwi),Str=$P(Str," ",qqwi+1,10000)
 ...S qqw=$P(do,"="),do=$P(do,"=",2,1000)
 ...I do="" S qqwlist=qqwlist_" "_qqw Q
 ...I do="@" S do=..GetPar("X75",,qqo,qqw) S:$E(do)="@" @("do="_$E(do,2,1000)) I 1
 ...E  S @("do="_do)
 ...I "@Z"'[$E(qqw),qqw'[":" S W(qqw)=qW.G(qqw) Q:W(qqw)=do  S W(qqw)=do,qqwlistc=qqwlistc_" "_qqw ;???Y-понятия
 ...S qqwlist=qqwlist_" "_qqw
 ..D:qqwlistc'="" qW.rCor(qqo,qqc,$E(qqwlistc,2,1000),,0) D:qqwlist'=""  D qARM.wwww($E(qqwlist,2,1000))
 I end S $$$CurObj=qqcurobj,Vc(qqnump)=qqci Q:$Q 1 Q
 Q:$Q 0 Q
]]></Implementation>
</Method>

<Method name="EditDoc">
<Description>
           Завершение редактирования документа.</Description>
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 G:$G(Arg1) EditDocRead
 I '$P(W("ZredB")," ",3) K W("ZredB") Q:$Q 1 Q
 //sas 20090601
 i $P(W("ZredB")," ",2)["QVWordpad" K W("ZredB") Q:$Q 1 Q
 S $P(W("ZredB")," ")=2 ;признак будет показывать, что текст уже в массиве
 D ..wM("-qARM","BufferClear"),..wM($P(W("ZredB")," ",2),"Save"),..wM($P(W("ZredB")," ",2),"Destroy")
 I $P(W("ZredB")," ",3)=1 D ..Question("Сохранить изменения",1,"d:0 qARM.wM("""_$P(W("ZredB")," ",2)_""",""Destroy"") k qwin("""_$P(W("ZredB")," ",2)_"""),W(""ZredB"")","D qARM.wM(""-qARM"",""BufferOut"",$P(W(""ZredB""),"" "",4)),qARM.Wait(""D qARM.EditDoc(1)"")") Q:$Q "" Q
 D ..wM("-qARM","BufferOut",$P(W("ZredB")," ",4)),..Wait("D qARM.EditDoc(1)") Q ""
EditDocRead
 I ..EndEdit(,,1) S W("ZredB")="1 "_$P(W("ZredB")," ",2,4) Q:$Q "" Q  ;рестарт редактирования
 ;D ..wM($P(W("ZredB")," ",2),"Destroy")
 k qwin($P(W("ZredB")," ",2)),W("ZredB") S qqred="" ;;D ..wwww(qqw) ;@Dol 15.11.06 лишний перевывод. Катастрофичен в варианте формирования строк
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="EditDocRE">
<Description>
Завершение редактирования документа в новом RichEdit @sas 20091006.</Description>
<Internal/>
<FormalSpec>Arg1:%String,rtf:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N ii,iii,iiii,rtf,tag,sss,ci,tagp,beg,end,ttt,qqred
 s qqred=$TR($p(W("ZredB")," ",5),"")
 
 i qqred="" k W("ZredB") q ""
 
 ;;правильная обработка неизмененного текста
 i '$D(MasTxT) K W("ZredB") S qqred="" Q ""  
 
 K W(qqred) S rtf=$P(W("ZredB")," ",6)

 ;вставлена проверка, если текст уже xml, не надо резать 0 строку
 I rtf i MasTxT(0)["\viewkind4" S MasTxT(0)=$P(MasTxT(0),"\viewkind4",2,225) S:$E(MasTxT(0),1)=" " $E(MasTxT(0),1)="" S ii=$O(MasTxT("")),MasTxT(ii)=$E(MasTxT(ii),1,$L(MasTxT(ii))-1) ;отсечем заголовок и закрывающую скобку
 S iiii=-1,tag=0 F ii=0:1 Q:'$D(MasTxT(ii))  F iii=1:1:$L(MasTxT(ii),$C(13,10)) D
 .I 'rtf S W(qqred,$I(iiii))=$P(MasTxT(ii),$C(13,10),iii) Q
 .S ss=$P(MasTxT(ii),$C(13,10),iii),sss=ss_$C(1)[("\par"_$C(1)) ;уберем лишний \par перед $C(13,10)
 .S:'tag W(qqred,$I(iiii))=$S('sss:ss,1:$E(ss,1,$L(ss)-4))
 .S:tag W(qqred,iiii)=W(qqred,iiii)_$S('sss:ss,1:$E(ss,1,$L(ss)-4)) S tag='sss
 
 
 S:'$D(qqConvXMLRTF) qqConvXMLRTF=$LB("b","<b>","b0","</b>","i","<i>","i0","</i>","ul","<u>","ulnone","</u>","qc","<p_align='center'>","","</p>","qr","<p_align='right'>","","</p>","ql","<p_align='left'>","","</p>","sub","<sub>","nosupersub","</sub>","super","<sup>","nosupersub","</sup>","","<br>","\par","</br>")
  
 D:rtf=2  ;XML
 .;qqConvXMLRTF см в qW.CRTF
 .F ii=0:1 Q:'$D(W(qqred,ii))  D
 ..S sss="",ss=W(qqred,ii),tagp="",beg="",end="" K ttt F  S iii=$F(ss,"\") Q:'iii  D
 ...I $TR($E(ss,iii),"{}\")="" S sss=sss_$E(ss,1,iii-2)_$E(ss,iii),ss=$E(ss,iii+1,30000) Q
 ...S sss=sss_$E(ss,1,iii-2),ss=$E(ss,iii,30000),tag=$P($TR(ss,"\}{ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮЁйцукенгшщзхъфывапролджэячсмитьбюё","                                                                                ")," ")
 ...S ss=$E(ss,$E(ss,$L(tag)+1)=" "+$L(tag)+1,30000)
 ...S ci=$LF(qqConvXMLRTF,tag)  Q:'ci  ;'ci S sss=sss_"\"_tag Q
 ...I " qc qr ql "[(" "_tag_" ") S beg=ci Q  ;цент, лево в начало строки
 ...I " super sub "[(" "_tag_" ") S tagp=tag
 ...I ci#4=1 D  Q
 ....D OnTreeRs() S ttt($I(ttt))=ci+2 I ss[("\"_$LI(qqConvXMLRTF,ci+2)) Q  ;есть завершающий
 ....S ss=ss_"\"_$LI(qqConvXMLRTF,ci+2) ;нет - добавим в конец строки
 ...I $S('$G(ttt):1,tag="nosupersub":tagp="",1:sss'[$LI(qqConvXMLRTF,ci-1)) Q  ;нет начального тега
 ...I $I(ttt,-1),ttt(ttt+1)'=ci S end=$S(tag'="nosupersub":$LI(qqConvXMLRTF,ci+1),tagp'="":$LI(qqConvXMLRTF,$LF(qqConvXMLRTF,tagp)+3),1:"")_end Q  ;неверный порядок тегов
 ...I tag="nosupersub" D:tagp'="" OnTreeRs($LI(qqConvXMLRTF,$LF(qqConvXMLRTF,tagp)+3),end) S end="" Q  ;спец.случай - общий завершающий тег
 ...D OnTreeRs(,end) S end="" Q
 ..S W(qqred,ii)=sss_ss I beg'="" S W(qqred,ii)=$LI(qqConvXMLRTF,beg+1)_$S($E(W(qqred,ii))=" ":"",1:" ")_W(qqred,ii)_$S($E(W(qqred,ii),$L(W(qqred,ii)))=" ":"",1:" ")_"</p>" 
 
 k MasTxT
 ;;i '$D(W(qqred)) m W(qqred)=MasTxT
 n qqstr,wredRE,Value
 ;;s wredRE=$TR($p(W("ZredB")," ",4),"") ;;,Value=$S(W(qqred,0)'="":"W(qqred)",1:"MasTxT")
 ;k @wredRE
 ;m @wredRE=W(qqred)
 I ..EndEdit()
 K W("ZredB") S qqred=""
 Q:$Q "" Q
OnTreeRs(tagpp,eee) S:$G(eee)'="" ss=eee_ss S sss=sss_$S(sss="":"",$E(sss,$L(sss))=" ":"",1:" ")_$S($D(tagpp):tagpp,1:$LI(qqConvXMLRTF,ci+1))_$S(ss="":"",$E(ss)=" ":"",1:" ") Q
 ///????eee
]]></Implementation>
</Method>

<Method name="EditTest">
<Description>
Проверка допустимости коррекции.</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqw:%Library.String,NoMes:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ;запрет коррекции для отображения ;;@Dol 26.05.04 переделан для добавления условия из роли
 ;; @Dol 25.03.10 блокирован автопоиск по двойному щелчку - оказалось не очень удобно ;I $G(qqdbl),..GetPar("X1201")  D:0 qARM.Wait("D qARM.AvtoFind("""_qqo_""","""_qqw_""","""_qqc_""")",,"Поиск") D qARM.AvtoFind(qqo,qqw,qqc) K qqwold Q:$Q 0 Q  ;@Dol 21.04.09 Автопоиск
 N end
 I '$D(Vo(qqnump,-1,85)) S Vo(qqnump,-1,85)=..GetPar("X185") I $G(qruls)'="",$D(^Q(1,"XRuls",qruls,"XViewStat",Vo(qqnump),"Ref2")) S Vo(qqnump,-1,850)=^("Ref2") ;@22.07.03 с учетом роли
 I Vo(qqnump,-1,85)'="",$G(Vo(qqnump,-1,850))'="","&!|"[$E(Vo(qqnump,-1,850)) S end=..Value(Vo(qqnump,-1,85)_Vo(qqnump,-1,850)) G:$E(end)'=0&&(end'="") EditTmes G EditTob
 I Vo(qqnump,-1,85)'="" S end=..Value(Vo(qqnump,-1,85)) I $E(end)'=0,end'=""  G EditTmes
 I $G(Vo(qqnump,-1,850))'="" S end=Vo(qqnump,-1,850),end=$S("&!|"'[$E(end):end,"|&"[$E(end,2):$E(end,3,30000),1:$E(end,2,30000)),end=..Value(end) I $E(end)'=0,end'=""  G EditTmes ;по роли
 ;для объекта
EditTob I '$D(Vo(qqnump,qqo,35)) S Vo(qqnump,qqo,35)=..GetPar("X535",,qqo) I $G(qruls)'="",$D(^Q(1,"XRuls",qruls,"XViewStat",$S($G(Vo(qqnump,qqo,889))'="":Vo(qqnump,qqo,889),1:Vo(qqnump)),"CxObj",qqo,"Ref2")) S Vo(qqnump,qqo,350)=^("Ref2") ;@22.07.03 с учетом роли
 I Vo(qqnump,qqo,35)'="",$G(Vo(qqnump,qqo,350))'="","&!|"[$E(Vo(qqnump,qqo,350)) S end=..Value(Vo(qqnump,qqo,35)_Vo(qqnump,qqo,350)) G:$E(end)'=0&&(end'="") EditTmes Q:$Q 0 Q
 I Vo(qqnump,qqo,35)'="" S end=..Value(Vo(qqnump,qqo,35)) I $E(end)'=0,end'=""  G EditTmes
 I $G(Vo(qqnump,qqo,350))'="" S end=Vo(qqnump,qqo,350),end=$S("&!|"'[$E(end):end,"|&"[$E(end,2):$E(end,3,30000),1:$E(end,2,30000)),end=..Value(end) I $E(end)'=0,end'=""  G EditTmes
 Q:$Q 0 Q
EditTmes D:'$G(NoMes)&(end'=2) ..Message($S($L(end)=1:"Коррекция запрещена",1:end),,,$G(qqXBMesTime)) Q:$Q 1 Q  ;@Dol 24.20.07 ,,,10) - всплывающее окно
]]></Implementation>
</Method>

<Method name="EditText">
<Internal/>
<FormalSpec>Sender:%String,Text:%String,Button:%Integer</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 ;D ..wP("MesForm","Destroy")
 ;D ..wP("MesForm","Visible",0) ;D:$G(qxecute1)'="" ..Value(qxecute1,"X")
 I Button'=0 Q:$Q "" Q  ;Cancel
 D:$G(qxecute1)'="" ..Value(qxecute1,"X") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="EndEdit">
<Description>
Завершение редактирования.
qqstr - редактируемое значение
qqkey - код клавиши завершения
Arg1=1 - блокировка перехода к следующему понятию
Arg2=1 - блокировка AfterEdit для навесных элементов
Nowr=1 - запрет перевывода @Dol 27.01.09
redqqw - код понятия для программного вызова действия по завершению редактирования (например, из пункта меню) ;@Dol 03.08.09</Description>
<Internal/>
<FormalSpec>qqstr:%String,qqkey:%String,Arg1:%Library.String,Arg2:%Library.String,Nowr,redqqw</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qqdat,qqx,qqy,qqtr,qqwred ;@dol 3.2.04 добавлен анализ qqkey при переходах (можно только по Enter?)
 S:$G(redqqw)'="" qqred=redqqw ;@Dol 03.08.09
 K W("Zpdrl") ;развертка по большому словарю выключена
 K W("Zederr") ;флаг для отлова ESC
 S qqkey=$G(qqkey),qqtr=qqred'="ZfI9"+1 ;номер дерева (в дереве 1 всегда редактируемое понятие ZfI9)
 S qqdat=$G(W("Zpos",qqtr,"d")),qqx=+$G(W("Zpos",qqtr,"x")),qqy=+$G(W("Zpos",qqtr,"y"))
 I qqtr=1 S %1=$$wz631(qqstr,qqkey) D:%1=""&('W("ZBt0")) ..wM(qwin_".T1","M9",1,0,qqdat,1) I 1 ;@Dol 15.10.08 остаться на текущей строке в дереве объектов ;;;$$$CurObj,1) I 1
 E  S %1=$$wz632($G(qqstr),qqkey) d:$D(Vt(qqnump,9,"FCBUT")) ..wM(qwin,"Vol_ArrayElementPaint") ;@dol 7.11.04 перерисовка кнопок
 S:qqkey=0 qqkey=13 ;@Dol 19/19/06 выход из экранных разверток
 I %1="" G:($P($G(Vo(qqnump,-1,856))," ",1)=1)&&(qqkey'=120) MetTab G:qqtr=1 EndEd0 G:$G(Arg1)||(..GetPar("X179")=2)||('$G(qqkey)) EndEd0 D  G EndEd0 ;@dol 14.03.03 после редактирования - встали на следующее понятие  ;;вставка 03.10.06 @Sasha MetTab @sas+dim &&(qqkey'=120)
 .I $S(qqkey=9:0,..GetPar("X179")=1:0,1:1) D qARM.NextEdit($S(qqkey=120:"-",1:"")_qqwred,1) Q  ;@Dol 15.04.07 @sas 20081212 не работало открытие развертки по понятию из редактируемой ячейки по F9, происходило открытие развертки по следующему понятию
 .;;I $S(qqkey=9:0,..GetPar("X179")=1:0,1:1) D qARM.NextEdit(qqwred,1) Q  ;@Dol 15.04.07
 .I $P($G(qARM("Ver","qARMProj1.ocx")),".",2)>4 D qARM.NextEdit(qqwred) Q
 .D ..Wait("D qARM.NextEdit("""_qqwred_""")")
 I %1=-1 D:$G(qwin(qwin,"child"))'=""  S:$D(W("Zdomod")) W("Zdomod")=2 S:..GetPar("x173")'="" Vo(qqnump,-1,73)=2 D ..wM(qwin,"EvClose") G EndEd0 ;Выход из экрана
 .D qARM.GetBqqnump(1) ;@Dol 14.01.08 переход в базовое окно
 I qqtr=2,$E(%1)?1N G:%1="3-"||$G(Arg1) EndEd0 N qNx S qNx=%1 G:$S(+qNx'=1:0,1:..EndOP()) EndEd1 G:$D(String)||($G(qqkey)'=9&&($G(qqkey)'=13)) EndEd0 G:$S(qNx'[":":0,+qNx=1:0,1:..EndOP()) EndEd1 Q:$S(qNx'[":":0,1:'..Obj($P($E(qNx,2,255),":"))) 1 S:qNx[":" qNx=$E(qNx)_$P(qNx,":",2) S:qNx=1&&('..GetPar("X179")) qNx=3 G:$E(qNx,2,255)'=""||(+qNx=2)||(+qNx=3) EndEdN G:($P($G(Vo(qqnump,-1,856))," ",1)=1) MetTab G EndEd0 ;@Dol 2.08.02 немедленнная запись измененных значений @dol 16.02.03 и переход к редактированию заданного/следующего понятия ;;вставка 03.10.06 @Sasha MetTab
 ;ненормальное завершение - выдача сообщения и позиционирование на старое место 
 ;S W("Zederr")=1 
 I +W("Zcdrl")=6 D ..Message(%1,,,$G(qqXBMesTime)) G EndEd1 ;внешний текст ?????
 I $D(String) S W("Zederr")=1 D ..Wait("D qARM.Message("""_qSYS.dblqw(%1)_""",,,$G(qqXBMesTime)) K W(""Zederr"") S (qqw,qqred)="""_qqred_""" D qARM.wpoe("""_qqdat_"""),qARM.wfoc("_qqtr_","""","_qqx_","""_qqdat_""")") G EndEd1 ;@Dol 24.11.06 вставлен ..Wait вместо Cancel=1 в ..OnAfterEdit
 ;;'$D(String) - не из AfterEdit
 I qqtr=2,$P(W("Zcdrl")," ",2)=1&(+W("Zcdrl")'=3) D ..Message(%1,,,$G(qqXBMesTime)) N qqw S qqw=qqred,W(qqw)=qW.GG($P(qqdat," ",2),qqw,qqc),qqred="" D ..wwww(qqw) G EndEd1 ;если только развертка ?;@Dol 27.04.06 Убрано $P(W("Zcdrl")," ",2)=1&(+W("Zcdrl")'=3) - появилась развертка-календарь
 ;S W("Zederr")=1
 ;I qqtr=2,$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqx,44))'="",Key<0 D ..Message(%1) D ..OpenTimer(200,"S (qqw,qqred)="""_qqred_""" D qARM.wpoe("""_qqdat_"""),qARM.wfoc("_qqtr_","""","_qqx_","""_qqdat_""")") G EndEd1 ;маска и ушли по потере фокуса
 N qq S qq=$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqx,10))  ;@dol 18.02.04
 I qqtr=2,$P($G(qARM("Ver","qARMProj1.ocx")),".",2)<5,$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqx,44))'=""||(qq=1)||(qq=6)||(qq="Ht")||(qq="T")||(qq=10)||($E(qq)="M") S W("Zederr")=1 D ..wwww(qqw),..Message(%1),..Wait("S (qqw,qqred)="""_qqred_""" D qARM.wpoe("""_qqdat_"""),qARM.wfoc("_qqtr_","""","_qqx_","""_qqdat_""")") G EndEd1 ;маска и ушли по потере фокуса;@Dol 16.02.06 D ..OpenTimer(100,->Wait
 Q:$Q 1_%1 Q  ;@Dima@Dol 10.07.07 вывод по возврату в OnCommmonExitEdit + заблокирован wwww в строке I qqpodo'="",qqpodo'=-1.... ;;;;D ..Message(%1) D:0 ..wM(qwin_".T"_qqtr,"M9",1,0,qqdat) D ..wfoc(qqtr,qqy,qqx) ;D ..OpenTimer(50,"D qARM.wfoc("_qqtr_","""","_qqx_","""_qqdat_""")")
EndEd1 Q:$Q 1 Q
EndEd0 Q:$Q 0 Q
EndEdN ;G:$P($G(Vo(qqnump,-1,856))," ",1) MetTab   ;;вставка 03.10.06 @Sasha ;@Dol 22.05.07 для позиционирования в правиле проверки не надо
 I +qNx'=2 D ..NextEdit($S($E(qNx,2,255)="":qqwred,1:$E(qNx,2,255)),1) Q:$Q "0 1" Q  ;@Dol 15.04.07
 I $P($G(qARM("Ver","qARMProj1.ocx")),".",2)>4 D qARM.NextEdit($S($E(qNx,2,255)="":qqwred,1:$E(qNx,2,255))) Q:$Q "0 1" Q
 D qARM.Wait("D qARM.NextEdit("""_$S($E(qNx,2,255)="":qqwred,1:$E(qNx,2,255))_""")")
 Q:$Q "0 1" Q  ;@Dol 1.09.05 для блокировки позиционирования по Tab в OnCeKeyDown
 ;метки табуляции 03.10.06 @Sasha
MetTab d ..wM(qwin_".T2","NextCell",''$P(Vo(qqnump,-1,856)," ",4),0,0,0) q:$Q "" q
 ;
wz631(qqstr,qqkey) ;объекты
 I $G(qqkey),'$G(Arg2) D ..wM(qwin_".T1","EndEdit",0) ;Q:qqkey'=13 ""
 N qqo S qqo=$P(qqdat," ") ;код объекта
 S Z=qqstr
 I 'W("ZBt0") D  D ..wwde() D:$D(qqkey) ..wP(,"List",qqstr,qqy,qqx) D:$$$CurObj'=qqo ..wP(,"MultiSelect",1),..wM(,"M9",1,0,qqdat,"","",Z,qqx) D:qqx=1 ..wM(,"M9",1,0,qqo),..wP(,"M4",$S($D(Vs(qqnump,8,qqo)):"Bor",1:"Red0"),"",1) Q "" ;редактирование поискового образа и выражений аналитик
 .I 'qqy S Vs(qqnump,120,qqx)=Z Q  ;@Dol 26.05.06 редактирование заголовков
 .N qqw S qqw=$P(qqdat," ",2) ; код понятия
 .S qqred="",Z=$ZSTRIP(Z,"<>W") ;@dol 15.10.03 удаление пробелов
 .I qqx=2 D  Q  ;выражения аналитик
 ..I Z=""!(Z?." ") K Vs(qqnump,12,qqo,qqw,2),Vs(qqnump,12,qqo,qqw,1),Vs(qqnump,12,qqo,qqw,17) S qqstr="" Q
 ..S Vs(qqnump,12,qqo,qqw,2)=$P(Z,$C(13,10)) ;выражение
 ..I Z[$C(13,10) S Vs(qqnump,12,qqo,qqw,1)=$P(Z,$C(13,10),2),Vs(qqnump,12,qqo,qqw,17)=$P(Z,$C(13,10),3),Vs(qqnump,12,qqo,qqw,18)=$P(Z,$C(13,10),4) ;заголовок   .;поисковый образ ;@Dol 23.09.10 18
 .I Z=""!(Z?." ") K W("ZfI9"),Vs(qqnump,8,qqo,qqw) K:$D(Vs(qqnump,8))<10 Vs(qqnump,8) S qqstr="" Q
 .S (W("ZfI9"),Vs(qqnump,8,qqo,qqw))=Z
 .S Vs(qqnump,8,qqo,qqw,1)=$I(Vs(qqnump,8)) ;порядковый номер ввода
 ;
wz632(qqstr,qc) ;экземпляры
 ;I qqred="" Q ""
 S qc=$G(qc)
 ///D qARM.Message(qqstr_"-"_qc_"-"_qqred)
 ;S qqo=$P(qqdat," ",2) ;$$$CurObj ;????????? вроде нельзя менять qqo и он вполне может не быть текущим
 N qqw,qqcmp S (qqwred,qqw)=qqred,qqcmp=0 ;qqcmp - признак совпадения значений (не измено значение) ;@dol 11.08.02
 I qqred="" Q ""
 
 I qc,'$G(Arg2),$P(qARM("Ver","qARMProj1.ocx"),".",2)<5 D ..wM(qwin_".T2","EndEdit",0) ;подавим выход по AfterEdit (для даты и маске никокда не будет)
 
 //старый вариант выхода по ESC. закрыта sas 20081119
 //I qc=27 S W(qqw)=qW.GG($P(qqdat," ",2),qqw,qqc),qqred=""  D ..wwww(qqw) Q "" ;ESC к сожалению не бывает для немаски
 
 S qqstr=$TR(qqstr,$C(0,1,2,3,4,5,6,7,8,9,11,12,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31)) ;@dol 26.09.02 - уберем ненужные упр.сим (кроме 13,10)
 ;
 ;Q:qc'=13 "" ;????
 N qqZN,qqver
 I $P(W("Zdrl")," ",8)'="",'W("Zcdrl")!(+W("Zcdrl")=4)!(+W("Zcdrl")=5) D  ;восстановим размер графы
 .S qqZN=$P($G(Vo(qqnump,-1,0,0,qqx,2)),",")
 .I qqZN="" S qqZN=$P($G(Vo(qqnump,-1,9,qqx)),",") S:qqZN="" qqZN=15
 .I qqZN'=-1 D ..wP(qwin_".T2","ColumnWidth",$S(qqZN["px":+qqZN,1:qqZN*$P(W("Zfont"),",",3)),qqx) Q
 .D ..wM(qwin_".T2","MakeColumnOptimal",qqx)
 S qqZN=$G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx)) ;описание ячейки
 I $E(qqw,1,3)="ZZR" S Z=qqstr,qqred="" Q:$S($E(+W("Zcdrl"))=2:qARM.Value(..GetPar(74,,$P(qqdat," ",2),$P(qqdat," ",3),qqx))||1,1:0) "" Q:"045"'[$E(+W("Zcdrl")) "" K qqCEKey D  Q ""
 .;восстановим константу на месте развертки
 .;D ..wM(qwin_".T2","EndEdit",0)
 .S qqZN=$E(qqZN,2,511)
 .;I $E(qqZN)="@" S qqZN=$S($L($P(qqZN," "))=1:qW.GetWoc("CxObj",$P(qqdat," ",2)),1:qW.GetWoc("CxWoc",$E($P(qqZN," "),2,20)))
 .I $E(qqZN)="@" S qqZN=$S($L($P(qqZN," "))=1:..GetName(,$P(qqdat," ",2)),1:..GetName(,$P(qqdat," ",2),$E($P(qqZN," "),2,200)))
 .I $D(String) S String=$TR(qqZN,"_"," ") Q  ;возврат по ссылке (см. AfterEdit дерева)
 .D ..wP(qwin_".T2","List",$TR(qqZN,"_"," "),qqy,qqx)
 D:$G(qqkey)'=0  ;не выход из экранных разверток
 .I $E(qqZN)=3 D  Q  ;обработка введенного списка (нормализация)
 ..N i,j,qq,qqzsav S qqzsav=W(qqw),W(qqw)="" F i=1:1:$L(qqstr,$C(13,10)) S q=$P(qqstr,$C(13,10),i) D:q'=""
 ...S qq="" F j=1:1:$L(q," ") S:$P(q," ",j)'="" qq=qq_"_"_$P(q," ",j)
 ...S:qq'="" W(qqw)=W(qqw)_" "_$E(qq,2,32000)
 ..S W(qqw)=$E(W(qqw),2,32000) S qqcmp=qqzsav=W(qqw)
 .;$G(W("ZredB"))- пришли из внешнего редактирования текста (из EditDoc)
 .I $E(qqw)="T"||($E(qqw,1,2)="HT") D  Q  ;преобразование текстового понятия @dol 11.08.02 для анализа совпадения
 ..I +$G(W("ZredB"))=2 D  Q  ;@dol 31.01.05 не удалялось текстовое понятие при редактирвании Текст-экран
 ...I $D(W(qqw))>1 N qqqq S qqqq=$O(W(qqw,"")) I qqqq'="",$O(W(qqw,qqqq))="",W(qqw,qqqq)="" K W(qqw)
 ..I $TR(qqstr," ")="" S qqcmp=$D(W(qqw))>1 K W(qqw) Q  ;@dol 1.02.04 не удалялось текстовое понятие!!!
 ..N WwWw,i S qqcmp=1 F i=1:1:$L(qqstr,$C(13,10)) S WwWw(i-1)=$P(qqstr,$C(13,10),i) S:qqcmp qqcmp=$G(W(qqw,i-1),"??????????")=WwWw(i-1)
 ..S:qqcmp qqcmp=$O(WwWw(""),-1)=$O(W(qqw,""),-1) K W(qqw) M W(qqw)=WwWw
 .I $TR(qqstr," ")="",qqw'="X71" S qqstr=""
 .S qqcmp=$G(W(qqw))=qqstr S W(qqw)=qqstr
 .;?????S qqstr=$TR(qqstr,$C(13,10),"  "),W(qqw)="" N i F i=1:1:$L(qqstr," ") S:$P(qqstr," ",i)'="" W(qqw)=$S(W(qqw)="":"",1:W(qqw)_" ")_$P(qqstr," ",i) ;уберем лишние пробелы
 I +$G(W("ZredB"))=2,$S(+W("Zcdrl")=6:$TR($P(W("Zdrl")," ",2),"*")="",1:1),"TY"'[$E(qqw) D  ;@Dol 08.03.08 сформируем строку из массива;@Dol 27.01.09 $TR($P(W("Zdrl")," ",2),"*")=""
 .S qqZN="",Z="" F  S qqZN=$O(W(qqw,qqZN)) Q:qqZN=""  S Z=Z_$S("MXZ"[$E(qqw):$C(13,10),1:$C(32,13,10,32))_$G(W(qqw,qqZN)) ;Для кодируемых обрамим пробелами чтобы не сливалось со значением (ВК\ПС будет отдельным словом
 .K W(qqw) S W(qqw)=$E(Z,$S("MXZ"[$E(qqw):3,1:5),32000)
 S Z=$G(W(qqw))
 I qqcmp,'$G($$$Tree),"@ZYT"'[$E(qqw) I qW.GG($P(qqdat," ",2),qqw,qqc)=$G(W(qqw)) S qqpodo=$$pver(),qqred="" S:$E(qqpodo)'?1N&(qqpodo'=-1) qqpodo="" G wz632end ;еще раз проверим (вдруг сложная развертка) ;@dol 23.12.02 ,qqred="" - было пропущено!!! Ужас!!
 ;S Z=$G(W(qqw)) 
 I Z'="",..GetPar(741,,$P(qqdat," ",2),qqw) S Z=$TR(qW.qConv(Z)," ","_"),W(qqw)=Z ;режим одного слова
 I Z'="" S qqpodo=..GetPar(742,,$P(qqdat," ",2),qqw) D:qqpodo  S W(qqw)=Z ;@Dol 2.09.05 преобразование регистров
 .I qqpodo<3 S Z=$ZCVT(Z,$S(qqpodo=1:"U",1:"L")) Q  ;большие-маленькие
 .S Z=$ZCVT($E(Z),"U")_$ZCVT($E(Z,2,32000),"L") ;Имя
 .S qqpodo=$TR(Z," ._,-'""",$C(1,1,1,1,1,1,1,1,1)) Q:qqpodo=Z  N ii S ii=1 F  S ii=$F(qqpodo,$C(1),ii) Q:'ii  S $E(Z,ii)=$ZCVT($E(Z,ii),"U")  
 N qqredS ;будет использоваться как флаг, если вызвано StartEdit из правила проверки (чтобы не сбросить qqred)
   
 ///правильная отработка выхода по ESC sas 20081119
 I qc=27 S (Z,W(qqw))=qW.GG($P(qqdat," ",2),qqw,qqc)
 
 S qqpodo=$$pver() I qqpodo=0 S:'$D(qqredS) qqred="" Q "" ;игнорирование редактирования
 ;S:qqpodo'=""&0 W(qqw)=qqzsav 
 
 I qqpodo'="",qqpodo'=-1,$E(qqpodo)'?1.N Q:$D(String)&&($E($G(Vt(qqnump,9,"PP",$P(qqdat," ",2),+$P(qqdat," ",3),qqx)))'="@")&&($E($G(Vt(qqnump,9,"PPP",$P(qqdat," ",2),+$P(qqdat," ",3),qqx)))'="@") qqpodo D:0 ..wwww(qqw) Q qqpodo ;****очень сомнительное место;@Dol 10.07.07 заблокровано wwww
 S:"YT"'[$E(qqw) W(qqw)=Z ;@Dol 31.01.05 писался лишний узел
 I +$G(W("ZredB"))=2,$S(+W("Zcdrl")=6:$TR($P(W("Zdrl")," ",2),"*")'="",1:0)  N end S end="" D  S:'$D(qqredS) qqred="" Q end ;23.06.05 end ;@dol 13.8.03 порождение записей из текста;$TR($P(W("Zdrl")," ",2),"*")'=""
 .N qqonew,qqwlst,c1,c2,c3,imax,q41,q42,corr S imax=$O(W(qqw,""),-1),qqwlst=$P(W("Zdrl")," ",2),q41=..GetPar(741,,$P(qqdat," ",2),qqw),q42=..GetPar(742,,$P(qqdat," ",2),qqw)
 .I imax'="" D  I end S end="Есть слова более 200 символов"_$S(end'=1:"",1:" (для режима одного слова)") Q  ;@Dol 23.06.05 проверка на длинные слова
 ..F c1=0:1:imax S c2=W(qqw,c1) I $L(c2)>200 D  Q:end
 ...I q41 S end=1 Q
 ...F c3=1:1:$L(c2," ") I $L($P(c2," ",c3))>200 S end=2 Q
 .S qqonew=$P(qqwlst,":",1),qqwlst=$P(qqwlst,":",2,255)
 .I imax'="",q41||q42 F c2=0:1:imax S:q41 W(qqw,c2)=$TR(W(qqw,c2)," ","_") S:q42 W(qqw,c2)=$S(q42<3:qW.qConv(W(qqw,c2),,,,q42),1:qW.qConv($E(W(qqw,c2)),,,,1)_qW.qConv($E(W(qqw,c2),2,32000),,,,2))
 .I imax'="" F  Q:$TR(W(qqw,imax)," ")'=""  K W(qqw,imax) S imax=imax-1 I imax<0 S imax="" Q
 .s c3="" S c1="" K W("Yo") F c2=0:1 S c1=$$$UserOrd(1,qqonew,c1,qqc) Q:c1=""  D  S c3=c1  ; tdv 20080528 добавлено s c3="", иначе создавались экземпляры с кодами, начинающимися на c3
 ..I c2>imax||(imax="") D qW.rDel(qqonew,c1) S corr=1 Q
 ..S Z=qW.GG(qqonew,$P(qqwlst,","),c1) Q:Z=W(qqw,c2)  S W($P(qqwlst,","))=W(qqw,c2)
 ..D qW.rCor(qqonew,c1,$P(qqwlst,",")_" Yo") S corr=1
 .I imax'="" S:$G(c3)="" c3=qqc F c2=c2:1:imax S W($P(qqwlst,","))=W(qqw,c2) S c3=$P(qW.rNew(qqonew,c3,2)," "),corr=1 D qW.rCor(qqonew,c3,$P(qqwlst,","))
 .Q:'$G(corr)  D qW.rCor($P(qqdat," ",2),qqc,"Z",,2) ;@dol 30.10.03 чтобы записалась дата коррекции
 .I $P(W("Zdrl")," ",8)'="" D  ;@Dol 08.03.08 постдейсвие
 ..N qqo S qqo=$P(qqdat," ",2) X $P(W("Zdrl")," ",8,255)
 .D ..wqqotree(,,,$D(W(qqw))>1)
 I $E(qqZN)=5 S:'$D(qqredS) qqred="" G wz632end ;если редактируется выражение @dol 4.04.03 был забыт сброс qqred
 ;I $E(qqw,1,4)="ZMAS" K:Z="" @Vt(qqnump,"mas",$P(qqdat," ",2),qqw) S:Z'="" @Vt(qqnump,"mas",$P(qqdat," ",2),qqw)=Z S:'$D(qqredS) qqred="" G wz632end ;@Dol 22.07.05
 I $E(qqw,1,4)="ZMAS" D ..SetZMAS($P(qqdat," ",2),,qqw,Z) S:'$D(qqredS) qqred="" G wz632end ;@Dol 08.08.10
 ;
 I qqred'="",$G(W(qqred))'="",qqred'="C",qqred'="CC" D  ;$L(W(qqred)," ")=1, а список???;@Dol 21.05.06 qqred'=""
 .I $E(qqw)'="C",'$D(Vo(qqnump,$P(qqdat," ",2),11,"C"_qqw)) Q  ;?????
 .;S qqZN=$G(qqw) N qqw S qqw=qqZN S qqZN=$G(q) N q S q=qqZN S q=qW.GetWoc(qqw,Z) I $E(qqw)="C" Q:q=""  S qqw=$E(qqw,2,10),W(qqw)=q D ..wwww(qqw) Q
 .S qqZN=$G(qqw) N qqw S qqw=qqZN,q="" D  I $E(qqw)="C" Q:$TR(q," ")=""&(" "_qqwchg_" "[(" "_$E(qqw,2,255)_" "))  S qqw=$E(qqw,2,10),W(qqw)=q,qqwchg=$G(qqwchg)_" "_qqw D ..wwww(qqw,1) Q
 ..N i F i=1:1:$L(Z," ") S $P(q," ",i)=qW.GetWoc(qqw,$P(Z," ",i))
 .I $S($TR(q," ")'="":1,1:" "_qqwchg_" "'[(" C"_qqw_" ")) S qqw="C"_qqw,W(qqw)=q D ..wwww(qqw,1) ;@Dol 29.08.06 I .. чтобы можно было ввести сначало новый код, затем новое значение
 I $E(qqw,1,2)="TB",$G(Vo(qqnump,$P(qqdat," ",2),2))'=6 S:'$D(qqredS) qqred="" S ^Q(1,$P(qqdat," ",2),qqc,qqw)="" Q "" ;@Dol 21.1.04 S ^Q большой текст
 I $E(qqw,1,4)="ZTMP",$G(qqc)'="",'$G($$$Tree) D   ;временные понятия, хранимые в перечне релевантных
 .S Zold=Z I $G(W(qqw))'="",$G(Vo(qqnump,$P(qqdat," ",2),0,+$P(qqdat," ",3),qqx,84))'="" S qqZN=..GetPar("x710",,$P(qqdat," ",2),$P(qqdat," ",3),qqx) I qqZN'="",qqZN'=3 S Zold=Z,Z=qW.GtoExt(qqZN,Z) ;@Dol 20.12.05 преобразование для динамических образцов (X784'="");@Dol 04.08.06 динамическая проверка x710
 .I Z="" K ^Q($$$Relind_qview,$P(qqdat," ",2),qqc,qqw) I 1
 .E  D:'($D(^Q($$$Relind_qview,$P(qqdat," ",2),qqc))#10) ..RecRel("+",$P(qqdat," ",1),1) S ^Q($$$Relind_qview,$P(qqdat," ",2),qqc,qqw)=Z S:qqZN=3 ^(qqw,1)=qqZN ;запись в перечень;@Dol 07.03.08 qqZN=3 - признак документа
 .I ..GetPar("X182")'="" N qqo,Arg1,qObj,qOref S (qObj,qqo)=$P(qqdat," ",2),qOref=$P(qqdat," ",1),Arg1="+" D ..Value(Vo(qqnump,-1,82),"X") ;@dol 9.03.03 действие по изменению релевантных;14.10.09 qObj;24.12.09 qOref
 S:" "_$G(qqwchg)_" "'[(" "_qqred_" ")&("@Z"'[$E(qqw))&(qqw'[":") qqwchg=$G(qqwchg)_" "_qqred S:'$D(qqredS) qqred=""
wz632end ;@Dol 10.03.05 так затиралось при динамических парметрах при наличии String ;;I $D(String),"TY"'[$E(qqw),$E($G(Vt(qqnump,9,"PP",$P(qqdat," ",2),+$P(qqdat," ",3),qqx)))'="@",$E($G(Vt(qqnump,9,"PPP",$P(qqdat," ",2),+$P(qqdat," ",3),qqx)))'="@" S String=$S($G(W(qqw))'="":W(qqw),$G(Vo(qqnump,-1,65))=2:" ",1:"") Q qqpodo ;@dol 6.08.0 $D(Vt(qqnump,9,"PP",$P(qqdat," ",2),+$P(qqdat," ",3),qqx)) дин.пар+картинки;;;если AfterEdit то нужно изменить String @dol 2.12.03 "TY"'[$E(qqw) - иначе текст пропадал 
 I $G(Nowr) Q qqpodo ;@Dol 27.01.09 без перевывода
 I $G(Arg2) D ..wwww(qqw) Q qqpodo ;@Dol 6.12.06 на всякий случай - проблемы с неперевыводом для навесных элементов
 I $G(Vo(qqnump,$P(qqdat," ",2),0,+$P(qqdat," ",3),qqx,10))=7,$D(String) S String=qW.GtoExt(7,$G(W(qqw))) Q qqpodo ; @tdv 05.08.05 добавлена обработка типа 7 - DATETIME
 I $D(String),"TY"'[$E(qqw) S String=$S($G(W(qqw))'="":W(qqw),$G(Vo(qqnump,-1,65))=2:" ",1:"") I $E($G(Vt(qqnump,9,"PP",$P(qqdat," ",2),+$P(qqdat," ",3),qqx)))'="@",$E($G(Vt(qqnump,9,"PPP",$P(qqdat," ",2),+$P(qqdat," ",3),qqx)))'="@"  Q qqpodo ;@dol 6.08.0 $D(Vt(qqnump,9,"PP",$P(qqdat," ",2),+$P(qqdat," ",3),qqx)) дин.пар+картинки;;;если AfterEdit то нужно изменить String @dol 2.12.03 "TY"'[$E(qqw) - иначе текст пропадал
 D ..wwww(qqw) Q qqpodo
 ;
pver()  ;правило проверки
 I $S($E(qqw)'="T":Z="",1:$D(W(qqw))<10) Q:..GetPar(740,,$P(qqdat," ",2),qqw)||(" "_..GetPar("X5223",,$P(qqdat," ",2))_" "[(" "_qqw_" ")) "Отсутствие значения недопустимо" ;@Dol 9.11.07 X5223
 I "@MTYCXLZ"'[$E(qqw) D  Q:qqver'="" "Слишком длинное слово (>200): "_qqver ;@dol 2.10.03
 .N iL S qqver="" F iL=1:1:$L(Z," ") I $L($P(Z," ",iL))>200 S qqver=$P(Z," ",iL) Q
 S qqver=..GetPar(74,,$P(qqdat," ",2),qqw)
 D:'$D(Vo(qqnump,-1,854)) ..GetPar("X1854") S:Vo(qqnump,-1,854)'="" @("qqver="_Vo(qqnump,-1,854)) ;@Dol 28.06.06 общее правило проверки
 Q:qqver="" ""
 I $E(qqw,1,3)="@ZL" D ..Value(qqver,"X") Q ""
 I $E(qqver)="Z" D  Q $S(qqver="":"",1:"Несоответствие условию "_qqver)  
 .I ..Value(qqver)'=0 S qqver="" Q
 I $E(qqver)?1N Q qqver
 S qqver=..Value(qqver) I $E(qqver)="=" S Z=$E(qqver,2,3000) Q "" ;@Dol 24.03.08 присваивание Z
 Q qqver
]]></Implementation>
</Method>

<Method name="EndOP">
<Description>
Проверить законченность операций с базой
Проверяется завершенность редактирования и неоходимсть коррекции текущего 
экземпляра объекта.
Arg1=1 - выполнить и при редактировании значения (qqred'="").
Возвращает 1 - не закончены, 0 - закончены.</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 ;S:$G(Arg1) qqred="" ;@dol 27.01.02 - для вызова из развертки типа действия
 Q:'$G(W("ZBtred")) 0
 I $G(Vt(qqnump,"ZTmpqqc"))'="",$G(Vt(qqnump,"ZTmpYT"))'=1,Vt(qqnump,"ZTmpqqc")'[" ",$L(Vt(qqnump,"ZTmpqqc"))=$S($G($$$ObjLqqc(Vt(qqnump,"ZTmpqqo")))'="":$$$ObjLqqc(Vt(qqnump,"ZTmpqqo")),1:$$$ObjLget(Vt(qqnump,"ZTmpqqo"))) D  ;@Dol 26.01.06 ;весьма спорная обработка связанности
 .;I $G($$$CurObj)'=Vt(qqnump,"ZTmpqqo")
 .D qW.rCor(Vt(qqnump,"ZTmpqqo"),Vt(qqnump,"ZTmpqqc"),"YT",,0) Q  ;автокоррекция предыдущего??? без изменения даты
 .;S qqwchg=$G(qqwchg)_" YT" ;сам объект и корректируется
 I '$G(Arg1),$G(qqred)'="" Q 0 ;Q:..EndEdit($G(W(qqred))) 1 ;Q 0 ;?такого не может быть Q:..EndEdit() 1 ;контроль ввода
 I $G(qqwchg)="" Q 0 ;Q:$G(qqc)[" " "" Q ..RecVerNoDef() ;@dol 18.02.03 проверка на обязательность значений
 I '..RecCor() S:$G(Arg1) qqred="" D:$D(W("Zpos",2,"y")) ..wP(qwin_".T2","Selected",1,W("Zpos",2,"y")) Q 1 ;строка известна
 I $G(Vt(qqnump,"ZTmpqqc"))'="",$G(Vt(qqnump,"ZTmpYT"))'=1,Vt(qqnump,"ZTmpqqc")'[" ",$L(Vt(qqnump,"ZTmpqqc"))=$S($G($$$ObjLqqc(Vt(qqnump,"ZTmpqqo")))'="":$$$ObjLqqc(Vt(qqnump,"ZTmpqqo")),1:$$$ObjLget(Vt(qqnump,"ZTmpqqo"))) D qW.rCor(Vt(qqnump,"ZTmpqqo"),Vt(qqnump,"ZTmpqqc"),"YT",,0) ;@dol 10.07.03
 Q 0
]]></Implementation>
</Method>

<Method name="Error">
<Description>
Обработчик ошибок</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 S length=10000 n NoMes s NoMes=0 ; @dima 20100708
 ;I $ZE["CLASS DOES NOT" S $EC="" D
 I $ZE["CLASS DOES NOT" D qARM.Message("Класс "_$G(class,$G(nameid))_" (ID="_$G(ID,$G(id))_") отсутствует."_$C(13)_$ZE,"Предупреждение") s NoMes=1 ; @dima 20110316 id,nameid - see InstSysClass
 K qqwold I $ZE["CLASS REC" D  S $EC="" D qARM.Message("Классы перекомпилированы","Предупреждение") Q:$Q "" Q
 .;S qARM=##class(%TqARM).%New()
 .;S qWEB=##class(%qWEB).%New()
 .;S qSYS=##class(%qSYS).%New()
 .;S qW=##class(%qWORD).%New()
 .D ..InstSysClass() ; @dima 20110316
 .D qARM.UserClass()
 ZD  ;@Dol 10.02.11 сброс Lock
 i $G(zzzqERR) g ErrorL1
 d:$G(qqXBErrETN) BACK^%ETN ;@dima+sasha 20081013
 i $G(qqXBErrMet)'="" n XQuiet x qqXBErrMet ; Пользовательское действие при ошибке. @dima+sasha 20081014
 S xxxstr="" n xxxi 
 n LinesCnt s LinesCnt=7
 f xxxi=$S(($ST-zzzzStLv)>LinesCnt:$ST-LinesCnt,1:zzzzStLv):1:$ST-1 s xxxstr=xxxstr_$C(13,10)_$STACK(xxxi,"PLACE")_" "_$zstrip($STACK(xxxi,"MCODE"),"<W")
 n xxxerrtxt s xxxerrtxt=$E($P($ZE,">"),2,255)_" "_$P($P($ZE,">",2,255)," ",2,255)
 n msgTxt,msgCap s msgTxt=$ZE_$C(13,10,13,10)_"GloRef="_$G(xxxZR)_$C(13,10)_"qqo="_$G(qqo)_" qqc="_$G(qqc)_" qqw="_$G(qqw)_" qqci="_$G(qqci)_" qqz="_$G(qqz)_" qqcond="_$G(qqcond)_" qqopcond="_$G(qqopcond)_" qoo2="_$G(qoo2)_" qqred="_$G(qqred)_" qqnump="_$G(qqnump)_" qqdat="_$G(qqdat)_" qqx="_$G(qqx)_" cond0="_$G(cond0)_" condC="_$G(condC)_" ArgV1="_$G(ArgV1)_" Z="_$G(Z)_" ref="_$G(ref)_" Obj="_$G(Obj)_$C(13,10)_xxxstr_$S($G(qqXBErrVar):$C(13,10)_qARM.getst(1),1:""),msgCap=xxxerrtxt ;dima 20101113
 ;i $G(^Q(1,"XBase",0,"XBErrAudit")),$p($p($zv,") ",2)," ",1)>5.2 d $SYSTEM.Security.Audit("qARM","Error","COS error","host="_$ZU(67,12,$J)_"  localuser="_$ZU(67,11,$J)_"  user="_$G(qARM("User"))_$C(13,10,13,10)_iZE_$C(13,10,13,10)_msgTxt_$C(13,10,13,10)_"qWORD-XML v. "_$TR($ZDT($G(^%QView),4),"/",".")_$C(13,10)_"qARMProj1.ocx v. "_$G(qARM("Ver","qARMProj1.ocx")),$S($D(%grtn):"GManager action error: ",1:"")_msgCap) ; @dima 20100728 запись в аудит. Для GMan независимо от флага в базе.
 i '$G(XQuiet),'$G(NoMes) d qARM.Message(msgTxt,"Ошибка "_msgCap,1) S zzzqERR=1
ErrorL1
 i $es>1 q:$q "" q
 s $ec="" k zzzqERR
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Estat">
<Description>
Сохранение состояние развернутости в Vs(qqnump,2,qqo,qqc)=1 для текущего объекта и его предков.
Arg1=1 - до объекта - Vs(qqnump,2,qqo)=1</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Vs(qqnump,2)) K Vt(qqnump,"Expand") Q:$Q "" Q  ;@dol 17.8.03 - раскрыть все
 K Vs(qqnump,2) N qqci,qqi,jj,srt S srt=$G(W("Zosrt")) F qqi=2:2:$L($G(Vc(qqnump))) S qqci=$E(Vc(qqnump),1,qqi) D
 .I srt=$G(Vc(qqnump,qqci,0)) S srt="" ;@Dol 14.12.06 все нижележащие разворачивать совсем необязательно
 .D:$G(Vc(qqnump,qqci,40))=1
 ..I srt="",'$G(Arg1) S Vs(qqnump,2,Vc(qqnump,qqci,0),Vc(qqnump,qqci))=1 Q  ;@Dol 14.12.06 было $G(W("Zosrt"))="" вместо srt=""
 ..S Vs(qqnump,2,Vc(qqnump,qqci,0))=1 ;@dol 31.03.05 - если сортировка - раскрыть все экземпляры
 .I $G(Vc(qqnump,qqci,6))'=""  F jj=1:2:$L(Vc(qqnump,qqci,6),"~") D  ;@Dol 6.11.05 для зачеркнутых тоже
 ..I srt="",'$G(Arg1) S Vs(qqnump,2,$P(Vc(qqnump,qqci,6),"~",jj),$P(Vc(qqnump,qqci,6),"~",jj+1))=1 Q
 ..S Vs(qqnump,2,$P(Vc(qqnump,qqci,6),"~",jj))=1
 S:$G(Vt(qqnump,"Expand"))'=""&&($G(Vc(qqnump,$P(Vt(qqnump,"Expand")," ")))'="") Vs(qqnump,2,$P(Vt(qqnump,"Expand")," ",2),Vc(qqnump,$P(Vt(qqnump,"Expand")," ")))=1
 K Vt(qqnump,"Expand")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="EstatSR">
<Description>
Сохранение (Arg1=1) восстановление (Arg1="") удаление (Arg1=0) состояния свертки для текущего отображения</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqci,qqoo,ref S ref=$NA(@("^Q(""V"_Vo(qqnump)_" "_quser_""",""Vs"")"))
 I $G(Arg1)=0 K @ref Q:$Q "" Q
 I '$G(Arg1) K Vs(qqnump,2) M Vs(qqnump,2)=@ref Q:$Q "" Q
 S qqci="" F  S qqci=$O(Vc(qqnump,qqci)) Q:qqci=""  S qqoo=Vc(qqnump,qqci,0) K @ref@(qqoo) S:$G(Vc(qqnump,qqci,40))=1 @ref@(qqoo)=1
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="EventTimer">
<Internal/>
<FormalSpec>Sender:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 I $P(Sender,".")'=("Q"_$G(qqnump)),..ChgWin() Q:$Q "" Q
 D ..Value($G(qqxtimer),"X") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="ExecExitCode">
<Description>
Событие завершения процесса, запущенного с помощью ModalExec (при Par5=1),
с возвратом кода завершения.

D qARM.wM("-qARM","ModalExec",Par1[,Par2,Par3,Par4,Par5])
([] - необязательные параметры)
Par1 - командная строка
Par2 - флаг скрытия окна приложения
Par3 - действие после успешного выполнения
Par4 - действие при ошибке выполнения
Par5 - вызывать событие в Cache с передачей кода завершения</Description>
<Internal/>
<FormalSpec>command:%Library.String,code:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 d ..Message("Процесс: "_command_$C(13)_"Код завершения: "_code)
 q ""
]]></Implementation>
</Method>

<Method name="Expand1">
<Description>
Свертка/развертка узла дерева экземпляров (первая строка объекта!!!).
Информация о текущем свернутом Vt(qqnump,"Expand")=qqci_" "_qqo_" 0", где qqci - текущий индекс в Vc(qqnump,qqci)
Если новый разворачивается, старый сворачивается
Arg1 - qqci
Arg2 =0/1 - свернуть/развернуть
Если Arg1="", то Arg1=Vc(qqnump) - текущий qqci
Arg3=1  - тестировать на предмет развертки для Arg1 (если вывели объект, подчиненный свернутому)</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;;;I $G(Vo(qqnump,qqo,4))=4 D ..Fix($S($G(Vs(qqnump,7))=qqo:"",1:qqo),1,,,,,1) Q:$Q "" Q  ;@Dol 02.03.08 фиксация
 I $G(Vt(qqnump,"Expand"))'="",$P(Vt(qqnump,"Expand")," ")'=$E(Arg1,1,$L($P(Vt(qqnump,"Expand")," "))) D
 .;есть развернутый, который нужно свернуть
 .;D Expand10($P(Vt(qqnump,"Expand")," "))
 .N qqci,qqi,qqq S qqq=$P(Vt(qqnump,"Expand")," ") F qqi=$L(qqq):-2:2 S qqci=$E(qqq,1,qqi) I $G(Vc(qqnump,qqci,40))=1,$G(Vo(qqnump,Vc(qqnump,qqci,0),4))<3,Arg1'=qqci D Expand10(qqci)
 N qqstat S qqstat=$G(Vc(qqnump,Arg1,40)) I $G(Vc(qqnump,Arg1,40))=-1||($G(Vc(qqnump,Arg1,40))=0) D Expand11(Arg1) Q:$Q "" Q
 I $G(Vc(qqnump,Arg1,40))=1 D Expand10(Arg1) Q:$Q "" Q
 I $P($G(Vt(qqnump,"Expand"))," ")=Arg1 D Expand10(Arg1) Q:$Q "" Q
 D Expand11(Arg1) Q:$Q "" Q
 ;
Expand10(qqci)  ;cвернуть объект
 K Vt(qqnump,"Expand") I $G(Vo(qqnump,$G(Vc(qqnump,qqci,0),9999),4))=4 S Vs(qqnump,"7stat")=$G(Vs(qqnump,"7statObj",Vc(qqnump,qqci,0))) D ..Fix("") Q
 D ..wM(qwin_".T2","M9",1,0,qqci_" "_Vc(qqnump,qqci,0)_" 0","",0) ;D:0 ..wP(,"M4","p0","",0,0) 
 S Vc(qqnump,qqci,40)=0 D ..wcellpic(Vc(qqnump,qqci,0),0,0,qqci)
 D:$D(Vt(qqnump,9,"FCBUT")) ..wM(qwin,"Vol_ArrayElementPaint") ;..wwwwFCBUT(1)
 D  ;@dol 10.1.04 правило проверки и для свертки
 .N qqver S qqver=..GetPar(74,,Vc(qqnump,qqci,0),0,0) Q:qqver=""  Q:$E(qqver)?1N  S qqver=..Value(qqver)
 ;S Vc(qqnump,qqci,40)=0
 Q
Expand11(qqci)  ;развернуть объект (@Dol 15.02.07 - wpoe почему-то вызывается дважды????)
 N qqq I $G(Vo(qqnump,$G(Vc(qqnump,qqci,0),9999),4))=4 S qqq=Vc(qqnump,qqci,0),Vs(qqnump,2,qqq)=1 S Vc(qqnump,qqci,40)=1 D ..Fix(Vc(qqnump,qqci,0),1,,,,,1) S Vs(qqnump,"7statObj",qqq)=Vs(qqnump,"7stat") S qqci=Vc(qqnump),Vc(qqnump,qqci,40)=1 G Expand11e
 S qqq=qqci_" "_Vc(qqnump,qqci,0)_" 0"
 I $G(Vc(qqnump,qqci,40))=-1 Q:..EndOP()  D ..wqqotree(qqci,,,1,1,,,0) D:0 ..wM(qwin_".T2","M9",1,0,qqq),..wP(,"M4","p1","",0,0) S Vc(qqnump,qqci,40)=1 I 1  ;@dol 13.05.03 ..EndOP
 E  D
 .D ..wM(qwin_".T2","M9",1,0,qqq,"",2) D:0 ..wP(,"M4","p1","",0,0) S Vc(qqnump,qqci,40)=1 D ..wcellpic(Vc(qqnump,qqci,0),0,0,qqci) ;S:$G(Vc(qqnump,qqci,40))=0 Vc(qqnump,qqci,40)=1
 .N qqcii S qqcii=qqci F  S qqcii=$O(Vc(qqnump,qqcii)) Q:$E(qqcii,1,$L(qqci))'=qqci  D:$G(Vc(qqnump,qqcii,40))=0 ..wM(qwin_".T2","M9",1,0,qqcii_" "_Vc(qqnump,qqcii,0)_" 0","",0)
 S:$G(Vo(qqnump,$G(Vc(qqnump,qqci,0)),4))'=3 Vt(qqnump,"Expand")=qqq
 I $D(Vt(qqnump,9,"FCBUT")),qqstat'=-1 D ..wM(qwin,"Vol_ArrayElementPaint") ;..wwwwFCBUT(1)
Expand11e S qqq=1 D  ;@dol 1.08.03 правило проверки (для перехода или выполнения некоторого действия
 .N qqver,qNx D  Q:qqver=0
 ..S qqver=..GetPar(74,,Vc(qqnump,qqci,0),0,0) Q:qqver=""
 ..I $E(qqver)?1N Q
 ..S qqver=..Value(qqver),qqq=0
 .I qqver="" D:W("ZBtred") ..NextEdit("",1) Q  ;@dol 24.06.03 На первое редактируемое;@Dol 10/03/05 третий $P от : - выражение для кода экзепляра ;..Obj($P($E(qNx,2,255),":"),$S($P(qNx,":",3)="":"
 .S qNx=qqver Q:$S(qNx'[":":0,1:'..Obj($P($E(qNx,2,255),":"),$S($P(qNx,":",3)="":"",1:..Value($P(qNx,":",3)))))  S:qNx[":" qNx=$E(qNx)_$P(qNx,":",2) D:$E(qNx,2,255)'=""||(+qNx=2)||(+qNx=3) ..NextEdit($S($E(qNx,2,255)="":"",1:$E(qNx,2,255)),+qNx'=2) ; переход к редактированию заданного/следующего понятия
 ;D:$G(Vo(qqnump,-1,62)) ..wM(qwin,"qResize"_$S(Vo(qqnump,-1,62)=1:"",1:"Hor")) D:qqq ..wpoe(,2) ;D:qqq ..Wait("D qARM.wpoe(,2)") ;@dol 10.09.05 если не было установки, спозиционируемся на первую строку с установлением видимости развернутых
 D:$G(Vo(qqnump,-1,62)) ..wM(qwin,"qResize",$TR(Vo(qqnump,-1,62),"123","312")) D:qqq ..wpoe(,2) ;@Dol&@Dima 04.02.09 qResize
 Q
]]></Implementation>
</Method>

<Method name="Find">
<Description>
Запуск поиска.
Arg1=0 - выдача экземпляров с условием.
Arg1=1 - выдача  полного поддерева вершины поискового образа.
Arg2 - max кол-во найденных экземпляров
qqolst - содержит список объектов в варианте продолжения поиска по понятию в нескольких объектах.
NoReFind=1 - не входить в режим Уточнение после поиска
NoDial=1 - не выводить сообщения (ничего не найдено, ошибка в условии)
NoWarning=1 - не выводить предупреждения "Нет условий на невиртуальные объекты.Поиск МОЖЕТ занять много времени!!!"
NoWr=1 - не делать перевывод
n808=1 - не удалять массив альтернативных (по ИЛИ) условий поиска - Vo(qqnump,808). ;@Dol 18.05.09
      В Vs(qqnump,808) могут находится наборы поисковых образов. Результаты всех наборов объединяются по ИЛИ
        Vs(qqnump,808)- кол-во наборов
        Vs(qqnump,808,номер_набора,qqo,qqw)=условие
     !!!!!Если заданы наборы, то текущий поисковый образ Vs(qqnump,8) должен также находится в одном из наборов

Управляющие переменные:
Vs(qqnump, 99, "Find")=0/1 - поиск(отметка) экземпляров/поддерева 
Vs(qqnump, 99, "Find", 1) =1 - учитывать одинаковые понятия в разных объектах 
Vs(qqnump, 99, "Find", 2) - максимальное количество экземпляров (если не задано - ищутся все) 
Vs(qqnump, 99, "Find",5) =1 поиск без учета регистра (Поисковый образ должен быть большими буквами !!!)</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%String,qqolst:%String,Con:%Library.String,NoDial:%Library.String,NoReFind:%Library.String,NoWarning:%Library.String,NoWr:%Library.String,n808</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I W("ZBt0") Q:$Q "" Q 
 D ..ResetSrt()
 I $D(qqolst) G FindBeg ;G FindLst:$G(qqolst)'="",FindBeg
 I '$D(Arg1) S Arg1=+$G(Vs(qqnump,99,"Find")) I 1
 E  S Vs(qqnump,99,"Find")=Arg1 D ..MenuAn("F")
 I '$D(Arg2) S Arg2=+$G(Vs(qqnump,99,"Find",2)) I 1
 E  S Vs(qqnump,99,"Find",2)=Arg2 D ..MenuAn("F")
 I '$D(Vs(qqnump,8)) D FindMessage("Нет условий поискового образа") Q:$Q "" Q
 D:..GetPar("X1193") ..Fix("") ;@dol 10.1.04
 I $P($$$CondFind," ")'="" S $P($$$CondFind," ")="" D ..wbut(2) ;уберем упорядоченность
 I $D(Vt(qqnump,111)),'$G(Con),$D(Vt(qqnump,111,0)) S %1=0 D  I '%1,W("Zadm"),'$g(NoWarning) D ..Question("Нет условий на невиртуальные объекты."_$C(13,10)_"Поиск МОЖЕТ занять много времени!!! Продолжить",1,"","D qARM.Wait(""D qARM.Find(,,,1)"")") Q:$Q "" Q
 .S %2="" F  S %2=$O(Vs(qqnump,8,%2)) Q:%2=""  I $D(Vt(qqnump,111,0,%2)),$D(Vs(qqnump,8,%2))>1 S %1=1 Q
FindBeg K:'$G(n808) Vs(qqnump,808) ;@dol 19.06.08 Наборы по ИЛИ ;@Dol 18.05.09 n808
 ;проверка задания условия на одно понятие, встречающееся в разных объектах
 S qqolst=..FindAll()   
 I $G(Vs(qqnump,99,"Find",3)) G FindFon ;???,'$D(Vt(qqnump,111)) пока без виртуальных ;,'$G(Vt(qqnump,0))
 S qqftime=$P($H,",",2),%1=qW.qFind(Arg1,Arg2,$G(qqolst)),qqftime=$P($H,",",2)-qqftime I W("Zadm"),qqftime>3,'$G(NoDial) D ..Message((qqftime\60)_":"_$E(qqftime#60+100,2,3),"Время выполнения")
 I +%1'=%1 D FindMessage($S(%1["Не существует":" Ничего не найдено"_$C(13,10,13,10)_%1,1:"Ошибка в условии: "_%1)) Q:$Q "" Q  ;ошибка (SYNTAX)
 I '%1 D FindMessage("Ничего не найдено") Q:$Q "" Q
 S $$$RelNum=%1 G:$G(NoReFind) FindEndE ;;D ..wcre() Q:$Q "" Q  ;@Dol 11.11.04
 S $$$ReFind=1
FindEnd
 I $G(Vs(qqnump,7))'="",'$G(Vs(qqnump,17)) D ..Fix() ;@Dol 8.10.07 раньше сбрасывалась всегда - теперь - если не жесткая
 D ..wfot(-2)
 S qqc="" I $G($$$CurObj)'="" S:'$D(^Q($$$Relind_qview,$$$CurObj)) $$$CurObj="" 
 I $E($G(W("Zsform")))'=1||($G(W("Zsform"))>99) D ..wbuttb(401,1),..wbuttb(402,0) ;@Dol 15.05.07 D ..wP(qwin_".TBC.b401","Down",1),..wP(qwin_".TBC.b402","Down",0) ;.b62
FindEndE I '$G(NoWr) D ..wcre() I $G(Vo(qqnump,-1,88))'=1,'$G(Vo(qqnump,-1,80)),$G(Vo(qqnump,-1,194))'="" D ..wP(qwin_".T2","RowColPictureH@1",$P(Vo(qqnump,-1,194)," ",''$$$RelNum+1),0) ;@Dol 23.01.07 заголовок колонки релевантных
 I ..GetPar("X182")'="" N qObj S qObj=-1 D ..Value(Vo(qqnump,-1,82),"X") ;@Dol 13.08.07 действие по изменению релевантных ;@Dol 06.11.09 qObj
 Q:$Q "" Q
FindFon ;Запуск поиска в фоне ;?????? qA
 N qviewf,qqr,Cond,qqmod S qqmod=+$G(Arg1)
 Q:qview="" 1/0 ;на всякий случай, иначе катастрофа
 I $$$ReFind N qql S qql=$$$Relind_qview,$$$Relind='$$$Relind,Cond=0 K ^Q($$$Relind_qview) I 1
 E  S Cond=$G(Vt(qqnump,0)) ;если уточнение, пстоянные условия проверять не надо (???)
 S qviewf=$$$Relind_qview ;ссылка на перечень релевантных
 ;S qqr=qW.qFindList(Cond,+$G(Arg1),$G(qqolst))
 D qW.qFindList0() ;@dol 21.06.03
 I qqr'="" S:$$$ReFind $$$Relind='$$$Relind D ..Message(qqr) Q:$Q "" Q
 ZK ^Q(qviewf)
 J AFonFind^%ooLibrary.qWORD.1(+$G(Arg2),qql,qqlang,qviewf,qlistF,qlistFR,500,$G(Vs(qqnump,99,"Find",5))):("":''$D(Vt(qqnump,111))):15 I '$T D ..Message("Фоновый поиск не может быть запущен") S:$$$ReFind $$$Relind='$$$Relind Q:$Q "" Q  ;:("":1)- вся локальная среда ;500 - чтобы записать в релевантные первый найденный
 N it F it=1:1:5 Q:$D(^Q(qviewf))  H 2
 I '$D(^Q(qviewf)) G FindFonStart  ;пока ничего не найдено
 I '$G(^Q(qviewf),1) D FindMessage("Ошибка при поиске"_$C(13,10)_^Q(qviewf)) I $D(^Q(qviewf))<10 Q:$Q "" Q
 I $D(^Q(qviewf))>1 S $$$ReFind=1,$$$RelNum=1 D FindEnd ;что-то найдено
 I '$G(^Q(qviewf),0) G FindFonStart  ;поиск еще не завершен
 I $D(^Q(qviewf))<10 D FindMessage("Ничего не найдено") S:$$$ReFind $$$Relind='$$$Relind Q:$Q "" Q
 I W("Zadm") S %1=$P(^Q(qviewf)," ",2) D:%1>2&('$G(NoDial)) ..Message("Время выполнения: "_(%1\60)_":"_$E(%1#60+100,2,3),"Поиск")
 Q:$Q "" Q
FindFonStart S W("ZfindF")=1 D ..wP(qwin_$S($G(W("Zsform"))<100:".TBS",1:".T1.TBS")_".b62","ImageIndex",5),..wP(qwin_$S($G(W("Zsform"))<100:".TBS",1:".T1.TBS")_".b62","Hint","Остановка Фонового Поиска") D ..OpenTimer(2000,"D qARM.FindFonEnd()") Q:$Q "" Q
FindMessage(mes)
 I $G(NoDial) S qMessage=mes Q
 D ..Message(mes,"Поиск") Q
]]></Implementation>
</Method>

<Method name="FindAll">
<Description>
Параметры поиска по всем объектам</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 Q:'$G(Vs(qqnump,99,"Find",1)) ""
 N qqolst,qq1,qq2,qq3,qq4,qq5,qii
 S qq1=$O(Vs(qqnump,8,"")) Q:$O(Vs(qqnump,8,qq1))'="" "" ;условия только на одном объекте
 ;;новый вариант. формируется массив наборов условий (Vs(qqnump,808,qii) для объектов с совпадающими понятиями
 S qqolst="",qq4=-1,qii=$G(Vs(qqnump,808))+2 F  S qq4=$O(Vo(qqnump,qq4)) Q:qq4=""  I qq4'=qq1,qq4'=-1 D  I $D(Vs(qqnump,808,qii,qq4))>1,$I(qii) S qqolst=qqolst_","_qq4
 .S qq2="" F  S qq2=$O(Vs(qqnump,8,qq1,qq2)) Q:qq2=""  M:$D(Vo(qqnump,qq4,11,qq2)) Vs(qqnump,808,qii,qq4,qq2)=Vs(qqnump,8,qq1,qq2)
 I $G(qqolst)'="" M Vs(qqnump,808,$G(Vs(qqnump,808))+1,qq1)=Vs(qqnump,8,qq1) S Vs(qqnump,808)=qii-1
 Q $G(Vs(qqnump,808))
 ;;старый текст
 S qq2=$O(Vs(qqnump,8,qq1,"")) Q:$O(Vs(qqnump,8,qq1,qq2))'="" ""
 S qqolst="",qq4=-1 F  S qq4=$O(Vo(qqnump,qq4)) Q:qq4=""  I qq4'=qq1,$D(Vo(qqnump,qq4,11,qq2)),$G($$$ObjRef(qq4))'="",'$G(Vs(qqnump,7,qq4)) S qqolst=qqolst_","_qq4
 Q:$G(qqolst)="" "" Q qq2_" "_qq1_qqolst_" "_Vs(qqnump,8,qq1,qq2) ;@dol 13.06.03 Vs(qqnump,8,qq1,qq2)
]]></Implementation>
</Method>

<Method name="FindFonEnd">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Arg1) S %1=$ZU(4,$ZC),qqxtimer="" D:0 ..Message(%1_" "_$ZC) G FindFonStop ;снятие фонового процесса
 N qviewf
 S qviewf=$$$Relind_qview ;ссылка на перечень релевантных
 I '$D(^Q(qviewf))  D ..OpenTimer(2000,"D qARM.FindFonEnd()") Q:$Q "" Q  ;пока ничего не найдено
 I '$G(^Q(qviewf),1) D ..Message(^Q(qviewf),"Ошибка при фоновом поиске") G:$D(^Q(qviewf))<10 FindFonStop
 I $D(^Q(qviewf))>1 D  ;что-то найдено
 .D ..wP(qwin_".TBN.b41","Caption",$J($G(^Q($$$Relind_qview,$$$CurObj)),7))  ;поменяем только счетчик
 .Q:$$$ReFind  S $$$ReFind=1,$$$RelNum=1 D ..Fix(),..wfot(-2)
 .S qqc="" S:'$D(^Q($$$Relind_qview,$$$CurObj)) $$$CurObj="" I $E($G(W("Zsform")))'=1 D:0&$G(Vs(qqnump,99,"Find",1)) ..wP(qwin_".TBS","Color",255) D ..wP(qwin_".TBC.b401","Down",1),..wP(qwin_".TBC.b402","Down",0) ;.b62
 .D ..wcre()
 I '$G(^Q(qviewf),0) D ..OpenTimer(2000,"D qARM.FindFonEnd()") Q:$Q "" Q  ;поиск еще не завершен
 S %1=$P(^Q(qviewf)," ",2) D:%1>2 ..Message("Время выполнения: "_(%1\60)_":"_$E(%1#60+100,2,3),"Фоновый поиск"_$S($D(^Q(qviewf))<10:" Ничего не найдено",1:""))
FindFonStop I $D(^Q($$$Relind_qview))<10,$$$ReFind S $$$Relind='$$$Relind
 K W("ZfindF") D ..MenuAn("F") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Fix">
<Description>
Фиксировать объект Arg1.
Если Arg1 не задан, расфиксировать последний зафиксированный объект ( в Vs(qqnump,7)).
Arg2=1 жесткая фиксация. Если нет, то возможно перемещение
по обектам вершины фиксации.
Arg3=1 - сделать кнопку неактивной
Arg4=1 - блокировка перевывода
NoMes=1 - не выдавать сообщение о невозможности фиксации
Nopos=1 - не позиционироваться (в противном случае позиционирование на первую строку фиксируемого объекта)
Stat=1 - сохранять состояние переред фиксацией (при снятии фиксации восстанавливается)</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%String=0,Arg3:%String,Arg4:%Library.String,NoMes:%Library.String,Nopos:%Library.String,Stat:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $D(Vt(qqnump,111)),$D(Vc(qqnump))>1,'$D(Vt(qqnump,111,0,$$$CurObj)) D ..Virt(1) ; ;@dol 6.03.03 для виртуальных
 ;.N qqob,qqobi S qqob=$G($$$ObjRef($$$CurObj)) I qqob'="" F qqobi=$L(qqob,","):-1:1 I $G(Vo(qqnump,$P(qqob,",",qqobi),2)) S Vs(qqnump,"Virt",$P(qqob,",",qqobi))=Vc(qqnump,$E(Vc(qqnump),1,qqobi*2))
 ;.S qqc0=$S($L(qqob,",")=1:"",1:Vc(qqnump,$E(Vc(qqnump),1,$L(qqob,",")-1*2)))
 N qqot1
 I $G(Arg1)="" Q:$G(Vs(qqnump,7))=""&$Q "" Q:$G(Vs(qqnump,7))=""  D   D:$G(W("Zsform"))'=11 ..wP(qwin_".TBG.b3","Down",0) S qqot1=..GetPar("X1668") X:qqot1'="" qqot1 Q:$Q "" Q
 .K Vs(qqnump,17) ;признак жесткой фиксации
 .S Vs(qqnump,7)="" D
 ..I $G(Vs(qqnump,"7stat"))="" S $P($$$CondFind," ",10,11)="" Q
 ..;S qqc=$P(Vs(qqnump,"7stat"),$C(0),4),$$$CurObj=$P(Vs(qqnump,"7stat"),$C(0),3)
 ..;sas 20090722 криво работала свертка объектов 3 уровня с типом свернутости фиксация
 ..S qqc=$P(Vs(qqnump,"7stat"),$C(0),2),$$$CurObj=$P(Vs(qqnump,"7stat"),$C(0),1)
 ..S $$$CondFind=$P(Vs(qqnump,"7stat"),$C(0),7) I $P($$$CondFind," ",1)'="" K W($P($$$CondFind," ",1))
 ..;M Vs(qqnump,7)=Vs(qqnump,"7stat")
 ..S Vs(qqnump,7)=$P(Vs(qqnump,"7stat"),$C(0),5) S:$P(Vs(qqnump,"7stat"),$C(0),6) Vs(qqnump,17)=1 I $D(Vc(qqnump))>1 D ..Estat() K Vc(qqnump),Vs(qqnump,2,$P(Vs(qqnump,"7stat"),$C(0),1))
 .D ..wfot(Vs(qqnump,7)) I '$G(Arg4) D ..wcre(,,$G(Vs(qqnump,"7stat"))'="") I $G(Vs(qqnump,"7stat"))'="" D ..wpoe(,,,,$P(Vs(qqnump,"7stat"),$C(0),1),$P(Vs(qqnump,"7stat"),$C(0),2))
 I $G(Stat) D  ;запомнить текущее остояние
 .K Vs(qqnump,"7stat") ;M Vs(qqnump,"7stat")=Vs(qqnump,7)
 .S Vs(qqnump,"7stat")=$$$CurObj_$C(0)_$$$ID_$C(0)_$G(Vc(qqnump,"AA",0))_$C(0)_$G(Vc(qqnump,"AA"))_$C(0)_$G(Vs(qqnump,7))_$C(0)_$G(Vs(qqnump,17))_$C(0)_$$$CondFind
 K Vs(qqnump,17)
 K Vs(qqnump,7)
 ;??????????S:'$D(Vo(qqnump,Arg1,0)) Vo(qqnump,Arg1,0)=$$$ObjLget(Arg1) ;@Dol 28.07.05 - фиксация по отсутствующему
 ;S:Arg2 Vs(qqnump,17)=1
 I '$$$Tree,$$$ObjLqqc(Arg1)'=255,$L(qqc)<$$$ObjLqqc(Arg1) S qqot1=qW.gOrder(1,Arg1,"",qqc) D  I qqot1="" D:'$G(NoMes) ..Message("Фиксация невозможна. qqo="_Arg1_" qqc="_qqc_" Отображение "_Vo(qqnump)) Q:$Q "" Q
 .I qqot1="",$G(Vo(qqnump,Arg1,87)) S qqot1=qqc_" " ;@Dol 6.08.06 фиксация на несуществующем при установленном выводе отсутствующих (пока без контроля и учета выражения)
 .S:qqot1'="" qqc=qqot1
 S:Arg2 Vs(qqnump,17)=1
 I $$$CurObj'=Arg1 D
 .;I $$$Tree S $$$CurObj=Arg1 Q
 .I $$$CurObj="" S $$$CurObj=Arg1 Q
 .I "_,"_$G($$$ObjRef($$$CurObj))_","'[(","_Arg1_",") S $$$CurObj=Arg1 Q
 S Vs(qqnump,7)=Arg1 D:'$G(Arg4) ..wfot(Arg1)
 S qqot1=$S($$$Tree:$S($L($$$ObjRef(Arg1),",")=1:"",1:qqc),1:$E(qqc,1,$$$ObjLqqc(Arg1))),$P($$$CondFind," ",10,11)=$TR(qqot1," ")_" "_$TR(qqot1," ")
 D:'$G(Arg4) ..wcre(,,$G(Nopos)) ;@dol 10.01.03 кол-во экземпляров увеличивается автоматически
 I $G(W("Zsform"))#100<11,qqnump'="P" D ..wbuttb(3,1) D:$G(Arg3) ..wbuttb(3,,0)
 S qqot1=..GetPar("X1668") X:qqot1'="" qqot1 ;@Dol 15.10.05 действие после фиксации
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="FlatButton">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$D(qwin(qwin,"FBUT")) D ..wC("TqCellButton",qwin_".FBUT",qwin_".T2",-1,+$G(W("Zpos",2,"x")),0) D ..wP(qwin_".FBUT","OnClick",1) I 1
 E  D ..wM(qwin_".FBUT","CellNew",qwin_".T2",-1,+$G(W("Zpos",2,"x"))),..wP(,"Visible",1)
 S qwin(qwin,"FBUT")=Arg1 ;S qxecuteFB=$G(Arg1)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="FolderDialog">
<Description>
Arg2 - выбранная папка; если выбор отменен - пустая строка. </Description>
<Internal/>
<FormalSpec>Sender:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 S qARM("qpars",0)=Arg2
 D ..Value($G(qxecuted),"X")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="GetBqqnump">
<Description>
Получение qqnump базового окна (для текущего встроенного)
Arg1=1 - переход в контекст этого окна</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(qwin(qwin,"child"))="" Q:$Q qqnump Q
 N qqnumpE S qqnumpE=qqnump F  S qqnumpE=qwin("Q"_qqnumpE,"child") Q:$G(qwin("Q"_qqnumpE,"child"))=""  ;поиск базового окна
 D:$G(Arg1) ..csav(),..crst(,qqnumpE,2) Q:$Q qqnump Q
]]></Implementation>
</Method>

<Method name="GetCellToolTip">
<Description><![CDATA[
Событие по всплывающей подсказке @Dima&@Dol 03.09.08 ]]></Description>
<Internal/>
<FormalSpec>Sender:%String,qqdat:%String,qqx:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 ;$$$FEvent @dima убрал 20101220
 ;I $P(Sender,".")'=("Q"_$G(qqnump)),..ChgWin() Q ""
 ;I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 N qqnumpt S qqnumpt=qqnump N qqci,qqc,qqo,qqw,qqnump,ret S qqnump=$E($P(Sender,"."),2,255)
 S qqw=$P($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx))," "),qqw=$S('$E(qqw):"",$E(qqw)=5:"Zs"_$P(qqdat," ",3)_"c"_qqx,1:$E($P(qqw," "),2,31))
 S qqo=$P(qqdat," ",2),qqci=$P(qqdat," ",1),qqc=$G(Vc(qqnump,qqci)),ret=$E($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,102)),3,30000)
 I $TR(ret," ")="" S:'$D(Vo(qqnump,-1,702)) Vo(qqnump,-1,702)=..GetPar("X1702") S ret=Vo(qqnump,-1,702) Q:ret="" ""
 Q @ret
]]></Implementation>
</Method>

<Method name="GetDLValues">
<Description>
Получение значения выражения или текста ошибки, если некорректное (для datalink'ов) @dima 20100128</Description>
<Internal/>
<FormalSpec>StrSet:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 n len,rez,sl,s,j s len=0,rez=""
GetDLValuesLp
 s sl=$P(StrSet," ")
 s s=$E(StrSet,$L(sl)+2,$L(sl)+1+sl)
 s s=$E($$GetDLValuesGet(s),1,4000)
 s rez=rez_$L(s)_" "_s
 s StrSet=$E(StrSet,$L(sl)+2+sl,131071)
 g:$L(StrSet)>0 GetDLValuesLp
 q rez
GetDLValuesGet(Str)
 n res,$ET,$ES s $EC="",$ET="s res=$ZE,$EC="""" q:$Q res q"
 i $G(%qDebug("wMet")) d ..Log("Datalink: s res="_Str)
 s @("res="_Str)
 q res
]]></Implementation>
</Method>

<Method name="GetName">
<Description>
Имя в отображении (выводимое)
qqview - код отображения (пусто - текущее)</Description>
<Internal/>
<FormalSpec>qqview:%Library.String,Obj:%Library.String,Woc:%Library.String,Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 I $G(Arg1)'="" N qqnump S qqnump=Arg1 ;относительно другого окна
 
 
 i $G(qqview)="" s qqview=$g(Vo(qqnump,-1,-1))_$s($g(Vo(qqnump,-1,-1))'="":$C(1),1:"")_Vo(qqnump)
  
 n qqoView
 S qqoView=$S($g(qqview)'[$C(1):"XView",1:$P($g(qqview),$C(1))) S:$g(qqview)[$C(1) qqview=$P($g(qqview),$C(1),2,255) ;Маслова 06.08.2010    
 
  
 N qcomp I $G(Woc)'="" N qqw S qqw=Woc,qcomp=..GetPar(7100,qqoView_$C(1)_qqview,Obj,Woc) S:$E(qcomp)="@"&&($TR(qcomp," ")'="@") @("qcomp="_$E(qcomp,2,1000)) S:qcomp=""||(qcomp="@") qcomp=$TR(qW.GetWoc("CxWoc",Woc),"_"," ") Q qcomp ;@Dol 1.09.05 @("comp...)
 I $G(Obj)'="" S qcomp=..GetPar(51,$G(qqview),Obj) S:$E(qcomp)="@"||(qcomp="") qcomp=$TR(qW.GetWoc("CxObj",Obj),"_"," ") Q qcomp
 Q ..GetPar(11,$G(qqview))
]]></Implementation>
</Method>

<Method name="GetPar">
<Description>
Взять параметр отображения.
qqpar - код понятия параметра (например, "x121". можно использовать сокращенную форму - 121). 
qqview - код отображения. По умолчанию Vo(qqnump) - текущее отображение. Если есть View - то
используется оно (нужно для печатных форм, когда текущий контекст и вызываемая форма - разные
отображения).
!!! ЕСЛИ ЗАДАНО qqview, то НЕОБХОДИМО задать y и х а НЕ qqw
qqObj - код объекта
y - строка (или понятие)
x - колонка (если Arg4 не понятие)

qqnumpmem - номер открытого отображения (находящегося в памяти)


Параметры берутся из описания отображения (см. системный объект базы данных XView). Если
отсутсствует, то проверяется наличие параметра в описаниии объекта или понятия (системные
объекты базы CxObj, CxWoc). Этим обеспечивается наследование. 
При первом взятии параметра его значение переносится в массив Vo(qqnump) и при следующих
обращениях берется уже из массива.
Структура массива (qqwp - код понятия параметра в сист.обекте XView):
Vo(qqnump)=код_отображения
Vo(qqnump,-1)=имя отображения (X11)
Vo(qqnump,-1,$E(qqwp,3,5))=значения параметра отображения qqwp=x1..., X1....
Vo(qqnump,-1,2,$E(qqwp,3,5))=значения параметра действия qqwp=x2..., X2...
Vo(qqnump,-1,3,$E(qqwp,3,5))=значения параметра печати qqwp=x3..., X3...

Например,
Vo(qqnump,-1,28)=список отображений печати (X128)

Vo(qqnump,код_об)=имя объект (X51)
Vo(qqnump,код_об,0)=длина кода (X50)
Vo(qqnump,код_об,$E(qqwp,3,5))=значения параметра объекта qqwp=x5..., X5...

Vo(qqnump,код_об,0,Nстр)=ссылка на объект-потомок (X60)

Vo(qqnump,код_об,0,Nстр,Nкол)=тип_содержимое ячейки (x70_X71)
Vo(qqnump,код_об,0,Nстр,Nкол,$E(qqwp,3,5))=значения параметра ячейки объекта qqwp=x7..., X7..

Часть параметров переносится в массив Vo сразу при открытии отображения (они всегда нужны)
в методе qSys.CreVo. Этот метод создает дополнительные узлы в Vo.
Vo(qqnump,код_об,5)=объектная_ссылка
Vo(qqnump,код_об,10)=кол-во понятий (N)
Vo(qqnump,код_об,10,N)=qqw
Vo(qqnump,код_об,11,qqw)=Nстр_" "_Nкол

Vo(qqnump,-1,6,объектная_ссылка)="" - массив всех объектных ссылок
Vo(qqnump,-1,9)=Nпоследней колонки
Vo(qqnump,-1,9,Nкол)=параметры_колонки (первые три из X72)</Description>
<Internal/>
<FormalSpec>qqpar:%String,qqview:%String,qqObj:%String,y:%String,x:%String,qqnumpmem:%Library.String,tmplval:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qqval,qqpn,qt,qqcur
 ;S:$G(qqview)="" qqview=$S($G(View)'="":View,1:$P(qview," "))
 I $G(qqnumpmem)'="" N qqnump S qqnump=qqnumpmem,qqview=""
 
 ;Маслова 06.08.2010
 I $G(qqview)="" S qqview=$g(Vo(qqnump,-1,-1))_$s($g(Vo(qqnump,-1,-1))'="":$C(1),1:"")_$G(Vo(qqnump),"?") Q:qqview="" "" ;нет отображения;@Dol 21.08.06 если нет отображения, то все полохо в постдействии по восстановлению GManager
  
 N qqoView
 S qqoView=$S($g(qqview)'[$C(1):"XView",1:$P($g(qqview),$C(1))) S:$g(qqview)[$C(1) qqview=$P($g(qqview),$C(1),2,255) ;Маслова 06.08.2010
 
 
 ;если имя параметра задано неполностью
 I $E(qqpar)?1.N S qt=$E(qqpar),qqpn=$E(qqpar,2,10),qqpar=$S(qt=1:$S(qqpn=21||(qqpn=61)||(qqpn=73)||(qqpn=81)||(qqpn=87)||(qqpn=65):"x",1:"X"),qt=3:$S(qqpn<23:"x",qqpn=23:"TB",1:"X"),qt=5:$S(qqpn=2!(qqpn=21)!(qqpn=32):"x",1:"X"),qt=7:$S(qqpn=0||(qqpn=10)||(qqpn=30)||(qqpn=7)||(qqpn=42)||(qqpn=43):"x",1:"X"),1:"X")_qqpar I 1  ;||(qqpn=31)
 E  S qt=$E(qqpar,2),qqpn=$E(qqpar,3,10)
 S qqval="",qqcur=$S($E(qqview,4,6)="sys":1,1:$G(Vo(qqnump))=qqview) ;@dol 19.11.03 $P(qview," ")=qqview) ;запрос параметра текущего отображения
 I $E(qqpar)="T" D  Q:$Q qqval Q  ;19.08.09 Пояснения
 .I $G(qqObj)="" S qqval=qW.zMLine($NA(^Q(1,qqoView,qqview,qqpar)),,,,$C(13,10),1) Q
 .I $G(y)="" S qqval=qW.zMLine($NA(^Q(1,qqoView,qqview,"CxObj",qqObj,qqpar)),,,,$C(13,10),1) S:qqval="" qqval=qW.zMLine($NA(^Q(1,"CxObj",qqObj,qqpar)),,,,$C(13,10),1) Q
 .N qqw I $G(x)="" Q:$G(y)=""  S qqw=y D   I y="" S qqval=qW.zMLine($NA(^Q(1,"CxWoc",qqw,qqpar)),,,,$C(13,10),1) ;нет в отображении, взяли из понятий
 ..I $E(qqw,1,2)="Zs",qqw?1"Zs"1.n1."c"1.n S y=+$E(qqw,3,20),x=$P(qqw,"c",2) Q  ;для выражений
 ..S y=$G(Vo(qqnump,qqObj,11,qqw)) S:y'="" x=$P(y," ",2),y=$P(y," ")
 .S qqval=qW.zMLine($NA(^Q(1,qqoView,qqview,"CxObj",qqObj,"Xy",y,"Xx",x,qqpar)),,,,$C(13,10),1) S:qqval="" qqval=qW.zMLine($NA(^Q(1,"CxWoc",qqw,qqpar)),,,,$C(13,10),1)
 I qt=1 D  Q:$Q qqval Q  ;параметры отображения
 .I qqpn=1,qqcur S qqval=$G(Vo(qqnump,-1)) Q:qqval'=""  S (qqval,Vo(qqnump,-1))=$G(^Q(1,qqoView,qqview,qqpar)) Q  ;имя отображения
 .I qqcur,$D(Vo(qqnump,-1,qqpn)) S qqval=Vo(qqnump,-1,qqpn) Q
 .S (Vo(qqnump,-1,qqpn),qqval)=$G(^Q(1,qqoView,qqview,qqpar)) ;раньше в Vo не записывали
 I qt=3 D  Q:$Q qqval Q  ;параметры печати
 .I '$D(Vo(qqnump,-1,30)) S Vo(qqnump,-1,30)=+$G(^Q(1,qqoView,qqview,"X130"))
 .S qt=Vo(qqnump,-1,30) ;набор параметров печати по умолчанию
 .I $D(Vo(qqnump,-1,3,qqpn)) S qqval=Vo(qqnump,-1,3,qqpn) Q
 .S qqval=$G(^Q(1,qqoView,qqview,"XPrint",qt,qqpar)) I qqval="",qqpar="x321" S qqval=1 ;по умолчанию-таблица
 .S Vo(qqnump,-1,3,qqpn)=qqval
 I qt=2 D  Q:$Q qqval Q  ;параметры действий (y - номер действия)
 .S y=+$G(y)
 .I $D(Vo(qqnump,-1,2,y,qqpn)) S qqval=Vo(qqnump,-1,2,y,qqpn) Q
 .S qqval=$G(^Q(1,qqoView,qqview,"XQuest",y,qqpar))
 S:$G(qqObj)="" qqObj=$$$CurObj S:qqObj="" qqObj=-1 ;@Dol 19.03.08 "" -1 ;текущий объект
 N qqObji S qqObji=qqObj I $G(Vo(qqnump,qqObj,889))'="" S qqview=$P(Vo(qqnump,qqObj,889)," ") S:$P(Vo(qqnump,qqObj,889)," ",2)'="" qqObji=$P(Vo(qqnump,qqObj,889)," ",2) ;@dol 26.09.04 объект создан по ссылке на другое отображение
 I qt=5 D  Q:$Q qqval Q  ;параметры объекта
 .I qqpn=1 S qqval=$G(Vo(qqnump,qqObj)) Q:qqval'=""  S (qqval,Vo(qqnump,qqObj))=$G(^Q(1,qqoView,qqview,"CxObj",qqObji,qqpar)) Q  ;имя объекта
 .I $D(Vo(qqnump,qqObj,qqpn)) S qqval=Vo(qqnump,qqObj,qqpn) Q
 .I $G(^Q(1,qqoView,qqview,"CxObj",qqObji,qqpar))'="" S qqval=^(qqpar) I 1
 .E  S qqval=$G(^Q(1,"CxObj",qqObji,qqpar))
 .S Vo(qqnump,qqObj,qqpn)=qqval ;переносится
 I qt=6 D  Q:$Q qqval Q  ;параметры строки объекта
 .I qqpn=0 S qqval=$G(Vo(qqnump,qqObj,0,y)) Q:$D(Vo(qqnump,qqObj,0,y))#1  S (qqval,Vo(qqnump,qqObj,0,y))=$G(^Q(1,qqoView,qqview,"CxObj",qqObji,"Xy",y,qqpar)) Q  ;ссылка на объект-потомок
 .S qqval=$G(^Q(1,qqoView,qqview,"CxObj",qqObji,"Xy",y,qqpar))
 N qqw,qtmpl I $G(x)="" Q:$G(y)="" "" S qqw=y D   I y="" Q $G(^Q(1,"CxWoc",qqw,qqpar)) ;нет в отображении, взяли из понятий
 .I $E(qqw,1,2)="Zs",qqw?1"Zs"1.n1."c"1.n S y=+$E(qqw,3,20),x=$P(qqw,"c",2) Q  ;для выражений
 .S y=$G(Vo(qqnump,qqObj,11,qqw)) S:y'="" x=$P(y," ",2),y=$P(y," ")
 I qt=7 D  S:qqpn=5&&($E(qqval)="=") (qqval,Vo(qqnump,qqObj,0,y,x,qqpn))="@"_qUSER.MACRO($E(qqval,2,30000)) Q:$Q $S(qqval'="":qqval,1:$G(tmplval)) Q  ;параметры ячейки объекта ;@Dol 1.07.06 - макроподстановки для значения по умолчанию (X75);@Dol tmplval - значение по умолчанию (см. qW.gForm wtwe , дин.параметры для образцов)
 .I qqpn=1 S qqval=$E($G(Vo(qqnump,qqObj,0,y,x)),2,1000) Q:qqval'=""  S qqval=$G(^Q(1,qqoView,qqview,"CxObj",qqObji,"Xy",y,"Xx",x,qqpar)),Vo(qqnump,qqObj,0,y,x)=+$G(^Q(1,qqoView,qqview,"CxObj",qqObj,"Xy",y,"Xx",x,"x70"))_qqval Q  ;содержимое ячейки
 .I qqpn=0 S qqval=$E($G(Vo(qqnump,qqObj,0,y,x))) Q:qqval'=""  S qqval=+$G(^Q(1,qqoView,qqview,"CxObj",qqObji,"Xy",y,"Xx",x,qqpar)),Vo(qqnump,qqObj,0,y,x)=qqval_$G(^Q(1,qqoView,qqview,"CxObj",qqObj,"Xy",y,"Xx",x,"X71")) Q  ;содержимое ячейки
 .S qtmpl=$S(qqpn=84:"",$D(Vo(qqnump,qqObj,0,y,x,84)):Vo(qqnump,qqObj,0,y,x,84),1:..GetPar("X784",qqoView_$C(1)_qqview,qqObj,y,x)) I qtmpl["(" N:qqpn'=10 qqend S qqval="",@("qtmpl="_qtmpl) Q:$G(qqend)'=""&0  K Vo(qqnump,qqObj,0,y,x,qqpn)  ;@Dol 4.02.06 qqend ;qqpn'=10 для x710 - см. qW.GetLine;;;;вычисление кода понятия образца
 .I qtmpl'="" D  Q:qtmpl'=""  K Vo(qqnump,qqObj,0,y,x,qqpn) ;@dol 7.07.04 текущая ссылка на образец
 ..I $E(qtmpl)="@"||(qtmpl[",") S:$E(qtmpl)="@" qtmpl=qW.GG(qqObj,$E(qtmpl,2,255),$G(qqc,"???")) D:qtmpl'=""  Q  ;динамический образец;@Dol 26.12.07 [","
 ...I qtmpl'["," D  Q
 ....S:'$D(Vo(qqnump,-1,857)) Vo(qqnump,-1,857)=$G(^Q(1,qqoView,qqview,"X1857")) I Vo(qqnump,-1,857)'="" S @("qqval="_Vo(qqnump,-1,857)) I qqval'="" S:qqval=" " qqval="" S Vo(qqnump,qqObj,0,y,x,qqpn)=qqval Q  ;@Dol 27.09.06 обработка динамического образца
 ....I qqpn="tmpl" S qqval=qtmpl Q  ;@Dol 13.07.08 код понятие образца (X7tmpl)
 ....S (Vo(qqnump,qqObj,0,y,x,qqpn),qqval)=$G(^Q(1,"CxWoc",qtmpl,qqpar)) Q
 ...I ",31,30,3,40,41,42,44,4,5,10,45,20,6,47,2,60,61,"[(","_qqpn_",") S (Vo(qqnump,qqObj,0,y,x,qqpn),qqval)=qSYS.PSYN(qtmpl,",",$L($P(",31,30,3,40,41,42,44,4,5,10,45,20,6,47,2,60,61,",","_qqpn_","),","),,,1) Q  ;список в qSYS.RedDCpar-диалоговое редактирование параметров образца.!!! В qARM.StartEditT2 должны всегда перевычислятся!!!
 ...S qtmpl=""
 ..I qqpn="tmpl" s qqval=$e($g(Vo(qqnump,qqObj,0,y,x)),2,255) Q  ;OlgaS 21/01/09 - 
 ..I $D(Vo(qqnump,qqObj,0,y,x,qqpn)) S qqval=Vo(qqnump,qqObj,0,y,x,qqpn) Q
 ..S (Vo(qqnump,qqObj,0,y,x,qqpn),qqval)=$G(^Q(1,"CxWoc",qtmpl,qqpar)) Q
 .I $D(Vo(qqnump,qqObj,0,y,x,qqpn)) S qqval=Vo(qqnump,qqObj,0,y,x,qqpn) Q
 .D  S Vo(qqnump,qqObj,0,y,x,qqpn)=qqval Q
 ..I $G(^Q(1,qqoView,qqview,"CxObj",qqObji,"Xy",y,"Xx",x,qqpar))'="" S qqval=^(qqpar) Q
 ..I qqpn="1"!(qqpn="0") S qqval="" Q  ;тип и понятие ячейки
 ..;наследование от понятия
 ..;I '$D(qqw) S qqval="" Q:"234"'[..GetPar("x70",qqview,qqObj,y,x)  S qqw=..GetPar("x71",qqview,qqObj,y,x) Q:qqw=""
 ..I '$D(qqw) S qqval="",qt=+..GetPar("x70",qqoView_$C(1)_qqview,qqObj,y,x) Q:"05"[qt  S qqw=..GetPar("X71",qqoView_$C(1)_qqview,qqObj,y,x) Q:qqw=""  I qt=6,$E(qqw,1,3)'="@ZX" Q  ;@dol 6.8.03 @ZX*-кнопка
 ..S:qqw[":" qqw=$P(qqw,":",2) ;@Dol 25.03.06
 ..S qqval=$G(^Q(1,"CxWoc",qqw,qqpar)) Q  ;I $D(^Q(1,"CxWoc",qqw,qqpar)) S qqval=^(qqpar) Q
 ..Q  ;наследование от домена пока не задействовано
 ..S qqval=$G(^Q(1,"CxWoc",qqw,"xWoc")) Q:qqval=""  ;ссылка на домен
 ..S qqval=$G(^Q(1,"CxWoc",qqval,qqpar))
 Q:$Q "???" Q
]]></Implementation>
</Method>

<Method name="GetProp">
<Description>
Считывание свойств</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 I $E($P(Obj("Object"),".",2))="Q" S Obj("Object")=$P(Obj("Object"),".",2,255) ;@Dol 1.07.05 для встроенных окон
 I Obj("Object")=qwin,Obj("ProCode")="Width" S $P(^Q(1,"XView",Vo(qqnump),"X129"),",",1)=Obj("ProValue") Q:$Q "" Q
 I Obj("Object")=qwin,Obj("ProCode")="Height" S $P(^Q(1,"XView",Vo(qqnump),"X129"),",",2)=Obj("ProValue") Q:$Q "" Q
 ;
 I Obj("Object")=(qwin),Obj("ProCode")="SplitterMove" S $P(^Q(1,"XView",Vo(qqnump),"X129"),",",3)=Obj("ProValue") Q:$Q "" Q
 I Obj("Object")=(qwin),Obj("ProCode")="ShowTrees" S:Obj("ProValue")'=2 $P(^Q(1,"XView",Vo(qqnump),"X129"),",",3)=$S(Obj("ProValue")=0:0,1:"100%") Q:$Q "" Q
 ;
 I Obj("Object")=(qwin_".T1"),Obj("ProCode")="ColumnWidth" N qq S qq=$P(^Q(1,"XView",Vo(qqnump),"X170")," ",1),$P(qq,",",Obj("params",1)+1)=Obj("ProValue")_"px",$P(^Q(1,"XView",Vo(qqnump),"X170")," ",1)=qq Q:$Q "" Q  ;графы дерева объектов
 I Obj("Object")=(qwin_".T2"),Obj("ProCode")="ColumnWidth" S $P(Vo(qqnump,-1,9,Obj("params",1)),",",1)=Obj("ProValue")_"px",$P(^Q(1,"XView",Vo(qqnump),"CxObj",-1,"Xy",0,"Xx",Obj("params",1),"X72"),",",1)=Obj("ProValue")_"px" Q:$Q "" Q  ;графы дерева экземпляров
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="GetProtocol">
<Internal/>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 I '$D(qprotsto) Q:$Q "" Q
 S qcnext="",qc="" N ret1 K:0 W("Zproto") f  s ret=$$NextCmnd(.Obj) s:$G(Obj("ProCode"))="GetIVolSec.KrasInfoCardRead" qCardRead=$LB(Obj("params",2),Obj("params",3),Obj("params",8)) Q:'ret  D
 .I Obj("ProCode")="Cursor" D ..Value($G(qxecute1),"X") D ..wP("-qARM","Cursor",0) Q
 .I $E(Obj("ProCode"),1,10)="MessageBox" D ..Value($S(Obj("ProValue")=1:$G(qxecute1),1:$G(qxecute0)),"X") Q
 .I Obj("ProCode")["ShowMessagePos" D ..Value($S(Obj("ProValue")=6:$G(qxecute1),Obj("ProValue")=7:$G(qxecute0),1:""),"X")
 .I Obj("ProCode")["ReadClientFile" s ZFile=$g(Obj("ProValue")) D ..Value($G(qxecutef),"X") q
 .i $D(qswitch("GOTO")) d @qswitch("GOTO") Q
 .D ..GetProp() Q
 .D ..Message("????")
 Q:$Q "" Q
 ;подпрограммы
NextCmnd(Object) 
 i +$G(qprotsto("code")) k qprotsto("code") d RecProt
 n b1,b2,byte,marker,whatfun,t,displ,j,ret,nb,bn,cntq,i k Object s marker=$G(qprotsto,1),qprotsto=marker,byte=$A($$ReadStr(marker,1)),displ=0
 i byte=7 d
 .s b1=$A($$ReadStr(marker+1,1)),b2=$A($$ReadStr(marker+2,1)),t=+$E($$StrTByte(b1),1,4),whatfun=$S(t=1:"DoMet",t=10:"SetPro",t=11:"CreObj",t=100:"GetPro",t=101:"GetPro_",1:"?")
 .i (whatfun="GetPro")!(whatfun="GetPro_") d
 ..s t=$E($$StrTByte(b1),5,8),Object("WhatFunction")=whatfun,j=0,nb=0,displ=3+b2
 ..f i="Class","Object","ProCode","ProValue" s j=j+1 i $E(t,j)=1 s nb=nb+1,ret=$$GetAtom(marker+b2+3,nb,.cntq),Object(i)=ret,displ=displ+$L(ret)+3+cntq
 ..f i=1:1:b2 s bn=$$StrTByte($A($$ReadStr(marker+2+i,1))) f j=1:1:8 i $E(bn,j)=1 s nb=nb+1,ret=$$GetAtom(marker+b2+3,nb,.cntq),Object("params",i-1*8+j)=ret,displ=displ+$L(ret)+3+cntq
 ..s displ='b2+displ+1 i '$D(Object("ProValue")) s Object("ProValue")=""
 .i whatfun="GetPro_" i $D(Object("params"))>1 k j m j=Object("params") k Object("params") f i=1:1:$O(j(""),-1)\2 s:j(2*i)'="" Object("params",j(2*i))=j(2*i-1)
 s qprotsto=qprotsto+displ,ret=''$D(Object) q:$Q ret q
GetAtom(marker,displ,cntq) 
 n parn,i,outstr,dqt,byte,aquite s dqt=0,parn=0,aquite=0,outstr="",cntq=1 ;0
 f i=marker:1  s byte=$$ReadStr(i,1) q:'$L(byte)  d  q:aquite
 .s:$A(byte)=147 dqt=dqt+1 i $A(byte)=46,'(dqt/2-(dqt\2)) s parn=parn+1
 .s:parn=displ outstr=outstr_byte s:parn>displ aquite=1
 s aquite=$L(outstr),outstr=$E($E(outstr,2,aquite),1,aquite-2) f i=1:1  q:i>$L(outstr)  i $A($E(outstr,i))=147 s outstr=$E(outstr,1,i-1)_$E(outstr,i+1,aquite),cntq=cntq+1
 s cntq=cntq-2 q outstr
CntBit(str) 
 n i,j,cnt,byte s cnt=0
 f i=1:1:$L(str) s byte=$$StrTByte($E(str,i)) f j=1:1:8 i $E(byte,j)=1 s cnt=cnt+1
 q cnt
ReadStr(marker,length) ;
 q $E(qprotsto(1),marker,marker+length-1)

StrTByte(str) 
 n strbyte,i,ok s strbyte="",ok=0
 f i=7:-1:0 s:((2**i)<(str+1)) strbyte=strbyte_1,ok=1 s:((2**i)>(str))!('str) strbyte=strbyte_0,ok=0 s:ok str=str-(2**i)
 q strbyte
RecProt 
 n end,length,i,j,out,byteout,byte,marker,rem,bitin,qprotstr m qprotstr=qprotsto k qprotsto
 d StrSave($TR($J("",8)," ",$C(0)),32*1024-1) s end=$O(qprotstr(""),-1),marker=0,rem="" m out=qprotstr k qprotstr q:'end
 f i=1:1:end s length=$L(out(i)) f j=1:1:length d
 .s marker=marker+1,byte=$$StrTByte($A($E(out(i),j))),bitin=$E(byte),rem=rem_$E(byte,2,8)
 .i bitin,marker>1 d StrSave($C($$ByteTStr($E(rem,1,8))),length) s rem=$E(rem,9,$L(rem))
 .i marker=8 s rem="",marker=0
 m qprotsto=qprotstr q
StrSave(str,length) 
 n lin,lout,indx s lin=$L(str),indx=+$O(qprotstr(""),-1),indx=$S('indx:1,$L(qprotstr(indx))<length:indx,1:indx+1),qprotstr(indx)=$G(qprotstr(indx)),lout=$L(qprotstr(indx))
 i (lin+lout)<(length+1) s qprotstr(indx)=qprotstr(indx)_str
 e  s qprotstr(indx)=qprotstr(indx)_$E(str,1,length-lout) d StrSave($E(str,length-lout+1,lin),length)
 q
ByteTStr(strbyte) 
 n str,i,n s str=0,n=$L(strbyte)
 f i=0:1:7 s:$E(strbyte,n-i)=1 str=2**i+str
 q str
]]></Implementation>
</Method>

<Method name="Grid">
<Internal/>
<FormalSpec>Color:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N bc,bw,p161,p180,p188,p155,qqz,qqzF S p161=+Vo(qqnump,-1,61)
 S bw=256*256*256-1 ;белый ненаследуемый для цвета небланка по умолчанию
 S bc=qqXBColor ;-2147483633   ;@dol 30.01.03 цвет от Виндов (ранше был серебряный 12632256 ) ;16777215
 D ..GetPar("X119") S (Vo(qqnump,-1,55),p155)=qSYS.BasePar("X155",..GetPar("X155")) S:$P(p155,",",4)'="" (bw,bc)=$P(p155,",",4) I $P(p155,",",3)'="" D ..wP(qwin_".T3","ForeColor",$P(p155,",",3)),..wP(qwin_".T2","ForeColor",$P(p155,",",3))
 I $P(p155,",",5)'="" D ..wP(qwin_".T3","SelectForeColor",$P(p155,",",5)),..wP(qwin_".T2","SelectForeColor",$P(p155,",",5))
 I $P(p155,",",6)'="" D ..wP(qwin_".T3","SelectBackColor",$P(p155,",",6)),..wP(qwin_".T2","SelectBackColor",$P(p155,",",6))
 ;p161 0-дерево, 1-бланк, 2-пояснения, 3 - выбор, 4 - таблица 5 - список
 S p180=$S($G($$$Tree):1,1:..GetPar(180)) I p180="","125"[p161 S p180=1 ;по умолчанию, для совместимости с прежним вариантом не показывать колонку релевантныхдля бланка и пояснений
 S p188=..GetPar(188) I p188="","125"[p161 S p188=1 ;по умолчанию, для совместимости с прежним вариантом не показывать заголовки колонок для бланка и пояснений
 I $G(W("ZotSt"))="","15"[p161 S W("ZotSt")=1 ;для бланка и списка - наличие отступа по умолчанию
 S:$G(Color)="" Color=$S("1235"[p161:bc,W("ZBtred"):180,1:-2147483632)
 ;;;;;D:$G(qqXBNoXP) ..wP(qwin_".T1","UseThemes",0),..wP(qwin_".T2","UseThemes",0)
 S (qqz,qqzF)=$S($G(qqXBNfon):"",1:..GetPar("X1667")) ; картинка фона
 D ..wP(qwin_".T3","BackColor",$S("1235"[p161:bc,1:bw)),..wP(qwin_".T2","BackColor",$S("1235"[p161:bc,1:bw))
 ;!!!! - а где установка p155 НАДО ПЕРЕДЕЛАТЬ - наследуется в qW.gForm(wtwe,qARM.gre) D ..wM(qwin_".T2","SetDefHeadersFont"),..wM(qwin_".T3","SetDefHeadersFont") ;@Dima сделать фонт заголовков колонок таким же, как у дерева
 I qqz'=""  D  ; картинка фона; @Dol 02.10.08
 .N qqzz S:$E(qqz)="@" @("qqz="_$E(qqz,2,1000)) S qqzz=$P(qqz," ",2),qqz=$P(qqz," ",1) D  D ..wP(qwin_".T2","BackgroundPicture_",qqz) D:qqzz'="" ..wP(Tree,"BackgroundStyle",qqzz)
 ..I $E(qqz,1,2)="R," S qqz=$P(qqz,",")_$P(qqz,",",2) Q:$D(WQ(qqz))  D qARM.wC("TBitmap",qqz) S WQ(qqz)="" D qARM.wM(qqz,"LoadFromRsc","R,"_$E(qqz,2,255)) Q
 ..;I $E(qqz,1,2)="F," N qqzF S qqzF=qqz,qqz=$P(qqz,",")_$TR($P($P(qqz,",",2),"\",$L($P(qqz,",",2),"\")),".") Q:$D(WQ(qqz))  D qARM.wC("TBitmap",qqz) S WQ(qqz)="" D qARM.wMByf(qqz,"LoadFromFile",$S($E(qqzF,4)=":":"",1:qARM("ClientPath")_"F\")_$P(qqzF,",",2),1,"00") Q
 ..I $E(qqz,1,2)="F," N qqzF S qqzF=qqz,qqz=$P(qqz,",")_$TR($P($P(qqz,",",2),"\",$L($P(qqz,",",2),"\")),".") Q:$D(WQ(qqz))  D qARM.wC("TBitmap",qqz) S WQ(qqz)="" D ..wM(qqz,"LoadFromRsc","F,"_$S($E(qqzF,4)=":":"",1:qARM("ClientPath")_"F\")_$P(qqzF,",",2)) Q
 ..;I $E(qqz,1,2)="M," N qqzF S qqzF=$P(qqz,",",2,255),qqzF=$P(qqzF,")",1,$L(qqzF,")")-1)_")",qqz=$TR(qqzF,"^,.\:"")(") Q:$D(WQ(qqz))  D qARM.wC("TBitmap",qqz) S WQ(qqz)="" D qARM.wMByf(qqz,"LoadFromFile",qqzF,1,,1) Q
 ..I $E(qqz,1,2)="M," N qqzF,qqzo S qqzo=qqz,qqzF=$P(qqz,",",2,255),qqzF=$P(qqzF,")",1,$L(qqzF,")")-1)_")",qqz=$TR(qW.Translit($ZCVT(qqzF,"U")),"^,.\:""'`~@&$%*/[]{}!?|+-)(#") Q:$D(WQ(qqz))  D ..wC("TBitmap",qqz) S WQ(qqz)="" D:$D(@qqzF)>1 ..wM(qqz,"LoadFromRsc","M,"_$NA(@qqzF)) Q
 D  ;@dol 28.1.04
 .I p180 D ..wP(,"RowHeaderAppearance",0) Q  ;нет колонки релевантных
 .D ..wP(,"OnMouseMove",1),..wP(,"ToolTipRowE","Сброс релевантных/Включение в релевантные",-1) ;@Dol 13.10.05 ТоolTips заголовка релевантных
 .N i D ..GetPar("X1194") S:Vo(qqnump,-1,194)="" Vo(qqnump,-1,194)=$G(qqX1194) S:$E(Vo(qqnump,-1,194))="@" @("Vo(qqnump,-1,194)="_$E(Vo(qqnump,-1,194),2,1000)) D  D ..wP(qwin_".T2","RowHeaderWidth",i) I Vo(qqnump,-1,194)="" S Vo(qqnump,-1,194)="Bog Bor" Q
 ..S i=$S(p180:1,Vo(qqnump,-1,194)="":16,$P(Vo(qqnump,-1,194)," ",3)'="":$P(Vo(qqnump,-1,194)," ",3),Vo(qqnump,-1,194)["R,291":16,1:22) ;@Dol 25.03.11
 ..I $G(qqXBwsize),$P($G(qqX155),",",2)>8 S i=$P(qARM.wsize("0,"_i),",",2)
 .F i=1:1:2 S qqz=$P(Vo(qqnump,-1,194)," ",i) D
 ..D  ;@Dima 7.04.08 @Dol 15.09.05 любой ресурс для релевантных
 ...I $E(qqz,1,2)="R," S qqz=$P(qqz,",")_$P(qqz,",",2) Q:$D(WQ(qqz))  D qARM.wC("TBitmap",qqz) S WQ(qqz)="" D ..wM(qqz,"LoadFromRsc","R,"_$E(qqz,2,255)) Q
 ...;I $E(qqz,1,2)="F," N qqzF S qqzF=qqz,qqz=$P(qqz,",")_$TR($P($P(qqz,",",2),"\",$L($P(qqz,",",2),"\")),".") Q:$D(WQ(qqz))  D qARM.wC("TBitmap",qqz) S WQ(qqz)="" D qARM.wMByf(qqz,"LoadFromFile",$S($E(qqzF,4)=":":"",1:qARM("ClientPath")_"F\")_$P(qqzF,",",2),1,"00") Q
 ...I $E(qqz,1,2)="F," N qqzF S qqzF=qqz,qqz=$P(qqz,",")_$TR($P($P(qqz,",",2),"\",$L($P(qqz,",",2),"\")),".-") Q:$D(WQ(qqz))  D ..wC("TBitmap",qqz) S WQ(qqz)=""  D ..wM(qqz,"LoadFromRsc","F,"_$S($E(qqzF,4)=":":"",1:qARM("ClientPath")_"F\")_$P(qqzF,",",2))  Q
 ...;I $E(qqz,1,2)="M," N qqzF S qqzF=$P(qqz,",",2,255),qqzF=$P(qqzF,")",1,$L(qqzF,")")-1)_")",qqz=$TR(qqzF,"^,.\:"")(") Q:$D(WQ(qqz))  D qARM.wC("TBitmap",qqz) S WQ(qqz)="" D qARM.wMByf(qqz,"LoadFromFile",qqzF,1,,1) Q
 ...I $E(qqz,1,2)="M," N qqzF,qqzo S qqzo=qqz,qqzF=$P(qqz,",",2,255),qqzF=$P(qqzF,")",1,$L(qqzF,")")-1)_")",qqz=$TR(qW.Translit($ZCVT(qqzF,"U")),"^,.\:""'`~@&$%*/[]{}!?|+-)(#") Q:$D(WQ(qqz))  D ..wC("TBitmap",qqz) S WQ(qqz)="" D:$D(@qqzF)>1 ..wM(qqz,"LoadFromRsc","M,"_$NA(@qqzF)) Q
 ..S $P(Vo(qqnump,-1,194)," ",i)=qqz
 .D ..wP(qwin_".T2","RowColPictureH@1",$P(Vo(qqnump,-1,194)," ",1),0) ;@dol 28.07.05
 ;;;;нужно модифицировать @dima перенесено в qARMProj1 ///////////////////////////////////
 d qARM.wM(qwin,"F3",Color,bc,p161,$S("1235"[p161:1,$G(Vo(qqnump,-1,19)):1,1:0),p188'=1)
 ;D:qqzF="" ..wP(qwin_".T2","GridHorizontalColor",Color),..wP(,"GridVerticalColor",Color)
 ;D ..wP(,"TreeLineStyle","145"'[p161*2),..wP(,"SelectStyle",$S("1235"[p161:1,$G(Vo(qqnump,-1,19)):1,1:0)) ;*2) c учетом X119
 ;D:qqzF="" ..wP(,"TreeLineColor",$S('p161:180,1:bc))
 ;D ..wP(,"ColHeaderAppearance",'p188) ;"034"[p161) ;????
 ;D ..wP(,"InheritBgColor",p161>3) ;,..wP(,"ColumnBackColor",$S("1235"[p161:bc,1:bw),0),..wP(qwin_".T3","InheritBgColor",0) ;чтобы первая ячейка не распространяла влево свой цвет
 ;//////////////////////////////////
 ;D ..wP(,"AutoRespond","145"'[p161) ;???
 ;D:p161=1 ..wP(qwin_".T3","BackColorOdd",bc),..wP(qwin_".T2","BackColorOdd",bc)
 I $G(Vo(qqnump,-1,19))=2||($G(Vo(qqnump,-1,19))=4)||($G(Vo(qqnump,-1,19))=6) D ..wP(qwin_".T2","SelectStyle",3) ;@Dol 19.10.05 не выделять ничего ;=2
 I '$G(Vo(qqnump,-1,19)),+$G(Vo(qqnump,-1,59)) D ..wP(qwin_".T2","CellColorMult",+Vo(qqnump,-1,59)) 
 I p188>2 D ..wP(qwin_".T2","ColHeaderAppearance",2) ;S Vo(qqnump,-1,88)=p188#3 ;@Dol @21.07.05 заголовки как текст  
 D  ;вид кнопок дерева экземпляров
 .Q:"145"[p161  N but S but=$G(Vo(qqnump,-1,81)) S:but="" but=$S('p161:$G(^Q(1,"XBase",0,"R0x181"),0),p161=3:$G(^Q(1,"XBase",0,"R3x181"),6),1:$P("0,,2,6,7,",",",p161+1)) ;@Dol 10.11.05 x1810,x1813
 .I but=0 D ..wP(qwin_".T2","ButtonPictureH@1","But",1) Q
 .I but=1 D ..wP(qwin_".T2","ButtonPictureH@1","Button",1) Q
 .N butn S butn=$P(",221,217,219,220,218,224,262,374,375,",",",but) I '$D(WQ("but"_butn)) D ..wC("TBitmap","but"_butn) S WQ("but"_butn)="" D
 ..D ..wM("but"_butn,"LoadFromRes",butn)
 .D ..wP(qwin_".T2","ButtonPictureH@1","but"_butn,1)
 D ..wP(qwin_".T2","ButtonStyle","145"'[p161*2) ;@Dol 10.02.08 высота за счет MinItemHeit в qW.gForm (wtwe
 ;I "145"'[p161 D ..wP(,"ButtonStyle","145"'[p161*2) I 1
 ;E  D:'$D(WQ("but"_262))  D ..wP(qwin_".T2","ButtonPictureH@1","but"_262,1) ;@dol 20.03.03 псевдо кнопки (очень узкие), чтобы высота строк была в бланке и таблице не очень маленькой
 ;.D ..wC("TBitmap","but"_262) S WQ("but"_262)=""
 ;.D ..wM("but"_262,"LoadFromRes",262)
 D ..wP(,"AttItemClick",p161'=3) ;иммитация фокуса на следующую ячейку при клавишных перемещениях
 I ..GetPar("X1720") S:$G(child)'="" Vo(qqnump,-1,720)="" I $G(child)="" D ..wM(qwin,"StdBottomBar",Vo(qqnump,-1,720)-1) S qqz=..GetPar("X1196") D:qqz'=""  ;@Dol 13.02.06 кнопки выхода;@Dol 13.07.08 $G(child)=""
 .S:$E(qqz)="@" @("qqz="_$E(qqz,2,30000)) D:qqz'="" ..wP(qwin_".StdBottomBar.BOk","Hint",qqz) ;@Dol 02.03.06 вопрос выхода
 I $G(Vo(qqnump,-1,669))'="",'$D(qwin(qwin,"SBM")) D ..wC("TScrollBar",qwin_".SBM",qwin_".T2",$P(Vo(qqnump,-1,669)," ",4)'=0) D ..wP(qwin_".SBM","Period",100) S qwin(qwin,"SBM")=1 ;@Dol 28.06.06 скролбар перемещений ;@Dol 09.03.10 $P(," ",4) кнопки листания по страницам
 I p161=3 S Vs(qqnump,99,"Auto")=1
 I $P($G(Vo(qqnump,-1,856))," ",1)=1 d qARM.wP(qwin_".T2","UpDnToClick",0),qARM.wP(qwin_".T2","NextCellMet",$P(Vo(qqnump,-1,856)," ",2)),qARM.wP(qwin_".T2","TabStopClicksOnly",$S(($P(Vo(qqnump,-1,856)," ",3)'=1)!($G(W("Zadm"))=1):0,1:1))  ;;sasha@dima 22.09.06 нажатие кнопок "вверх", "вниз" вызывает OnKeyDown вместо обычного OnItemClick, это нужно для перемещения по меткам этими кнопками Cyclic=0: отключить циклический переход по меткам (с последней на первую)  ;;sasha@dima 03.10.06 добавка 241006 sasha@dima
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="GridColor">
<Description>
Цвет линий сетки Color=RJB ( X155 - 11 и 12)
Если не задан - утанавливается в зависимости от W("ZBtred")
 -1 - сброс в фон
qqnumpw - qqnump окна. не задано - текущее</Description>
<Internal/>
<FormalSpec>Color:%String,qqnumpw:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(qqnumpw)="" qqnumpw=qqnump
 S:$G(Color)="" Color=$P($G(Vo(qqnumpw,-1,55)),",",11+$S(qqnump=qqnumpw:$G(W("ZBtred")),1:$G(WS(qqnumpw,"ZBtred")))) Q:Color=""   I Color=-1 S Color=$P($G(Vo(qqnumpw,-1,55)),",",4) S:Color="" Color=qqXBColor
 D ..wP("Q"_qqnumpw_".T2","GridHorizontalColor",Color),..wP(,"GridVerticalColor",Color)
]]></Implementation>
</Method>

<Method name="InnerC">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqlev,qi,x
 I '$G(Arg1) D  K W("ZiNN") D:0 ..Message("Удалено") Q:$Q "" Q  ;удаление
 .D ..wM(qwin_".T2","M9",1,0,"-2 1") ;W("Zpos",2,"d"))
 .D ..wM(,"M6","",W("ZiNN")-1) Q
 S qqlev=$L($P(W("Zpos",2,"d")," "))\2,x=$G(W("Zpos",2,"x"),1)
 F qi=1:1:5 D
 .D ..wM(qwin_".T2","M2",""," ",qqlev,-2_" "_qi,0)
 .D ..wP(,"M4","Bog","",x,0) ;картинка для понятий
 .D ..wP(,"M1",qi,"",x,"",16777215)
 S W("ZiNN")=qi_" "_x
 D:0 ..Message("Вставлено")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="InstSysClass">
<Description>
Создание экземляров системных классов</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	i $d(^%QView("XSClass")) K ^Q(1,"XSClass") M ^Q(1,"XSClass")=^%QView("XSClass")
    n id,nameid
    i '$d(^Q(1,"XSClass")) m ^Q(1,"XSClass")=^%QView("XSClass")
    s id=""
    f  {
        s id=$o(^Q(1,"XSClass",id))
        q:id=""
        s nameid=$g(^Q(1,"XSClass",id))
        i (id'="&")&(nameid'="") s @("@id=##class("_nameid_").%New()")
    }
    q
]]></Implementation>
</Method>

<Method name="LoadView">
<Description>
Загрузка  отображения Arg1.
Arg2=1 - запуск поиска по текущему поисковому образу</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qqZot S W("Zomod")=0,qqZot=Arg1 ;$P(qview," ") ;код отображения
 N qqoView
 S qqoView=$S($g(qqZot)'[$C(1):"XView",1:$P($g(qqZot),$C(1))) S:$g(qqZot)[$C(1) qqZot=$P($g(qqZot),$C(1),2,255) ;Маслова 06.08.2010
 
 I $E(qqZot,4,6)="sys" K Vo(qqnump),Vs(qqnump),Vt(qqnump) S $$$CondFind="",qqc="",$$$ReFind=0,$$$RelNum=0 D qSYS.sysView($E(qqZot,4,7),$E(qqZot,8,30000))  D:$D(Vs("par"))!$D(Vo("par"))  S Vo(qqnump)=qqZot,Vt(qqnump,"Znsp")=$ZU(5) G LoadVend
 .M Vo(qqnump)=Vo("par"),Vs(qqnump)=Vs("par") K Vo("par"),Vs("par") ;есть сформированный массив параметров
 .S:$G(Vo(qqnump,-1,67))'="" Vt(qqnump,0)=1 ;пост.усл.
 ;контекст восстанавливается только для отображения входа (qqnump=0)
 ;иначе состояние берется для кода администратора
 K Vs(qqnump),Vc(qqnump) ;@dol 26.03.03
 D qSYS.CreVo(qqoView_$C(1)_qqZot)
 ;K Vs(qqnump) 
 D
 .I $D(Vs("par")) M Vs(qqnump)=Vs("par") K Vs("par") D:$D(Vs(qqnump,1))  Q  ;есть сформированный массив параметров
 ..;спец.обработка зачеркнутых понятий @dol 27.09.02
 ..N qqo,qqw S qqo="" F  S qqo=$O(Vs(qqnump,1,qqo)) Q:qqo=""  I $D(Vs(qqnump,1,qqo))>1 S qqw="" F  S qqw=$O(Vs(qqnump,1,qqo,qqw)) Q:qqw=""  I $G(Vs(qqnump,1,qqo,qqw))'=0,qqw'?1.n D qSYS.SetVs(1,qqo,qqw)
 .I qqnump=0||(..GetPar("X1198")) D ..RestView(1) ;@dol 7.10.04 X1198
 .;;;.;надо переделать на XViewStat
 .;;;.I '$D(^Q(1,"XViewStat",$TR(qview," ","_"))) M Vs(qqnump)=^Q("V"_qview,"XObjStat") Q
 .;;;.D qSYS.ViewStat(0,1)
 .;@dol 7.10.04 атавизм ;I '$D(Vs(qqnump)) M Vs(qqnump)=^Q("V"_qqZot,"XObjStat") ;
 .K:$G(Vs(qqnump,7))="" Vs(qqnump,7) ;вдруг были релевантные или упорядочивание
 ;
LoadVend ;K Vs(qqnump,1) ;временно
 S (Vt(qqnump,"Zparent"),Vt(qqnump,"ZparentW"))=$G(qqParent)
 S:$P(Vt(qqnump,"ZparentW")," ",2)="Q" Vt(qqnump,"ZparentW")=$G(Vt("Q","Zparent")) ;@dol 01.04.03 - реальное окно
 I qqnump'=0,'..GetPar("X1198")  K $$$GloRef S $$$ReFind=0,$$$RelNum=0,qqc="" S:1 $$$Relind=0 S $$$CurObj="",$$$CondFind="" I 1  ;;@dol 7.10.04 X1198
 E  D
 .S $$$ReFind=$G($$$ReFind,0)
 .S $$$RelNum=$G($$$RelNum,0)
 .S qqc=$G($$$ID,"")
 .S $$$Relind=$G($$$Relind,0)
 .S $$$CurObj=$G($$$CurObj,"")
 .S $$$CondFind=$G($$$CondFind,"")
 .I $$$CondFind'="" S $$$CondFind=" "_$P($$$CondFind," ",2,6)_"  "_$P($$$CondFind," ",8,11),$P($$$CondFind," ",5)=""  ;востановим старый контекст убрав упорядоченность
 .K W("Zosrt")
 I $G(qviewpre)'="",..GetPar(189) D  I 1 ;Наследование релевантных
 .S qview=qviewpre,$$$Relind=+$G(Vs($P(qqParent," ",2),"Relind")),$$$ReFind=+$G(Vs($P(qqParent," ",2),"ReFind")) ;,$$$RelNum=+$G(Vs($P(qqParent," ",2),"RelNum")) ;@Dol 23.05.06
 E  K qviewpre
 I $P(..GetPar(172)," ")>4 D  ;;восстановим сохраненный перечень релевантных
 .K ^Q($$$Relind_qview) 
 .I "56"[(+Vo(qqnump,-1,72)) Q:$G(Vs($P(qqParent," ",2),"ID"))=""  M ^Q($$$Relind_qview)=^Q(1,$E(Vs($P(qqParent," ",2),"CurObj"),$S($E(Vs($P(qqParent," ",2),"CurObj"))="v":3,1:1),255),Vs($P(qqParent," ",2),"ID"),"Y"_Vo(qqnump)) Q  ;@Dol 4.05.05 Q:...ID))="  ;;;надо бы перейти на Yo
 .I "78"[(+Vo(qqnump,-1,72)) D  Q  ;@dol 18.11.03 спецю вариант восстановления релевантных для 8
 ..N qqcc,qqcc0,qqoo,qqii,qqiii,qqo0,qqc0,qY,q8,qqo8,qqq,qqoo8 S q8=+Vo(qqnump,-1,72)=8,qqoo=$P($P(Vo(qqnump,-1,72)," ",2),":") D:qqoo="*"  S qqcc0=Vs($P(qqParent," ",2),"ID"),qqo0=$P($P($P(Vo(qqnump,-1,72)," ",2),",",2),":")
 ...N qqw S qqw=$P($P($P(Vo(qqnump,-1,72)," ",2),","),":",2) N qqnump S qqnump=$P(qqParent," ",2),qqoo=qSYS.Chiqqw($$$CurObj,qqw) S:qqoo="" qqoo="???" ;7 *:qqw,
 ..S qqcc="" F qqii=1:1 S qqcc=$$$UserOrd(1,qqoo,qqcc,qqcc0) Q:qqcc=""  K qY M qY=^Q(1,qqoo,qqcc,"Yo") I $D(qY) D  M ^Q($$$Relind_qview)=qY
 ...S qqq=0,qqo8="" F  S qqo8=$O(qY(qqo8)) Q:qqo8=""  S qqc0="" F  S qqc0=$O(qY(qqo8,qqc0)) Q:qqc0=""  I '$D(^Q(1,qqo8,qqc0)) S qqq=1 Q  ;проверка на наличие релевантных в базе
 ...I qqq K ^Q(1,qqoo,qqcc,"Yo"),qY Q  ;удалим из экземпляра перечень если проверка не прошла
 ...;!!!I 'q8!1 S qqc0=$O(qY(qqo0,"")) S:qqc0'=""&($D(Vo(qqnump,qqo0,11,"ZTMPN"))||(" "_$G(Vo(qqnump,qqo0,7))_" "[" ZTMPN ")) qY(qqo0,qqc0,"ZTMPN")=qqii,qY("ZTMPNcount",qqo0)=qqii ;Q  @dol 17.06.02 - оставлена дальнейшая проверка (вдруг смена 8->7) и 'q8!1 - всегда оставлять последовательность ввода
 ...S qqo8=$O(qY("")) Q:qqo8=""  S qqq=$P(","_$G($$$ObjRef(qqo8))_",",","_qqo8_",") I qqq'="" S qqc0=$O(qY(qqo8,"")) I qqc0'="" F qqiii=2:1:$L(qqq,",") S qqoo8=$P(qqq,",",qqiii),qY(qqoo8,$E(qqc0,1,$$$ObjLqqc(qqoo8)))=""
 ...S qqc0=$O(qY(qqo0,"")) S:qqc0'=""&($D(Vo(qqnump,qqo0,11,"ZTMPN"))||(" "_$G(Vo(qqnump,qqo0,7))_" "[" ZTMPN ")) qY(qqo0,qqc0,"ZTMPN")=qqii,qY("ZTMPNcount",qqo0)=qqii ;Q  @dol 17.06.02 - оставлена дальнейшая проверка (вдруг смена 8->7) и 'q8!1 - всегда оставлять последовательность ввода
 ..S qqq=$P(","_$G($$$ObjRef(qqo0))_",",","_qqo0_",") I qqq'="" S qqc0="" F  S qqc0=$O(^Q($$$Relind_qview,qqo0,qqc0)) Q:qqc0=""  F qqii=2:1:$L(qqq,",") S qqoo=$P(qqq,",",qqii),^Q($$$Relind_qview,qqoo,$E(qqc0,1,$$$ObjLqqc(qqoo)))=""  ;@dol 18.11.03 дополнение вершины релевантных
 ..S qqoo="" F  S qqoo=$O(^Q($$$Relind_qview,qqoo)) Q:qqoo=""  S ^(qqoo)=0,qqcc="" F  S qqcc=$O(^Q($$$Relind_qview,qqoo,qqcc)) Q:qqcc=""  I $I(^Q($$$Relind_qview,qqoo))  ;@dol 24.04.03 подсчет релевантных
 I $P(..GetPar(172)," ")=2 D qARM.wP(qwin_".T2","RowHeaderWidth",1) ;исключим релевантные
 S $$$RelNum=$D(^Q($$$Relind_qview))>1 I $$$RelNum,$G(Arg2)=-1 S $$$RelNum=qW.gRel(0),$$$ReFind=0
 I $G(Arg2)="0",$$$RelNum S $$$ReFind=1
 I $G(Arg2)'="0",$S($G(Arg2)="":$G(qviewpre)="",1:1),$$$ReFind,$$$RelNum S $$$ReFind=0 
 ;???
 S:$P(qqp4," ")'="" qqc=$P(qqp4," ") S:$P(qqp4," ",2)'="" $$$CurObj=$P(qqp4," ",2) I $$$Tree,$P(qqp4," ",4)'="" S $$$GloRef=$P(qqp4," ",4) ;если были при вызове
 I $P(qqp4," ",5)'="" K Vs(qqnump,7) ;S Vs(qqnump,7)=$P(qqp4," ",5) D:0 ..wfot($P(qqp4," ",5),1) ;фиксация
 ;LoadVend  ;
 ;S Vo(qqnump,-1,61)=+$G(Vo(qqnump,-1,61)) D:$G(constr,"TFormTree")="TFormTree" ..Grid()
 S Vo(qqnump,-1,61)=+$G(Vo(qqnump,-1,61)) D  ;@Dol 23.01.09 чтобы возможен был нижний тулбар с кнопками выхода в других конструкторах
 .I $G(constr,"TFormTree")="TFormTree" D ..Grid() Q
 .I ..GetPar("X1720") S:$G(child)'="" Vo(qqnump,-1,720)="" I $G(child)="" D ..wM(qwin,"StdBottomBar",Vo(qqnump,-1,720)-1) S qqz=..GetPar("X1196") D:qqz'=""  ;@Dol 13.02.06 кнопки выхода;@Dol 13.07.08 $G(child)=""
 ..S:$E(qqz)="@" @("qqz="_$E(qqz,2,30000)) D:qqz'="" ..wP(qwin_".StdBottomBar.BOk","Hint",qqz) ;@Dol 02.03.06 вопрос выхода
 I 'W("ZBt0"),$G(Vo(qqnump,-1,855)),$P(qqParent," ",2)'="" S W("ZBtred")=WS($P(qqParent," ",2),"ZBtred"),W("Zadm")=WS($P(qqParent," ",2),"Zadm") ;@Dol 27.07.06
 I $G(constr,"TFormTree")="TFormTree" D ..wcro() I 1
 E  D ..GetPar("X129") ;@Dol 28.03.08 чтобы остались сведения о конструкторе
 D ..MenuView("",-1),..MenuView(W("Zadm")),..MenuAn()
 I W("ZBt0") S Vo(qqnump,-1,72)="",Vo(qqnump,-1,73)="",Vo(qqnump,-1,62)=0 Q "" ;@Dol 20.08.10 блокировка авторазмеров и выхода в режиме дизайнирования
 ;
 S:$$$CurObj="" $$$CurObj=$O($$$MObjRef("")) ;@dol 30.07.02 чтобы было хорошо с начальным автоупорядочиванием
 N qqflg240 S qqflg240=0 I $P(qqp4," ",5)'="" D ..Fix($P(qqp4," ",5),''$P(qqp4," ",6),''$P(qqp4," ",7),1)
 ;
 N qqend D ..Value(..GetPar(123),"X") I $G(qqend)'="" Q:$Q qqend Q  ;Действие по загрузке отображения
 I $G(qruls)'="",$G(^Q(1,"XRuls",qruls,"XViewStat",Vo(qqnump),"Ref4"))'="" D ..Value(^("Ref4"),"X") I $G(qqend)'="" Q:$Q qqend Q  ;Действие по загрузке отображения изРоли
 D
 .I W("ZBtred"),$G(Vt(qqnump,570)) D ..wP(qwin_".T2","OnAutoEndDragging",1)
 .I $G(W("Zsform")),$G(W("Zsform"))'=3 Q  ;вдруг выставлено редактирование
 .I 'W("ZBtred"),$P(qqp4," ",3)=0!(W("ZBtred")="00") D ..wP(qwin_".TBM.b21","Visible",0) Q  ;запрет перехода в редактирование
 .D ..wP(qwin_".TBR","Visible",+W("ZBtred")),..wP(qwin_".TBM.b21","Down",+W("ZBtred"))
 I $G(W("Zadm")),$G(W("Zsform"))#10'=1 D ..wP(qwin_$S($G(W("Zsform"))<100:"",1:".T1")_".TBE","Visible",W("Zadm")) D:$G(W("Zsform"))<100 ..wcrm("P10_10p4",1,"",W("Zadm"),0) D qSYS.MenuServ() D:$G(Vt(qqnump,0))'="" ..wcrm("P7161",1,"",W("Zadm")_","_$G(Vt(qqnump,0))) ;@dol 18.10.04
 I $G(Arg2)>0 S:+Arg2=1 $$$RelNum=qW.gRel(0) D ..Find(,,,,1,$P(Arg2," ",3)) D:0&&$$$RelNum&$P(Arg2," ",3)  I '$$$RelNum,$P(Arg2," ",2) Q:$Q 1 Q  ;выход если ничего не найдено
 I Vo(qqnump,-1,61)=3 S:$G($$$CurObj)="" $$$CurObj=$O($$$MObjRef("")) D ..ObjAuto($$$CurObj,0)
 I '$G(qqflg240),$G(constr,"TFormTree")="TFormTree" D ..wcre() ;сли уже было в действии перед загрузкой
 I $G(Vs(qqnump,7))'="",$G(W("Zsform"))#100<11 D ..wbuttb(3,1) ;есть фиксация
 I $G(Vs(qqnump,99,"Revers")),$G(W("Zsform"))'=11 D ..OnRevers() ;@Dol 06.05.09 ;..wP(qwin_".TBG.b98","ImageIndex",6+(''Vs(qqnump,99,"Revers"))),..wP(,"Down",1) ;включен реверс
 I $G(constr,"TFormTree")="TFormTree",$G(Vo(qqnump,-1,88))'=1,'$G(Vo(qqnump,-1,80)),$G(Vo(qqnump,-1,194))'="" D ..wP(qwin_".T2","RowColPictureH@1",$P(Vo(qqnump,-1,194)," ",''$G($$$RelNum)+1),0) ;@Dol 23.01.07 заголовок колонки релевантных
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Log">
<Description>
Запись в лог на клиенте (SysLog.txt) непосредственно во время вызова, не отложенно (до 32 кб)
(Для этого не требуется включение детального лога и т.п.)
Большое количество вызовов замедляет работу вызывающего метода.
Не работает с SSH.
@Dima 20090210</Description>
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 q:$E($G(qARM("CntStr")),1,3)="SSH"
 n dev s dev=$IO u $P w "!&OUT"_Arg1 u dev q
]]></Implementation>
</Method>

<Method name="LoginWinCaption">
<Description>
Возвращает имя приложения. Используется в окне регистрации.
Если первый символ имени -, то префикс qWORD-XML не выводится</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 Q $S($G(^Q(1,"XBase",0,"XBName"))="":"qWORD-XML",$E(^("XBName"))="-":$E(^("XBName"),2,3000),1:"qWORD-XML. "_$G(^Q(1,"XBase",0,"XBName")))
]]></Implementation>
</Method>

<Method name="MenuAn">
<Description>
Начальные установки при смене отображения. 
Arg1["B" - установки кнопок тулбаров.
Arg1["A" - меню аналитик 
Arg1["F" - меню поиска
Arg1["D" - меню диаграмм
Arg1="" - все.</Description>
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$P($G(Vo(qqnump,-1,70))," ",5)'="" Vs(qqnump,99,"Pic")=$P($G(Vo(qqnump,-1,70))," ",5) ;@dol 10.02.02
 N i,qnpic I $G(W("Zsform"))=1!($G(W("Zsform"))=11) Q:$Q "" Q
 S:$G(Arg1)="" Arg1="LBFADS"
 D:$D(^Q(1,"XView",Vo(qqnump),"XMenu",5))  ;@dol 20.08.04 меню картинк-ресурсов
 .S qnpic=1 D ..wP(qwin_".TBM.b23","Style",2),..wP(qwin_".TBR","Left",150)
 .I $D(qwin(qwin,"XU5")) D ..wM(qwin_".XU5","Destroy") K qwin(qwin,"XU5")
 .S qwin(qwin,"XU5")="" D ..wC("TPopupMenu",qwin_".XU5"),..wP(qwin_".TBM.b23","DropdownMenu","XU5"),..MenuCre(,,5,1)
 D:$D(^Q(1,"XView",Vo(qqnump),"XMenu",6))  ;@dol 20.08.04 меню настроек
 .I Arg1["L" S Arg1=$P(Arg1,"L")_$P(Arg1,"L",2)
 .I $D(qwin(qwin,"XU6")) D ..wM(qwin_".XU6","Destroy") K qwin(qwin,"XU6")
 .S qwin(qwin,"XU6")="" D ..wC("TPopupMenu",qwin_".XU6"),..wP(qwin_".TBM.b20","DropdownMenu","XU6"),..MenuCre(,,6,1)
 I $G(W("Zsform"))<100,qqllang'="",Arg1["L" D  ;язык
 .D ..wcrm("P550",1,"",1,0)
 .D ..wcrm("50_1",+$G(qwin(qwin,"Lang")),"Русский",","_(qqlang=1))
 .F i=1:1:$L(qqllang," ") S %1=$P(qqllang," ",i) D:%1'=1 ..wcrm("50_"_%1,+$G(qwin(qwin,"Lang")),qW.GetWoc("CxLang",%1),","_(qqlang=%1))
 .S qwin(qwin,"Lang")=1
 D:Arg1["B"  ;Начальные установки
 .D:'$G(qnpic)&&($G(W("Zsform"))<100) ..wP(qwin_".TBM.b23","Down",+$G(Vs(qqnump,99,"Pic"))) ;Рисунок
 .D ..wP(qwin_$S($G(W("Zsform"))<100:".TBC",1:".T1.TBC")_".b402","Down",'$$$ReFind),..wP(qwin_$S($G(W("Zsform"))<100:".TBC",1:".T1.TBC")_".b401","Down",$$$ReFind) ;выбор/уточнение
 .D:$G(W("Zsform"))<100 ..wcrm("P10_10p4",1,"",W("Zadm"),0)
 .I $P($G(qARM("Ver","qARMProj1.ocx")),".",4)'="" D ..wcrm("P7101",1,"",$E(..GetPar(168))'="-") D  Q  ;Запросы... ;@Dol 24.05.07 временно на переходный период
 ..D ..wcrm("158_6",0,"Веб диаграмма") ;диаграмма
 ..D ..wcrm("158_7",0,"диаграмма CFX NEW") //@AKA 08.02.2011
 ..D ..wcrm("169_21",0,"-",,0),..wcrm("169_6",0,"Параметры приемник-печать",0,0),..wcrm("169_22",0,"-",,0) ;@Dol 30.04.09
 ..D ..wcrm("169_8",0,"Размер колонки № п/п",,0),..wcrm("169_8_2",0,2),..wcrm("169_8_5",0,5),..wcrm("169_8_0",0,0)
 ..D ..wcrm("169_14",0,"№п/п только для A",,0),..wcrm("169_14_0",0,"для всех"),..wcrm("169_14_1",0,"A1"),..wcrm("169_14_2",0,"A1-A2"),..wcrm("169_14_3",0,"A1-A3")
 ..D ..wcrm("169_15",0,"Не выводить ИТОГО")
 ..D ..wcrm("169_16",0,"Замена пустых значений",,0),..wcrm("169_16_1",0,"???"),..wcrm("169_16_2",0," пробел"),..wcrm("169_16_3",0,"- минус")
 ..D ..wcrm("169_9",0,"Повтор одинаковых значений")
 ..D ..wcrm("169_10",0,"Наследование типов данных аналитик")
 ..D ..wcrm("169_11",0,"Наследование параметров аналитик")
 ..D ..wcrm("169_12",0,"Наследование типов данных агрегатов")
 ..D ..wcrm("169_13",0,"Наследование параметров агрегатов")
 ..D ..wcrm("P91701",1,"Экран результатов",,0),..wcrm("1701_1",0,"Общая аналитика..."),..wcrm("1701_2",0,"Приемник-печать...") ;@Dol 13.04.11
 ..Q
 .;*********@Dima 23.05.07 перенесено в qARMProj1.ocx
 .D ..wcrm("156_3",0,"отклонение y=(y-mid)*100/(max-min)")
 .D ..wcrm("158_5",0,"диаграмма Objective Chart") ;диаграмма Objective Chart
 .D ..wcrm("158_1",1,"VRML",,1)
 .D ..wcrm("P8169",1,"Параметры",,0)
 .D ..wcrm("169_0",0,"Вид",,0)
 .D ..wcrm("169_0_0",0,"Столбики верт.")
 .D ..wcrm("169_0_1",0,"Столбики гор.")
 .D ..wcrm("169_0_2",0,"Круг для Y1")
 .D ..wcrm("169_0_3",0,"Линии")
 .D ..wcrm("169_0_4",0,"Точки")
 .D ..wcrm("169_1",0,"3D")
 .D ..wcrm("169_2",0,"Инструменты")
 .D ..wcrm("169_3",0,"Легенда по X")
 .D ..wcrm("169_5",0,"Размер легенды",,0)
 .D ..wcrm("169_5_0",0,50)
 .D ..wcrm("169_5_1",0,100)
 .D ..wcrm("169_5_2",0,200)
 .D ..wcrm("169_5_3",0,500)
 .D ..wcrm("169_4",0,"Легенда серий")
 .D ..wcrm("P8166",1,"-",,0)
 .D ..wcrm("P8160",0,"?")
 .D:$G(W("Zsform"))<100 ..wcrm("10p4_7",0,"-",,0)
 .D:$G(W("Zsform"))<100 ..wcrm("10p4_8",0,"Замечания по реализации")
 .D ..wcrm("P9167",1,"Полное дерево","",1)
 .D ..wcrm("P9168",1,"Архив","",0)
 .D ..wcrm("168_1",0,"Сброс"),..wcrm("168_2",0,"Новый"),..wcrm("168_3",0,"Выбор")
 .D ..wcrm("P9172",0,"Учет условий")
 .D ..wcrm("P9173",0,"Запуск в фон",0)
 .D ..wcrm("P91700",0,"-",,0)
 .D ..wcrm("P91701",0,"Экран результатов...")
 .D ..wcrm("P9170",0,"-",,0)
 .D ..wcrm("P9171",0,"?")
 .;
 .D ..wcrm("P7102",0,"Без учета регистра","",1)
 .D ..wcrm("P7164",1,"Запуск в фон","",1)
 .D ..wcrm("P7165",1,"-",,0)
 .D ..wcrm("P7101",0,"Запросы...",$E(..GetPar(168))'="-")
 .D ..wcrm("P7100",0,"-",,0)
 .D ..wcrm("P7175",0,"?")
 .D ..wcrm("P551",1,"OLE Drag&Drop",0) ;@Dol 12.05.07 изяет - ест копировать/востановить в буфер (+$G(Vs(qqnump,99,"OLEDD")))) ;"Автовыбор",","_(+$G(Vs(qqnump,99,"Auto"))))
 I Arg1["S",$G(W("Zsform"))<100 D  ;размер фонта
 .S q=$G(Vs(qqnump,99,"SFont"),8) I q=+W("Zfont") D ..wcrm("53_"_q,1,"",",1") Q  ;требуемый фонт совпадает
 .S W("Zfont")=q_","_(q-1)_","_(q-1) ;примерные размеры в пикселях
 .D ..wP("F0","Size",q)
 .D ..wP("F1","Size",q)
 .D ..wP("F2","Size",q)
 .D ..wP("F3","Size",q)
 .;N j F i="T1","T2","T3" F j="Font" D  ;,"ItemEditFont","ColHeaderFont","RowHeaderFont"
 .;.D ..wP(qwin_"."_i,j,"F1")
 .F i=8,10,12,14 D ..wcrm("53_"_i,1,"",",0")
 .D ..wcrm("53_"_q,1,"",",1")
 D:Arg1["F"  ;Меню поиска
 .;I ..MenuCre("P7")  D ..wP(qwin_".TBS.b62","ImageIndex",3) Q  ;есть переназначение
 .I '$D(Vs(qqnump,99,"Find")),$P($G(Vo(qqnump,-1,70))," ",2)'="" D  ;умолчания
 ..S q=$P($G(Vo(qqnump,-1,70))," ",2) F i=0:1:3 D:$P(q,",",i+1)'=""
 ...I 'i S Vs(qqnump,99,"Find")=''$P(q,",",i+1) Q
 ...S Vs(qqnump,99,"Find",i)=$P(q,",",i+1)
 .D ..wP(qwin_$S($G(W("Zsform"))<100:".TBS",1:".T1.TBS")_".b62","ImageIndex",3+$G(Vs(qqnump,99,"Find")))
 .D ..wcrm("P7150",1,"",","_($G(Vs(qqnump,99,"Find"))))
 .D ..wcrm("P7151",1,"",","_($G(Vs(qqnump,99,"Find",1))))
 .D ..wcrm("P7161",1,"",$G(W("Zadm"))&($G(Vt(qqnump,0))'="")_","_$G(Vt(qqnump,0))) ;только в режиме Администратор можно переустановить Постоянные условия
 .D ..wcrm("163_1",1,"",","_($G(Vs(qqnump,99,"Find",2))=1))
 .D ..wcrm("163_2",1,"",","_($G(Vs(qqnump,99,"Find",2))=10))
 .D ..wcrm("163_3",1,"",","_($G(Vs(qqnump,99,"Find",2))=100))
 .D ..wcrm("163_4",1,"",","_($G(Vs(qqnump,99,"Find",2))=1000))
 .D ..wcrm("163_5",1,"",","_($G(Vs(qqnump,99,"Find",2))=""))
 .D ..wcrm("P7164",1,"",","_($G(Vs(qqnump,99,"Find",3))))
 .D ..wcrm("P7102",1,"",","_($G(Vs(qqnump,99,"Find",5)))) ;@dol 19.06.04 учет регистра
 .D ..wP(qwin_$S($G(W("Zsform"))<100:".TBS",1:".T1.TBS")_".b62","Hint","Поиск "_$S($G(Vs(qqnump,99,"Find",2))="":"",1:"(Max="_$G(Vs(qqnump,99,"Find",2))_") ")_$S($G(Vs(qqnump,99,"Find")):"поддерева",1:"экземпляров")_$S($G(Vs(qqnump,99,"Find",3)):$C(13,10)_"запуск в фоне",1:"")_$S($G(Vs(qqnump,99,"Find",1)):$C(13,10)_"по всем объектам",1:"")_$S($G(Vs(qqnump,99,"Find",5)):$C(13,10)_"БЕЗ учета регистра",1:"")_$S($G(Vt(qqnump,0)):$C(13,10)_"с учетом постоянных условий",1:""))
 D:Arg1["A"  ;Меню аналитик
 .;I ..MenuCre("P9") Q  ;есть переназначение
 .I '$D(Vs(qqnump,99,"Anal")),$P($G(Vo(qqnump,-1,70))," ",3)'="" D  ;умолчания
 ..S q=$P($G(Vo(qqnump,-1,70))," ",3) F i=1:1:6 D:$P(q,",",i)'=""
 ...I i=2 S Vs(qqnump,99,"Anal")=''$P(q,",",i) Q
 ...S Vs(qqnump,99,"Anal",$S(i=1:0,1:i-2))=$P(q,",",i)
 .D ..wcrm("P9152",1,"",","_(''$G(Vs(qqnump,99,"Anal",0))))
 .D ..wcrm("P9153",1,"",","_(''$G(Vs(qqnump,99,"Anal"))))
 .D ..wcrm("P9154",1,"",","_(''$G(Vs(qqnump,99,"Anal",1)))) D
 ..N i F i=0,1,2,3,6,11,101 D ..wcrm("154_"_i,1,"",","_(+$G(Vs(qqnump,99,"Anal",1))=i))
 .D ..wcrm("P9167",1,"",","_(''$G(Vs(qqnump,99,"Anal",2))))
 .D ..wcrm("P9172",1,"",","_(''$G(Vs(qqnump,99,"Anal",3))))
 .D ..wcrm("P9173",1,"",","_(''$G(Vs(qqnump,99,"Anal",4))))
 .D ..wcrm("P9168",1,"",","_(''$D(W("Zar"))))
 .;D ..wcrm("P91701",1,"",''$D(^Qa($S($G(W("Zar"))="":"A"_qview,1:W("Zar")))))
 .D ..wcrm("1701_1",1,"",''$D(^Qa($S($G(W("Zar"))="":"A"_qview,1:W("Zar"))))),..wcrm("1701_2",1,"",''$D(^Qa($S($G(W("Zar"))="":"A"_qview,1:W("Zar")))))
 .D ..wP(qwin_$S($G(W("Zsform"))<100:".TBS",1:".T1.TBS")_".b63","Hint","Вычисление аналитик "_$S('$G(Vs(qqnump,99,"Anal")):"по значениям",1:"по значениям слов")_$S($G(Vs(qqnump,99,"Anal",0)):$C(13,10)_"с учетом пустых значений",1:"")_$S($G(Vs(qqnump,99,"Anal",1)):$C(13,10)_"порог "_$S(Vs(qqnump,99,"Anal",1)=1:"=1",1:">"_(Vs(qqnump,99,"Anal",1)-1)),1:"")_$S($G(Vs(qqnump,99,"Anal",2)):$C(13,10)_"полное дерево",1:"")_$S($G(Vs(qqnump,99,"Anal",3)):$C(13,10)_"учет условий",1:"")_$S($D(W("Zar")):$C(13,10)_"Запись в архив "_W("Zar"),1:"")_$S($G(Vs(qqnump,99,"Anal",4)):$C(13,10)_"запуск в фон",1:""))
 D:Arg1["D"  ;Параметры диаграммы
 .I $O(Vs(qqnump,13," "))="",$P($G(Vo(qqnump,-1,70))," ",4)'="" D  ;умолчания
 ..N qq S qq="P,M,S,X,R",q=$P($G(Vo(qqnump,-1,70))," ",4) F i=1:1:5 D:$P(q,",",i)'=""
 ...S Vs(qqnump,13,$P(qq,",",i))=$TR($P(q,",",i),"_"," ")
 .D ..wcrm("155_1",1,"",","_($G(Vs(qqnump,13,"P"))=""))
 .D ..wcrm("155_2",1,"",","_($G(Vs(qqnump,13,"P"))=.1))
 .D ..wcrm("155_3",1,"",","_($G(Vs(qqnump,13,"P"))=1))
 .D ..wcrm("155_4",1,"",","_($G(Vs(qqnump,13,"P"))=2))
 .D ..wcrm("155_5",1,"",","_($G(Vs(qqnump,13,"P"))=5))
 .D ..wcrm("155_6",1,"",","_($G(Vs(qqnump,13,"P"))=10))
 .;
 .D ..wcrm("156_0",1,"",","_('$G(Vs(qqnump,13,"M"))))
 .D ..wcrm("156_1",1,"",","_($G(Vs(qqnump,13,"M"))=1))
 .D ..wcrm("156_2",1,"",","_($G(Vs(qqnump,13,"M"))=2))
 .D ..wcrm("156_3",1,"",","_($G(Vs(qqnump,13,"M"))=3))
 .;
 .S Vs(qqnump,13,"S")=$S($G(Vs(qqnump,13,"S"))="":0,1:Vs(qqnump,13,"S"))
 .D ..wcrm("157_1",1,"",","_(Vs(qqnump,13,"S")=0))
 .D ..wcrm("157_2",1,"",","_(Vs(qqnump,13,"S")=1))
 .D ..wcrm("157_3",1,"",","_(Vs(qqnump,13,"S")="0-"))
 .D ..wcrm("157_4",1,"",","_(Vs(qqnump,13,"S")="1-"))
 .;
 .D ..wcrm("P8159",1,"",","_(''$G(Vs(qqnump,13,"X")))) ;XYZ
 .;
 .D ..wcrm("158_0",1,"",","_('$G(Vs(qqnump,13,"R")))) ;"диаграмма CFX")
 .D ..wcrm("158_1",1,"",","_(+$G(Vs(qqnump,13,"R"))=1),0) ;"диаграмма VRML")
 .D:+$G(Vs(qqnump,13,"R"))=1
 ..N i F i=0,3,4,5 D ..wcrm("158_1_"_i,1,"",","_(+$P(Vs(qqnump,13,"R")," ",2)=i))
 .D ..wcrm("158_2",1,"",","_(+$G(Vs(qqnump,13,"R"))=2)) ;"таблица IE")
 .D ..wcrm("158_3",1,"",","_(+$G(Vs(qqnump,13,"R"))=3)) ;"таблица MS-Word")
 .D ..wcrm("158_4",1,"",","_(+$G(Vs(qqnump,13,"R"))=4)) ;"таблица MS-Excel")
 .D ..wcrm("158_5",1,"",","_(+$G(Vs(qqnump,13,"R"))=5)) ;диаграмма Objective Chart
 .D ..wcrm("158_6",1,"",","_(+$G(Vs(qqnump,13,"R"))=6)) ; веб диаграмма (исполнение на сервере php)
 .D ..wcrm("158_7",1,"",","_(+$G(Vs(qqnump,13,"R"))=7)) ;@Dol 24.09.10
 .;
 .N i F i=0:1:4 D ..wcrm("169_0_"_i,1,"",","_(+$P($G(Vs(qqnump,13,"R"))," ",2)=i))
 .D ..wcrm("169_1",1,"",","_('$P($G(Vs(qqnump,13,"R"))," ",3))) ;3D
 .D ..wcrm("169_2",1,"",","_('$P($G(Vs(qqnump,13,"R"))," ",4))) ;Панель инструментов
 .D ..wcrm("169_3",1,"",","_('$P($G(Vs(qqnump,13,"R"))," ",5))) ;легенда Х
 .F i=0:1:3 D ..wcrm("169_5_"_i,1,"",","_(+$P($G(Vs(qqnump,13,"R"))," ",7)=i)) ;размер легенды
 .D ..wcrm("169_4",1,"",","_('$P($G(Vs(qqnump,13,"R"))," ",6))) ;легенда серий
 .F i=0,2,5 D ..wcrm("169_8_"_i,1,"",","_($P($G(Vs(qqnump,13,"R"))," ",8)=i||($P($G(Vs(qqnump,13,"R"))," ",8)=""&&(i=2)))) ;@Dol 30.04.09 Размер колонки № п/п
 .F i=9:1:13,15 D ..wcrm("169_"_i,1,"",","_($P($G(Vs(qqnump,13,"R"))," ",i)))
 .F i=0:1:3 D ..wcrm("169_14_"_i,1,"",","_(+$P($G(Vs(qqnump,13,"R"))," ",14)=i))
 .F i=1:1:3 D ..wcrm("169_16_"_i,1,"",","_($P($G(Vs(qqnump,13,"R"))," ",16)=$P("???~_~-","~",i))) ;@Dol 18.05.09
 .;
 .D ..wP(qwin_$S($G(W("Zsform"))<100:".TBS",1:".T1.TBS")_".b64","Hint","Построение диаграммы "_$S($G(Vs(qqnump,13,"X")):"(вида XYZ) ",1:"")_$P("CFX/VRML/таб.MS-IE/таб.MS-Word/таб.MS-Excel/ObjChart","/",$G(Vs(qqnump,13,"R"))+1)_" ("_$P("столбики_верт. столбики_гор. круг линии точки"," ",+$P($G(Vs(qqnump,13,"R"))," ",2)+1)_$S('$P($G(Vs(qqnump,13,"R"))," ",3):" 3D",1:"")_$S('$P($G(Vs(qqnump,13,"R"))," ",3):" ToolBar",1:"")_")"_$C(13,10)_"порог "_$S($G(Vs(qqnump,13,"P"))="":"все",1:$G(Vs(qqnump,13,"P"))_"%")_$S('$G(Vs(qqnump,13,"M")):"",1:$C(13,10)_$P("нормирование взвешивание отклонение"," ",Vs(qqnump,13,"M")))_$S(Vs(qqnump,13,"S")=0:"",1:$C(13,10)_"упорядочивание по "_$S(Vs(qqnump,13,"S"):"Y1",1:"A")_$E(Vs(qqnump,13,"S"),2)))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="MenuAr">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qv,qv1 G:$G(Arg1)'="" MenuArE:Arg1=1,MenuArC
 S qv=$G(W("Zar")) K W("Zar") S W("Zar")=qv,(qv,qv1)=Vo(qqnump)_"zz" I $E($O(^Q(1,"XView",qv)),1,$L(qv))'=qv D ..Message("Нет архивов для текущего отображения") Q:$Q "" Q
 F  S qv=$O(^Q(1,"XView",qv)) Q:$E(qv,1,$L(qv1))'=qv1  D
 .S W("Zar",qv)=qv_" "_$G(^(qv,"X11"))
 D ..MenuWoc("Zar","Zar",W("Zar"),1,"D ..MenuAr(qqchoice)") Q:$Q "" Q
 ;Обработка выбора
MenuArC S qv=qwin(qwin,"Zar",$P(Arg1,"Zar",2))
 S W("Zar")=qv
 ;восстановим состояние части исходного отображения (без поискового образа???)
 F qv1=3,4,12,13,14 K Vs(qqnump,qv1) M Vs(qqnump,qv1)=^Q("V"_qv,"XObjStat","Vsold",qv1)
 K Vs(qqnump,99,"Anal") M Vs(qqnump,99,"Anal")=^Q("V"_qv,"XObjStat","Vsold",99,"Anal")
 D ..wcro(),..wcre(),..MenuAn("D")
MenuArE S:$D(qwin(qwin,"o",1,1)) qwin(qwin,"o",1,1)=$S($G(W("Zar"))="":$E(qview,1,3)_"sysA"_qview,1:W("Zar"))
 K ^Qa("A"_qview) ;уберем временный набор
 D:$D(qwin(qwin,"o",1,1)) ..wcrm("200_1",1,$S($G(W("Zadm")):qwin(qwin,"o",1,1)_" ",1:"")_"Текушая Аналитика",''$D(^Qa($S($G(W("Zar"))="":"A"_qview,1:W("Zar")))))
 D ..MenuAn("A")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="MenuCre">
<Description>
Создание переназначаемых меню дополнительной панели отображения.
Arg1 - кол-во кнопок (1-4, 0 - нет панели)
Arg2=1 только переназначение активности кнопок и пунктов меню
NoTab=1 - без переинициализации закладок</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String,Arg4:%Library.String,NoTab:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqlst,qqch,qqchi,qqch0,qqch00,qqch1,qqch2,qqch3,qqch0,qqch01,qqchii,qRes,qqTab0,qqCTab,CTab,qqch42,qq430,qqnumpTab,virt,vvv
 I '$G(NoTab),'$G(Vs(qqnump,"NoTab")),$D(^Q(1,"XView",Vo(qqnump),"XTabs"))>1 D  ;@Dol 6.07.05 закладки
 .S qqnumpTab=qqnump
 .S qqchi="" F  S qqchi=$O(qwin(qwin,"Tabs",qqchi)) Q:qqchi=""  D ..wM(qwin_".Tabs"_qqchi,"Destroy") K qwin(qwin,"Tabs",qqchi) ;уничтожение старых
 .S qqchi="" F  S qqchi=$O(^Q(1,"XView",Vo(qqnump),"XTabs",qqchi),$s($g(Vs(qqnump,-1,-2))="":1,1:Vs(qqnump,-1,-2))) Q:qqchi=""  S qqch=qwin_".Tabs"_qqchi D
 ..S virt=$G(^Q(1,"XView",Vo(qqnump),"XTabs",qqchi,"X448")) ;@Dol 27.04.08 виртуальные закладки
 ..K Vs(qqnump,"Tabs",qqchi) S Vs(qqnump,"Tabs",qqchi,-1,48)=virt,Vs(qqnump,"Tabs",qqchi)=-1,qwin(qwin,"Tabs",qqchi)="",qqch0=$G(^("X41")),qqch1=+$G(^("x42")),qqch2=$G(^("X43")) I 'virt Q:$TR(qqch0," ")=""  D
 ...I $E(qqch0)="@" S Vs(qqnump,"Tabs",qqchi,"X41")=qqch0,@("qqch0="_$E(qqch0,2,30000)) ;@Dol 3.04.08 
 ...S qqch0=$TR(qqch0,","," ") I $P(qqch0," ")=-1 S qqch0="-1 "_qqch0 Q
 ...I $P(qqch0," ")["%" S qqch0=$P(qqch0," ")_"   "_$P(qqch0," ",3,25) Q
 ...N qqci S qqci="" F  S qqci=$O(Vc(qqnump,qqci)) Q:qqci=""  Q:Vc(qqnump,qqci,0)=$P(qqch0," ")
 ...S qqch0=qqci_" "_qqch0
 ..S Vs(qqnump,"Tabs",qqchi,-1)=$G(^Q(1,"XView",Vo(qqnump),"XTabs",qqchi,"X48")),qqTab0=$G(^("X441")),Vs(qqnump,"Tabs",qqchi,-1,4)=$G(^("X44")),Vs(qqnump,"Tabs",qqchi,-1,5)=$G(^("X45")),Vs(qqnump,"Tabs",qqchi,-1,80)=$G(^("X480")) ;окно вывода и общее действие
 ..S:$E(Vs(qqnump,"Tabs",qqchi,-1))="#" @("Vs(qqnump,""Tabs"",qqchi,-1)="_$E(Vs(qqnump,"Tabs",qqchi,-1),2,30000)) S:$E(Vs(qqnump,"Tabs",qqchi,-1,80))="#" @("Vs(qqnump,""Tabs"",qqchi,-1,80)="_$E(Vs(qqnump,"Tabs",qqchi,-1,80),2,30000)) ;@Dol 06.02.10
 ..I Vs(qqnump,"Tabs",qqchi,-1)[" ",$P(Vs(qqnump,"Tabs",qqchi,-1)," ")'["," S Vs(qqnump,"Tabs",qqchi,-1)=$TR(Vs(qqnump,"Tabs",qqchi,-1)," ",",") ;@Dol 16.02.06 позиция окон с пробелами недопустима
 ..;D ..wC("TTabControl",qqch,qwin_".T2",$P(qqch0," ",1,3)_$C(13)_$S('$P(qqch0," ",6):1,1:$P(qqch0," ",6)),$P(qqch0," ",4),$P(qqch0," ",5)) ;,0)
 ..G:virt MenuCreTab1 D ..wC("TTabControl",qqch,qwin_".T"_$S($P(qqch0," ",7)=1:1,1:2),$ZSTRIP($P(qqch0," ",1,3),"<>W"),$S('$P(qqch0," ",6):1,1:$P(qqch0," ",6)),$P(qqch0," ",4),$P(qqch0," ",5)) ;,0)
 ..D:$G(^Q(1,"XView",Vo(qqnump),"XTabs",qqchi,"x45")) ..wP(qqch,"TabPosition",1) D:qqch1 ..wP(qqch,"Style",qqch1) S qqch1=$G(^("X46")) S:$P(qqch1,",",3)="" $P(qqch1,",",3)=$P($G(Vo(qqnump,-1,55)),",",2) D:$TR(qqch1," ,")'=""  ;@Dol 19.07.09 наследование размера фонта;@Dol 16.06.10 Было $G(^("x45"))
 ...D:$P(qqch1,",",1)'="" ..wP(qqch,"Font.Name",$P(qqch1,",",1))
 ...D:$P(qqch1,",",2)'="" ..wP(qqch,"Font.Style.+",$P(qqch1,",",2)-1)
 ...D:$P(qqch1,",",3)'="" ..wP(qqch,"Font.Size",$P(qqch1,",",3))
 ...D:$P(qqch1,",",4)'="" ..wP(qqch,"Font.Color",$P(qqch1,",",4))
 ..;S qqch2=$G(^("X43")) I qqch2["~",qqch2'[$C(13,10) S qqch2=qW.zChSym(qqch2,"~",$C(13,10))
 ..I $G(^("X444"))'="" D ..wP(qqch,"Short",+^("X444")) ;@Dol 29.08.06 ограничение неактивной закладки
 ..I $G(^("X445")) D ..wP(qqch,"Back",1) ;@Dima 13.09.06 рельефный фон
 ..I $G(^("X446")) D ..wP(qqch,"MultiLine",1) ;@Dima 23.03.07 многострочность
 ..I $G(^("X447")) D ..wP(qqch,"Visible",0) ;@Dol 26.10.07 невидимость группы
MenuCreTab1 ..S qqch01="",qqch2="",qRes="",qq430="" F  S qqch01=$O(^Q(1,"XView",Vo(qqnump),"XTabs",qqchi,"XTab",qqch01)) Q:qqch01=""  D  Q:qqch01=-1
 ...N qqend  ;@Dol 12.07.08
 ...S qqch00=$G(^(qqch01,"X440")),(CTab,qqCTab)=$G(^("X40")) D  Q:'qqch00
 ....I qqch00="" S qqch00=1 Q
 ....S:$ZV["GT.M" qqch00=$$Zso^VCPU(qqch00) I @qqch00 S qqch00=1 Q
 ....S qqch00=0
 ...S qqchii=$G(^Q(1,"XView",Vo(qqnump),"XTabs",qqchi,"XTab",qqch01,"X43")) S:$E(qqchii)="@" @("qqchii="_$E(qqchii,2,1000)) 
 ...S qqch2=$S(virt:"",qqch2="":"",1:qqch2_$C(13,10))_qqchii
 ...S qqchii=$G(^Q(1,"XView",Vo(qqnump),"XTabs",qqchi,"XTab",qqch01,"X430")) S:$E(qqchii)="@" @("qqchii="_$E(qqchii,2,1000))
 ...S qq430=$S(virt:"",qq430="":"",1:qq430_$C(31))_qqchii ; вспл.подсказка ;@Dol 31.07.09 13->31
 ...S Vs(qqnump,"Tabs",qqchi,$I(Vs(qqnump,"Tabs",qqchi)))=qqch01 ;реальный номер
 ...I qqCTab'="" S Vs(qqnump,"Tabs",qqchi,Vs(qqnump,"Tabs",qqchi),-1)=qqCTab,Vs(qqnump,"Tabs",qqchi,-2,qqCTab)=Vs(qqnump,"Tabs",qqchi)
 ...S qqchii=$G(^Q(1,"XView",Vo(qqnump),"XTabs",qqchi,"XTab",qqch01,"X49")) S:$E(qqchii)="@" @("qqchii="_$E(qqchii,2,1000)) S:qqchii'="" qRes=qRes_$C(13)_qqchii
 ...S:virt Vs(qqnump,"Tabs",qqchi,Vs(qqnump,"Tabs",qqchi),43)=qqch2,Vs(qqnump,"Tabs",qqchi,Vs(qqnump,"Tabs",qqchi),430)=qq430,Vs(qqnump,"Tabs",qqchi,Vs(qqnump,"Tabs",qqchi),49)=qqchii ;@Dol 25.02.11
 ...F qqchii=6,7,8,80,42 S vvv=$G(^Q(1,"XView",Vo(qqnump),"XTabs",qqchi,"XTab",qqch01,"X4"_qqchii)) S:$E(vvv)="#" @("vvv="_$E(vvv,2,30000)) S Vs(qqnump,"Tabs",qqchi,+$G(Vs(qqnump,"Tabs",qqchi)),qqchii)=vvv I qqchii=42,vvv'="" S qqch42=1 ;@Dol 24.10.08 выражения # (на момент создания);@Dol 14.12.09 был неполн.синт. vvv=$G(^(
 ...I $D(qqend) S:qqend'="" qqch01=$S(qqend=1:-1,Vs(qqnump,"Tabs",qqchi)>50:-1,1:$O(^Q(1,"XView",Vo(qqnump),"XTabs",qqchi,"XTab",qqch01),-1)) ;@Dol 12.07.08 прекращение или повтор обработки последней закладки
 ..s:($g(XBLocal))&&('virt) qqch2=qSYS.TransfLocal($tr(qqch2,$c(10)),$c(13)),qq430=qSYS.TransfLocal(qq430,$c(31))  ;@pav подключение справочника локализации 15.02.2010
 ..I 'virt D ..wP(qqch,"Tabs",qqch2) D:$TR(qq430,$C(31))'="" ..wP(qqch,"TabHints",qq430)
 ..S Vs(qqnump,"Tabs",qqchi)=""
 ..S:$G(qqch42) Vs(qqnump,"Tabs",qqchi,-1,42)=1 ;@Dol 15.03.06 условия видимости
 ..I 'virt,$TR(qRes,$C(13))'="" D
 ...D:$D(qwin("Tabs"_qqchi_qwin)) ..wM("Tabs"_qqchi_qwin,"Destroy")
 ...S qwin("Tabs"_qqchi_qwin)="" D ..wC("TCustomImageList","Tabs"_qqchi_qwin)
 ...D:$G(^Q(1,"XView",Vo(qqnump),"XTabs",qqchi,"X490"))'="" ..wP(,"Width",$P(^("X490"),",",1)),..wP(,"Height",$P(^("X490"),",",2))
 ...D ..wM("Tabs"_qqchi_qwin,"Fill",$P(qRes,$C(13),2,255)),..wP(qqch,"Images","Tabs"_qqchi_qwin)
 ..I $G(qqTab0)'="" S:$E(qqTab0)="@"||(qqTab0'?1.n) @("qqTab0="_$S($E(qqTab0)="@":$E(qqTab0,2,10000),1:qqTab0)) D:qqTab0'=""
 ...I $G(^Q(1,"XView",Vo(qqnump),"XTabs",qqchi,"X4411")) D qARM.OnTabChange(qqnump_"."_qqchi,qqTab0) Q  ;@Dol 15.10.08 X4411 - старый вариант
 ...S qqTab0=qARM.OnTabChange(qqnump_"."_qqchi,qqTab0,,,1) D:qqTab0'="" ..Wait("D qARM.crst(1,"""_qqTab0_""",2)") ;@Dol 20.07.08 чтобы был переход на открытую закладку.
  ;tdv 16.02.2004: Ref - вставка для динамического меню
 N Ref S Ref=$S($D(Vs(qqnump,"XMenu"))'=0:$NA(Vs(qqnump,"XMenu")),1:$NA(^Q(1,"XView",Vo(qqnump),"XMenu")))
 I ($D(Vs(qqnump,"XMenu"))'=0) D
 .N Temp M Temp=Vs(qqnump,"XMenu")
 .M Vs(qqnump,"XMenu")=^Q(1,"XView",Vo(qqnump),"XMenu")
 .M Vs(qqnump,"XMenu")=Temp
 ;
 S Arg2=+$G(Arg2) I $G(Arg3) S Arg1=0,qqchi=Arg3 G MenuCre0 ;доп.меню (6-настройки, 7-запросы ,8 - главное,9 - отображения)
 I '$D(Arg1) S Arg1=..GetPar("X183") S:$G(W("Zsform"))=11 Arg1=0 I 'Arg1,$G(W("Zsform"))'=11 D ..wP(qwin_".TBH","Visible",0) I '$D(@Ref@(8)) Q:$Q 0 Q  ;кол-во кнопок
 I '$D(@Ref),$G(W("Zsform"))'=11 D:Arg1  Q:$Q 0 Q  ;нет пользовательских меню
 .F qqchi=0:1:3 I qqchi>(Arg1-1) D ..wbuttb(101+qqchi,,,0)  ;лишние кнопки
MenuCre0 ;
 D:$G(Arg3)  Q:$G(Arg3)&$Q 1 Q:$G(Arg3)  F qqchi=0:1:3,8 D  ;удаление старых, создание новых
 .I $G(qqchi)=8,$G(qwin(qwin,"child"))'="" Q  ;@Dol 4.07.05 блокировка для встроенных окон
 .D:'Arg2
 ..I '$G(Arg4),$D(qwin(qwin,"XU"_qqchi)) D ..wM(qwin_".XU"_qqchi,"Destroy") K qwin(qwin,"XU"_qqchi)
 ..Q:qqchi>4  I Arg1,qqchi>(Arg1-1) D ..wbuttb(101+qqchi,,,0) Q  ;лишние кнопки
 ..S qqch0=$G(@Ref@(qqchi,"XMenuAct")) D:qqch0'=""  ;активность
 ...I ..Value(qqch0) Q  ;@qqch0 Q
 ...D ..wbuttb(101+qqchi,,0)
 ..S qqch0=$G(@Ref@(qqchi,"XMenuName")) I qqch0'="" D ..wP(qwin_".TBH.b"_(101+qqchi),"Hint",qqch0) ;всплывающая подсказка
 ..S qqch0=$G(@Ref@(qqchi,"Xsys")) I qqch0'="" D ..wP(qwin_".TBH.b"_(101+qqchi),"ImageIndex",qqch0) ;Картинка
 .I qqchi<5 Q:qqchi>(Arg1-1)
 .S qqch0=$G(@Ref@(qqchi,"XMenuDo")) I $E(qqch0)="@" D MenuCreOp,..MenuWoc("XU"_qqchi,..Value($E(qqch0,2,32000)),,,,,,1,-1)  Q  ;ссылка на меню
 .Q:$D(@Ref@(qqchi,"XMenu1"))<10   ;нет потомков - нет меню
 .D MenuCreOp
 .S qqch1="" F  S qqch1=$O(@Ref@(qqchi,"XMenu1",qqch1)) Q:qqch1=""  D
 ..S qqch=$D(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2")) ;есть потомки?
 ..S qqch00=$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenuCond")) D  Q:'qqch00  ;условие вывода
 ...I qqch00="" S qqch00=1 Q
 ...S:$ZV["GT.M" qqch00=$$Zso^VCPU(qqch00) I @qqch00 S qqch00=1 Q
 ...S qqch00=0
 ..I 'Arg2 S qqch0=$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenuName")) S:$E(qqch0)="@" qqch0=..Value($E(qqch0,2,30000)) ;@dol 13.04.04
 ..S qqch01=$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenuCh")) S:qqch01'="" @("qqch01="_qqch01) ;@dol 23.06.04
 ..S qqch00=$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenuAct")) D
 ...I qqch00="" S qqch00=1 Q
 ...I @qqch00 S qqch00=1 Q
 ...S qqch00=0
 ..D ..wcrm("XU"_qqchi_"_"_qqchi_"u"_qqch1,Arg2,$S(Arg2:"",1:qqch0),+qqch00_$S(qqch01="":"",1:","_qqch01),'qqch,$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenuRes"))) Q:'qqch
 ..S qqch2="" F  S qqch2=$O(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2)) Q:qqch2=""  D
 ...S qqch=$D(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2,"XMenu3")) ;есть потомки?
 ...S qqch00=$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2,"XMenuCond")) D  Q:'qqch00  ;условие вывода
 ....I qqch00="" S qqch00=1 Q
 ....I @qqch00 S qqch00=1 Q
 ....S qqch00=0
 ...S:'Arg2 qqch0=$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2,"XMenuName"))
 ...S qqch01=$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2,"XMenuCh")) S:qqch01'="" @("qqch01="_qqch01) ;@dol 23.06.04
 ...I 'Arg2 S qqch0=$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2,"XMenuName")) S:$E(qqch0)="@" qqch0=..Value($E(qqch0,2,30000)) ;@dol 13.04.04
 ...S qqch00=$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2,"XMenuAct")) D
 ....I qqch00="" S qqch00=1 Q
 ....I @qqch00 S qqch00=1 Q
 ....S qqch00=0
 ...D ..wcrm(qqchi_"u"_qqch1_"_"_qqch2,Arg2,$S(Arg2:"",1:qqch0),+qqch00_$S(qqch01="":"",1:","_qqch01),'qqch,$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2,"XMenuRes"))) Q:'qqch
 ...S qqch3="" F  S qqch3=$O(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2,"XMenu3",qqch3)) Q:qqch3=""  D
 ....S qqch=$D(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2,"XMenu3",qqch3,"XMenu4")) ;есть потомки?
 ....S qqch00=$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2,"XMenu3",qqch3,"XMenuCond")) D  Q:'qqch00  ;условие вывода
 .....I qqch00="" S qqch00=1 Q
 .....I @qqch00 S qqch00=1 Q
 .....S qqch00=0
 ....I 'Arg2 S qqch0=$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2,"XMenu3",qqch3,"XMenuName")) S:$E(qqch0)="@" qqch0=..Value($E(qqch0,2,30000)) ;@dol 13.04.04
 ....S qqch01=$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2,"XMenu3",qqch3,"XMenuCh")) S:qqch01'="" @("qqch01="_qqch01) ;@dol 23.06.04
 ....S qqch00=$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2,"XMenu3",qqch3,"XMenuAct")) D
 .....I qqch00="" S qqch00=1 Q
 .....I @qqch00 S qqch00=1 Q
 .....S qqch00=0
 ....D ..wcrm(qqchi_"u"_qqch1_"_"_qqch2_"_"_qqch3,Arg2,$S(Arg2:"",1:qqch0),+qqch00_$S(qqch01="":"",1:","_qqch01),1,$G(@Ref@(qqchi,"XMenu1",qqch1,"XMenu2",qqch2,"XMenu3",qqch3,"XMenuRes")))
 .I qqchi=8,$G(@Ref@(qqchi,"XMenuR"))'="" D ..wM(qwin_".XU8","RightItems",@Ref@(qqchi,"XMenuR")) ;@Dima 13.05.07
 Q:$Q 1 Q
MenuCreOp Q:Arg2  I qqchi<5 d ..wC("TPopupMenu",qwin_".XU"_qqchi) S qwin(qwin,"XU"_qqchi)=""  Q:qqchi>4  D ..wP(qwin_".TBH.b"_(101+qqchi),"DropdownMenu","XU"_qqchi) Q
 I qqchi=8 d ..wC("TMainMenu",qwin_".XU"_qqchi,qwin) S qwin(qwin,"XU"_qqchi)="" Q
 I qqchi=9,$G(@Ref@(qqchi,"XMenuName"))'="" D ..wP(qwin_".TBM.b22","Hint",^("XMenuName")) Q  ;всплывающая подсказка меню отображений
 I qqchi=6,$G(@Ref@(qqchi,"XMenuName"))'="" D ..wP(qwin_".TBM.b20","Hint",^("XMenuName")) Q  ;всплывающая подсказка меню настроек
 I qqchi=5,$G(@Ref@(qqchi,"XMenuName"))'="" D ..wP(qwin_".TBM.b23","Hint",^("XMenuName")) Q  ;всплывающая подсказка меню картинок/ресурсов
 Q
]]></Implementation>
</Method>

<Method name="MenuEx">
<Description>
@dima 20091119 заменено $C(9) на "~" перед названием клавиши</Description>
<Internal/>
<FormalSpec>Ngr:%String,Arg1:%String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 I $G(Arg1)<0 Q:'$D(qwin(qwin,"E"_Ngr))  d ..wM(qwin_".E"_Ngr,"Destroy") K qwin(qwin,"E"_Ngr) Q:$Q "" Q
 N New S New=1
 I Ngr=8,$D(qwin(qwin,"E"_Ngr)) d ..wM(qwin_".E"_Ngr,"Destroy") K qwin(qwin,"E"_Ngr) ;@Dol 9/06/06
 D:'$D(qwin(qwin,"E"_Ngr))
 .d ..wC("TPopupMenu",qwin_".E"_Ngr) S qwin(qwin,"E"_Ngr)=1,New=0
 ;заголовки рядов
 I Ngr=0 D  G MenuExEnd
 .D ..wcrm("E"_Ngr_900,New,"Включить в релевантные",$S($G(qqarea)=7:0,1:'$G(Vc(qqnump,$P(qqdat," "),2))),0)
 .D ..wcrm("900_1",New,"Экземпляр~Ins")
 .D ..wcrm("900_2",New,"Поддерево")
 .D ..wcrm("E"_Ngr_901,New,"Исключить из релевантных~Del",$S($G(qqarea)=7:0,1:$G(Vc(qqnump,$P(qqdat," "),2))))
 .D ..wcrm("E"_Ngr_902,New,"Сбросить релевантные~F7",$$$RelNum)
 .D ..wcrm("E"_Ngr_903,New,"-")
 .D ..wcrm("E"_Ngr_904,New,"Выбор~F6",$$$ReFind)
 .D ..wcrm("E"_Ngr_905,New,"Уточнение~F6",'$$$ReFind&$$$RelNum)
 .D ..wcrm("E"_Ngr_908,New,"-")
 .D ..wcrm("E"_Ngr_909,New,"?")
 ;ячейки
 I Ngr=1 D  G MenuExEnd
 .D ..wcrm("E"_Ngr_910,New,"Ввод",+$G(W("ZBtred")),0)
 .D:'New ..wcrm("910_1",New,"Ввод~F4")
 .D:'New ..wcrm("910_2",New,"Коррекция")
 .D:'New ..wcrm("910_3",New,"Удаление~F8")
 .D ..wcrm("910_4",New,"Очистка",W("Zadm"))
 .D:'New ..wcrm("910_6",New,"Откат")
 .D:'New ..wcrm("910_7",New,"-",,0)
 .D ..wcrm("910_8",New,"Вставка",W("Zadm"))
 .D ..wcrm("910_9",New,"Сортировка",W("Zadm"))
 .D ..wcrm("E"_Ngr_911,New,"Редактирование",+$G(W("ZBtred")),0)
 .D:'New ..wcrm("911_1",New,"Редактирование")
 .D:'New ..wcrm("911_2",New,"Развертка~F9")
 .D ..wcrm("911_3",New,"Репликация для релевантных",W("Zadm")&&$$$ReFind&&($E(qqw)'="Z")) 
 .D ..wcrm("E"_Ngr_913,New,"Копирование",,0)
 .D:'New ..wcrm("913_1",New,"Сохранить текущее поддерево в буфер обмена")
 .D ..wcrm("913_2",New,"Восстановить из буфера обмена",+$G(W("ZBtred")))
 .I 'New N qm,qqol S qm=0,qqol=..GetPar(168) D:$E(qqol)="@" ..wcrm("E"_Ngr_912,New,"Запросы...") I $E(qqol)'="@" D ..wcrm("E"_Ngr_912,New,"Запросы",qm,0) D  D:qm ..wcrm("E"_Ngr_912,1,"",qm,0) ;запросы
 ..N qqot Q:$E(qqol)="-"  ;@dol 29.09.03
 ..I qqol'="" S qm=1 D  Q
 ...F qqot=1:1:$L(qqol," ") S query=$P(qqol," ",qqot) I query'="" S qwin(qwin,"o",7,qqot+1)=query D ..wcrm("912_"_(qqot+1),New,$G(^Q(1,"XQuery",query,"XQName")))
 ..N query S query=Vo(qqnump)_"qq" F qqot=1:1 S query=$O(^Q(1,"XQuery",query)) Q:$E(query,1,$L(Vo(qqnump))+2)'=(Vo(qqnump)_"qq")  S qwin(qwin,"o",7,qqot+1)=query,qm=1 D ..wcrm("912_"_(qqot+1),New,$G(^Q(1,"XQuery",query,"XQName")))
 .D:'New ..wcrm("E"_Ngr_914,New,"-")
 .D:'New ..wcrm("E"_Ngr_915,New,"Пояснения","",0)
 .D:'New ..wcrm("915_1",New,"Отображение")
 .D:'New ..wcrm("915_2",New,"Объект")
 .D:'New ..wcrm("915_3",New,"Понятие")
 .D:'New ..wcrm("915_4",New,"Приложение")
 .D ..wcrm("E"_Ngr_916,New,"Свойства...",W("Zadm"))
 .D ..wcrm("E"_Ngr_918,New,"Словарь развертки...",W("Zadm")) ;&&$G(W("ZBtred")))
 .D ..wcrm("E"_Ngr_940,New,"Поиск...") ;@Dol 09.05.09 ;"Понятие-образец...",W("Zadm")&&(..GetPar("X784",,$P($G(W("Zpos",2,"d"))," ",2),$P($G(W("Zpos",2,"d"))," ",3),$G(W("Zpos",2,"x")))'="")) ;@dol 9.07.04
 .D ..wcrm("E"_Ngr_917,New,"Состояние...",W("Zadm"))
 .D:'New ..wcrm("E"_Ngr_999,New,"-")
 .;D:'New ..wcrm("E"_Ngr_918,New,"Выход")
 .D:'New ..wcrm("E"_Ngr_919,New,"?")
 I Ngr=2 D  G:$D(qwin(qwin,"o",7,3)) MenuExEnd Q 1 ;запросы (по F2) (если меньше двух-выход)
 .N qqol S qqol=..GetPar(168) I $E(qqol)="@" D ..MenuQ() Q  ;@dol 11.1.04
 .I 'New N qm S qm=0 D   ;запросы
 ..N qqot Q:$E(qqol)="-"
 ..I qqol'="" S qm=1 D  Q
 ...F qqot=1:1:$L(qqol," ") S query=$P(qqol," ",qqot) I query'="" S qwin(qwin,"o",7,qqot+1)=query D ..wcrm("E"_Ngr_(920+(qqot+1)),New,$G(^Q(1,"XQuery",query,"XQName")))
 ..N query S query=Vo(qqnump)_"qq" F qqot=1:1 S query=$O(^Q(1,"XQuery",query)) Q:$E(query,1,$L(Vo(qqnump))+2)'=(Vo(qqnump)_"qq")  S qwin(qwin,"o",7,qqot+1)=query,qm=1 D ..wcrm("E"_Ngr_(920+(qqot+1)),New,$G(^Q(1,"XQuery",query,"XQName")))
 ;меню сброса/отметки релевантных (кнопка заголовка ряда релевантных)
 I Ngr=6 D:'New  G MenuExEnd
 .D ..wcrm("E"_Ngr_960,New,"Сбросить релевантные~F7",$$$RelNum)
 .D ..wcrm("E"_Ngr_961,New,"Отметить (включить в релевантные) все ВИДИМЫЕ экземпляры")
 .D ..wcrm("E"_Ngr_963,New,"-")
 .D ..wcrm("E"_Ngr_964,New,"Выбор~F6",$$$ReFind)
 .D ..wcrm("E"_Ngr_965,New,"Уточнение~F6",'$$$ReFind&$$$RelNum)
 ;.D ..wcrm("E"_Ngr_968,New,"-")
 ;.D ..wcrm("E"_Ngr_969,New,"?")
 ;меню перемещений
 I Ngr=7 D:'New  G MenuExEnd
 .D ..wcrm("E"_Ngr_975,New,"Первый")
 .D ..wcrm("E"_Ngr_974,New,"Предыдущий")
 .D ..wcrm("E"_Ngr_972,New,"Следующий")
 .D ..wcrm("E"_Ngr_971,New,"Последний")
 ;вопрос-меню (метод QuestionM) @Dol 9/06/06 переделан на множественный выбор
 I Ngr=8 D  G MenuExEnd
 .N ii F ii=1:1:$L($G(Arg2),"~") D ..wcrm("E"_Ngr_98_(ii-1),New,$P($G(Arg2),"~",ii))
 .D:ii>1 ..wcrm("E"_Ngr_989,New,"-")
 .D ..wcrm("E"_Ngr_988,New,"Отказ")
 ;Выход из окна с выбором
 I Ngr=9 D  G MenuExEnd
 .D:'New ..wcrm("E"_Ngr_990,New,$G(Arg2,"Выбор"))
 .D:'New ..wcrm("E"_Ngr_991,New,"Отказ")
 ;
MenuExEnd I $G(Arg1) Q:$Q "" Q
 D ..wM(qwin_".E"_Ngr,"Popup"),..wM("-qARM","SetFocus",qwin) ;@dima Скорее всего, для встроенных надо ..wM(qwin_".T2","SetFocus")
 Q:$Q "" Q  ; tdv 20110505 - добавлен выход по Q
]]></Implementation>
</Method>

<Method name="MenuGr">
<Description>
              Всплывающие меню граф 1-9 дерева объектов.</Description>
<Internal/>
<FormalSpec>Ngr:%String,Arg1:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N New S New=1
 D:'$D(qwin(qwin,"G"_$S(Ngr>4:5,1:Ngr)))
 .d ..wC("TPopupMenu",qwin_".G"_$S(Ngr>4:5,1:Ngr)) S qwin(qwin,"G"_$S(Ngr>4:5,1:Ngr))=1,New=0
 I Ngr=0 D  G MenuGrEnd
 .N qqsto S qqsto=$S(W("Zadm"):1,1:..GetPar("X184")) S:$G(Vs(qqnump,"Analit")) $P(qqsto,",")=1 ;стиль объектов
 .;D ..wcrm("G"_Ngr_801,New,"Свернуть",$S($P(W("Zpos",1,"d")," ")="":$S('$P(qqsto,",",2)&$D(Vs(qqnump,3)):"1,1",1:"0,0"),1:'$P(qqsto,",",2)_","_(''$G(Vs(qqnump,3,$P(W("Zpos",1,"d")," "))))))
 .D ..wcrm("G"_Ngr_803,New,"Зачеркнуть",$S($P(W("Zpos",1,"d")," ")="":$S('$P(qqsto,",",3)&$D(Vs(qqnump,1)):"1,1",1:"0,0"),1:'$P(qqsto,",",3)_","_$S($P(W("Zpos",1,"d")," ",2)="":''$G(Vs(qqnump,1,W("Zpos",1,"d"))),1:''$G(Vs(qqnump,1,$P(W("Zpos",1,"d")," "),$P(W("Zpos",1,"d")," ",2))))))
 .D ..wcrm("G"_Ngr_800,New,"Зачеркнуть все",'$P(qqsto,",",3))
 .D ..wcrm("G"_Ngr_802,New,"Размеры колонок",'$P(qqsto,",",3),0) ;@Dol 11.11.06
 .D ..wcrm("802_0",New,"Сохранить"),..wcrm("802_1",New,"Восстановить"),..wcrm("802_2",New,"-"),..wcrm("802_3",New,"Сбросить")
 .D ..wcrm("G"_Ngr_804,New,"-","",0)
 .D ..wcrm("G"_Ngr_805,New,"Свойства...",''$G(W("Zadm")))
 .D ..wcrm("G"_Ngr_806,New,"Словарь развертки...",W("Zadm")&($P(W("Zpos",1,"d")," ",2)'=""))
 .D ..wcrm("G"_Ngr_808,New,$S($P(W("Zpos",1,"d")," ")="":"Переход на объект...",1:"Таблица..."),$S($P(W("Zpos",1,"d")," ")="":1,1:''$G(W("Zadm"))))
 .;D ..wcrm("G"_Ngr_806,New,"-","",0)
 .D ..wcrm("G"_Ngr_801,New,"Дополнительные понятия...",$S($P(W("Zpos",1,"d")," ")="":"0,0",1:"1")) ///@Dol 30.07.08
 .D ..wcrm("G"_Ngr_807,New,"Пояснения...")
 .D ..wcrm("G"_Ngr_809,New,"?")
 I Ngr=1 D  G MenuGrEnd
 .D ..wcrm("G"_Ngr_810,New,"Условие",qqw'="")
 .D ..wcrm("G"_Ngr_811,New,"Словарь",qqw'="")
 .D ..wcrm("G"_Ngr_812,New,"Сброс",$S(qqw'="":''$D(Vs(qqnump,8,qqo,qqw)),1:''$D(Vs(qqnump,8,qqo))))
 .D ..wcrm("G"_Ngr_813,New,"Наличие",$S($S(qqw'="":''$D(Vs(qqnump,8,qqo,qqw)),1:''$D(Vs(qqnump,8,qqo))):"0,1",1:"1,0"))
 .D ..wcrm("G"_Ngr_814,New,"Функции",qqw'="",0)
 .D ..wcrm("814_0",New,"Значение (текущий объект)")
 .D ..wcrm("814_1",New,"Значение (произвольный объект)")
 .D ..wcrm("814_2",New,"Возраст")
 .D ..wcrm("814_3",New,"Количество")
 .D ..wcrm("814_4",New,"Сумма")
 .D ..wcrm("G"_Ngr_815,New,"Набор",$S(qqw="":0,"MLT@X"'[$E(qqw):1,1:..GetPar("X7801",,qqo,qqw)'="")) ;@Dol 15.10.08 X7801
 .D ..wcrm("G"_Ngr_816,New,"Спец.Условие",qqw'=""&&(..GetPar("X78",,qqo,qqw)'=""))
 .D ..wcrm("G"_Ngr_817,New,"Примеры",qqw'=""&&(..GetPar("X780",,qqo,qqw)'=""))
 .D ..wcrm("G"_Ngr_818,New,"-")
 .D ..wcrm("G"_Ngr_819,New,"?")
 I Ngr=2 D  G MenuGrEnd
 .D ..wcrm("G"_Ngr_820,New,"Выражение",qqw'="")
 .D ..wcrm("G"_Ngr_821,New,"Характеристика",qqw'="")
 .D ..wcrm("G"_Ngr_822,New,"Стандарт",qqw'="",0)
 .D ..wcrm("822_0",New,"Дата->Год")
 .D ..wcrm("822_1",New,"Дата->ГодМесяц")
 .D ..wcrm("822_2",New,"Дата->Возраст")
 .D ..wcrm("822_3",New,"Интервал")
 .D ..wcrm("822_4",New,"Диапазон")
 .D ..wcrm("822_5",New,"Значение (текущий объект)")
 .D ..wcrm("822_6",New,"Значение (произвольный объект)")
 .D ..wcrm("G"_Ngr_823,New,"Сброс",qqw'="")
 .D ..wcrm("G"_Ngr_827,New,"Примеры",qqw'=""&&(..GetPar("X782",,qqo,qqw)'=""))
 .D ..wcrm("G"_Ngr_828,New,"-")
 .D ..wcrm("G"_Ngr_829,New,"?")
 I Ngr=3 D  G MenuGrEnd
 .D ..wcrm("G"_Ngr_830,New,"Аналитический срез",qqw'=""_","_$S(qqw="":0,1:$G(Vs(qqnump,12,qqo,qqw,3))'=""&&'$G(Vs(qqnump,12,qqo,qqw,3,1)))) ;@Dol 23.03.08 $G(Vs(qqnump,12,qqo,qqw,3,1)) - без подсчета сумм
 .D ..wcrm("G"_Ngr_831,New,"Аналитический срез без подсчета сумм",qqw'=""_","_$S(qqw="":0,1:$G(Vs(qqnump,12,qqo,qqw,3))'=""&&$G(Vs(qqnump,12,qqo,qqw,3,1))))
 .D ..wcrm("G"_Ngr_838,New,"-")
 .D ..wcrm("G"_Ngr_839,New,"?")
 I Ngr=4 D  G MenuGrEnd
 .D ..wcrm("G"_Ngr_845,New,"Сброс",qqw'="") ;_","_$S(qqw="":0,1:1)) ;$G(Vs(qqnump,12,qqo,qqw,4))'=""))
 .D ..wcrm("G"_Ngr_846,New,"-")
 .D ..wcrm("G"_Ngr_840,New,"Подсчет",qqw'=""_","_$S(qqw="":0,1:$G(Vs(qqnump,12,qqo,qqw,4))'=""&&'$G(Vs(qqnump,12,qqo,qqw,4,1))))
 .D ..wcrm("G"_Ngr_857,New,"Без подсчета итогов (приемник-печать)",qqw'=""_","_$S(qqw="":0,1:$G(Vs(qqnump,12,qqo,qqw,4))'=""&&($G(Vs(qqnump,12,qqo,qqw,4,1))=5))) ;@Dol 22.09.10
 .D ..wcrm("G"_Ngr_842,New,"Sum - первое значение",qqw'=""_","_$S(qqw="":0,1:$G(Vs(qqnump,12,qqo,qqw,4))'=""&&($G(Vs(qqnump,12,qqo,qqw,4,1))=1)))
 .D ..wcrm("G"_Ngr_843,New,"Sum - список уникальных значений",qqw'=""_","_$S(qqw="":0,1:$G(Vs(qqnump,12,qqo,qqw,4))'=""&&($G(Vs(qqnump,12,qqo,qqw,4,1))=2)))
 .D ..wcrm("G"_Ngr_844,New,"Sum - полный список значений",qqw'=""_","_$S(qqw="":0,1:$G(Vs(qqnump,12,qqo,qqw,4))'=""&&($G(Vs(qqnump,12,qqo,qqw,4,1))=3))) ;@Dol 1.10.08
 .D ..wcrm("G"_Ngr_847,New,"Sum - последнее значение",qqw'=""_","_$S(qqw="":0,1:$G(Vs(qqnump,12,qqo,qqw,4))'=""&&($G(Vs(qqnump,12,qqo,qqw,4,1))=4))) ;@Dol 20.01.10
 .D ..wcrm("G"_Ngr_848,New,"Sum - кол-во уникальных значений",qqw'=""_","_$S(qqw="":0,1:$G(Vs(qqnump,12,qqo,qqw,4))'=""&&($G(Vs(qqnump,12,qqo,qqw,4,1))=5))) ;@Dol 21.12.10
 .D ..wcrm("G"_Ngr_841,New,"Экземпляры",qqw=""_","_($G(Vs(qqnump,12,qqo))))
 .D ..wcrm("G"_Ngr_836,New,"-")
 .D ..wcrm("G"_Ngr_849,New,"?")
 I Ngr>4 D  G MenuGrEnd
 .D ..wcrm("G"_5_850,New,"Диаграмма",$S(qqw="":0,$G(Vs(qqnump,12,qqo,qqw,4))="":0,1:1)_","_$S(qqw="":0,1:+$G(Vs(qqnump,13,0,qqo_" "_qqw_" "_Ngr))&&'$G(Vs(qqnump,13,0,qqo_" "_qqw_" "_Ngr,1))))
 .D ..wcrm("G"_5_853,New,"Без подсчета итогов (приемник-печать)",$S(qqw="":0,$G(Vs(qqnump,12,qqo,qqw,4))="":0,1:1)_","_$S(qqw="":0,1:+$G(Vs(qqnump,13,0,qqo_" "_qqw_" "_Ngr,1))=1)) ;@Dol 22.09.10
 .D ..wcrm("G"_5_854,New,"-")
 .D ..wcrm("G"_5_851,New,"только Num",$S(qqw="":0,$G(Vs(qqnump,12,qqo,qqw,4))="":0,1:1)_","_$S(qqw="":0,1:$G(Vs(qqnump,12,qqo,qqw))=1))
 .D ..wcrm("G"_5_852,New,"Дисперсия",$S(qqw="":0,$G(Vs(qqnump,12,qqo,qqw,4))="":0,1:1)_","_$S(qqw="":0,1:$G(Vs(qqnump,12,qqo,qqw))=2))
 .D ..wcrm("G"_5_858,New,"-")
 .D ..wcrm("G"_5_859,New,"?")
 .S Ngr=5
 ;
MenuGrEnd I $G(Arg1) Q:$Q "" Q
 D ..wM(qwin_".G"_Ngr,"Popup") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="MenuQ">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N qq168 S qq168=..GetPar(168)
 I $E(qq168,2)="@" D   Q  ;@Dol 20.03.08 пользовательские запросы
 .I $E(qq168,3)="@" D qARM.OpenWindow(,,,,,"mseQuery") Q  ;Для qMS
 .X $E(qq168,3,30000)
 I $TR(qq168," ")'="@" D ..MenuWoc("XU7",..Value($E(qq168,2,30000)),,," ",,,1) Q
 D ..MenuCre(,,7)  D ..wM(qwin_".XU7","Popup") Q
]]></Implementation>
</Method>

<Method name="MenuView">
<Description>
Создание меню отображений (emno)
qqpar1=1 -`включать код отображения в меню
qqpar2=1 - переотметка текущего отображения
0 или пусто- создание
-1 - удаление меню</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$G(qqpar2),$G(constr,"TFormTree")="TFormTree" D ..wipa() ;инициализация дерева образцов
 I $E($G(W("Zsform")))=1 G:'..GetPar("X183") emnofe G:$G(^Q(1,"XView",Vo(qqnump),"XMenu",0,"XMenuDo"))'="" emnofe G:$D(^("XMenu1")) emnofe ;сокращенная форма
 I $G(qqpar2)<0 G:'$D(qwin(qwin,"P1")) emnofe D ..wM(qwin_".P1","Destroy") K qwin(qwin,"P1") G:qqpar2=-1 emnofe s qqpar2=0
 N qq127,qq128,qq168,qqcond S qq127=..GetPar("X127") I $E(qq127)="@" D  Q:$Q "" Q  ;@dol 11.1.04
 .I $E($G(W("Zsform")))=1 Q
 .;D:$D(^Q(1,"XView",Vo(qqnump),"XMenu",6))  ;меню настроек
 ..I $D(qwin(qwin,"XU6")) D ..wM(qwin_".XU6","Destroy") K qwin(qwin,"XU6")
 ..S qwin(qwin,"XU6")="" D ..wC("TPopupMenu",qwin_".XU6"),..wP(qwin_".TBM.b20","DropdownMenu","XU6"),..MenuCre(,,6,1)
 .I $D(qwin(qwin,"XU9")) D ..wM(qwin_".XU9","Destroy") K qwin(qwin,"XU9")
 .S qwin(qwin,"XU9")="" D ..wC("TPopupMenu",qwin_".XU9"),..wP(qwin_".TBM.b22","DropdownMenu","XU9")
 .I $TR(qq127," ")'="@" D emnodi(qq127,9) Q
 .D ..MenuCre(,,9,1)
 S qq128=..GetPar(128),qq168=..GetPar(168)
 D  ;проверка условий активности пунктов меню
 .N i,j,qqq,qq,q F i=127,128,168 S qqq=@("qq"_i) I qqq'="--",qqq'="" D  S @("qq"_i_"=q")
 ..S q="" F j=1:1:qSYS.PSYN(qqq," ") S qq=qSYS.PSYN(qqq," ",j),qqcond=$P(qq,":",2,255) S:qq="-" $P(q," ",j)="-" I qq'="-" D  S $P(q," ",j)=$P(qq,":")_":"_(''qqcond)
 ...I qqcond="" S qqcond=1 Q
 ...S qqcond=..Value(qqcond) ;@("qqcond="_qqcond)
 G:$G(qqpar2)=1 emnob
 d ..wC("TPopupMenu",qwin_".P1")
 S qwin(qwin,"P1")=""
 I $E($G(W("Zsform")))'=1 D ..wP(qwin_".TBM.b22","DropdownMenu","P1") I 1 ;"TPopupMenu"
 E  G:$G(W("Zsform"))=11 emnofe G:'..GetPar("X183") emnofe G:$G(^Q(1,"XView",Vo(qqnump),"XMenu",0,"XMenuDo"))'="" emnofe G:$D(^("XMenu1")) emnofe D ..wP(qwin_".TBH.b101","DropdownMenu","P1") ;@dol 6.03.03 далеко не всегда нужно меню
 D ..wcrm("P1200",0,"Вызов",(qq127'="--"),0) ;@dol 15.11.02 полный запрет по --
 D ..wcrm("P1300",0,"Печать",(qq128'="--"),0)
 D  ;запросы
 .I $E(qq168)="@" S qq168="--" D ..wcrm("P1777",0,"Запросы...") Q
 .D ..wcrm("P1777",0,"Запросы",(qq168'="--"),0)
 .D ..wcrm("777_0",0,"новый Запрос",W("Zadm"))
 .D ..wcrm("777_1",0,"-","",0)
 ;D ..wcrm("P1030",0,"-","",0)
 ;D ..wcrm("P1100",0,"XML-браузер","0,0",0)
 ;D ..wcrm("100_0",0,"текущий")
 ;D ..wcrm("100_1",0,"полный")
 ;;D ..wcrm("P1033",0,"-","",0)
 ;
 D:..GetPar(20,,,0)'="" ..wcrm("P1060",0,"-","",0),..wcrm("P1888",0,"Действия","",0)
 D ..wcrm("P1033",0,"-","",0)
 D ..wcrm("P1034",0,"Выход")
 D ..wcrm("P1035",0,"?")
 ;
emnob   N qqot,qqot1,qqo,qqn,qqo1,qqol,qqon,qqful
 S qqpar2=+$G(qqpar2) K qwin(qwin,"o")
 I $E(qq168)'="@",qq168'="--" D  ;запросы
 .D ..wcrm("777_0",1,"",W("Zadm")!$G(Vs(qqnump,"Analit")))
 .S qqol=qq168 I qqol'="" D  Q
 ..F qqot=1:1:$L(qqol," ") S query=$P(qqol," ",qqot) I query'="",query'="-" S qqcond=$P(query,":",2),query=$P(query,":",1),qwin(qwin,"o",7,qqot+1)=query D ..wcrm("777_"_(qqot+1),qqpar2,$S(W("Zadm"):query_" ",1:"")_$G(^Q(1,"XQuery",query,"XQName")),qqcond)
 .N query S query=Vo(qqnump)_"qq" F qqot=1:1 S query=$O(^Q(1,"XQuery",query)) Q:$E(query,1,$L(Vo(qqnump))+2)'=(Vo(qqnump)_"qq")  S qwin(qwin,"o",7,qqot+1)=query D ..wcrm("777_"_(qqot+1),qqpar2,$S('W("Zadm"):"",query="XXXMinus":"",1:query_" ")_$G(^Q(1,"XQuery",query,"XQName")))
 S qqot1=Vo(qqnump) ;$P(qview," ") ;код отображения
 ;
 I qq127'="--",$S($L(qq127," ")>1&($P(qq127," ")="-"):0,1:1) S qwin(qwin,"o",1)=1,qwin(qwin,"o",1,1)=$S($G(W("Zar"))="":$E(qview,1,3)_"sysA"_qview,1:W("Zar")) D ..wcrm("200_1",qqpar2,$S($G(qqpar1):qwin(qwin,"o",1,1)_" ",1:"")_"Текушая Аналитика",''$D(^Qa($S($G(W("Zar"))="":"A"_qview,1:W("Zar")))))
 I qq128'="--",$S($L(qq128," ")>1&($P(qq128," ")="-"):0,1:1) S qwin(qwin,"o",2)=1,qwin(qwin,"o",2,1)=qqot1 D ..wcrm("300_1",qqpar2,$S($G(qqpar1):$E(qqot1,4,255),1:"")_"Текущее отображение",",1")
 ;
 S qqol=$TR(qq127," ",",")_" "_$TR(qq128," ",",") ;список доступных отображений перехода и печати
 S qqful="" F qqot=1:1:2 I $P(qqol," ",qqot)="" S $P(qqful," ",qqot)=1 ;список полных списков
 D:qqful'=""
 .S qqot=$E(qqot1,1,3) F  S qqot=$O(^Q(1,"XView",qqot)) Q:$E(qqot,1,3)'=$E(qqot1,1,3)  D  ;обход группы
 ..S qqn=$S('$G(qqpar1):"",qqot="XXXMinus":"",1:qqot_" ")_..GetPar(11,qqot) ;код и имя отображения
 ..S qqo1=","_(qqot=qqot1)
 ..D:$$emnof(1) ..wcrm("200_"_qwin(qwin,"o",1),qqpar2,qqn,qqo1) ;Вызовы
 ..I qqot'=qqot1 D:$$emnof(2) ..wcrm("300_"_qwin(qwin,"o",2),qqpar2,qqn,qqo1) ;Печать ;(Бланк)
 ;обработка явных списков
 N qqo2,qqo0 
 I qqful'="1 1" F qqo0=1:1:2 S qqful=$P(qqol," ",qqo0) I qqful'="",qqful'="--" D
 .F qqo2=1:1:$L(qqful,",") S qqo=$P(qqful,",",qqo2) I qqo'="",qqo'="-" S qqcond=$P(qqo,":",2),qqo=$P(qqo,":",1) D
 ..;S qqot=$S($E(qqo)="N"&($L(qqo)>7):$E(qqo,2,4)_$E(8,255),$L(qqo)<4:$E(qqot1,1,3)_qqo,1:qqo)
 ..S qqot=$S($L(qqo)<4:$E(qqot1,1,3)_qqo,1:qqo)
 ..S qqn=$S('$G(qqpar1):"",qqo="XXXMinus":"",1:qqo_" ")_$S($L(qqo)>3&($E(qqo,3,255)["qq"):$S($G(qqpar1):"(запрос) ",1:"")_$G(^Q(1,"XQuery",qqo,"XQName")),1:..GetPar(11,qqot)) ;код и имя отображения
 ..S qqo1=qqcond_","_(qqot=qqot1)
 ..S qwin(qwin,"o",qqo0)=$G(qwin(qwin,"o",qqo0))+1,qwin(qwin,"o",qqo0,qwin(qwin,"o",qqo0))=qqot
 ..D ..wcrm($S(qqo0=1:"200_",qqo0=2:"300_",qqo0=3:"300_",1:"300_2_")_qwin(qwin,"o",qqo0),qqpar2,qqn,qqo1)
 ;Действия
 D
 .I $E(Vo(qqnump),4,6)="sys" D  Q
 ..F qqo2=0:1 S qqo=..GetPar(20,,,qqo2) Q:qqo=""  D ..wcrm("888_"_qqo2,qqpar2,$TR(qqo,"_"," "))
 .S qqo2="" F  S qqo2=$O(^Q(1,"XView",Vo(qqnump),"XQuest",qqo2)) Q:qqo2=""  S qqo=..GetPar(20,,,qqo2) D ..wcrm("888_"_qqo2,qqpar2,$TR(qqo,"_"," "))  ;@dol 9.06.04
emnofe Q:$Q "" Q
emnof(qqon) ;проверка вхождения отображения в списки допустимых
 I $P(qqful," ",qqon) S qwin(qwin,"o",qqon)=$G(qwin(qwin,"o",qqon))+1,qwin(qwin,"o",qqon,qwin(qwin,"o",qqon))=qqot Q 1
 Q 0
emnodi(qqch0,qqchi) ;@dol 11.1.04 динамические меню
 S qqch0="qqch0="_$E(qqch0,2,32000),@qqch0 D ..MenuWoc("XU"_qqchi,qqch0,,,,,,1,-1) Q
]]></Implementation>
</Method>

<Method name="MenuWoc">
<Description>
Создание меню из словарей.
Mname - имя меню (уникальное имя объекта меню). При вызове меню в качестве развертки используется код понятия.
lwoc - список словарей (через пробел или $P(lwoc,"/",2)). Или список значений через ~.
lz - список текущих значений (для отметки в меню).
noreset=1 - не включать пункт меню СБРОС.
Xec - действие по выбору (новый вариант организации меню через словари)
Если понятие на Z, то предполагается, что значения в словаре содержатся в W(qqw,код)=значение
Если Xec'=""  - без привязки к текущей ячейки дерева экземпляров если pos'=1
Имя добавочного пункта (выводится вконце после черты). Если пусто, то  "иное..."
pos=1 привязка к нижнему краю текущей ячейки дерева экземпляров.
pos=-1 - не создавать меню (используется для вызова из доп. панели. См. метод MenuCre)

md=1 - меню действий. Для меню по экземплярам объекта есть понятие XMenuDo - действие по выбору
!!! В варианте вызова меню через развертку типа Действие имя меню (Mname) должно начинаться на XU)
reset - в любом случае (вне зависмости от меню действий) включить (1) исключить (0) пункт Cброс
qorder - порядок обхода (1-прямой, -1 - обратный) словарей.</Description>
<Internal/>
<FormalSpec>Mname:%String,lwoc:%String,lz:%String,noreset:%String=0,Xec:%String,add:%Library.String,cond:%Library.String,md:%Library.String,pos:%Library.String,reset:%Library.String,qorder:%Library.String=1</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I "QP"[qqnump S qwin="Q"_$P(Vt(qqnump,"Zparent")," ",2) ;@Dol 19.11.05 для вызова из запроса;N qqnump S qqnump=$E(qwin,2,3)
 D ..wM("-qARM","SetFocus",qwin)
 N newM,woc,woccod,z,i,sep,ii,ch,ch0,ch1,ch2
 K:$G(add)="-" add
 S Mname=$TR(Mname,"@","o") S:Mname[":" Mname=$P($P(Mname,":",2),"{") ;@dol 2.11.02 проблема с меню для обобщений и кодов понятий с подчерком
 S qxecuteMeNu=$G(Xec),ch0=0 S:qxecuteMeNu=" " qxecuteMeNu=""
 S:$G(lwoc)="" lwoc=Mname
 S Mname=$TR(qW.Translit(Mname),"^,.\:""'`~@&$%*/[]{}!?|+-)(#") ;$TR(Mname,"_","") ;@Dol 27.07.09 Translit;@dol 2.11.02 проблема с меню для обобщений и кодов понятий с подчерком
 S newM=1,woc=$P(lwoc," ") I lwoc'["~",lwoc'[$C(13,10),$L(lwoc," ")>1 G MenuWocP
 I lwoc["~" S noreset=$S($E(lwoc)="~":0,1:1) ;S:'noreset lwoc=$E(lwoc,2,30000)
 G:$G(pos)=-1 MenuWocBeg
 I $D(qwin(qwin,"MeNu",$ZCVT(Mname,"U"))),qwin(qwin,"MeNu",$ZCVT(Mname,"U"))'=Mname||($G(cond)'="") D ..wM(qwin_"."_qwin(qwin,"MeNu",$ZCVT(Mname,"U")),"Destroy") K qwin(qwin,qwin(qwin,"MeNu",$ZCVT(Mname,"U"))),qwin(qwin,"MeNu",$ZCVT(Mname,"U")) ;Delphi не различает большие и маленькие буквы в именах ;@Dol 27.11.09 ||($G(cond)'="") при наличии условия меню всегда перестраивается
 I $D(qwin(qwin,Mname)),qwin(qwin,Mname)'=woc||$G(md)||($E(Mname)="Z") D ..wM(qwin_"."_Mname,"Destroy") K qwin(qwin,Mname),qwin(qwin,"MeNu",$ZCVT(Mname,"U")) ;@dol 30.10.03 ||($E(Mname)="Z") - для пересчета Z-меню
 I '$D(qwin(qwin,Mname)) D
 .N qqme S qqme="" F  S qqme=$O(qwin(qwin,"MeNu",qqme)) Q:qqme=""  I $ZCVT(qwin(qwin,qwin(qwin,"MeNu",qqme)),"U")=$ZCVT(woc,"U") Q
 .I qqme'="" D ..wM(qwin_"."_qqme,"Destroy") K qwin(qwin,qwin(qwin,"MeNu",qqme)),qwin(qwin,"MeNu",qqme) ;@dol 21.07.03 удалим меню с одинаковым словарем
 .S qwin(qwin,"MeNu",$ZCVT(Mname,"U"))=Mname
 .S qwin(qwin,Mname)=woc,newM=0 D
 ..I $G(Xec)'=""||($G(pos)=0)||($E(Mname,1,2)="XU"),'$G(pos) d ..wC("TPopupMenu",qwin_"."_Mname) Q
 ..d ..wC("TqPopupMenu",qwin_"."_Mname,qwin_".T2") ;,..wP(,"OnPopUp",0),..wP(,"AutoPopUp",0)
 .Q:$G(reset)=0  I $G(reset)'=1 Q:noreset!$G(md)  ;!(lwoc["~");@dol 10.10.03 reset
 .D ..wcrm(Mname_"_"_0_"w"_Mname,0,"Сброс")
 .D ..wcrm(Mname_"_"_1_"w"_Mname,0,"-","",0)
MenuWocBeg S woccod="",z=$S($G(md):"",$D(lz):lz,1:$G(W(Mname)))
 I lwoc["~" D  G MenuWocEnd
 .N cha F ii='noreset:1:$L(lwoc,"~")-1 S woccod=$P(lwoc,"~",ii+1) Q:woccod=""&(ii+1=$L(lwoc,"~"))  D  ;@dol 22.05.03 для меню из одного пункта (ппп~)
 ..S:$E(woccod)="@" woccod=..Value($E(woccod,2,30000)) ;@dol 13.04.04
 ..S cha=1 I woccod'="-",$E(woccod)="-" S cha=0,woccod=$E(woccod,2,30000) ;@dol 5.04.04 активность
 ..S ch=$S($D(Xec):ii=z,1:" "_z_" "[(" "_woccod_" ")) S:ch ch0=1 D ..wcrm(Mname_"_"_2_"w"_Mname_ii,$D(qwin(qwin,Mname,ii)),$TR(woccod,"_"," "),cha_","_ch)
 ..S qwin(qwin,Mname,ii)=ii
 S cond=$G(cond)
 S (Cc,cond)=$G(cond),ii=0 S:cond="" cond=1 N Z
 I lwoc[":" D  G MenuWocEnd ;меню экземпляров
 .N qqcv S woc=Mname I lwoc["::" D  Q
 ..;;S ii=1 D:lwoc'["+"  Q:lwoc'["+"  N llwoc S llwoc=lwoc F  S lwoc=$P(llwoc,"+") D  S llwoc=$P(llwoc,"+",2,255) Q:llwoc=""  D ..wcrm(Mname_"_"_2_"w"_$TR(woc,"_")_(ii-1),$D(qwin(qwin,Mname,2_"w"_$TR(woc,"_")_(ii-1))),"-","",0) S qwin(qwin,Mname,2_"w"_$TR(woc,"_")_(ii-1))="",ii=ii+1 ;@Dol 23.03.10 объединение меню
 ..N pls S pls=qSYS.PSYN(lwoc,"+",2)'="" S ii=1 D:'pls  Q:'pls  N llwoc S llwoc=lwoc F  S lwoc=qSYS.PSYN(llwoc,"+",1,,,1) D  S llwoc=qSYS.PSYN(llwoc,"+",2,255,,1) Q:llwoc=""  D ..wcrm(Mname_"_"_2_"w"_$TR(woc,"_")_(ii-1),$D(qwin(qwin,Mname,2_"w"_$TR(woc,"_")_(ii-1))),"-","",0) S qwin(qwin,Mname,2_"w"_$TR(woc,"_")_(ii-1))="",ii=ii+1 ;@Dol 23.03.10 объединение меню;@Dol 15.04.11 PSYN
 ...I $P(lwoc,"::")="",$P(lwoc,";",2)="" D
 ....N ii S ii=$P($P(lwoc,"::",2),",") N lwoc S lwoc="uMenu::"_ii_",;uMenu1:,;uMenu2:,;uMenu3:,;uMenu4:,"
 ...S ii=$$MenuWocObj($P($P($P(lwoc,";"),"::",2),","),2,Mname_"_"_2_"w"_Mname,1,ii-1)+ii
 .;.I $P(lwoc,"::")="",$P(lwoc,";",2)="" S ii=$P($P(lwoc,"::",2),",") N lwoc S lwoc="uMenu::"_ii_",;uMenu1:,;uMenu2:,;uMenu3:,;uMenu4:,"
 .;.S ii=$$MenuWocObj($P($P($P(lwoc,";"),"::",2),","),2,Mname_"_"_2_"w"_Mname,1)+1
 .S ii=$$MenuWocObj("",1,Mname_"_"_2_"w"_Mname,1)+1
 F  S woccod=$S($E(woc)'="Z":$O(^Q(qqlang,"C"_woc,woccod),qorder),1:$O(W(woc,woccod),qorder)) Q:woccod=""  S Z=$S($E(woc)'="Z":^(woccod),1:$G(W(woc,woccod))) S:$E(Z)="@" Z=..Value($E(Z,2,3000)) I @cond D  ;@dol 13.04.04 S:$E(Z)="@" Z=..Value(
 .I $D(add),add'="",Z=add Q
 .S ch=$S($D(Xec):woccod=z,1:" "_z_" "[(" "_Z_" ")) S:ch ch0=1 D ..wcrm(Mname_"_"_2_"w"_$S($G(md)&0:Mname,1:$TR(woc,"_"))_ii,$D(qwin(qwin,Mname,ii)),$TR(Z,"_"," "),","_ch)
 .S qwin(qwin,Mname,ii)=woccod,ii=ii+1
MenuWocEnd I $G(pos)=-1 Q:$Q "" Q
 S:lwoc["~" ii=ii+1,woc=Mname
 N sss S sss=$S(lwoc["~":"",lwoc[":":"2w"_woc,1:"")
 D:$D(add)
 .;S:lwoc["~" ii=ii+1,woc=Mname
 .;N sss S sss=$S(lwoc[":":"2w"_woc,1:"")
 .S:add="" add="иное..." D ..wcrm(Mname_"_"_2_"w"_$TR(woc,"_")_ii,$D(qwin(qwin,Mname,sss_ii)),"-","",0) S qwin(qwin,Mname,sss_ii)="",ii=ii+1
 .D ..wcrm(Mname_"_"_2_"w"_$TR(woc,"_")_ii,$D(qwin(qwin,Mname,sss_ii)),add,","_$S(z="":0,'ch0:1,1:add=z)) S qwin(qwin,Mname,sss_ii)="@@@",ii=ii+1
 I $D(qwin(qwin,Mname,sss_ii)) F ii=ii:1:$O(qwin(qwin,Mname,""),-1) D ..wcrm(Mname_"_"_2_"w"_$TR(woc,"_")_ii,-1) K qwin(qwin,Mname,sss_ii) ;@dol 31.07.03 удаление лишних пунктов
 I $D(qwin(qwin,Mname))<10 Q:$Q "" Q  ;@Dol 20.01.10 пустое меню
 I $G(Xec)'=""||($G(pos)=0)||($E(Mname,1,2)="XU"),'$G(pos) D ..wM(qwin_"."_Mname,"Popup") Q:$Q "" Q
 D ..wM(qwin_"."_Mname,"CellPopUp",qwin_".T2","",$G(W("Zpos",2,"x"),1)) Q:$Q "" Q
 ;@Dol 31.08.10 qqoM - ссылка на массив ( ["(" )
MenuWocObj(qqc0,lev,mname,levv,num) ;levv - реальный уровень
 N qqcM,qqoM,qqwlist,qqwM,qqwi,next,Zz,Zold S Zold=$G(Z),qqwlist=$P(lwoc,";",lev),qqoM=$P(qqwlist,":"),qqwlist=$P(qqwlist,":",2),qqcM="" ;@Dol 03.06.10 qqcM="" вместо =qqc0
 ;;;Q:qqoM="" 0 S num=0 F  S qqcM=$$$UserOrd(qorder,qqoM,qqcM,$P(qqc0,"!")) S:qqcM="" qqc0=$P(qqc0,"!",2,255) Q:qqc0=""&&(qqcM="")  I qqcM'="" D  I $I(num)  ;@dol 25.05.04 !
 Q:qqoM="" 0 S:$G(num)="" num=0 F  S qqcM=$S(levv=1&&($P(qqc0,"!")'="")&&$D(^Q(1,qqoM,$P(qqc0,"!"))):$S(qqcM="":$P(qqc0,"!"),1:""),qqoM["(":$O(@qqoM@(qqcM)),1:$$$UserOrd(qorder,qqoM,qqcM,$P(qqc0,"!"))) S:qqcM="" qqc0=$P(qqc0,"!",2,255) Q:qqc0=""&&(qqcM="")  I qqcM'="" D  I $I(num)  ;@dol 23.03.10 задан qqc объекта а не вершины
 .I cond'="" D  Q:'ch1  ;@dol 24.09.03 для условия вывода
 ..N qqc,qqo S qqc=qqcM,qqo=qqoM
 ..I @cond S ch1=1 Q
 ..S ch1=0
 .I $G(md) S ch1=$$MenuWocObjGG("XMenuCond") I ch1'="" D  Q:'ch1  ;md=1 - меню действий
 ..I @ch1 S ch1=1 Q
 ..s ch1=0 Q
 .;S Z="" F qqwi=1:1:$L(qqwlist,",") S qqwM=$P(qqwlist,",",qqwi) S:qqwM=""&&(qqwi=1) qqwM="XMenuName" I qqwM'="" S Zz=$S(qqoM'["(":qW.GG(qqoM,qqwM,qqcM),qqwM="C":qqcM,qqwM="CC":$G(@qqoM@(qqcM)),1:$G(@qqoM@(qqcM,qqwM))) S:$E(Zz)="@" Zz=..Value($E(Zz,2,30000)) S Z=Z_$C(9)_Zz  ;@dol 13.04.04 Zz
 .S Z="" F qqwi=1:1:$S(qqoM'["(":$L(qqwlist,","),1:qSYS.PSYN(qqwlist,",")) S qqwM=$S(qqoM'["(":$P(qqwlist,",",qqwi),1:qSYS.PSYN(qqwlist,",",qqwi,qqwi,,1)) S:qqwM=""&&(qqwi=1) qqwM="XMenuName" I qqwM'="" S Zz=$S(qqoM'["(":qW.GG(qqoM,qqwM,qqcM),qqwM="C":qqcM,qqwM="CC":$G(@qqoM@(qqcM)),qqwM["(":"@"_qqwM,1:$G(@qqoM@(qqcM,qqwM))) S:$E(Zz)="@" Zz=..Value($E(Zz,2,30000)) S Z=Z_$C(9)_Zz  ;@dol 01.03.11 
 .S Z=$E(Z,2,1000),ch=" "_z_" "[(" "_$S(qqoM'["(":"",Zold="":"",1:Zold_" ")_$P($TR(Z,$C(9)," ")," ")_" ") S:ch ch0=1 S ch1=1 D:$G(md)
 ..S ch2=$$MenuWocObjGG("XMenuCh") S:ch2'="" @("ch2="_ch2) ;@Dol 23.06.04
 ..S ch1=$$MenuWocObjGG("XMenuAct") I ch1="" S ch1=1 Q
 ..I @ch1 S ch1=1 Q
 ..s ch1=0 Q
 .S:qqoM["(" qqcv(levv)=qqcM S next=$S($P(lwoc,";",lev+1)="":0,qqoM'["(":$$$UserOrd(1,$P($P(lwoc,";",lev+1),":"),"",qqcM)'="",1:$D(@$P($P(lwoc,";",lev+1),":"))>1) ;@Dol 31.08.10 qqoM["("
 .D ..wcrm($S(levv=1:mname,1:$P(mname,"_",2,$L(mname,"_")))_num,$D(qwin(qwin,Mname,$P(mname,"_",2,255)_num)),$TR(Z,"_"," "),ch1_","_$S($G(ch2)'="":ch2,1:ch),'next,qW.GG(qqoM,"XMenuRes",qqcM)) S qwin(qwin,Mname,$P(mname,"_",2,255)_num)=Z S:'next&$G(md) qwin(qwin,Mname,$P(mname,"_",2,255)_num,1)=qqoM_" "_qqcM I next,$$MenuWocObj(qqcM,lev+1,mname_num_"_",levv+1) ;2 = $L(mname,"_")-1
 Q num
MenuWocObjGG(qqw) Q $S(qqoM'["(":qW.GG(qqoM,qqw,qqcM),1:$G(@qqoM@(qqcM,qqw))) ;@Dol 31.08.10
MenuWocP ;меню-набор параметров
 S sep=$E($P(lwoc,"/",2)),lwoc=$P(lwoc,"/")
 S:sep="" sep=" " ;разделитель значений
 S Mname="MMenu"
 I $D(qwin(qwin,Mname)) D ..wM(qwin_"."_Mname,"Destroy")
 S qwin(qwin,Mname)="",newM=0
 d ..wC("TqPopupMenu",qwin_"."_Mname,qwin_".T2") ;,..wP(,"OnPopUp",0)
 D:'noreset ..wcrm(Mname_"_"_0_"w"_Mname,0,"Сброс")
 F i=1:1:$L(lwoc," ") S woc=$P(lwoc," ",i),z=$P(lz,sep,i) D:woc'=""
 .D ..wcrm(Mname_"_"_i_"w"_woc,newM,$TR(^Q(qqlang,"CxWoc",woc),"_%"," "),"",0) D
 ..;D ..wcrm(i_"w"_woc_"_m",newM,"сброс")
 ..S woccod="" F  S woccod=$O(^Q(qqlang,"C"_woc,woccod)) Q:woccod=""  D
 ...D ..wcrm(i_"w"_woc_"_"_$TR(woccod,"-","m"),newM,^(woccod),","_(woccod=z))
 ;D ..wM(qwin_"."_Mname,"Popup") Q
 D ..wM(qwin_"."_Mname,"CellPopUp",qwin_".T2","",$G(W("Zpos",2,"x"),1)) Q:$Q "" Q
 ;D ..wM(qwin_".T1","CellPopUp",qwin_"."_Mname,"",1) Q
]]></Implementation>
</Method>

<Method name="Message">
<Description>
Вывод сообщения. Появляется как окно в центре текущего окна. Если задано time - то используется 
всплывающее окно.

message - текст. Если несколько строк - через $C(13,10).
title - заголовок окна (по умолчанию - "Сообщение")
type - тип ресурса (картинки). 0 - Warning, 1 - Error, 2 - Information, 3 - Confirmation, 4 - Custom;

time - время (в секундах) на которое появляется всплывающее окно.
lage=1 - крупные буквы во всплывающем окне.
umf=1 - окно появляется под указателем курсора мыши


****Далее комментарии для использования  "ShowMessagePos" в пользовательких вариантах выдачи сообщений.

d ..wM("-qARM","ShowMessagePos",par1,par2,par3,par4,par5,par6)
par1- окно, относительно которого центрировать окно сообщения;
par2 - текст сообщения;
par3 - заголовок окна сообщения;
par4 - тип окна:
0 - Warning,
1 - Error,
2 - Information,
3 - Confirmation, 
4 - Custom;
par5 - определяет, какие кнопки присутствуют:
0 - "OK",
1 - "OK","Cancel",
2 - "Yes","No","Cancel";
3 - "Yes","No"
par6 - определяет на какой кнопке фокус (нумерация начинается с 2, в случае par4=4 с 1).
Пример:
d ..wM("-qARM","ShowMessagePos",qwin,"text","title",4,2,3)
Centr=1 - вывод по центру экрана</Description>
<Internal/>
<FormalSpec>message:%String,title:%String,type:%Library.String,time:%Library.String,large:%Library.String,umf:%Library.String,Centr:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(W("Zmesb")) W !,"Сообщение: "_$G(message) Q:$Q "" Q  ;вывод на текущее у-во (для WebLink) 
 ;если окно существует
 I "PQW"[$G(qqnump),$D(qqParent) N qwin S qwin="Q"_$P(qqParent," ",2)
 I '$G(time) D ..wM("-qARM","ShowMessagePos",$S($G(Centr):"",1:$G(qwin)),$G(message,"Сообщение"),$G(title,"Сообщение"),+$G(type),0,2) Q:$Q "" Q  ;@sasha 20080707 @Dol+Dima 12.05.08 Centr - всегда по центру окна
 I $G(qwin)'="",$D(qwin(qwin)),"PQW"'[$E(qwin,2) D   Q:$Q "" Q  
 .;I '$G(time) D ..wM("-qARM","ShowMessagePos",qwin,$G(message,"Сообщение"),$G(title,"Сообщение"),+$G(type),0,2) Q
 .;S:'$D(large) large=$P($G(qqX155),",",2)>8 ;18.12.09 убрано - криво (неполностью) выводится
 .d qARM.wM(qwin_".T2","ScreenMsg","",$G(W("Zpos",2,"x")),$G(message,"Сообщение"),time*1000,''$G(large),''$G(umf,1)) ;@Dima 17.10.07 ;@Dol 24.07.09 large
 ;если time и окна нет
 D ..wM("-qARM","MessageBox",$G(message,"Сообщение"),$G(title,"Сообщение"),0) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Move">
<Description>
Экранная отработка перемещений по базе (относительно текущего объекта и экземпляра)
Arg1 = Beg  -первый
Up    - предыдущий
Down - следующий
End - последний
PageUp    - предыдущая страница (Arg3 - размер)
PageDown - следующая  страница (Arg3 - размер)

Arg2=1 внешний вызов (из скрола перемещений - обытие ..OnScroll)</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N X54Fix,ObjM,qqcii,qqoParent,qqcVc,qqc0,qqo0 I $G($$$CurObj)="" Q   //@sasha 20081214
 s:qqo="" qqo=$$$CurObj   //sas 20090625   
 I $G($$$Tree),$G($$$GloRef)="" S $$$GloRef="^Q(1)" ;@Dol 15.02.09
 i $G(Vo(qqnump,$$$CurObj,2))=1 D
 .;;для встроенного объекта с зачеркнутым Parent sas 20090212 
 .s qqoParent=$E($$$CurObj,3,$L($$$CurObj))
 .i $G(Vs(qqnump,1,qqoParent))=1 i (Arg1="Down")!(Arg1="Up")  s $$$CurObj=qqoParent  Q  ;перемещение по встроенным с зачеркнутым Parent sas 20090212 
 .S qqcii=Vc(qqnump)  F  S qqcii=$E(qqcii,1,$L(qqcii)-2) Q:qqcii=""  I $G(Vo(qqnump,Vc(qqnump,qqcii,0),2))'=1 S qqcVcold=Vc(qqnump) s Vc(qqnump)=qqcii s $$$CurObj=Vc(qqnump,Vc(qqnump),0) ;@Dol 17.06.05 перемещение по встроенным
 .;;для встроенного объекта с зачеркнутым Parent sas 20090212 
 .i $G(Vs(qqnump,1,qqoParent))=1 s $$$CurObj=qqoParent  ;перемещение по встроенным с зачеркнутым Parent sas 20090212 
 S ObjM=$P($G(Vo(qqnump,-1,669))," ") I ObjM'="",$$$CurObj'=ObjM D  ;объект перемещения для скролирования (перепозиционирование на него)
 .S qqcii=Vc(qqnump) F  S qqcii=$E(qqcii,1,$L(qqcii)-2) Q:qqcii=""  Q:Vc(qqnump,qqcii,0)=ObjM  
 .I qqcii="" S qqcii=Vc(qqnump) F  S qqcii=$O(Vc(qqnump,qqcii)) Q:$E(qqcii,1,$L(Vc(qqnump)))'=Vc(qqnump)  Q:Vc(qqnump,qqcii,0)=ObjM
 .I qqcii'="" S Vc(qqnump)=qqcii,$$$CurObj=ObjM ;@Dol 28.04.08 qqcii'=""
 G @("Move"_Arg1)
MoveBeg   ;начало
 Q:$$$CurObj=-1
 d X54Fixm(Vc(qqnump)) i $G(X54Fix)=1 Q     //никаких перемещений, если развернут экземпляр объекта с X54 фиксация 
 D
 .;;получение для встроенного объекта с зачеркнутым Parent qqcc sas 20090709
 .i $G(Vo(qqnump,qqo,2))=1 i $G(qqoParent)'="" i $G(Vs(qqnump,1,qqoParent))=1 D Movevs S (Vs(qqnump,"Virt",qqo),qqcc)=qW.gOrder(1,$$$CurObj,"",qqc0),$$$CurObj=qqo  Q  
 .I $D(Vt(qqnump,111)),'$D(Vt(qqnump,111,0,$$$CurObj)) N qqc0 D Movev S (Vs(qqnump,"Virt",$$$CurObj),qqcc)=qW.gOrder(1,$$$CurObj,"",qqc0) Q  ;,'$D(Vt(qqnump,111,0,$$$CurObj))
 .D ..ObjSort()
 .S qqcc=qW.gOrder(1,$$$CurObj,"")
 ;;для встроенного объекта с зачеркнутым Parent выход не нужен sas 20090212
 i ($G(Vo(qqnump,qqo,2))=1)&&($G(qqoParent)'="")&&($G(Vs(qqnump,1,qqoParent))=1) 
 e  Q:qqc=qqcc
 S qqpar1="",qqc=qqcc F  S qqpar1=$O(Vc(qqnump,qqpar1),1) Q:qqpar1=""  Q:$$$CurObj=Vc(qqnump,qqpar1,0)  ;в текущем дереве
 I qqpar1'="",qqc=Vc(qqnump,qqpar1),$G(Vc(qqnump,qqpar1,1),1) S Vc(qqnump)=qqpar1 G MoveE ;существует и активен
 D ..wcre() Q
MoveUp   ;предыдущий
 Q:$$$CurObj=-1
 d X54Fixm(Vc(qqnump)) i $G(X54Fix)=1 Q     //никаких перемещений, если развернут экземпляр объекта с X54 фиксация 
 ;;переназначение для встроенного объекта с зачеркнутым Parent $$$CurObj sas 20090212
 S qqpar1=Vc(qqnump) D:$O(Vc(qqnump,qqpar1),-1)'="" X54Fixm($O(Vc(qqnump,qqpar1),-1)) F  S qqpar1=$O(Vc(qqnump,qqpar1),-1) Q:(qqpar1="")&&($G(X54Fix)="")  i qqpar1'="" I $$$CurObj=Vc(qqnump,qqpar1,0)  D:$G($$$Tree) qW.qRef(qqpar1) Q  ;в текущем дереве  sas 20081214 добавлено условие выхода из цикла если развернут экземпляр объекта родителя с X54 фиксация 
 ;;получение для встроенного объекта с зачеркнутым Parent qqcc sas 20090212
 i $G(Vo(qqnump,qqo,2))=1 i $G(qqoParent)'="" i $G(Vs(qqnump,1,qqoParent))=1 S (Vs(qqnump,"Virt",qqo),qqcc)=qW.gOrder(-1,$$$CurObj,qqc,Vc(qqnump,Vc(qqnump))) S qqpar1=Vc(qqnump),$$$CurObj=qqo F  S qqpar1=$O(Vc(qqnump,qqpar1),-1) Q:qqpar1=""  Q:qqo=Vc(qqnump,qqpar1,0)
 I qqpar1="" D  Q:qqcc=""  S qqc=qqcc D ..wcre() Q
 .I $D(Vt(qqnump,111)),'$D(Vt(qqnump,111,0,$$$CurObj)) N qqc0 D Movev S (Vs(qqnump,"Virt",$$$CurObj),qqcc)=qW.gOrder(-1,$$$CurObj,qqc,qqc0) Q  ;,'$D(Vt(qqnump,111,0,$$$CurObj))
 .D ..ObjSort() S:$P($$$CondFind," ")'="" W($P($$$CondFind," "))=qW.GG($$$CurObj,$P($$$CondFind," "),qqc) S qqcc=qW.gOrder(-1,$$$CurObj,qqc)
 S Vc(qqnump)=qqpar1,qqc=Vc(qqnump,qqpar1) I $G(Vc(qqnump,qqpar1,1),1) G MoveE ;существует и активен
 D ..wcre() Q
MoveDown   ;следующий
 Q:$$$CurObj=-1
 d X54Fixm(Vc(qqnump)) i $G(X54Fix)=1 Q     //никаких перемещений, если развернут экземпляр объекта с X54 фиксация 
 S qqpar1=Vc(qqnump) F  S qqpar1=$O(Vc(qqnump,qqpar1),1) Q:qqpar1=""  I $$$CurObj=Vc(qqnump,qqpar1,0) D:$G($$$Tree) qW.qRef(qqpar1) Q  ;в текущем дереве
 ;;получение для встроенного объекта с зачеркнутым Parent qqcc sas 20090212
 i $G(Vo(qqnump,qqo,2))=1 i $G(qqoParent)'="" i $G(Vs(qqnump,1,qqoParent))=1 S (Vs(qqnump,"Virt",qqo),qqcc)=qW.gOrder(1,$$$CurObj,qqc,Vc(qqnump,Vc(qqnump))) S qqpar1=Vc(qqnump),$$$CurObj=qqo F  S qqpar1=$O(Vc(qqnump,qqpar1),1) Q:qqpar1=""  Q:qqo=Vc(qqnump,qqpar1,0)
 I qqpar1="" D  Q:qqcc=""  S qqc=qqcc D ..wcre() Q
 .I $D(Vt(qqnump,111)),'$D(Vt(qqnump,111,0,$$$CurObj)) N qqc0 D Movev S (Vs(qqnump,"Virt",$$$CurObj),qqcc)=qW.gOrder(1,$$$CurObj,qqc,qqc0) Q  ;,'$D(Vt(qqnump,111,0,$$$CurObj))
 .D ..ObjSort() S:$P($$$CondFind," ")'="" W($P($$$CondFind," "))=qW.GG($$$CurObj,$P($$$CondFind," "),qqc) S qqcc=qW.gOrder(1,$$$CurObj,qqc) ;$$$CondFind....;@Dol 16.12.05
 S Vc(qqnump)=qqpar1,qqc=Vc(qqnump,qqpar1) I $G(Vc(qqnump,qqpar1,1),1) G MoveE  ;существует и активен
 D ..wcre() Q
MovePageDown   ;следующая страница (34);@Dol 09.03.11
 N qqpar1o,nnn Q:$$$CurObj=-1  S:'$G(Arg3) Arg3=$S(10<$G(Vo(qqnump,-1,60)):10,1:Vo(qqnump,-1,60)-2) S:Arg3=1 Arg3=$S($G(Vo(qqnump,-1,60))'="":Vo(qqnump,-1,60),1:20) S nnn=Arg3*2
 ;D qARM.Message(Arg3_" "_nnn)
 d X54Fixm(Vc(qqnump)) i $G(X54Fix)=1 Q     //никаких перемещений, если развернут экземпляр объекта с X54 фиксация 
 S (qqpar1,qqpar1o)=Vc(qqnump) F  S qqpar1=$O(Vc(qqnump,qqpar1),1) Q:qqpar1=""  I $$$CurObj=Vc(qqnump,qqpar1,0) S:nnn'<Arg3 qqpar1o=qqpar1 I '$I(nnn,-1) D:$G($$$Tree) qW.qRef(qqpar1) Q  ;в текущем дереве
 ;;получение для встроенного объекта с зачеркнутым Parent qqcc sas 20090212
 i $G(Vo(qqnump,qqo,2))=1 i $G(qqoParent)'="" i $G(Vs(qqnump,1,qqoParent))=1 S (Vs(qqnump,"Virt",qqo),qqcc)=qW.gOrder(1,$$$CurObj,qqc,Vc(qqnump,Vc(qqnump))) S qqpar1=Vc(qqnump),$$$CurObj=qqo F  S qqpar1=$O(Vc(qqnump,qqpar1),1) Q:qqpar1=""  Q:qqo=Vc(qqnump,qqpar1,0)
 ;D qARM.Message(qqpar1o_" "_qqpar1_" "_Arg3_" "_nnn)
 I qqpar1="",nnn<Arg3 S Vc(qqnump)=qqpar1o,qqc=Vc(qqnump,qqpar1o) D ..wcre() Q
 I qqpar1="" S Vc(qqnump)=qqpar1o,qqc=Vc(qqnump,qqpar1o) D  Q:qqcc=""  S qqc=qqcc D ..wcre() Q
 .I $D(Vt(qqnump,111)),'$D(Vt(qqnump,111,0,$$$CurObj)) N qqc0 D Movev S (Vs(qqnump,"Virt",$$$CurObj),qqcc)=qW.gOrder(1,$$$CurObj,qqc,qqc0) Q  ;,'$D(Vt(qqnump,111,0,$$$CurObj))
 .D ..ObjSort() S:$P($$$CondFind," ")'="" W($P($$$CondFind," "))=qW.GG($$$CurObj,$P($$$CondFind," "),qqc) S qqcc=qW.gOrder(1,$$$CurObj,qqc) ;$$$CondFind....;@Dol 16.12.05
 S Vc(qqnump)=qqpar1o,qqc=Vc(qqnump,qqpar1o) I $G(Vc(qqnump,qqpar1o,1),1) D ..wpoe(qqpar1_" "_$$$CurObj_" "_$S($$$CurObj=$P($G(W("Zpos",2,"d"))," ",2):+$P($G(W("Zpos",2,"d"))," ",3),1:0)) S qqpar1=qqpar1o G MoveE  ;существует и активен
 D ..wcre() Q
MovePageUp   ;предыдущая страница (35);@Dol 09.03.11
 N qqpar1o,nnn,qqpar1e Q:$$$CurObj=-1  S:'$G(Arg3) Arg3=$S(10<$G(Vo(qqnump,-1,60)):10,1:$G(Vo(qqnump,-1,60))-2) S:Arg3=1 Arg3=$S($G(Vo(qqnump,-1,60))'="":Vo(qqnump,-1,60),1:20) S nnn=Arg3
 d X54Fixm(Vc(qqnump)) i $G(X54Fix)=1 Q     //никаких перемещений, если развернут экземпляр объекта с X54 фиксация 
 S (qqpar1,qqpar1o,qqpar1e)=Vc(qqnump) F  S qqpar1=$O(Vc(qqnump,qqpar1),-1) Q:qqpar1=""  I $$$CurObj=Vc(qqnump,qqpar1,0) S qqpar1e=qqpar1 I '$I(nnn,-1) D:$G($$$Tree) qW.qRef(qqpar1) Q  ;в текущем дереве
 ;;получение для встроенного объекта с зачеркнутым Parent qqcc sas 20090212
 i $G(Vo(qqnump,qqo,2))=1 i $G(qqoParent)'="" i $G(Vs(qqnump,1,qqoParent))=1 S (Vs(qqnump,"Virt",qqo),qqcc)=qW.gOrder(1,$$$CurObj,qqc,Vc(qqnump,Vc(qqnump))) S qqpar1=Vc(qqnump),$$$CurObj=qqo F  S qqpar1=$O(Vc(qqnump,qqpar1),1) Q:qqpar1=""  Q:qqo=Vc(qqnump,qqpar1,0)
 I qqpar1="" S Vc(qqnump)=qqpar1e,(qqc,qqcc)=Vc(qqnump,qqpar1e) D  D:Arg3'=nnn qARM.wcre() Q:Arg3'=nnn  Q:qqpar1e=qqpar1o  S qqpar1=qqpar1e
 .I $D(Vt(qqnump,111)),'$D(Vt(qqnump,111,0,$$$CurObj)) N qqc0 D Movev I 1
 .E  D ..ObjSort() 
 .F Arg3=nnn:-1:0 D  Q:qqcc=""  S qqc=qqcc
 ..I $D(Vt(qqnump,111)),'$D(Vt(qqnump,111,0,$$$CurObj)) S (Vs(qqnump,"Virt",$$$CurObj),qqcc)=qW.gOrder(-1,$$$CurObj,qqcc,qqc0) Q
 ..S:$P($$$CondFind," ")'="" W($P($$$CondFind," "))=qW.GG($$$CurObj,$P($$$CondFind," "),qqcc) S qqcc=qW.gOrder(-1,$$$CurObj,qqcc)
 S Vc(qqnump)=qqpar1,qqc=Vc(qqnump,qqpar1) I $G(Vc(qqnump,qqpar1o,1),1)  G MoveE  ;существует и активен
 D ..wcre() Q
MoveEnd   ;конец
 Q:$$$CurObj=-1
 d X54Fixm(Vc(qqnump)) i $G(X54Fix)=1 Q     //никаких перемещений, если развернут экземпляр объекта с X54 фиксация 
 D
 .;;получение для встроенного объекта с зачеркнутым Parent qqcc sas 20090708
 .i $G(Vo(qqnump,qqo,2))=1 i $G(qqoParent)'="" i $G(Vs(qqnump,1,qqoParent))=1 D Movevs S (Vs(qqnump,"Virt",qqo),qqcc)=qW.gOrder(-1,$$$CurObj,"",qqc0),$$$CurObj=qqo Q  
 .I $D(Vt(qqnump,111)),'$D(Vt(qqnump,111,0,$$$CurObj)) N qqc0 D Movev S (Vs(qqnump,"Virt",$$$CurObj),qqcc)=qW.gOrder(-1,$$$CurObj,"",qqc0) Q  ;,'$D(Vt(qqnump,111,0,$$$CurObj)) D s1300v Q
 .D ..ObjSort()
 .S qqcc=qW.gOrder(-1,$$$CurObj,"")
 ;;для встроенного объекта с зачеркнутым Parent выход не нужен sas 20090212
 i ($G(Vo(qqnump,qqo,2))=1)&&($G(qqoParent)'="")&&($G(Vs(qqnump,1,qqoParent))=1) 
 e  Q:qqc=qqcc
 S qqpar1="",qqc=qqcc F  S qqpar1=$O(Vc(qqnump,qqpar1),-1) Q:qqpar1=""  Q:$$$CurObj=Vc(qqnump,qqpar1,0)  ;в текущем дереве
 I qqpar1'="",qqc=Vc(qqnump,qqpar1),$G(Vc(qqnump,qqpar1,1),1) S Vc(qqnump)=qqpar1 G MoveE ;существует и активен
 //криво работает wcre при включенной сортировке, поэтому делаю 2 раза wqqotree
 i ($G(Vo(qqnump,qqo,2))=1)&&($G(qqoParent)'="")&&($G(Vs(qqnump,1,qqoParent))=1) n qqovo,qqcvo s qqovo=qqo,qqcvo=qqc d ..wqqotree(qqo0,qqc0),..wqqotree(qqovo,qqcvo) Q
 D ..wcre() Q
MoveE D ..wpoe(qqpar1_" "_$$$CurObj_" "_$S($$$CurObj=$P($G(W("Zpos",2,"d"))," ",2):+$P($G(W("Zpos",2,"d"))," ",3),1:0),1) Q
Movev ;для виртуальных объектов
 ;S qqc0="" Q  ;отключим, тогда перемещение в рамках текущего поддерева
 N qqoobj,qqob,qqobi,qqob0,qqcvs S qqob=$G($$$ObjRef($$$CurObj)) I qqob=$$$CurObj S qqc0="" Q  ;@dol 24.12.03
 i qqob="" s qqc0="" Q    ;;@sas 20081212 если объект был -1 то валилось по subs
 //F qqobi=$L(qqob,","):-1:1 I $G(Vo(qqnump,$P(qqob,",",qqobi),2)) S Vs(qqnump,"Virt",$P(qqob,",",qqobi))=Vc(qqnump,$E(Vc(qqnump),1,qqobi*2))
 F qqobi=$L(qqob,","):-1:1 s qqoobj=$P(qqob,",",qqobi) I $G(Vo(qqnump,qqoobj,2)) S Vs(qqnump,"Virt",qqoobj)=$E(Vc(qqnump,$E(Vc(qqnump),1,qqobi*2)),1,$$$ObjLqqc(qqoobj))     ;;sas 20081213 правильное определение длины qqc (старый вариант приводил к ошибке при варианте свертки фиксация). 
 //если ссылочный аналог sas 20090503
 s qqcvs=$G(Vc(qqnump,Vc(qqnump),6)) i qqcvs'="" s qqc0=$P(qqcvs,"~",$L(qqcvs,"~")) Q
 //S qqc0=$S($L(qqob,",")=1:"",$D(Vc(qqnump))<10:"",1:Vc(qqnump,$E(Vc(qqnump),1,$L(qqob,",")-1*2))) ;@Dol 20.05.06 $D(V
 S qqc0=$S($L(qqob,",")=1:"",$D(Vc(qqnump))<10:"",1:Vc(qqnump,$E(Vc(qqnump),1,$L(Vc(qqnump))-$S($L(Vc(qqnump))>2:2,1:0)))) ;sasha 20081010 sasha 20080908 общая часть кода неверно определялась, ввиду этого не работал Begin и End см. метод Virt
 Q
X54Fixm(Arg)
 ///если развернут экземпляр объекта Arg, а X54 фиксация
 i ..GetPar("X54",,$G(Vc(qqnump,Arg,0)))=4 i $G(Vc(qqnump,Arg,40))=1 s X54Fix=1
 Q
Movevs ;для встроенных объектов 20090709
 n qqcvs
 s qqc0=$G(Vc((qqnump),$G(qqcVcold,Vc(qqnump))))
 s qqo0=$G(Vc((qqnump),Vc(qqnump),0))
 s qqcvs=$G(Vc(qqnump,qqcVcold,6)) i qqcvs'="" s qqc0=$P(qqcvs,"~",$L(qqcvs,"~")) i qqc0=Vc(qqnump,qqcVcold) s qqc0=$E(qqc0,1,$L(qqc0)-2)
 Q
]]></Implementation>
</Method>

<Method name="NewResW">
<Description>
поиск нового окна для ресурса</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 n i,qqwin f i=0:1  s qqwin="ZRes"_i i '$D(qwin(qqwin)) s qwin(qqwin)="" q
 Q qqwin
]]></Implementation>
</Method>

<Method name="NextEdit">
<Description>
Редактирование текущей ячейки или переход к редактированию следующей. -qqwt - переход на заданное понятие
Arg1=1 - только позиционирование</Description>
<Internal/>
<FormalSpec>qqwt:%String,Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qqdatold S:$G(qqo)="" qqo=$G($$$CurObj) ;???
 I qqo'=$G($$$CurObj),$G($$$CurObj)'="" S qqo=$$$CurObj ;с qqo иногда все неблогополучно
 I '$D(qqwt) S qqdatold=$G(qqdat) G NextEB
 ;поиск следующего редактируемого понятия
 ;не очень хорошо
 N qi,qq,qqq,qqx,qqy,qqdat,qqz S (qqdatold,qqdat)=$G(W("Zpos",2,"d"))
 I $E(qqwt)="-" S qqwt=$E(qqwt,2,255) G NextE2
 S:$E(qqwt,1,3)="ZZR" qqwt=$E(qqwt,4,20)
 I qqwt="" S (qqyi,qqxi,qi)=0 G NextE0
 F qi=1:1 S qq=$G(Vo(qqnump,$$$CurObj,10,qi)) Q:qq=""!(qq=qqwt)
 I qq="" Q:$Q "" Q 
NextE0 F qi=qi+1:1 S qq=$G(Vo(qqnump,$$$CurObj,10,qi)) Q:qq=""  S qqq=$G(Vo(qqnump,$$$CurObj,11,qq)) I qqq'="" S qqz=$G(Vo(qqnump,$$$CurObj,0,$P(qqq," "),$P(qqq," ",2))) I $S($E(qqz,2,4)'="@ZX"||($E(qqz)=6):1,$E(qqz,2,255)="@ZXXmove":0,1:$E(qqz,2,255)="@ZXXadd") Q:..RedTest($$$CurObj,$P(qqq," "),$P(qqq," ",2))  ;@Dol 7.02.08 $G(Vo(qqnump,$$$CurObj,0,$P(qqq," "),$P(qqq," ",2),31))'<0  ;на псевдокнопки не ходить (31 было пропущено)
NextE1 D ..wcellsel("",$G(W("Zpos",2,"x")),"","")
 I qq'="" D  S (W("Zpos",2,"d"),qqdat)=$P(qqdat," ",1,2)_" "_$P(qqq," "),qqy="",W("Zpos",2,"x")=qqx G NextEB
 .I $P(qqq," ",2) D  I $L(qqw)>3 S qqx=$P(qqq," ",2)-1 Q
 ..S qqw="" I $E($G(Vo(qqnump,$P(qqdat," ",2),$P(qqq," ",1),$P(qqq," ",2)-1)))=0 S %3=..GetPar(730,,$P(qqdat," ",2),$P(qqq," ",1),$P(qqq," ",2)-1) I %3'="",%3'<0 S qqw="ZZR" D  ;D:"045"[$E(+%3) ..wP(".T2","OnCEClick",1),..wP(,"OnCEKeyDownT",0) ;I "6789"'[%3,%3'=10,%3'=11
 ...S %4=$E($P($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqq," ",1),$P(qqq," ",2)))," ")) I +%4'=2,+%4'=3,%4'=4 Q
 ...S qqw="ZZR"_$E(%4,2,20)
 .S qqw=qq,qqx=$P(qqq," ",2)
 ;следующий объект
 I ..EndOP() Q:$Q "" Q
 S qq=$O(Vc(qqnump,Vc(qqnump))) I qq="" S Vc(qqnump)=$P(qqdatold," ") D ..wpoe(qqdatold,,1) Q:$Q "" Q
 S Vc(qqnump)=qq,qqdat=qq_" "_Vc(qqnump,qq,0)_" "_0,qqo=Vc(qqnump,qq,0) D ..wpoe(qqdat,,1) S qi=0 G NextE0
NextEB
 D ..wM(qwin_".T2","M9",1,0,W("Zpos",2,"d"),1) ;@dol 16.02.03 ???было забыто
 D ..wcellsel("","","",$G(qqx)) ;$G(W("Zpos",2,"x"))) ;qqx)
 ;D ..OpenTimer(1500,"D qARM.wM("""_qwin_".T2"_""",""DoSftTreeItemClick"","""","_qqx_",+5,+1,0)") Q ""
 ;I $E($G(Vo(qqnump,$P(W("Zpos",2,"d")," ",2),0,$P(W("Zpos",2,"d")," ",3),$G(qqx,"???"))))=6 D ..wpoe(),..wP(qwin_".FCBUT"_$G(Vt(qqnump,9,"FCBUT",$P(W("Zpos",2,"d")," ",2),$P(W("Zpos",2,"d")," ",3),qqx)),"Focused",1) Q:$Q "" Q  ;@dol 17.01.05 фокус на кнопку
 I $G(Arg1) D ..wpoe() Q:$Q "" Q  ;@dol 14.03.03
 I ..EditTest($$$CurObj,qqw) Q:$Q "" Q  ;запрет коррекции
 S %1=..StartEditT2() I %1=-1 D ..wM(qwin,"EvClose") Q:$Q "" Q
 ;I ",6,7,10,11,"'[(","_(+W("Zcdrl"))_","),$S(+W("Zcdrl")=9:$E(qqw,1,3)'="@ZX",1:1) D:$E(qqw,1,3)="ZZR" ..wP(".T2","OnCEClick",0),..wP(,"OnCEKeyDownT",1) Q "" ;запрет коррекции;???,..EditTest($$$CurObj,qqw)
 I %1=112 S %1=..s112() G:+$G(W("Zcdrl"))=6 NextEE I %1=-1 D ..wM(qwin,"EvClose") Q:$Q "" Q  ;развертка (большой текст- выход) или выход из формы по развертке-действию (9)
 ;I qqred'="",$S(+W("Zcdrl")=3:1!'$P(W("Zcdrl")," ",2),+W("Zcdrl")'=2:1,1:'$P(W("Zcdrl")," ",2)) D ..wfoc(2,qqy,qqx,qqdat) ;очень сомнительное место ;,+W("Zcdrl")'=2:1 - развертка-меню
 I qqred'="",$S(+W("Zcdrl")=12:0,+W("Zcdrl")=3:$P(W("Zcdrl")," ",2)'=1,+W("Zcdrl")'=2:1,1:'$P(W("Zcdrl")," ",2)) D   ;D ..wfoc(2,"",qqx,qqdat)  ;очень сомнительное место ;,+W("Zcdrl")'=2:1 - развертка-меню
 .;I $P(qARM("Ver","qARMProj1.ocx"),".",2)>4 D ..Wait("D qARM.wfoc(2,"""","""_qqx_""","""_qqdat_""")") Q
 .D ..wfoc(2,"",qqx,qqdat)
NextEE Q:$Q "" Q
 ;поиск ячейки ближайщего понятия (для Enter)
NextE2
 I qqwt=""||(qqwt="ZZR")||1,"15"[(+$G(Vo(qqnump,-1,61))),'$G(W("Zpos",2,"x")),'$P(qqdat," ",3),$G(Vo(qqnump,qqo,4)),$S($P($G(Vt(qqnump,"Expand"))," ")'=$P(qqdat," "):1,'W("ZBtred"):1,qqwt=""!(qqwt="ZZR"):1,1:$G(Vo(qqnump,qqo,0,$P(qqdat," ",3),31))=-1) D ..Expand1($P(qqdat," ")) Q:$Q "" Q  ;свертка,развертка свернутых узлов в бланке   
 ///sas 20081216 В случае повторного вызова развертки без значений Vs(qqnump,"CurObj") был равен "", ввиду чего возникала ошибка по subs, теперь Vs(qqnump,"CurObj") равен C.
 I qqwt'="" S qq=qqwt S:$$$CurObj="" Vs(qqnump,"CurObj")="C" S qqq=$G(Vo(qqnump,$$$CurObj,11,qq)) S:qqq=""&(qq?1"Zs"1.N1"c"1.N) qqq=+$P(qq,"Zs",2)_" "_(+$P(qq,"c",2)) G:qqq'="" NextE1
 F qi=1:1 S qq=$G(Vo(qqnump,$$$CurObj,10,qi)) Q:qq=""  S qqq=Vo(qqnump,$$$CurObj,11,qq) I $P(qqdat," ",3)=$P(qqq," "),$G(W("Zpos",2,"x"))'>$P(qqq," ",2) Q
 G NextEE:qq="",NextE1
]]></Implementation>
</Method>

<Method name="NoSort">
<Description>
Сброс сортировки
Arg1=1 - без перевывода</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(W("Zosrt"))=""  Q:$Q "" Q
 I '$G(Arg1) D qARM.T2ColHButton(-1) Q:$Q "" Q
 S W("Zosrt")="" K Vs(qqnump,"SortV"),Vs(qqnump,"SortVn"),Vs(qqnump,"NoSortD")
 N but S but="ZBs" F  S but=$O(W(but)) Q:$E(but,1,3)'="ZBs"  I but?1"ZBs"1.N  K W(but)
 S $P($$$CondFind," ",1,6)="     " D ..wbut(2) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="ONEVENT">
<Description>
Вызывается перед каждым обработчиком события ($$$FEvent)</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 s runtimeact=0 ; на всякий случай
 q:$D(%grtn)  ; Gmanager - выход
 
 /* На будущее
 lock +^UpdLock:1 ; проверка lock'а "Происходит установка обновления" @dima 20101229
 i '$T d   ; lock стоит - свой не поставился
 .i $E($G(qARM("CntStr")),1,3)'="SSH" n dev s dev=$IO u $P w "!&UPD" u dev  ; показ сообщения. Под SSH сообщения не будет!
 .lock +^UpdLock lock -^UpdLock  ; ждём бесконечно снятия блокировки
 .i $E($G(qARM("CntStr")),1,3)'="SSH" n dev s dev=$IO u $P w "!&UPE" u dev  ; убираем сообщение
 e  lock -^UpdLock  ; удалось поставить - lock'а нет - снимаем свой
 */

 i $G(^RenewOREF($J)) d  ; пересоздание объектных ссылок по флагу ^RenewOREF($J)
 .d ..InstSysClass()
 .d ..UserClass()
 .k ^RenewOREF($J) ; удаление флага
 .d ..Log("! Пересозданы объектные ссылки после установки обновления")
 q
]]></Implementation>
</Method>

<Method name="Obj">
<Description>
Переход к ближайшему экземпляру заданного объекта
next=1 - следующий за текущим (curqqc задавать не надо). В варианте "+"_curobj устанавливается автоматически next=1</Description>
<Internal/>
<FormalSpec>curobj:%Library.String,curqqc:%Library.String,next:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $E(curobj)="+" S next=1,curobj=$E(curobj,2,255)
 I '$G(next),curobj=$$$CurObj Q:$Q 0 Q
 N q,i,qqci,objref
 I curobj=-1 S qqc="",qqo=curobj D ..wpoe("-1 -1 0") Q:$Q 1 Q
 S qqci=Vc(qqnump) D  S:qqci'="" qqc=Vc(qqnump,qqci)
 .I $G(curqqc)="",'$G(next) S objref=$$$ObjRef($$$CurObj) D  ;Q;@Misuno 28.11.06  надо продолжиь поиск
 ..I ","_objref_","'[(","_curobj_",") S qqci="" Q
 ..F  S qqci=$E(qqci,1,$L(qqci)-2) Q:Vc(qqnump,qqci,0)=curobj
 .i $G(curqqc)="",'$G(next),qqci'="" q       ;@Misuno 28.11.06 выход, если наден экземпляр
 .i $G(curqqc)="",qqci="",","_objref_","[(","_curobj_",") q        ;@Misuno 28.11.06 выход, если экземпляр не найден, но он в дереве, иначе поиск в других деревьях
 .F  S qqci=$O(Vc(qqnump,qqci))  Q:qqci=""  I Vc(qqnump,qqci,0)=curobj Q:$G(next)  I $S($G(curqqc)="":1,1:Vc(qqnump,qqci)=curqqc) Q
 I qqci="" Q:$Q 0 Q
 S qqo=curobj,Vc(qqnump)=qqci D ..wpoe(qqci_" "_curobj_" 0") Q:$Q 1 Q
 ;;;;;;;;;;; было так, исправил @Misuno 24.11.06
 .I $G(curqqc)="",'$G(next) S objref=$$$ObjRef($$$CurObj) D  Q
 ..I ","_objref_","'[(","_curobj_",") S qqci="" Q
 ..F  S qqci=$E(qqci,1,$L(qqci)-2) Q:Vc(qqnump,qqci,0)=curobj
 .F  S qqci=$O(Vc(qqnump,qqci))  Q:qqci=""  I Vc(qqnump,qqci,0)=curobj Q:$G(next)  I $S($G(curqqc)="":1,1:Vc(qqnump,qqci)=curqqc) Q
 .Q:qqci'=""  Q:$G(next)  F  S qqci=$O(Vc(qqnump,qqci))  Q:qqci=""  I Vc(qqnump,qqci,0)=curobj,$S($G(curqqc)="":1,1:Vc(qqnump,qqci)=curqqc) Q
 ;;;
 .I $G(curqqc)="",'$G(next) S objref=$$$ObjRef($$$CurObj) D  ;Q;@Misuno 28.11.06  надо продолжиь поиск
 ..I ","_objref_","'[(","_curobj_",") S qqci="" Q
 ..F  S qqci=$E(qqci,1,$L(qqci)-2) Q:Vc(qqnump,qqci,0)=curobj
 .i $G(curqqc)="",'$G(next),qqci'="" q       ;@Misuno 28.11.06 выход, если наден экземпляр
 .i $G(curqqc)="",qqci="",","_objref_","[(","_curobj_",") q        ;@Misuno 28.11.06 выход, если экземпляр не найден, но он в дереве, иначе поиск в других деревьях
 .F  S qqci=$O(Vc(qqnump,qqci))  Q:qqci=""  I Vc(qqnump,qqci,0)=curobj Q:$G(next)  I $S($G(curqqc)="":1,1:Vc(qqnump,qqci)=curqqc) Q
]]></Implementation>
</Method>

<Method name="ObjAuto">
<Description>
Отработка автовыбора</Description>
<Internal/>
<FormalSpec>Obj:%Library.String,Arg1:%Library.String,qqdat:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 I '$D(Arg1) S:'$D(qqdat) qqdat=$G(W("Zpos",2,"d")) G:$P(qqdat," ")="" ObjAuto1 S Vc(qqnump)=$P(qqdat," "),qqc=Vc(qqnump,$P(qqdat," ")),Arg1=$O(Vc(qqnump,$P(qqdat," "))) S:Arg1="" Arg1=$O(Vc(qqnump,$P(qqdat," ")),-1) S Arg1=$S(Arg1="":0,1:$E(Arg1,1,$L($P(qqdat," ")))'=$P(qqdat," ")) ;@Dol 10.09.07 Arg1="" - вроде так
 D:$G(W("Zosrt"))'=""  ;сброс сортировки
 .D ..T2ColHButtonClr() ;???qqw S %1="ZBs" F  S %1=$O(W(%1)) Q:$E(%1,1,3)'="ZBs"  I %1'=qqw,%1?1"ZBs"1.N K W(%1) ;удалим старые кнопки
 .K W("Zosrt") S $$$CondFind=""
 .K Vs(qqnump,7),Vt(qqnump,7)
 .D ..wipa(),..wbut(2),..wfot()
 ;Q:'$G(Vs(qqnump,99,"Auto")) ""
 N qqq
 I '$G(Arg1) D  D ..wcre(,1) S qqq=..GetPar("X1668") X:qqq'="" qqq Q:$Q "" Q  ;перемещение на верхний объект;@Dol 15.10.05 действие после фиксации
 .K Vs(qqnump,7),Vt(qqnump,7) D ..wpot(Obj,0) ;;сброс раскрытых папок
 .K:0 Vs(qqnump,3) D ..wrot(Obj) S qqq=$$$ObjRef(Obj),qqq=$P(qqq,",",$L(qqq,",")-1)
 .S $P($$$CondFind," ",10,11)="" I qqq="" S qqc="",$$$CurObj=-1 Q
 .S Vs(qqnump,7)=qqq,$$$CurObj=Obj N qqqq S qqqq="" F  S qqqq=$O(Vc(qqnump,qqqq)) Q:qqqq=""  Q:Vc(qqnump,qqqq,0)=qqq
 .I qqqq="" D  Q
 ..I $G(Vs(qqnump,1,qqq)) S qqc=$S($D(Vt(qqnump,111)):Vs(qqnump,"Virt",qqq),1:$E(qqc,1,$$$ObjLqqc(qqq))),$P($$$CondFind," ",10,11)=qqc_" "_qqc Q  ;@Dol 15.10.05 если объект зачеркнут
 ..S qqc="",$$$CurObj=-1 K Vs(qqnump,7) Q
 .;S qqc=Vc(qqnump,qqqq),$P($$$CondFind," ",10,11)=qqc_" "_qqc,qqc="" ;;@Dol 10.09.07 qqc="" - иначе - повтор на экране
 .S $P($$$CondFind," ",10,11)=Vc(qqnump,qqqq)_" "_Vc(qqnump,qqqq),qqo=Obj,qqc=$G(Vs(qqnump,"AutoTop",Obj)) ;@Dol 21.02.10
 S qqq=Vo(qqnump,Obj,"xObj")  ; потомки
 N qqqq S qqqq="" F  S qqqq=$O(Vc(qqnump,qqqq)) Q:qqqq=""  Q:Vc(qqnump,qqqq,0)=Obj  ;@Dol 21.02.10
 S Vs(qqnump,"AutoTop",Obj)=$S(qqqq="":"",1:Vc(qqnump,qqqq)) ;@Dol 21.02.10 для сохранения первого на уровне. Используется чуть выше при возврате на предыдущий уровень
 G:qqq="" ObjAuto1 ;нет потомков
 ;I $L(qqq," ")>1 D ..wrot(Obj) S $$$CurObj=$P(qqq," ") D ..wcre() Q "" ;нет единственного потомка 
 F  Q:qW.gOrder(1,$P(qqq," "),"",qqc)'=""||$G(Vo(qqnump,$P(qqq," "),87))  S qqq=$P(qqq," ",2,1000) Q:qqq=""  ;@Dol 10/10/05 ||$G(Vo(qqnump,$P(qqq," "),87)) - вывод отсутствующего
 G:qqq="" ObjAuto1 ;нет экземпляров
 I $D(Vt(qqnump,111)) D
 .N qc,ii F ii=$L(Vc(qqnump)):-2:2 S qc=$E(Vc(qqnump),1,ii),Vs(qqnump,"Virt",Vc(qqnump,qc,0))=Vc(qqnump,qc) ;заполнение Vs(qqnump,"Virt",qqo)=qqc для виртуальных объектов
 K Vs(qqnump,7),Vt(qqnump,7) S Vs(qqnump,7)=Obj
 D ..wrot(Obj) ;,..wfot(Obj) 
 S $P($$$CondFind," ",10,11)=qqc_" "_qqc,$$$CurObj=$P(qqq," ") K Vc(qqnump) D ..wcre(,1) S qqq=..GetPar("X1668") X:qqq'="" qqq Q:$Q "" Q
ObjAuto1 Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="ObjSort">
<Description>
Сменить текущий объект на объект сортировки.
Возвращает 0, если сортировка выключена или нельзя уйти с текущего объекта.</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $G(W("Zosrt"))="" Q:$Q 0 Q
 I $S('W("ZBtred"):0,1:..EndOP()) Q:$Q 0 Q
 I $G(Vs(qqnump,"NoSortD")) Q:$Q 0 Q  ;@Dol 31.08.06 запрет сужения выбора при сортировке
 I $$$CurObj=W("Zosrt") Q:$Q 1 Q
 S $$$CurObj=W("Zosrt"),qqc=$E(qqc,1,$$$ObjLqqc(W("Zosrt"))) Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="OnAutoDragging">
<Internal/>
<FormalSpec>Sender:%Library.String,Index:%Library.Integer,Button:%Library.Integer,Shift:%Library.Integer</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 Q:+$G(W("ZBt0")) 1 Q:$G(Vs(qqnump,99,"OLEDD")) 0 Q:'..GetPar("x570",,qqo) 0 Q 1
]]></Implementation>
</Method>

<Method name="OnAutoEndDragging">
<Internal/>
<FormalSpec>Sender:%String,qqy:%Integer,qqbut:%Integer,Shift:%Integer,Alloved:%Integer,qqdat:%String,qqx:%Integer</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 I '$G(W("ZBt0")) D:'$G(Vs(qqnump,99,"OLEDD"))  Q:$Q "" Q  ;заблокирован
 .;D ..Message(Sender_"-"_$G(W("Zpos"))_" "_qqy_" "_qqdat_" "_qqx)
 .;I $G(W("Zpos"))=2,qqdat'="" D  Q
 .I $P($G(W("Zpos",2,"d"))," ",2)'="",qqdat'="" D ..GetPar("x570",,$P(W("Zpos",2,"d")," ",2)) I Vo(qqnump,$P(W("Zpos",2,"d")," ",2),70) D  Q
 ..I 'W("ZBtred") D ..Message("Перетаскивание толко в режиме редактирования") Q
 ..S qqCopyFrom=$P(W("Zpos",2,"d")," ",2)_" "_Vc(qqnump,$P(W("Zpos",2,"d")," ",1))_" "_(..wcroCell($P(W("Zpos",2,"d")," ",2)))_$S($G(qqw)="":"",1:"("_(qW.GG($P(W("Zpos",2,"d")," ",2),qqw,Vc(qqnump,$P(W("Zpos",2,"d")," ",1))))_")"),Vc(qqnump)=$P(qqdat," "),qqo=$P(qqdat," ",2),W("Zpos",2,"y")=qqy,W("Zpos",2,"x")=qqx
 ..D ..wpoe(qqdat)
 ..D ..MenuWoc("DrDrop",$S(Vo(qqnump,$P(qqCopyFrom," "),70)=1:"-",1:"Копировать "_$E($P(qqCopyFrom," ",3,255),1,50))_"~"_$S(Vo(qqnump,$P(qqCopyFrom," "),70)=2:"-",1:"Перенести "_$E($P(qqCopyFrom," ",3,255),1,50)),,1,"I qARM.TMenuItemOnClick(qwin_"".M913_""_($E(qqchoice,9)+2)_""_3"")") Q
 ..;D ..TMenuItemOnClick(qwin_".M913_3_2") Q
 I qqx<0 D ..Message("Вне зоны") Q:$Q "" Q
 I '$G(W("Zpos",1,"x")) D  Q:$Q "" Q  ;D ..Message("Строки/Объекты пока переносить нельзя") Q ""
 .I '$P($G(W("Zpos",1,"d"))," ",2),$P($G(W("Zpos",1,"d"))," ")=$P(qqdat," ",1) D ..Message("Строку 0 переносить нельзя") Q
 .I '$P(qqdat," ",2) D ..Message("В строку 0 переносить нельзя") Q
 .I $P($G(W("Zpos",1,"d"))," ",2),$P($G(W("Zpos",1,"d"))," ")'=$P(qqdat," ",1),$G(Vt(qqnump,"Zmenu94"),1)=1 D ..Message("Перенос только строк одного объекта") Q
 .I $O(Vo(qqnump,$P(qqdat," ",1),0,$P(qqdat," ",2),0))'="" D ..Message("Строку можно переместить только в пустую строку") Q
 .D qSYS.Redview(15,$P(qqdat," ",1),$P(qqdat," ",2),qqx-1,qqy)
 I 'qqx Q:$Q "" Q
 I $P($G(W("Zpos",1,"d"))," ")'=$P(qqdat," ",1),$G(Vt(qqnump,"Zmenu94"),1)=1 D ..Message("Перенос только ячеек одного объекта") Q:$Q "" Q
 ;S XX=qqy_" "_qqx
 I $G(W("Zpos",1,"y"))=qqy,$G(W("Zpos",1,"x"))=qqx Q:$Q "" Q
 I $E($G(Vo(qqnump,$P(qqdat," ",1),0,$P(qqdat," ",2),qqx-1),0))'=0,$G(Vt(qqnump,"Zmenu94"))'=2 D ..Question("Заместить",1,"","D qSYS.Redview(12,"""_$P(qqdat," ",1)_""","_$P(qqdat," ",2)_","_(qqx-1)_","_qqy_")") Q:$Q "" Q
 D qSYS.Redview(12,$P(qqdat," ",1),$P(qqdat," ",2),qqx-1,qqy)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OnCEClick">
<Description>
НЕ ИСПОЛЬЗУЕТСЯ в событиях НО используется в обработке меню ;@Dol 02.10.09</Description>
<Internal/>
<FormalSpec>Sender:%String,CurrString:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 I $G(qqCEKey) S qqCEKey=0 Q "" ;K qqCEKey Q ""
 ;;обработка выбора (CEClick) для ZZR-развертки (по соседней ячейке с константой)
 I qqred="" Q:$Q "" Q 
 I $E(qqw,1,3)'="ZZR",Sender'=1 D  Q:$Q "" Q
 .;D ..wM(qwin_".T2","EndEdit",0)
 .D ..wP(qwin_".T2","OnCEClick",0),..wP(,"OnCEKeyDown",0) ;..wP(,"OnCEKeyDownT",1)
 .S W(qqw)=CurrString,$P(W("Zcdrl")," ",2)=0 D:0 ..wwww(qqw) D ..Wait("D qARM.wM(qwin_"".T2"",""EndEdit"",0) D qARM.wfoc(2,"_W("Zpos",2,"y")_","_W("Zpos",2,"x")_")") ;D ..Wait("D qARM.wfoc(2,"_W("Zpos",2,"y")_","_W("Zpos",2,"x")_")")
 I Sender'=1 D ..wM(qwin_".T2","EndEdit",0),..wP(,"OnCEClick",0)
 N qqZN,qqver,Raz S qqZN=$E(qqw,4,20),Z=CurrString N qqw S qqw=qqZN ;@Dol 01.03.08 qqw-qqZN
 ;@Dol 28.10.09 синтаксически правильный непробельный разделитель
 S Raz=$P(W("Zldrl")," ",16) S:Raz="" Raz=" " S:$TR(Raz,",")?1.N @("Raz=$C("_Raz_")") S:Raz'=" " Raz=$S($L(Raz)=1:" "_Raz_" ",1:Raz) ;@Dol 26.10.09
 I qqZN'="" D  S Z=W(qqZN) ;@dol 01.03.08 Правило проверки для всего значения
 .I $G(Z)="" S W(qqZN)="" Q
 .I $G(W(qqZN))="" S W(qqZN)=$G(Z) Q
 .I Raz_W(qqZN)_Raz'[(Raz_$G(Z)_Raz) S W(qqZN)=W(qqZN)_Raz_$G(Z) Q  ;;@Dol 02.10.08 Символ-разделитель
 .I W(qqZN)=Z S W(qqZN)="" Q
 .I $P(W(qqZN),Raz)=Z S W(qqZN)=$P(W(qqZN),Raz,2,255) Q
 .I $P(W(qqZN),Raz,$L(W(qqZN),Raz))=Z S W(qqZN)=$P(W(qqZN),Raz,1,$L(W(qqZN),Raz)-1) Q
 .S W(qqZN)=$ZSTRIP($P(W(qqZN),Raz_Z_Raz)_Raz_$P(W(qqZN),Raz_Z_Raz,2,255),"<>W") ;@Dol 02.10.08 Символ-разделитель ;@Dol 26.10.09
 ;S Raz=$P(W("Zldrl")," ",16) S Raz=$S(Raz="":" ",$L(Raz)=1:" "_Raz_" ",$L(Raz)>4:" ",1:Raz) ;@Dol 02.10.08 Символ-разделитель
 ;I qqZN'="" D  S Z=W(qqZN) ;@dol 01.03.08 Правило проверки для всего значения
 ;.I $G(Z)="" S W(qqZN)="" Q
 ;.I $G(W(qqZN))="" S W(qqZN)=$G(Z) Q
 ;.I Raz_W(qqZN)_Raz'[(Raz_$G(Z)_Raz) S W(qqZN)=W(qqZN)_Raz_$G(Z) Q  ;;@Dol 02.10.08 Символ-разделитель
 ;.S W(qqZN)=$ZSTRIP($P(Raz_W(qqZN)_Raz,Raz_Z_Raz)_Raz_$P(Raz_W(qqZN)_Raz,Raz_Z_Raz,2,255),"<>W") ;@Dol 02.10.08 Символ-разделитель
 S qqver=..GetPar(74,,$P(W("Zpos",2,"d")," ",2),$P(W("Zpos",2,"d")," ",3),W("Zpos",2,"x"))
 D:'$D(Vo(qqnump,-1,854)) ..GetPar("X1854") S:Vo(qqnump,-1,854)'="" @("qqver="_Vo(qqnump,-1,854)) ;@Dol 28.06.06 общее правило проверки
 I qqver'="" D
 .I $E(qqver)="Z" D  D:qqver'="" ..Message("Несоответствие условию "_qqver) Q
 ..I ..Value(qqver)'=0 S qqver="" Q
 .S qqver=..Value(qqver) I qqver'="",$E(qqver)'?1N D ..Message(qqver)
 I $E(qqZN,1,4)="ZTMP",$G(qqc)'="",'$G($$$Tree) D   ;временные понятия, хранимые в перечне релевантных
 .N qqw,qqdat,qqx,Z S qqw=qqZN,qqdat=W("Zpos",2,"d"),qqx=W("Zpos",2,"x"),Z=W(qqw) N qqZN
 .S Zold=Z I $G(W(qqw))'="",$G(Vo(qqnump,$P(qqdat," ",2),0,+$P(qqdat," ",3),qqx,84))'="" S qqZN=..GetPar("x710",,$P(qqdat," ",2),$P(qqdat," ",3),qqx) I qqZN'="" S Zold=Z,Z=qW.GtoExt(qqZN,Z) ;@Dol 20.12.05 преобразование для динамических образцов (X784'="");@Dol 04.08.06 динамическая проверка x710
 .I Z="" K ^Q($$$Relind_qview,$P(qqdat," ",2),qqc,qqw) I 1
 .E  D:'($D(^Q($$$Relind_qview,$P(qqdat," ",2),qqc))#10) ..RecRel("+",$P(qqdat," ",1),1) S ^Q($$$Relind_qview,$P(qqdat," ",2),qqc,qqw)=Z  ;запись в перечень
 .I ..GetPar("X182")'="" N qqo,Arg1 S qqo=$P(qqdat," ",2),Arg1="+" D ..Value(Vo(qqnump,-1,82),"X") ;@dol 9.03.03 действие по изменению релевантных
 ;
 D ..wwww(qqZN) I Sender=1 S:$E(qqZN)'="Z"&&(" "_qqwchg_" "'[(" "_qqZN_" ")) qqwchg=qqwchg_" "_qqZN S qqred="" Q:$Q "" Q  ;вызов из меню
 ;D ..wM(qwin_".T2","EndEdit",0) ;???
 D ..Wait("D qARM.wfoc(2,"_W("Zpos",2,"y")_","_W("Zpos",2,"x")_"),qARM.wP(,""OnCEClick"",1)") ;Wait(
 ;D ..wfoc(2,W("Zpos",2,"y"),W("Zpos",2,"x")),..wP(qwin_".T2","OnCEClick",1)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OnCEKeyDown">
<Description>
НЕ ИСПОЛЬЗУЕТСЯ</Description>
<Internal/>
<FormalSpec><![CDATA[Sender:%String,&Key:%Integer,Shift:%Integer,qqy:%Integer,qqx:%Integer,qqstr:%String]]></FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 Q:$Q "" Q
 
 $$$FEvent
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 S qc=Key ;S ^AA($I(^AA))="CEKey "_qc_" (Shift="_$G(Shift)_") qqred="_$G(qqred)_" qqw="_$G(qqw)
 I $D(qqCEKey) D:qc=13 ..OnCEClick(Sender,qqstr) Q:qc=13 "" S qqCEKey=1 ;пока надо??? I $E(qqred,1,3)="ZZR"
 N qqtr S qqtr=$E($P(Sender,".",2),2) ;номер дерева
 S W("Zpos",qqtr,"y")=qqy,W("Zpos",qqtr,"x")=qqx ;"d" ????
 ;S ^Key($I(^Key))=Key_" "_$G(Shift)
 I qc<32 D:$C(9,13,15,27)[$C(qc)   Q "" ;S:qc=9 qc=$S(Shift=1:15,1:9) D  Q "" ;обратного передвижения по полям нет
 .S Key=0 I qc=13,..GetPar("X179")=1 S qc=9
 .N qkk S qkk=..EndEdit(qqstr,qc)  Q:qkk||$P(qkk," ",2)  Q:qqtr'=2||(qc'=9)  Q:($P($G(Vo(qqnump,-1,856))," ",1)=1)  D ..NextEdit(qqw) Q  ;@Dol 1.09.05 qkk (см. EndEdit EndEdN );;поиск следующего редактируемого понятия
 .;;;(KK($I(KK)),qkk)=..EndEdit(qqstr,qc)_" "_qqw_" "_qqstr_" "_qc
 I qc>111,qc<122 D  Q:$Q "" Q
 .;Обработка F -клавиш в режиме редактирования
 .S qc=qc-80,Key=0 ;F1-F10, qc=32-41
 .;I qc'=40 D ..Message(qc) Q
 .I qc=32 D ..OpenCHelp("W"_qqred) Q  ;F1 - пояснения по понятию
 .I qc=40 D ..EndEdit($G(qqstr),qc,1),..RecRaz() Q  ;F9 -вызов развертки
 D
 .I $G(W("Zpdrl")),$C(33,34,35,36,37,38,39,40,45,46)[$C(qc) S qc=$A($TR($C(qc),$C(33,34,35,36,37,38,39,40,45,46),$C(73,81,79,71,0,0,0,0,82,67))) Q
 .I $G(W("Zpdrl")),W(qqred)'=qqstr S:$E(qqred,1,3)'="ZZR" W(qqred)=qqstr S qc=65 Q
 .S qc=""
 I 'qc Q:$Q "" Q
 I qc=67!(qc=82) Q:$Q "" Q
 N Zndrl S Zndrl=$S(+$P(W("Zdrl")," ",9):+$P(W("Zdrl")," ",9),1:100),Key=0,@("%1=$$z0"_qc) I '%1 D ..wfoc(qqtr,qqy,qqx)
 Q:$Q "" Q
z081()  ; PgDn
 Q:$L(W("Zldrl"),"~")<Zndrl 1
 S W(qqw)=$P(W("Zldrl"),"~",$L(W("Zldrl"),"~")) D qW.qWoc(1,$P(W("Zdrl")," ")_" * "_$P(W("Zdrl")," ",3,6),Zndrl,Zndrl,$P(W("Zdrl")," ",7),"Zldrl")
 Q ""
z073()  ; PgUp
 S W(qqw)=$P(W("Zldrl"),"~",1)  S:W(qqw)="" W(qqw)=$P(W("Zldrl"),"~") D qW.qWoc(-1,$P(W("Zdrl")," ")_" * "_$P(W("Zdrl")," ",3,6),Zndrl,Zndrl,$P(W("Zdrl")," ",7),"Zldrl")
 Q ""
z079()  ; End
 S W(qqw)="" D qW.qWoc(-1,$P(W("Zdrl")," ",1,6),Zndrl,Zndrl,$P($G(W("Zdrl"))," ",7),"Zldrl")
 Q ""
z071()  ; Home
 S W(qqw)="" D qW.qWoc(1,$P(W("Zdrl")," ",1,6),Zndrl,Zndrl,$P(W("Zdrl")," ",7),"Zldrl")
 Q ""
 ;z082()    ;Ins ????
 ;Q 1
 ;z067()    ;Del ????
 ;Q 1
z065()  ;посимвольная детализация развертки по большому словарю для дерева
 Q:W("Zldrl")="" 1
 D qW.qWoc(1,$P(W("Zdrl")_"       "," ")_" * "_$P(W("Zdrl")_"      "," ",3,4)_" "_W(qqw)_" "_$P(W("Zdrl")," ",6),Zndrl,Zndrl,$P(W("Zdrl")," ",7),"Zldrl")
 I W("Zldrl")="" D ..Message(W(qqw)_"* Нет значений.") S W("Zpdrl")=0 Q ""
 Q ""
]]></Implementation>
</Method>

<Method name="OnColResize">
<Description>
tdv 7.6.2006 - динамическое получение размеров колонок
Параметры:
Sender - qwin_"."_T2
data - список размеров колонок в px через пробел
order - порядок колонок. Список чисел через пробел. Число означает позицию, в которой
находится данная колонка</Description>
<Internal/>
<FormalSpec>Sender:%Library.String,data:%Library.String,order:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 N qqnumpSender S qqnumpSender=$E($P(Sender,"."),2,255)
 N i F i=1:1:$L(data," ") S Vs(qqnumpSender,"ColWidth",i-1)=$P(data," ",i)
 Q ""
]]></Implementation>
</Method>

<Method name="OnCommonEditExit">
<Description>
завершение редактирования в новом дереве
Tree - дерево
EditType - тип редактирования
Value - значение
Key - код клавиши завершения редактирования или 0 - при потере фокуса
Shift - состояние Shift-клавиш
ErrorFlag - не используется

Старт редактирования - см. метод wfoc ( wfocnew )</Description>
<Internal/>
<FormalSpec>Tree:%Library.String,EditType:%Library.Integer,Value:%Library.String,Key:%Library.Integer,Shift:%Library.String,ErrorFlag:%Library.Integer</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 N String,zzz,X1858
 I $G(qqnump)'="",$G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 ;K W("Zederr") 
 I Key=27 s X1858=..GetPar("X1858") i +X1858=0 S qqred="" Q ""   ;20081010 @sasha учитывать выход по ESC
 I Key=121 S:qqw'="" W(qqw)=qW.GG($$$CurObj,qqw,qqc) S qqred="" D:qqw'="" ..wwww(qqw) Q "" ;F10
 I Key=46 S Value="" G OnCommonEditExitE  ;Del - удаление
 G:EditType<5 OnCommonEditExitE
 ;I EditType=10 S W("ZredB")=2 G OnCommonEditExitE ;@Dol 27.01.09 для типа Текст (RTF) см. ..wfoc
 I EditType=5 D  G OnCommonEditExitE ;дата
 .S Value=$ZD($P(Value,".")+21548,8) I Key=13,Shift["Ctrl" S Value=$E(Value,1,4)_"0000"  ;Ctrl/Enter (только год)
 ;I EditType=8 D  G OnCommonEditExitE ;время
 ;.S Value=$P(Value,":")*3600+($P(Value,":",2)*60) I Key=13,Shift["Ctrl" S Value=Value\3600*3600 Q  ;Ctrl/Enter только час
 ;I EditType=7 D  G OnCommonEditExitE
 ;.S Value=$E(10000+$P(Value,".",2),2,5)_$E(100+$P(Value,".",1),2,3)
 I EditType=9 D  G OnCommonEditExitE
 .S Value=$ZSTRIP(Value,"<>W")
 .N qqti S qqti=$G(Vo(qqnump,$$$CurObj,11,qqw)) Q:qqti=""  S qqti=$G(Vo(qqnump,$$$CurObj,0,$P(qqti," "),$P(qqti," ",2),10))
 .I qqti=6 D  Q  ;@Dol 17.07.07 ГГГГММ через маску
 ..S Value=$P(Value,".",2)_$P(Value,".",1) I Key=13,Shift["Ctrl" S Value=$E(Value,1,4)_"00"  ;Ctrl/Enter только год
 .I qqti="Ht" D  Q  ;@Dol 17.07.07 время через маску
 ..S Value=$P(Value,":")*3600+($P(Value,":",2)*60) I Key=13,Shift["Ctrl" S Value=Value\3600*3600  ;Ctrl/Enter только час
 .I $E(qqti)=8 S Value=qW.GtoExt("I",$TR(Value,"-",">")) Q  ;@Dol 27.10.07 интервал;$Tr - временно
 .Q:$E(qqti)'=7  ;ГГГГММДДЧЧММ (тип 7 или 70)
 .S Value=$E($TR(Value,". :")_"00000000000000",1,14),Value=$E(Value,5,8)_$E(Value,3,4)_$E(Value,1,2)_$E(Value,9,14)
 .I Key=13,Shift["Ctrl" S Value=$E(Value,1,8)_"000000" Q  ;Ctrl/Enter (только дата)
OnCommonEditExitE ;D ..Message(Key)
 ;;sas 20081118
 ;;sas 20081121
 S zzz=..EndEdit(Value,$S(Key=120:120,Key=27:27,Key=13:13,Key=9:9,1:""),(Key>111)&&(Key'=120),1) I zzz Q $E(zzz,2,30000) ;Q:$Q "" Q
 ;Обработка F -клавиш в режиме редактирования
 I Key=112 D ..OpenCHelp("W"_qqw) Q:$Q "" Q  ;F1 - пояснения по понятию
 I Key=120 S:EditType=3&&$P(W("Zdrl")," ",18) $P(W("Zdrl")," ",18)=0 D qARM.RecRaz() Q "" ;D qARM.Wait("D qARM.RecRaz()") Q:$Q "" Q  ;F9 -вызов развертки
 I Key>120,Key<124 D ..OnKeyDown(qwin,Key,Shift) ;@Dol 14.01.08 F10,11,12
 Q ""
]]></Implementation>
</Method>

<Method name="OnControlClick">
<Description>
qqxx - для обработки OnHeaderClik</Description>
<Internal/>
<FormalSpec>Sender:%Library.String,button:%Library.String,qqxx:%Library.String,qqy:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 ;D ..Message(Sender_"-"_$G(button)_"-"_$G(qqxx)_"-"_$G(qqy))
 S qqnumpT=$G(qqnump) ;dima 31.07.07
 I $P(Sender,".")'=("Q"_$G(qqnump)),..ChgWin() Q ""
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 D qARM.wM(qwin_".T2","SetFocus")
 I qqred'="" Q:$G(W("Zederr")) "" S qqred="" ;@dol 25.07.04 отлов ESC или невыбора меню
 ;I Sender=(qwin_".FBUT") X $G(qxecuteFB) D ..wP(qwin_".FBUT","Visible",0) Q:$Q "" Q
 I Sender=(qwin_".FBUT") D  Q:$Q "" Q
 .N qqz S qqz=qwin(qwin,"FBUT") D OnCntrl
 I $P(Sender,"FCBUT",2)'="",qwin'="" D  Q:$Q "" Q
 .N qqz S qqz=$P(Sender,"FCBUT",2),qqz=qwin(qwin,"FCBUT",qqz) D OnCntrl
 D:0 qARM.Message(Sender) Q:$Q "" Q
OnCntrl I $G(W("Zpos",2,"d"))'=$P(qqz," ",1,3) Q:..EndOP()  S Vc(qqnump)=$P(qqz," ") ;@dol&@Oleg 19.07.04 переустановка qqci
 N qqdat,qqx,qqbut S W("Zpos",2,"y")=qqy S qqbut=button+1,(qqdat,W("Zpos",2,"d"))=$P(qqz," ",1,3),(qqx,W("Zpos",2,"x"))=$S($G(qqxx)'="":qqxx,1:$P(qqz," ",4)),qqo=$P(qqdat," ",2) D qARM.wpoe(qqdat) ;@Dol 6.10.05 qqo не было
 S qqw=$P($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx))," "),qqw=$S('$E(qqw):"ZZR",$E(qqw)=5:"Zs"_$P(qqdat," ",3)_"c"_qqx,"67"[$E(qqw):$S($E(qqw,2,4)="@ZX":$E(qqw,2,31),1:"ZZR"),1:$E($P(qqw," "),2,31))
 I button=1,$D(Vo(qqnump,-1,69))||$G(qqXB2help) N qqend D qARM.Value($S($G(Vo(qqnump,-1,69))="":"I 'W(""Zadm"")  D qARM.OpenCHelp(2) S qqend=1",1:Vo(qqnump,-1,69)),"X") G:$G(qqend)=0 OnCntrle Q:$G(qqend)  ;общее действие по правой кнопке
 I button=1,$S(Vo(qqnump)'="XXXX":1,1:qqx) D qARM.MenuEx(1) Q 
OnCntrle I ..GetPar("X731",,$P(qqdat," ",2),$P(qqdat," ",3),qqx)="",..GetPar("x730",,$P(qqdat," ",2),$P(qqdat," ",3),qqx)=""  K qqwold Q  ;@dol 20.04.04
 D qARM.NextEdit() K qqwold Q
 ;D ..OnItemClickT2(qwin,0,$P(qqz," ",4),10,button+1,0,$P(qqz," ",1,3))
]]></Implementation>
</Method>

<Method name="OnDocumentClose">
<Description>
Закрытие MSWORD запущенного по D qARM.wC("TOpenDocument",ObjectName,FileName)</Description>
<Internal/>
<FormalSpec>Sender:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;$$$FEvent @dima убрал 20101220
 D:$D(W("ZredB")) ..EditDoc()
 Q ""
]]></Implementation>
</Method>

<Method name="OnDocumentSave">
<Internal/>
<FormalSpec>Sender:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;$$$FEvent @dima убрал 20101220
 //sas 20090727
 I '$P($G(W("ZredB"))," ",3) K W("ZredB") Q:$Q "" Q
 S $P(W("ZredB")," ")=2 ;признак будет показывать, что текст уже в массиве
 N mas,masi,mass,masj,mask 
 /*
 S masj=-1,mass="",mas=$P(W("ZredB")," ",4) K @mas F masi=0:1 Q:'$D(^mtempWP($J,masi))  S mass=mass_^(masi) F  S mask=$F(mass,$C(13,10)) Q:'mask  S @mas@($I(masj))=$E(mass,1,mask-3),mass=$E(mass,mask,32000)
 I mass'="" S @mas@($I(masj))=mass
 */
 //sas 20090623
 I Sender'["QVWordpad" D
 .S masj=-1,mass="",mas=$P(W("ZredB")," ",4) K @mas F masi=0:1 Q:'$D(^mtempWP($J,masi))  S mass=mass_^(masi) F  S mask=$F(mass,$C(13,10)) Q:'mask  S @mas@($I(masj))=$E(mass,1,mask-3) s mass=$E(mass,mask,32000)
 .I mass'="" S @mas@($I(masj))=mass
 //сохранение будет работать напрямую из WP @sas 20090911
 //e  s mas=$P(W("ZredB")," ",4)  k @mas m @mas=^mtempWP($J) k ^mtempWP($J)
 
 I ..EndEdit(,,1) ;S W("ZredB")="1 "_$P(W("ZredB")," ",2,4) Q:$Q "" Q  ;рестарт редактирования
 ;k qwin($P(W("ZredB")," ",2))
 K W("ZredB") S qqred="" D ..wwww(qqw)
 ///D qARM.Message(qqw)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OnDragStarting">
<Description>
               пока не нужен</Description>
<Internal/>
<FormalSpec>Sender:%String,Arg1:%Integer,Arg2:%Integer</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 S AA=Sender_"-"_Arg1_"-"_Arg2 ;S W("Zpos")=Sender
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OnItemClickT1">
<Internal/>
<FormalSpec>Sender:%String,qqy:%Integer,qqx:%Integer,qqarea:%Integer,qqbut:%Integer,Shift:%Integer,qqdat:%String,ItemData:%Integer,qqxR:%Library.Integer</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 Q:Shift=4 "" ;игнорирование Alt
 I $P(Sender,".")'=("Q"_$G(qqnump))!$G(W("ZredB")),..ChgWin() Q:$Q "" Q  ;Обработка смены окна (смена локальной среды)
 K Vt(qqnump,"Nodbl")
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 S qqnumpT=qqnump ;@Dol 26.06.05
 I $G(W("Zederr")) Q "" ;@dol 18.02.04 устанавливается в EndEdit при срабатывании правила проверки
 I qqarea=11 Q:$Q "" Q
 I 'qqy,'W("ZBt0"),qqbut'=2,qqarea'=7,qqx'=1,qqx'=2 D  Q:qqy="" "" S qqdat=$P(Vo(qqnump,-1,0,qqy)," "),qqy=1 D ..wP(qwin_".T1","ListIndex",1),..wP(,"Selected",1,1)
 .;поиск первого объекта
 .S qqy=0 F  S qqy=$O(Vo(qqnump,-1,0,qqy)) Q:qqy=""  I $G(Vo(qqnump,-1,0,qqy))'="",'$G(Vs(qqnump,1,$G(Vo(qqnump,-1,0,qqy)))) Q
 ;
 I qqred'="" Q:$G(W("Zederr")) "" S qqred="" ;отлов ESC 
 ;
 I qqarea=6 S Vt(qqnump,"Nodbl")=1 D ..T1ColHButton(qqx) Q "" ;заголовки рядов
 N qqyold,qqxold,qqdatold,qqxold1 S qqdatold=$G(W("Zpos",1,"d")),qqyold=$G(W("Zpos",1,"y")),qqxold1=$G(W("Zpos",1,"x")),qqxold=$S($G(W("Zpos",1,"x"))="":"",1:''$G(W("Zpos",1,"x")))
 S W("Zpos",1,"d")=qqdat,W("Zpos",1,"y")=qqy,W("Zpos",1,"x")=qqx,W("Zpos")=1
 I W("ZBt0") D  Q "" ;редактирование отображения
 .I '$G(qqdbl),qqbut=1,qqxold'=(''qqx) D  ;вывести все ячейки/только занятые
 ..D ..wP(qwin_".T1","BulkUpdate",1)
 ..N icol F icol=1:1:Vo(qqnump,-1,9)+1 D ..wP(,"ColumnStyle",'qqx*3072+12,icol)
 ..D ..wP(,"BulkUpdate",0)
 .I qqbut=2 S Vt(qqnump,"Nodbl")=1 D ..wM(qwin_".PO","Popup"),..wM("-qARM","SetFocus",qwin) Q
 .I $G(qqdbl),qqy=qqyold K qqdbl D qSYS.CallDef(Vo(qqnump),$S('qqy&('qqx):"",1:$P(qqdat," ")),$S('$P(qqdat," ",2)&('qqx):"",1:$P(qqdat," ",2)),$S('qqx:"",1:qqx-1))
 ;I $S($P(qqdat," ")="":qqbut=1,1:$G(Vs(qqnump,7,$P(qqdat," ")))) D ..wM(qwin_".T1","M9",1,0,$$$CurObj,1),..wP(,"ListIndex","") Q "" ;объект неактивен
 Q:qqarea=2 "" ;линии соединения ???
 I qqarea=7 D  Q "" ;@Dol 19.11.05 RowColHeader сброс/установка зачеркивания всех объектов
 .I qqbut=2 D ..MenuGr(0) Q
 .N qqz I $D(Vs(qqnump,1)) M qqz=Vs(qqnump,1,-1) K Vs(qqnump,1) M Vs(qqnump,1,-1)=qqz I 1
 .E  S qqz=-1 F  S qqz=$O(Vo(qqnump,qqz)) Q:qqz=""  S Vs(qqnump,1,qqz)=1
 .;;;;S qqz="" F  S qqz=$O(Vo(qqnump,$P(W("Zpos",1,"d")," "),11,qqz)) Q:qqz=""  S Vs(qqnump,1,$P(W("Zpos",1,"d")," "),qqz)=1
 .K W("ZBtredo") D ..wipa(),..wcro(),..wcre()
 I qqarea=8 D  Q "" ;@Dol 19.11.05 RowHeader зачеркнуть/расчеркнуть
 .I qqbut=2 D ..MenuGr(0) Q
 .D ..TMenuItemOnClick("Q"_qqnump_".M803")
 
 //sasha 20080723
 I qqarea=4 Q:W("ZBt0") "" Q:$L(qqdat," ")>1 "" D ..wpot(qqdat) Q "" ;папки понятий
 ;
 I qqx,qqbut=1,$S(qqdatold'=$G(W("Zpos",1,"d")):1,1:qqxold1'=$G(W("Zpos",1,"x"))) Q "" ;@Dol 23.03.08 чтобы по двойному щелчку
 I 'W("ZBt0"),qqbut=2,qqarea'=3,qqarea'=4,$S(qqx:qqy,1:1) S Vt(qqnump,"Nodbl")=1 D ..wM("-qARM","SetFocus",qwin) D  Q "" ;,qqy, ???
 .N qqw,qqo S qqo=$P(qqdat," "),qqw=$P(qqdat," ",2)
 .;I 'qqx D ..MenuStObj() Q
 .D ..MenuGr(qqx)
 
 //I qqarea=4 Q:W("ZBt0") "" Q:$L(qqdat," ")>1 "" D ..wpot(qqdat) Q "" ;папки понятий
 ;
 I '$G(W("ZBt0")),W("ZBtred"),..EndOP() S Vt(qqnump,"Nodbl")=1 Q ""
 N qqo S qqo=$P(qqdat," ") ;код объекта
 I qqarea=3 S Vt(qqnump,"Nodbl")=1 D  Q "" ;+\-
 .I W("ZBt0")||$P(Vo(qqnump,-1,84),",",2) D ..wM(qwin_".T1","Expand",qqy,0,1) Q  ;игнорирование свертки
 .D ..wrot(qqo) S %12=$$$ObjRef(qqo),%11=$$$ObjRef($$$CurObj) S:%11'=$P(%12,",",1,$L(%11,",")) $$$CurObj=qqo D ..wcre() Q
 I 'qqy,'$G(W("ZBt0")),qqx'=1,qqx'=2 Q ""
 ;;;;I qqy,
 //I '$G(W("ZBt0")),qqx S Vt(qqnump,"Nodbl")=1 D ..StartEditT1() Q ""
 I '$G(W("ZBt0")),qqx S:qqx>2 Vt(qqnump,"Nodbl")=1 D ..StartEditT1() Q "" //sasha 20080723
 ;
 Q:W("ZBt0") "????"
 ;S qqo=$P(qqdat," ") ;желаемый объект
 I $$$CurObj=qqo Q "" ;объект не изменился
 I $G($$$Tree),$G($$$GloRef)="" S $$$GloRef="^Q(1)"
 I '$G(Vo(qqnump,qqo,2)),$S('$G($$$Tree):$D(^Q(qql,qqo))<10,'W("ZBtred"):0,$G($$$CurObj)="":$D(@$$$GloRef@(qqo))<10,1:$D(@$$$GloRef@($$$CurObj,$$$ID,qqo))<10) D:'W("ZBtred") ..Message("Нет экземпляров данного объекта"),..wM(qwin_".T1","M9",1,0,$$$CurObj,1)  Q:'W("ZBtred") "" I $L($$$ObjRef(qqo),",")=1 D ..RecNew(qqo,""),..wM(qwin_".T1","M9",1,0,$$$CurObj,1) Q ""
 S qqob=$$$ObjRef(qqo) ;объектная ссылка для желаемого объекта
 S qqobold=$G($$$ObjRef($$$CurObj)) ;текущая объектная ссылка
OnItemClickT1o ;поиск ближайщего подходящего объекта
 I $P(qqob,",")'=$P(qqobold,",") S qqc="" S:$$$Tree $$$GloRef=$S($G($$$GloRef)'="":$NA(@$$$GloRef,1),1:"^Q(1)") S $$$CurObj=qqo D ..wcre() Q "" ;нет общей вершины
 ;
 N qqobo,qqoboo ;поиск общей объекной ссылки qqobo и объекта общей вершины qqoboo
 F qi=1:1:$L(qqobold,",")+1 Q:$P(qqob,",",qi)'=$P(qqobold,",",qi)
 S qqobo=$P(qqob,",",1,qi-1),qqoboo=$P(qqobo,",",$L(qqobo,",")) ;общая вершина
 ;если текущий объект не общая вершина, найдем qqci для общей вершины (она выше текущего положения)
 S qqobci=$G(Vc(qqnump)) D:0 ..Message(qqobci_"-"_qqoboo_"-"_$$$CurObj) 
 I $$$CurObj'=qqoboo,qqobci'="" F  Q:$G(Vc(qqnump,qqobci,0))=qqoboo  S qqobci=$O(Vc(qqnump,qqobci),-1) Q:qqobci=""  ;qqci для общей вершины
 I qqobci="" S $$$CurObj=qqo,qqc="" D ..wcre() Q "" ;вершина зачеркнута ???qqc=""
 ;если желаемый не общая вершина найдем qqci для него(явно ниже общей вершины)
 ;пройдемся по остатку объектной ссылки
 I qqoboo'=qqo S qqobcio=qqobci,qqo1=$L(qqobo,",")+1,qqobci1="" F  S qqobci=$O(Vc(qqnump,qqobci)) Q:qqobci=""  Q:Vc(qqnump,qqobci,0)=qqo  D  Q:qqobci=""
 .I $E(qqobci,1,$L(qqobcio))'=qqobcio S qqobci="" Q  ;поиск только в рамках поддерева общей вершины
 .I Vc(qqnump,qqobci,0)=$P(qqob,",",qqo1) S qqo1=qqo1+1,qqobci1=qqobci 
 ;если нашли в текущем дереве , то спозиционируемся, неактивен - перевыведем
 I qqobci'="" D  Q ""
 .I $G(Vc(qqnump,qqobci,1),1) S Vc(qqnump)=qqobci,qqc=Vc(qqnump,qqobci) D ..wpoe(qqobci_" "_qqo_" 0",1) Q
 .I $G($$$Tree) D qW.qRef(qqobci) S $$$CurObj=qqo,qqc=Vc(qqnump,qqobci) D ..wcre() Q
 .S $$$CurObj=qqo,qqc=Vc(qqnump,qqobci) D ..wcre() Q
 ;не нашли в дереве. А вообще есть?
 S qqobci=$S(qqobci1'="":qqobci1,1:qqobcio)
 S qqo1="" D  I qqo1'="" S $$$CurObj=qqo D ..wcre() Q "" ;есть 
 .I '$G($$$Tree) S qqo1=qW.gOrder(1,qqo,"",$G(Vc(qqnump,qqobci))) Q:qqo1=""  S qqc=qqo1 Q
 .;с деревом сложности
 D  I qqo1="" D:0 ..wP(qwin_".T1","Selected",0,qqy) D ..wM(qwin_".T1","M9",1,0,$$$CurObj,1) Q "" ;D ..wpoe(Vc(qqnump)_" "_$$$CurObj_" 0") Q "" ;попытка ввода, если неудачно, позиционируемся на старое место
 .I W("ZBtred") Q:$P($G(Vo(qqnump,-1,84)),",",4)  S qqo1=..RecNew(qqo,qqobci) Q
 .S qqo1=qW.gOrder(1,qqo,qqc,$P($$$CondFind," ",10)) ;D ..Message(qqc_" "_qqo1_" >"_$$$CondFind)
 .S qqo1=$S(qqo1'="":qqo1,1:qW.gOrder(-1,qqo,qqc,$P($$$CondFind," ",10))) Q:qqo1=""
 .S qqc=qqo1,$$$CurObj=qqo D ..wcre() Q
 Q ""
]]></Implementation>
</Method>

<Method name="OnItemClickT2">
<Description>
qqxR - реальная колонка (вне зависимости от mergeInto)</Description>
<Internal/>
<FormalSpec>Sender:%String,qqy:%Integer,qqx:%Integer,qqarea:%Integer,qqbut:%Integer,Shift:%Integer,qqdat:%String,ItemData:%Integer,qqxR:%Library.Integer</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 ;D qARM.Message(Sender_" "_qqnump_"-"_Shift)
 Q:Shift=4 "" ;игнорирование Alt
 ;D ..Message(qqdat) ;S ^AA($I(^AA))="T2 "_qqy_","_qqx_" area "_$G(qqarea)_") qqred="_$G(qqred)_" qqw="_$G(qqw)_" Vt(qqnump,""Nodbl"")="_$G(Vt(qqnump,"Nodbl"))_" qqdbl="_$G(qqdbl)
 I $P(Sender,".")'=("Q"_$G(qqnump))!$G(W("ZredB")),..ChgWin() Q "" ;Обработка смены окна (смена локальной среды)
 K Vt(qqnump,"Nodbl")
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 ;;;;I $G(Vt(qqnump,"Expand"))'="",$P(Vt(qqnump,"Expand")," ")'=$E(qqdat,1,$L($P(Vt(qqnump,"Expand")," "))) D ..Expand1() D ..wM(qwin_".T2","M9",1,0,qqdat) Q "" ;свернули ранее развернутый по ..Expand
 S qqnumpT=qqnump ;@Dol 26.06.05
 I $G(W("Zederr"))||(qqdat="00") Q "" ;@dol 18.02.04 устанавливается в EndEdit при срабатывании правила проверки ;@dol 19.03.03 qqdat="00" строка заданного уровня (чтобы не дергался экран)
 I +qqdat=-2 S W("ZiNN",$P(qqdat," ",2))=$S($G(W("ZiNN",$P(qqdat," ",2)))="":0,W("ZiNN",$P(qqdat," ",2))=0:1,1:"") D ..wP(qwin_".T2","M4",$S(W("ZiNN",$P(qqdat," ",2)):"Bor",1:"Bog"),qqy,$P(W("ZiNN")," ",2),0) Q ""
 I $D(W("ZiNN")) D ..InnerC(0) Q ""
 Q:qqarea=11 ""
 I qqarea=7 S Vt(qqnump,"Nodbl")=1 D  Q "" ;RowCol
 .I ..GetPar("X1820")'="" N qqend X Vo(qqnump,-1,820) Q:'$G(qqend)  ;@Dol 3.04.06 действие по кнопке сброса релевантных
 .I qqbut=1 D ..RecRel(0) Q
 .D ..MenuEx(6)
 I qqred'="" Q:$G(W("Zederr")) "" S qqred="" ;отлов ESC или невыбора меню
 I $P(qqdat," ",2)=-1 D ..wP(qwin_".T1","Selected",1,0) ;Q "" ;строка вершины
 I qqarea=2!(qqarea=0)!(qqarea=4) S qqarea=5 ;"" ;линии соединения ???
 I qqarea=6 S Vt(qqnump,"Nodbl")=1 D ..T2ColHButton(qqx) Q "" ;заголовки рядов
 I qqarea=3 D  Q "" ;+/- (внутри объекта)
 .I "145"[(+Vo(qqnump,-1,61))||..GetPar("X178") D ..wM(qwin_".T2","Expand",qqy,0,1) Q  ;кривое игорирование свертки
 .I $G(Vo(qqnump,$P(qqdat," ",2),4))>1 D  D:$D(Vt(qqnump,9,"FCBUT")) ..wwwwFCBUT(1) Q
 ..I $G(Vc(qqnump,$P(qqdat," ",1),40))'=-1 S Vc(qqnump,$P(qqdat," ",1),40)='Vc(qqnump,$P(qqdat," ",1),40) D:Vc(qqnump,$P(qqdat," ",1),40) ..wM(qwin_".T2","Collapse",qqy,0),..wM(,"Expand",qqy,0,1) Q  ;если разворот свернутых - то все
 ..D:'..EndOP() qARM.wqqotree($P(qqdat," ",1),,,1) Q
 ..;D ..OpenTimer(50,"D qARM.wqqotree("""_$P(qqdat," ",1)_""",,,1)") Q  ;подкачка
 .D:$G(Vs(qqnump,99,"Auto")) ..ObjAuto($P(qqdat," ",2),,qqdat)
 .D:$D(Vt(qqnump,9,"FCBUT")) ..wwwwFCBUT(1)
 I qqarea=8 Q:$P(qqdat," ",2)=-1 "" S Vt(qqnump,"Nodbl")=1 D  Q "" ;метка (включить\исключить релевантные)
 .I qqbut=1 D ..RecRel($S($G(Vc(qqnump,$P(qqdat," "),2)):"-",1:"+"),$P(qqdat," ")) Q
 .S qxecute0=$P(qqdat," ") D ..MenuEx(0)
 ;
 Q:qqdat="" ""   ;выход если qqdat="" sas 20081228
 I $P(qqdat," ")'=$G(Vc(qqnump)) D  I %2 S Vt(qqnump,"Nodbl")=1 Q "" ;????
 .I W("ZBtred"),qqwchg'="",..EndOP() S %2=1 Q  ;ошибка
 .;если дерево, то вычислим текущую ссылку на объект предыдущего уровня
 .S %2=0 Q:'$G($$$Tree)  S $$$GloRef=$S($G($$$GloRef)'="":$NA(@$$$GloRef,1),1:$NA(^Q(qql))),qqob=$$$ObjRef($P(qqdat," ",2)),%1=$P(qqdat," ") F i=1:1:$L(qqob,",")-1 S $$$GloRef=$NA(@$$$GloRef@($P(qqob,",",i),Vc(qqnump,$E(%1,1,i*2))))
 ;
 S qqo=$P(qqdat," ",2)
 S %2=qqdat D OnICT2 D:'$D(Vo(qqnump,-1,202)) qARM.GetPar("X1202") I Vo(qqnump,-1,202)'="" N qqend X Vo(qqnump,-1,202) I $G(qqend) Q:$Q "" Q  ;@Dol 04.09.09 Действие по ItemClick
 ;;;;;S W("Zao")=0 ;??  
 I $P(qqdat," ")'=$G(Vc(qqnump)) S Vc(qqnump)=$P(qqdat," "),qqc=$G(Vc(qqnump,Vc(qqnump))) I $D(Vt(qqnump,111)),qqo'=-1 D ..Virt(1)
 ;
 I qqarea=99||(qqarea=98) D  Q $$OnICT2b() ;@dol 18.03.03 при клавишном перемещении;4.8.03 D OnICT2 ;98 - вверх, 99 - вниз
 .I $P($G(W("Zpos",2,"d"))," ",2)=$P(qqdat," ",2),$G(W("Zpos",2,"x"))'="" S W("Zpos",2,"d")=qqdat,W("Zpos",2,"y")=qqy,qqx=W("Zpos",2,"x"),qqwold="" D OnICT2 I $S(qqw'="":1,1:'..GetPar("X1190")) D ..wpoe(qqdat,,1) Q
 .D:'$G(Vo(qqnump,-1,19)) ..wcellsel("",$G(W("Zpos",2,"x")),,qqx)
 .S W("Zpos",2,"d")=qqdat,W("Zpos",2,"y")=qqy,W("Zpos",2,"x")=qqx,qqwold=""
 .D ..wpoe(qqdat,,1)
 .D OnICT2 Q:qqw'=""   I '..GetPar("X1190") Q:..OnKeyDown("Q"_qqnump,39)  Q 
 .K W("Zpos",2,"x") D:0 ..wpoe(qqdat,,1) Q:..OnKeyDown("Q"_qqnump,39,99)'=""  D ..wM(qwin_".T2",$S(qqarea=98:"ItemPrev",1:"ItemNext")) 
 D:'$G(Vo(qqnump,-1,19)) ..wcellsel("",$G(W("Zpos",2,"x")),"",qqx) ;@dol 16.02.03
 I $G(W("Zpos",2,"d"))'=qqdat!('$D(W("Zpos",2,"y")))  S W("Zpos",2,"d")=qqdat,W("Zpos",2,"y")=qqy,W("Zpos",2,"x")=qqx,qqwold="",W("Zpos")=2 D:$S(qqx="":0,$P(qqdat," ",3)="":0,1:$D(Vt(qqnump,9,"FCBUT",$P(qqdat," ",2),$P(qqdat," ",3),qqx)))  D ..wpoe(qqdat,,1) I qqarea'=10,qqarea'=91 N end S end=$S($G(Vo(qqnump,-1,670))="":1,1:'qARM.Value(Vo(qqnump,-1,670))) Q:end&('$$OnICT2b()) "" d ..wM(qwin_".T2","EmulateClick",0,qqx,qqarea,qqbut,0) Q "" ;@Dol 16.02.07 EmCl_> D ..OpenTimer(50,"D qARM.OnItemClickT2("""_Sender_""","_qqy_","_qqx_","_qqarea_","_qqbut_","""_Shift_""","""_qqdat_""")") Q "" ;@dol 24.10.03 ;@Dol 16.12.04 I qqarea'=10 - по картинке - немедленное позиционирование
 .Q:'$D(Vt(qqnump,9,"FCBUT",$P(qqdat," ",2),$P(qqdat," ",3),qqx))
 .N qqwr S qqwr=$P($G(Vt(qqnump,9,"FCBUT",$P(qqdat," ",2),$P(qqdat," ",3),qqx))," ") S:qqwr="@" qqwr=..GetPar("x760",,$P(qqdat," ",2),$P(qqdat," ",3),qqx) Q:qqwr'="FCBUT"  ;@Dol 4.10.06 фокус на кнопке;@Dol 13.07.08 образец (см.qW.gForm wtwe)
 .N qqwr S qqwr="" F  S qqwr=$O(qwin(qwin,"FCBUT",qqwr)) Q:qqwr=""  Q:$G(qwin(qwin,"FCBUT",qqwr))=(qqdat_" "_qqx)
 .Q:qqwr=""   D ..wP(qwin_".FCBUT"_qqwr,"Focused",1) Q
 ;
 I qqarea'=90,qqbut=1,qqx'=$G(W("Zpos",2,"x")),"145"[(+Vo(qqnump,-1,19)) S W("Zpos",2,"x")=qqx D ..wcellsel("","","",qqx) Q "" ;@Dol 10.02.08 при отметке ячейки не входить в редактирование соседней;Vt(qqnump,"Nodbl")=1 - не нужно - чтобы срабатывало по двойному
 S W("Zpos",2,"x")=qqx
 S Vt(qqnump,"Nodbl")=1 ;событие отработано
 I qqarea=90 D:"145"[(+Vo(qqnump,-1,19)) ..wcellsel("",$G(W("Zpos",2,"x")),"",qqx) Q "" ;@Dol 1.11.06
 I qqbut=1,"15"[(+$G(Vo(qqnump,-1,61))),'qqx,'$P(qqdat," ",3),$G(Vo(qqnump,qqo,4)),$S($D(Vt(qqnump,"Expand"))&&($P($G(Vt(qqnump,"Expand"))," ")'=$P(qqdat," ")):1,'W("ZBtred")||(qqarea=10):1,qqw=""!(qqw="ZZR"):1,$G(Vo(qqnump,qqo,0,$P(qqdat," ",3),qqx,31))=-1:1,$E($G(Vo(qqnump,qqo,0,$P(qqdat," ",3),qqx,31)))="@":qARM.Value(Vo(qqnump,qqo,0,$P(qqdat," ",3),qqx,31))=-1,1:0) D  Q "" ;первая ячейка объекта для бланка/таблицы;@Dol 16.12.04 ||(qqarea=10) - чтобы разворачивалось по картинке;@Dol 25.12.04 $D(Vt(qqnump,"Expand"))
 .D ..Expand1($P(qqdat," ")) ;свертка,развертка свернутых узлов в бланке
 I qqw="" S %3=..GetPar(730,,$P(qqdat," ",2),$P(qqdat," ",3),qqx) I %3'="",%3'<0 S qqw="ZZR" ;D   ;@dol 4.12.03 далее развертка по связанной константе, которая все равно не работала. Если восстановить - ломается действие по константе
 I qqbut=2,qqw="@ZXXmove",'W("Zadm") G OnICT2e
 ;I qqbut=2,$D(Vo(qqnump,-1,69)) N qqend D ..Value(Vo(qqnump,-1,69),"X") Q:$G(qqend) "" G:$G(qqend)=0 OnICT2e ;общее действие по правой кнопке;@dol 5.1.04 :$G(qqend)=0
 I qqbut=2,$G(qqdbl)||'W("Zadm"),..GetPar("X1201")  D ..AvtoFind(qqo,qqw,qqc,1) K qqwold Q "" ;@Dol 09.05.09 Автопоиск (окно)
 I qqbut=2,$G(Vo(qqnump,-1,69))'=""||$G(qqXB2help) N qqend D ..Value($S($G(Vo(qqnump,-1,69))="":"I 'W(""Zadm"")  D qARM.OpenCHelp(2) S qqend=1",1:Vo(qqnump,-1,69)),"X") Q:$G(qqend) "" G:$G(qqend)=0 OnICT2e  ;@Dol 17.05.06 действие по правой кнопке с учетом флага выдачи пояснений
 I qqbut=2,$S(Vo(qqnump)'="XXXX":1,1:qqx) D ..MenuEx(1) Q "" ;D  D ..OpenCHelp(%1) Q "" ;по правой кнопке теперь всегда пояснения
OnICT2e ;I qqw=$G(qqred) Q "" ;?????надо бы вставить
 ;;;Q:$$OnICT2b(1) ""
 ;;sas 20090305
 D qARM.NextEdit() Q ""
OnICT2 S qqw=$P($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx))," "),qqw=$S('$E(qqw):"",$E(qqw)=5:"Zs"_$P(qqdat," ",3)_"c"_qqx,1:$E($P(qqw," "),2,31)) Q
OnICT2b(arg)     ;@dol 27.10.03 Flat-кнопки
 ;;;I $D(qwin(qwin,"FBUT")),$P($G(qwin(qwin,"FBUT"))," ",1,3)'=qqdat D ..wP(qwin_".FBUT","Visible",0)
 ;;;I $G(W("Zpos",2,"x"))'="",$E($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),W("Zpos",2,"x"))))=7 D ..FlatButton(qqdat_" "_W("Zpos",2,"x")) Q:$G(arg) 1
 Q ""
]]></Implementation>
</Method>

<Method name="OnItemDblClickT1">
<Internal/>
<FormalSpec>Sender:%String,qqy:%Integer,qqx:%Integer,qqarea:%Integer,qqbut:%Integer,Shift:%Integer,qqdat:%String,ItemData:%Integer,qqxR:%Library.Integer</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $P(Sender,".")'=("Q"_$G(qqnump))!$G(W("ZredB")),..ChgWin() Q:$Q "" Q  ;Обработка смены окна (смена локальной среды)
 I $G(Vt(qqnump,"Nodbl")) K Vt(qqnump,"Nodbl") Q "" 
 N qqdbl S qqdbl=1 I ..OnItemClickT1(Sender,qqy,qqx,qqarea,qqbut,Shift,qqdat,ItemData,$G(qqxR))
 Q ""
]]></Implementation>
</Method>

<Method name="OnItemDblClickT2">
<Description>
qqxR - реальная колонка (вне зависимости от mergeInto)</Description>
<Internal/>
<FormalSpec>Sender:%String,qqy:%Integer,qqx:%Integer,qqarea:%Integer,qqbut:%Integer,Shift:%Integer,qqdat:%String,ItemData:%Integer,qqxR:%Library.Integer</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 ;D qARM.Message(" area "_$G(qqarea)_" qqred="_$G(qqred)_" qqw="_$G(qqw)_" Vt(qqnump,""Nodbl"")="_$G(Vt(qqnump,"Nodbl"))_" qqdbl="_$G(qqdbl))
 Q:Shift=4 "" ;игнорирование Alt
 I $P(Sender,".")'=("Q"_$G(qqnump))!$G(W("ZredB")),..ChgWin() Q:$Q "" Q  ;Обработка смены окна (смена локальной среды)
 I qqarea'=90,$G(Vt(qqnump,"Nodbl")) K Vt(qqnump,"Nodbl") Q "" ;@Dol 28.03.08
 I qqarea'=90 N qqdbl S qqdbl=1
 S:qqarea=90 qqarea=91 I ..OnItemClickT2(Sender,qqy,qqx,qqarea,qqbut,Shift,qqdat,ItemData,$G(qqxR))
 Q ""
]]></Implementation>
</Method>

<Method name="OnKeyDown">
<Internal/>
<FormalSpec><![CDATA[Sender:%String,&Key:%Integer,Shift:%String]]></FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 S Shift=$G(Shift)
 I $E(Sender,1,4)="ZRes" D  S Key=0 Q:$Q "" Q
 .I +$G(W("ZredB"))=1,$P(W("ZredB")," ",2)=$P(Sender,".") S $P(W("ZredB")," ",3)=Key=-122*2 Q:'..EditDoc()  ;Большой текст (по F11 - занесение)
 .d ..wM($P(Sender,"."),"Destroy") k qwin($P(Sender,".")) Q  ;Служебное окно (диаграмма, картинка и т.п)
 I $P(Sender,".")'=("Q"_$G(qqnump)),..ChgWin() Q ""
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 I qqred'="" Q:$G(W("Zederr")) "" S qqred="" ;@dol 01.09.04 отлов ESC или невыбора меню
 ;S ^Key($I(^Key))=Key_" "_$G(Shift)
 S qc=Key S:qc<0 qc=-qc ;D ..Message(qc_" "_Key)
 S:'$D(Vo(qqnump,-1,86)) Vo(qqnump,-1,86)=..GetPar("X186") I Vo(qqnump,-1,86)'="" D ..Value(Vo(qqnump,-1,86),"X") Q:'qc ""
 I $G(qqXB186)'="" X qqXB186 Q:'qc "" ;@Dol 28.06.06 глобальная обработка 
 ;;;;;;I qc=9,W("ZBtred") S Key=0 D ..NextEdit($G(qqw)) Q "" ;Tab в OnKeyPress
 I qc=13 S Key=0 d ..wM(qwin_".T2","EmulateClick",0,+$G(W("Zpos",2,"x")),9,1,0) Q "" ;@dol 4.12.03 D ..NextEdit("-"_$G(qqw))  Q "" ;????? Enter
 I qc=27 S Key=0 D  Q "" ;Esc
 .I $G(W("Zosrt"))'="",..GetPar(176) D ..T2ColHButton(-1) Q  ;@dol 13.02.04 сброс сортировки если определены горячие клавиши колонок (X176)
 .I qqnump'=0 D  D ..wM(qwin,"EvClose") Q  ;@dol 27.01.02 qqwchg=""
 ..I '$G(W("Zadm"))!1,$G(qwin(qwin,"child"))'="" D qARM.GetBqqnump(1) ;@Dol 04.05.06 переход в базовое окно;@Dol 25.07.08 !1 по ESC всегда выход
 ..I ..GetPar("X1722")="" K W("Zdomod") S Vo(qqnump,-1,73)="",qqwchg=""  Q  ;@Dol 28.03.06 нет действия по невыбору
 ..S:$D(W("Zdomod")) W("Zdomod")=3 S:..GetPar("x173")'="" Vo(qqnump,-1,73)=3 ;@Dol 28.03.06 автоматический невыбор для действия по невыбору
 I qc<32  Q ""
 I qc=32 D  Q ""
 .I ..ObjSort() S Key=0 D ..Wait("S qq=""_"" I qARM.OnKeyPress(""Q""_qqnump,qq)") Q
 .S Key=0
 .Q:W("ZBt0")
 .I $G(Vs(qqnump,99,"Auto")) D ..ObjAuto($$$CurObj) Q  ; автовыбор
 .N qqo S qqo=$$$CurObj ;@dol 4.12.03
 .I qqo="" Q  ;sas 20100324 если $$$CurObj="" валилось по subsc.
 .I "15"[(+Vo(qqnump,-1,61)) Q:'$G(Vo(qqnump,qqo,4))  Q:'$D(W("Zpos",2,"d"))  Q:$P(W("Zpos",2,"d")," ",3)  D ..Expand1($P(W("Zpos",2,"d")," ")) Q        ;;sasha 20061027 Q:'$D(W("Zpos",2,"d"))
 .I $G(Vo(qqnump,qqo,4))=2 D  Q
 ..I $G(Vc(qqnump,Vc(qqnump),40))'=-1 S Vc(qqnump,Vc(qqnump),40)='Vc(qqnump,Vc(qqnump),40) D  Q
 ...I Vc(qqnump,Vc(qqnump),40) D ..wM(qwin_".T2","Collapse",$G(W("Zpos",2,"y")),0),..wM(,"Expand",$G(W("Zpos",2,"y")),0,1) Q  ;если разворот свернутых - то все
 ...D ..wM(qwin_".T2","Collapse",$G(W("Zpos",2,"y")),0)
 ..D:'..EndOP() qARM.wqqotree(Vc(qqnump),,,1) Q
 .Q:$$$CurObj=-1  
 .Q:'$$$MObjRef($$$ObjRef($$$CurObj))  D ..wrot($$$CurObj) D ..wcre() Q  ;+/- раскрыть-закрыть объект (если не бланк)
 I qc>111,qc<124 i (Shift'["Ctrl")&&(Shift'["Alt")&&(Shift'["Shift") S qc=qc-80 D  S Key=0 Q "" ;F-клавиши
 .I qc=32 D  Q  ;F1
 ..I $E($P(Sender,".",2),2)=1 D ..OpenDHelp("1,0,"_+$G(W("Zpos",1,"x"))) Q  ;по дереву объектов
 ..D ..OpenCHelp($E($P(Sender,".",2),2))  ;по ячейкам дерева экземпляров
 .I qc=33 D:..MenuEx(2)  Q  ;F2 всплывающее меню запросов
 ..I $D(qwin(qwin,"o",7,2)) D:0 ..ResetSrt() D ..Wait("D qWEB.Query("""_qwin(qwin,"o",7,2)_""")") Q  ;единственный запрос выполняется сразу
 .I qc=34  Q  ;F3
 .I qc=35 Q:..EndOP()  D:$G(W("ZBtred")) ..RecNew() Q  ;..NoSort(), ;D:$G(W("ZBtred")) ..RecNew() Q  ;F4 ввод
 .I qc=36 D ..Find() Q  ;F5 поиск
 .I qc=37 D ..RecRel(1) Q  ;F6 режим ВЫБОР/Уточнеие
 .I qc=38 D ..RecRel(0) Q  ;F7 сброс релевантных
 .I qc=39 D:$G(W("ZBtred")) ..RecDel() Q  ;F8 удаление
 .I qc=40 N qqbut S qqbut=2 D ..NextEdit("-"_$G(qqw)) Q  ;F9 развертка
 .I qc=41 D  D ..wM(qwin,"EvClose") Q  ;F10;@Dol 1.07.05 child
 ..I '$G(W("Zadm")),$G(qwin(qwin,"child"))'="" D qARM.GetBqqnump(1) ;@Dol 04.05 переход в базовое окно
 .;I qc=42!(qc=43),$S($G(W("Zadm")):1,1:$G(qwin(qwin,"child"))="") D  D ..wM(qwin,"EvClose") Q  ;F11 - выход с выбором, F12 - выход с "пустым выбором"
 .I qc=42!(qc=43) D  D ..wM(qwin,"EvClose") Q  ;F11 - выход с выбором, F12 - выход с "пустым выбором"
 ..I '$G(W("Zadm")),$G(qwin(qwin,"child"))'="" D qARM.GetBqqnump(1) ;@Dol 04.05 переход в базовое окно
 ..S:$D(W("Zdomod")) W("Zdomod")=2 S:..GetPar("x173")'="" Vo(qqnump,-1,73)=2
 ..S Vs(qqnump,"EndTb")=Key<0 ;@Dol 2.03.06 Выход по кнопке нижнего тулбара
 ..I qc=43,$D(W("Zdomod"))||$D(Vo(qqnump,-1,73)) S qqc=$J(" ",$L(qqc)) ;подсунем несуществующий код (для пустого выбора)
 I qc=39 D  S Key=0 Q $G(%4) ;(19)Right 
 .I '..GetPar("X1661"),..ObjSort() D  Q  ;расширение общей основы (сужение выбора);@Dol 29.03.05 X1661
 ..N qqw,z5 S qqw=$P($$$CondFind," ") S (z5,%1)=$P($$$CondFind," ",5),%2=qW.GG(W("Zosrt"),qqw,qqc) I $L(%1)'<$L(%2) Q
 ..S $P($$$CondFind," ",5)=$E(%2,1,$L(%1)+1),W(qqw)=%2 D ..wcre()
 ..I z5="" D:$G(Vo(qqnump,-1,62)) ..wM(qwin,"qResize",$TR(Vo(qqnump,-1,62),"123","312")) ;@Dol&@Dima 04.02.09 qResize
 .;смена текущей ячейки
 .I $P($G(Vo(qqnump,-1,856))," ",1) S %4="" d ..wM(qwin_".T2","NextCell",''$P(Vo(qqnump,-1,856)," ",4),0,0,0) q  ;sasha&dima 22.09.06 прохождение по меткам табуляции (19)Right
 .S %1=$G(W("Zpos",2,"x")),%4="" S %2=$G(W("Zpos",2,"d")),%3=$P(%2," ",2),%2=$P(%2," ",3) Q:%2=""  ;%2 - строка, %3 - объект
 .S %4=%1 F  S %4=$O(Vo(qqnump,%3,0,%2,%4)) Q:%4=""  I $S(W("ZBtred"):..RedTest(%3,%2,%4),1:$G(Vo(qqnump,%3,0,%2,%4))) Q  ;@Dol 7.02.08 1:$G(Vo(qqnump,%3,0,%2,%4)
 .I %4="" Q:$S(%1=""||($G(Shift)=99):1,1:..RedTest(%3,%2,%1))  S %4=$O(Vo(qqnump,%3,0,%2,%1)) Q:%4=""
 .;;;;????I %4="" Q:$S(%1="":1,W("ZBtred"):..RedTest(%3,%2,%1),1:$G(Vo(qqnump,%3,0,%2,%1)))  S %4=$O(Vo(qqnump,%3,0,%2,%1)) Q:%4=""
 .S W("Zpos",2,"x")=%4 D OnKeyDownqqw,..wcellsel("",%1,"",%4) I $E($G(Vo(qqnump,%3,0,%2,%4)))=6 D ..wP(qwin_".FCBUT"_$G(Vt(qqnump,9,"FCBUT",%3,%2,%4)),"Focused",1)
 I qc=37 D  S Key=0 Q $G(%4) ;(20)Left
 .I '..GetPar("X1661"),..ObjSort() D  Q  ;сужение общей основы (расширение выбора);@Dol 29.03.05 X1661
 ..I $P($$$CondFind," ",5)="",$P($$$CondFind," ",6)="" Q
 ..I $P($$$CondFind," ",6)'="" S $P($$$CondFind," ",6)=$E($P($$$CondFind," ",6),1,$L($P($$$CondFind," ",6))-1) S W("ZfIlTr")=$S($E($P($$$CondFind," ",6))="*":"",$P($$$CondFind," ",5)="":"",1:$L($P($$$CondFind," ",5))_"e")_qW.qFindC(,,$P($$$CondFind," ",6))_".e" D ..wcre() Q  ;@Dol 4.03.05
 ..S W($P($$$CondFind," "))="",qqc=$P($$$CondFind," ",10) ;"" ;qW.GG(W("Zosrt"),$P($$$CondFind," "),qqc)
 ..S %1=$P($$$CondFind," ",5),$P($$$CondFind," ",5)=$E(%1,1,$L(%1)-1) D ..wcre()
 .;смена текущей ячейки
 .I $P($G(Vo(qqnump,-1,856))," ",1) S %4="" d ..wM(qwin_".T2","NextCell",''$P(Vo(qqnump,-1,856)," ",4),1,0,0) Q  ;sasha&dima 22.09.06 переход по меткам табуляции
 .S %1=$G(W("Zpos",2,"x")),%4="" S %2=$G(W("Zpos",2,"d")),%3=$P(%2," ",2),%2=$P(%2," ",3) Q:%2=""  ;%2 - строка, %3 - объект
 .S %4=%1 F  S %4=$O(Vo(qqnump,%3,0,%2,%4),-1) Q:%4=""  I $S(W("ZBtred"):..RedTest(%3,%2,%4),1:1) Q  ;1) Q
 .I %4="" Q:..RedTest(%3,%2,%1)  S %4=$O(Vo(qqnump,%3,0,%2,%1),-1) Q:%4=""
 .S W("Zpos",2,"x")=%4 D OnKeyDownqqw,..wcellsel("",%1,"",%4) I $E($G(Vo(qqnump,%3,0,%2,%4)))=6 D ..wP(qwin_".FCBUT"_$G(Vt(qqnump,9,"FCBUT",%3,%2,%4)),"Focused",1)
 I $P($G(Vo(qqnump,-1,856))," ",1),$C(35,34,40,38,33,36)[$C(qc) S Key=0 D  Q:$Q "" Q  ;sasha&dima 22.09.06 переход по меткам табуляции
 .I qc=38!(qc=40) d ..wM(qwin_".T2","NextCell",''$P(Vo(qqnump,-1,856)," ",4),qc=38,0,1) q  ;Up, Down
 .I qc=35!(qc=36) i $P($G(Vo(qqnump,-1,856))," ",5)="" d ..wM(qwin_".T2","NextCell",0,qc=35,1,0) Q  //sasha&dima 11.01.07;Home End первая - последняя без редактирования
 .i $P($G(Vo(qqnump,-1,856))," ",6)'="" I (qc=33)!(qc=34) d ButtonUpDown(qc) Q   //sasha 11.01.07 ???PgUp ;???PgDn
 .i qc=33 Q:..TToolButtonOnClick(qwin_"..b4")  Q  ;???PgUp
 .i qc=34 Q:..TToolButtonOnClick(qwin_"..b2")  Q  ;???PgDn
 .I qc=35 Q:..TToolButtonOnClick(qwin_"..b1")  Q  ;End
 .I qc=36 Q:..TToolButtonOnClick(qwin_"..b5")  Q  ;Home
 I $C(35,34,40,38,33,36,45,46)[$C(qc) S Key=0 D:$S($G(Vo(qqnump,-1,61))'=1:1,1:$G(Vo(qqnump,-1,80))=0)  Q "" ;перемещения по базе, если не бланк
 .I qc=35 Q:..TToolButtonOnClick(qwin_"..b1")  Q  ;End
 .I qc=34 Q:..TToolButtonOnClick(qwin_"..b2")  Q  ;PgDn
 .I qc=40 Q:..TToolButtonOnClick(qwin_"..b2")  Q  ;Down
 .I qc=38 Q:..TToolButtonOnClick(qwin_"..b4")  Q  ;Up
 .I qc=33 Q:..TToolButtonOnClick(qwin_"..b4")  Q  ;PgUp
 .I qc=36 Q:..TToolButtonOnClick(qwin_"..b5")  Q  ;Home
 .I qc=45 D ..RecRel("+") Q  ;Ins Включить в релевантные ;,W("ZBtred") S Key=0 D ..RecNew() Q "" ;Ins создание экземпляра объекта
 .I qc=46 D ..RecRel("-") Q  ;Del Исключить из релевантных ;,W("ZBtred") S Key=0 D ..RecDel() Q "" ;Del удаление экземпляра объекта
 ;D ..Message(qc)
 Q ""
OnKeyDownqqw S qqw=$P($G(Vo(qqnump,%3,0,%2,%4))," "),qqw=$S('qqw:"",$E(qqw)=5:"Zs"_%2_"c"_%4,1:$E($P(qqw," "),2,31)) Q

ButtonUpDown(qc)
 n i,qqcnew,qqo,qqcpos
 s qqo=$$$CurObj
 //Page Up
 s qqcnew=Vc(qqnump,($O(Vc(qqnump,""))))
 s:$G(W("Zosrt"))'="" W($P($$$CondFind," "))=qW.GG($$$CurObj,$P($$$CondFind," "),qqc)
 i qc=33 s:$G(W("Zosrt"))'="" W($P($$$CondFind," "))=qW.GG($$$CurObj,$P($$$CondFind," "),qqcnew) f i=1:1:$S($G(Vo(qqnump,-1,60))'="":(Vo(qqnump,-1,60)+1),1:20+1) s qqcnew=qW.gOrder(-1,qqo,qqcnew,"") q:qqcnew="" 
 //Page Down
 i qc=34 s:$G(W("Zosrt"))'="" W($P($$$CondFind," "))=qW.GG($$$CurObj,$P($$$CondFind," "),qqcnew) f i=1:1:$S($G(Vo(qqnump,-1,60))'="":(Vo(qqnump,-1,60)+1),1:20+1) s qqcnew=qW.gOrder(1,qqo,qqcnew,"") q:qqcnew="" 
 s qqc=qqcnew
 //Page Down
 //q:qc=33
 //i (qc=34),(Vc(qqnump)'="AA") s qqc=Vs(qqnump,"ID") //если не первый  
 //i (qc=34),(Vc(qqnump)="AA") 
 //i (qc=34) s qqc=Vc(qqnump,($O(Vc(qqnump,""),-1))) //если первый
 //проверять наличие W("Zosrt") ;;циклизация без этой вставки
 i $G(W("Zosrt"))'="" S:$P($$$CondFind," ")'="" W($P($$$CondFind," "))=qW.GG($$$CurObj,$P($$$CondFind," "),qqc)
 d qARM.wcre()
 Q
]]></Implementation>
</Method>

<Method name="OnKeyPress">
<Internal/>
<FormalSpec><![CDATA[Sender:%String,&Key:%String]]></FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 I $P(Sender,".")'=("Q"_$G(qqnump)),..ChgWin() Q ""
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 I qqred'="" Q:$G(W("Zederr")) "" S qqred="" ;@dol 01.09.04 отлов ESC или невыбора меню
 ;S ^Key($I(^Key))=Key_" "_$A(Key)
 S (q,qc)=Key,Key=0
 I $A(qc)<32 D  Q "" ;@Dol 25.09.06
 .S qc=$A(qc)
 .S:'$D(Vo(qqnump,-1,86)) Vo(qqnump,-1,86)=..GetPar("X186") I Vo(qqnump,-1,86)'="" D ..Value(Vo(qqnump,-1,86),"X") Q:qc=0
 .I $G(qqXB186)'="" X qqXB186 Q:qc=0  ;@Dol 28.06.06 глобальная обработка 
 .I qc=1 D ..Analit() Q  ;Ctrl/A - переключение режима Пользователь/Аналитик
 .I qc=19 D ..Adm() Q  ;Ctrl/S - переключение режима Пользователь/Администратор
 .I qc=9,$P($G(Vo(qqnump,-1,856))," ",1) d ..wM(qwin_".T2","NextCell",''$P(Vo(qqnump,-1,856)," ",4),0,0,0) Q   ;sasha@dima 22.09.06 использование меток табуляции для движения по ячейкам Tab
 .I qc=9 D ..NextEdit($G(qqw),1) Q  ;Tab
 .I qc=2 D:$G(W("Zadm")) ..T1ColHButton(0) Q  ;Ctrl/B - вхход/выход в редактирование описания отображения
 .;;;;@Dol 12.05.07 изяет - ест копировать/востановить в буфер ;I qc=4,W("Zadm") S Vs(qqnump,99,"OLEDD")='$G(Vs(qqnump,99,"OLEDD")) D ..Message($S(Vs(qqnump,99,"OLEDD"):"ВКЛЮЧЕН",1:"ВЫКЛЮЧЕН")_" режим OLE DragDrop"_$C(13,10)_"(Перетаскивание по удерживанию Alt + кнопка мыши)") Q  ;Ctrl+D
 .;I $A(qc)=6 D ..Message($S('$G(film):"Включено",1:"Выключено")_" фильмирование") S film='$G(film) Q "" ;Ctrl+F
 .I qc=6,W("Zadm") D ..Wait("d qARM.OpenWindow(,,,,,""XXXGM"")") Q   ;Вызов нового варианта сохранения CTRL+F
 .;I $A(qc)=7 S pfilm=1 D qARM.Film() Q "" ;Ctrl+G
 .I qc=8 D  S Key=" " Q  ;сброс общей основы
 ..I $G(W("Zosrt"))="",$G(Vs(qqnump,99,"Auto")) N qqq S qqq=$$$ObjRef($$$CurObj),qqq=$P(qqq,",",$L(qqq,",")-1) Q:qqq=""  D ..ObjAuto(qqq,0) Q  ;вверх на уровень при автовыборе
 ..I ..ObjSort() D  Q
 ...I $P($$$CondFind," ",5)="",$P($$$CondFind," ",6)="" Q
 ...S W($P($$$CondFind," "))="",qqc=$P($$$CondFind," ",10) ;@Dol 2.04.05 ;qW.GG(W("Zosrt"),$P($$$CondFind," "),qqc)
 ...S $P($$$CondFind," ",5)="",$P($$$CondFind," ",6)="" K W("ZfIlTr") S:qqc="" qqc=qW.gOrder(1,W("Zosrt"),"",$S($P($$$CondFind," ",10)="":"",1:$P($$$CondFind," ",10))) D ..wcre() Q
 .;I $A(qc)=9,W("ZBtred") D ..NextEdit($G(qqw)) S Key=" " Q "" ;Tab
 .I qc=23 Q:'$G(W("Zadm"))  D ..Question("Сохранить размеры окна",1,"","I qSYS.TMenuServ(""62_5"")") Q  ;Ctrl+W сохранить размеры окна
 .I qc=5 Q:'$G(W("Zadm"))  D ..QuestionM("Сохранить размеры граф",1,"","I qSYS.TMenuServ(""62_7"")") Q  ;Ctrl+E сохранить размеры граф
 ;
 I $P($$$CondFind," ")="" D  Q "" ;обработка горячих клавиш
 .N qqg,qqgz S qqg=..GetPar(175),qqgz=..GetPar(176)  I qqg="",qqgz="" Q
 .S qc=$TR($ZCVT(qc,"U"),"ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ","QWERTYUIOP[]ASDFGHJKL;'ZXCVBNM,.")
 .I qqgz S qqgz=$F("123456789QWERTYUIOPASDFGHJKLZXCVBNM",qc) I qqgz S qqgz=$G(Vs(qqnump,176,qqgz-1)) Q:qqgz=""  I Vo(qqnump,-1,9)>(qqgz-1) D ..wbut(2,qqgz,1),..T2ColHButton(qqgz) Q  ;заголовки колонок;@dol 5.5.04 для сетки
 .S qqg=$TR(qqg,"ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ","QWERTYUIOP[]ASDFGHJKL;'ZXCVBNM,.") Q:qqg'[(qc_":")
 .S qqg=$P($P(qqg,qc_":",2)," ") I $$$CurObj=$P(qqg,",") D ..NextEdit("-"_$P(qqg,",",2)) Q
 .Q:..EndOP()  ;@dol 27.01.02
 .N qqoboo,qqobci S qqoboo=$P(qqg,",") I qqoboo=-1 S qqobci=""
 .E  S qqobci=$E($G(W("Zpos",2,"d"),"AA"),1,2) F  Q:Vc(qqnump,qqobci,0)=qqoboo  S qqobci=$O(Vc(qqnump,qqobci)) Q:qqobci=""
 .I qqoboo'=-1,qqobci="" Q
 .I qqobci'="",$G(Vc(qqnump,qqobci,1))=0 S qqc=Vc(qqnump,qqobci),$$$CurObj=qqoboo D ..wcre() I 1
 .E  S qqc=$S(qqobci="":"",1:Vc(qqnump,qqobci)) S (qqci,Vc(qqnump))=qqobci,qqo=qqoboo D ..wpoe(qqobci_" "_qqoboo_" "_+$G(Vo(qqnump,qqoboo,11,$P(qqg,",",2))))
 .D ..NextEdit("-"_$P(qqg,",",2))
 Q:'..ObjSort() ""
 ;изменение основы
 N qqw,z6 S qqw=$P($$$CondFind," "),z6=$TR($P($$$CondFind," ",5,6)," ")="" ;@Dol 14.08.06 признак что размер будет увеличен за счет заголовка и нужен Resize
 S:q=" " q="_"
 I "*?"[q S $P($$$CondFind," ",6)=$P($$$CondFind," ",6)_q D ..wpoe(),OnKeyPEres Q "" ;@Dol 4.03.05
 N Virt S Virt=$G(Vs(qqnump,"Virt",W("Zosrt"))) ;@Dol 24.03.10
 I $P($$$CondFind," ",6)'="" S %1=$P($$$CondFind," ",6),%4=qqc,$P($$$CondFind," ",6)=$P($$$CondFind," ",6)_$ZCVT(q,"U"),W("ZfIlTr")=$S($E($P($$$CondFind," ",6))="*":"",$P($$$CondFind," ",5)="":"",1:$L($P($$$CondFind," ",5))_"e")_qW.qFindC(,,$P($$$CondFind," ",6))_".e" D  Q "" ;@Dol 4.03.05
 .S W(qqw)="",qqc=qW.gOrder(1,W("Zosrt"),"",$S($P($$$CondFind," ",10)="":"",1:$P($$$CondFind," ",10))) I qqc'="" D ..wcre(),OnKeyPEres Q
 .D ..Message("Значений для шаблона """_$P($$$CondFind," ",6)_""" не существует")
 .S $P($$$CondFind," ",6)=%1,qqc=%4 S:Virt'="" Vs(qqnump,"Virt",W("Zosrt"))=Virt ;@Dol 24.03.10 Virt
 S %1=$P($$$CondFind," ",5),%2=qW.GG(W("Zosrt"),qqw,qqc) ;стоим на объекте сортировки - необязательно ??
 I $E(%2,$L(%1)+1)=q S $P($$$CondFind," ",5)=$E(%2,1,$L(%1)+1),qqc=$P($$$CondFind," ",10),W(qqw)="" D ..wcre(),OnKeyPEres Q "" ;qqc="" ???
 S %3=$$$CondFind,$P($$$CondFind," ",5)=%1_q,%4=qqc
 ;K W(qqw)
 S %12="",%1=$$$CondFind,W(qqw)="",qqc=qW.gOrder(1,W("Zosrt"),"",$S($P($$$CondFind," ",10)="":"",1:$P($$$CondFind," ",10)))
 ;I qqc'="" S %2=$P($$$CondFind," ",5) G:%2'=+%2 OnKeyPE0 S %5=qW.GG(W("Zosrt"),qqw,qqc) S:%5'=+%5 qqc="" I qqc'="" S W(qqw)="" G OnKeyPE0:$S('$G(Vs(qqnump,99,"Revers")):1,'$S(Vo(qqnump,-1,666)="":1,1:" "_Vo(qqnump,-1,666)_" "[(" "_W("Zosrt")_" ")):1,%2=%5:1,qW.gOrder(-1,W("Zosrt"),qqc,$S($P($$$CondFind," ",10)="":"",1:$P($$$CondFind," ",10)))'="":qARM.Value("S $P(Vs(qqnump,""CondFind""),"" "",5)=%2,W(qqw)=qW.GG(W(""Zosrt""),qqw,qqc)","X")!1,1:0) S qqc="" G OnKeyPE ;@Dol 18.04.07 если число и реверс, есть ли числа дальше
 I qqc'="" S %2=$P($$$CondFind," ",5) G OnKeyPE0 ;@Dol 27.04.09 см. qW.gOrder + qW.qOrd
 ;I qqc="" S %2=$P($$$CondFind," ",5) I %2=+%2 S $P($$$CondFind," ",5)=%2_$C(31),W(qqw)="",qqc=qW.gOrder(1,W("Zosrt"),"",$S($P($$$CondFind," ",10)="":"",1:$P($$$CondFind," ",10))) G:qqc="" OnKeyPE ;если число, и его нет, может это слово, начинающееся на цифру
 I qqc="" S (%12,%2)=$P($$$CondFind," ",5),$E(%2,$L(%2))=$S($E(%2,$L(%2))?1L:$ZCVT($E(%2,$L(%2)),"U"),1:$ZCVT($E(%2,$L(%2)),"L")),$P($$$CondFind," ",5)=%2,W(qqw)="",qqc=qW.gOrder(1,W("Zosrt"),"",$S($P($$$CondFind," ",10)="":"",1:$P($$$CondFind," ",10))) ;попробуем другой регистр
 I qqc="" S %2=$P($$$CondFind," ",5),$E(%2,$L(%2))=$ZCVT($TR($ZCVT($E(%2,$L(%2)),"U"),"ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮQWERTYUIOP[]ASDFGHJKL;'ZXCVBNM,.","QWERTYUIOP[]ASDFGHJKL;'ZXCVBNM,.ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ"),$S($E(%2,$L(%2))?1L:"U",1:"L")),$P($$$CondFind," ",5)=%2,W(qqw)="",qqc=qW.gOrder(1,W("Zosrt"),"",$S($P($$$CondFind," ",10)="":"",1:$P($$$CondFind," ",10))) ;попробуем другой язык
 I qqc="" S %2=$P($$$CondFind," ",5),$E(%2,$L(%2))=$S($E(%2,$L(%2))?1L:$ZCVT($E(%2,$L(%2)),"U"),1:$ZCVT($E(%2,$L(%2)),"L")),$P($$$CondFind," ",5)=%2,W(qqw)="",qqc=qW.gOrder(1,W("Zosrt"),"",$S($P($$$CondFind," ",10)="":"",1:$P($$$CondFind," ",10))) ;попробуем другой регистр
OnKeyPE I qqc="",$L(%12)>1,$G(Vs(qqnump,"CondEnd")) D  S $P($$$CondFind," ",5)=%12 D ..wM(qwin,"EvClose") Q "" ;@Dol 1.09.05 завершение для развертки с отсутствием требуемого значения (последняя буква добавляется)
 .I $L(%12)>1,$TR($E(%12,$L(%12)-1),"ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮйцукенгшщзхъфывапролджэячсмитьбю")="" S $E(%12,$L(%12))=$TR($E(%12,$L(%12)),"QWERTYUIOP[]ASDFGHJKL;'ZXCVBNM,.qwertyuiop[]asdfghjkl;'zxcvbnm,.","ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮйцукенгшщзхъфывапролджэячсмитьбю") ;@Dol 19.10.06 - если русские буквы ??? по предыдущей
 I qqc="" S $$$CondFind=%3,qqc=%4 D:$P($$$CondFind," ",5)="" ..Message("Значений на """_$P(%1," ",5)_""" не существует") S:Virt'="" Vs(qqnump,"Virt",W("Zosrt"))=Virt Q "" ;@Dol 24.03.10 Virt
OnKeyPE0 I qqw="C" S qqc=""
 ;S qqc="" ;???
 D ..wcre(),OnKeyPEres Q ""
OnKeyPEres Q:'z6  D:$G(Vo(qqnump,-1,62)) ..wM(qwin,"qResize",$TR(Vo(qqnump,-1,62),"123","312")) Q
]]></Implementation>
</Method>

<Method name="OnMSWordClose">
<Internal/>
<FormalSpec>Sender:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 D:$D(W("ZredB")) ..EditDoc()
 Q ""
]]></Implementation>
</Method>

<Method name="OnRevers">
<Description>
Arg=0 выключение реверса, Arg=1 или 2 - включение ;@Dol 06.05.09</Description>
<Internal/>
<FormalSpec>Arg:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(Arg)'="" Vs(qqnump,99,"Revers")=Arg
 D ..wP(qwin_".TBG.b98","ImageIndex",6+(''Vs(qqnump,99,"Revers"))),..wP(,"Down",''Vs(qqnump,99,"Revers")),..wP(,"Hint","Реверс "_$S('Vs(qqnump,99,"Revers"):"выключен",Vs(qqnump,99,"Revers")=1:"по объектам и по сортировке",1:"только по объектам"))
 I $G(Arg)="" Q:$Q "" Q
 I $D(Vt(qqnump,111)) D ..Move("v")
 D ..wcre() Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OnScroll">
<Internal/>
<FormalSpec>Sender:%Library.String,Pos:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 I $G(Sender)="" D:$G(Pos)=""  S Vs(qqnump,"SBM")=Pos D ..wP(qwin_".SBM","Position",Pos) Q:$Q "" Q  ;внешнее позиционирование
 .;автоматическое вычисление текущей позиции; Vt(qqnump,669)- qqcibeg_" "_qqciend - см. ..wwwwZXXadd
 .N p,pB,pE S pB=$P(Vt(qqnump,669)," ",1) I pB="" F  S pB=$O(Vc(qqnump,pB)) Q:pB=""  Q:Vc(qqnump,pB,0)=$P(Vo(qqnump,-1,669)," ")  ;qqci начала
 .S pE=$P(Vt(qqnump,669)," ",2) I pE="" F  S pE=$O(Vc(qqnump,pE),-1) Q:pE=""  Q:Vc(qqnump,pE,0)=$P(Vo(qqnump,-1,669)," ")  ;qqci конца
 .S p=$G(Vc(qqnump)) S:p="" p=pB ;текущий qqci
 .S pE=$$OnScrollN(pE),pB=$$OnScrollN(pB),p=$$OnScrollN(p)
 .S p=$S(pE=pB:0,1:$J(p-pB/(pE-pB),0,2)),pB=$P(Vt(qqnump,669)," ",1)'=""*20+($P(Vt(qqnump,669)," ",2)'=""*20)
 .S Pos=$J($P(Vt(qqnump,669)," ",1)'=""*20+(100-pB*p),0,0)
 
 ;D ..Message(Sender_"-"_$G(Pos))
 I $P(Sender,".")'=("Q"_$G(qqnump)),..ChgWin() Q ""
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 ;D ..wM(qwin_".T2","SetFocus") ;@Dol 10.07.06
 N qqcPos,PosOld S PosOld=$G(Vs(qqnump,"SBM"),1),qqcPos=qqc D:PosOld'=Pos
 .;D qARM.Message(PosOld_"-"_Pos)
 .D qARM.Move($S(Pos=1:"Up",Pos=100:"Down",Pos<PosOld:"Up",1:"Down")) Q
 .D ..Wait("D:0 qARM.Message("""_PosOld_"-"_Pos_""") D qARM.Move("""_$S(Pos=1:"Up",Pos=100:"Down",Pos<PosOld:"Up",1:"Down")_""")") Q
 .I Pos=1 D ..Move("Up",1) Q  ;D:qqc'=qqcPos ..OnScroll(,20) Q
 .I Pos=100 D ..Move("Down",1) Q  ;D:qqc'=qqcPos ..OnScroll(,80) Q
 .I Pos<PosOld D ..Move("Up",1) Q  ;D:qqc=qqcPos ..OnScroll(,1) Q
 .D ..Move("Down",1) ;D:qqc=qqcPos ..OnScroll(,100) Q 
 Q ""
OnScrollN(pp)   N iii,ppp,pppp S pp=$RE(pp),ppp=1,pppp=0 F iii=1:1:$L(pp) S pppp=$A(pp,iii)-65*ppp+pppp,ppp=ppp*55
 Q pppp
]]></Implementation>
</Method>

<Method name="OnSelectDate">
<Internal/>
<FormalSpec>Sender:%Library.String,date:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 ;D ..Message(date)
 D ..wM(qwin_".T2","SetFocus")
 D ..EndEdit($ZD($P(date,".")+21548,8),13)
 Q ""
]]></Implementation>
</Method>

<Method name="OnTabCaption">
<Description>
Перевывод заголовков закладок. Имеет смысл, если они выражения.
qqnumpTAB - qqnump окна закладки (по умолчанию - текущее). Если не совпадает, то в методе qqnump=qqnumpTAB (для корректного пересчета выражений)
qqTABg - код группы закладок (по умолчанию 0)
Img=1 - перевывести картинки закладок. Имеет смысл, если их ресурс выражение.</Description>
<Internal/>
<FormalSpec>qqnumpTAB:%Library.String,qqTABg:%Library.String=0,Img:%Library.String,Hint</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(qqnumpTAB)="" qqnumpTAB=qqnump I qqnumpTAB'=qqnump N qqnump S qqnump=qqnumpTAB ;@Dol 31.07.09
 N qqii,qqtn8,cap,qqiii,qRes,NTab,qHint S cap="" F qqii=0:1 Q:'$D(Vs(qqnumpTAB,"Tabs",qqTABg,qqii))  S NTab=qqii,qqiii=Vs(qqnumpTAB,"Tabs",qqTABg,qqii) D
 .S qqtn8=$G(^Q(1,"XView",Vo(qqnumpTAB),"XTabs",qqTABg,"XTab",qqiii,"X43")) S:$E(qqtn8)="@" @("qqtn8="_$E(qqtn8,2,30000)) S cap=cap_$C(13,10)_qqtn8
 .I $G(Img) S qqtn8=$G(^Q(1,"XView",Vo(qqnumpTAB),"XTabs",qqTABg,"XTab",qqiii,"X49")) S:$E(qqtn8)="@" @("qqtn8="_$E(qqtn8,2,1000)) S:qqtn8'="" qRes=$G(qRes)_$C(13)_qqtn8
 .I $G(Hint) S qqtn8=$G(^Q(1,"XView",Vo(qqnumpTAB),"XTabs",qqTABg,"XTab",qqiii,"X430")) S:$E(qqtn8)="@" @("qqtn8="_$E(qqtn8,2,1000)) S:qqtn8'="" qHint=$G(qHint)_$C(31)_qqtn8 ;@Dol 31.07.09 вспл.подсказка
 I $G(Img),$TR($G(qRes),$C(13))'="" D
 .D:$D(qwin("Tabs"_qqTABg_"Q"_qqnumpTAB)) ..wM("Tabs"_qqTABg_"Q"_qqnumpTAB,"Destroy")
 .S qwin("Tabs"_qqTABg_"Q"_qqnumpTAB)="" D ..wC("TCustomImageList","Tabs"_qqTABg_"Q"_qqnumpTAB)
 .D:$G(^Q(1,"XView",Vo(qqnumpTAB),"XTabs",qqTABg,"X490"))'="" ..wP(,"Width",$P(^("X490"),",",1)),..wP(,"Height",$P(^("X490"),",",2))
 .D ..wM("Tabs"_qqTABg_"Q"_qqnumpTAB,"Fill",$P(qRes,$C(13),2,255))
 s cap=$E(cap,3,30000),qHint=$E($g(qHint),2,30000)
 i $g(XBLocal) s cap=qSYS.TransfLocal($tr(cap,$c(10)),$c(13)) s:$G(Hint) qHint=qSYS.TransfLocal(qHint,$c(31)) ;@pav подключение справочника локализации 15.02.2010
 D ..wP("Q"_qqnumpTAB_".Tabs"_qqTABg,"Tabs",cap) D:$G(Hint) ..wP(,"TabHints",qHint) ;@Dol 31.07.09
 ;D ..wP("Q"_qqnumpTAB_".Tabs"_qqTABg,"Tabs",$E(cap,3,30000)) D:$G(Hint) ..wP(,"TabHints",$E(qHint,2,30000)) ;@Dol 31.07.09
 D:$D(qwin("Tabs"_qqTABg_"Q"_qqnumpTAB)) ..wP("Q"_qqnumpTAB_".Tabs"_qqTABg,"Images","Tabs"_qqTABg_"Q"_qqnumpTAB)
 D ..wP("Q"_qqnumpTAB_".Tabs"_qqTABg,"TabIndex",+$G(Vs(qqnumpTAB,"Tabs",qqTABg))) ;@Dol 31.07.09
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OnTabChange">
<Description>
Обработка события переключения закладок.
В действии по переключению и в действиях по входу в отображения закладок доступны переменные:
NTab, NTabOld, CTab,CTabOld (новый и старый коды закладок)
qqoTab,qqcTab,qqparTab - переменные ползователя (существуют только в момент переключения закладок)

При использовании для программного переключения:
Sender= qqnump_"."_код_группы
NTab - физический номер закладки. Можно использовать и код закладки (X40). Не задан - текущая закладка
  Спец. вариант (в кавычках!!!) "+1" - переход к следующей закладке, "-1" - к предыдущей ;@Dol 20.07.08
qqfTab - Параметр пользователя. Будет доступен в действии по переключению закладки и в действиях по входу в отображения закладки.
qqnumpold - qqnump окна отображения, для которого будут обработаны параметры выхода (X172) - т.е. симмитировано закрытие с выполнением предписанных действий)
progr =0 - активно последнее окно закладки при программном переключении закладок (по умолчанию) ;@Dol 20.07.08
      =1 - остаться на окне закладок
Метод возвращает qqnump последнего окна открытой закладки ;@dol 20.07.08</Description>
<Internal/>
<FormalSpec>Sender:%Library.String,NTab:%Library.String,qqfTab:%Library.String,qqnumpold:%Library.String,progr:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 K:$G(qqnumpold)="" qqnumpold I $D(qqnumpold) N qqcold,qqoold,viewf,ZTMPN D  I qqnump=qqnumpold Q:$Q "" Q  ;имитация действий по выходу
 .D ..GetPar("X172",,,,,qqnumpold)
 .S qqoold=Vs(qqnumpold,"CurObj"),qqcold=$S(qqnumpold=qqnump:qqc,1:Vs(qqnumpold,"ID")) I qqnumpold'=qqnump N qview S qview=WS(qqnumpold,"Zvars","qview")
 .S viewf=Vs(qqnumpold,"Relind")_qview ;Vo(qqnumpold)_$S($P(qview," ",2)="":"",1:" "_$P(qview," ",2)) ;старый перечень релевантных
 .;;;I "564"[$P(Vo(qqnumpold,-1,72)," "),$E(qqcold)'=" ",'$D(^Q(viewf)) D qW.gRel("+",qqoold,qqcold) ;при выборе - текущий экземпляр объекта поместить в релевантные (если он пуст) :@dol 25.02.03 Vo(qqnump,-1,73)=2 - если автоматический выбор
 .D ..TFormOnClose(,"Beg")
 I $E(Sender)'="Q" D ..csav() S:'$D(progr) progr=0 S Sender="Q"_$P(Sender,".")_".Tabs"_(+$P(Sender,".",2)) D   I '$G(Vs($E($P(Sender,"."),2,255),"Tabs",$P(Sender,".Tabs",2),-1,48)),'$G(Vs($E($P(Sender,"."),2,255),"Tabs",$P(Sender,".Tabs",2),-1,42)) D ..wP(Sender,"TabIndex",+$S($E(NTab)?1N:NTab,1:$G(Vs($E($P(Sender,"."),2,255),"Tabs",$P(Sender,".Tabs",2),-2,NTab)))) ;переустановка закладки;@Dol 9.02.08 ?csav();@Dol 16.06.10 42 - учет пересчета видимости (будет переустновлено позже)
 .N next I $G(NTab)'="","+-"[$E(NTab) S next=NTab,NTab=""
 .S:$G(NTab)="" NTab=+$G(Vs($E($P(Sender,"."),2,255),"Tabs",$P(Sender,".Tabs",2)))
 .I $D(next) F  S NTab=$O(Vs($E($P(Sender,"."),2,255),"Tabs",$P(Sender,".Tabs",2),NTab),next) S:$E(NTab)="-" NTab=$S(next=-1:"",1:0) Q:NTab'=""  ///@Dol 20.07.08 след-пред
 I $P(Sender,".")'=("Q"_$G(qqnump)),..ChgWin() Q:$Q "" Q
 N qqtn,qqtn8,qqtn8w,qqtn80,qqii,qqchi,NTabOld,qqend,qqcTab,qqoTab,qqparTab,qqnumpTab,CTab,CTabOld,qZBtred,qZadm,virt S qqchi=$P(Sender,".Tabs",2),NTabOld=$G(Vs(qqnump,"Tabs",qqchi))
 I $E(NTab)'?1N S CTab=NTab,NTab=$G(Vs(qqnump,"Tabs",qqchi,-2,NTab)) I NTab="" D ..Message("Несуществующий код закладки "_CTab) Q:$Q "" Q
 S Vs(qqnump,"Tabs",qqchi)=NTab,virt=$G(Vs(qqnump,"Tabs",qqchi,-1,48)) ;@Dol 27.04.08 Виртуальные закладки
 I virt,NTab'=NTabOld S Vs(qqnump,"Tabs",qqchi,-3)=NTabOld ;@Dol 25.02.11
 S qZBtred=$G(W("ZBtred")),qZadm=$G(W("Zadm")) ;@Dol 27.07.06 для обработки наследования режимов
 S CTab=$G(Vs(qqnump,"Tabs",qqchi,NTab,-1)),CTabOld="" S:NTabOld'="" CTabOld=$G(Vs(qqnump,"Tabs",qqchi,NTabOld,-1))
 S qqnumpTab=qqnump I $G(Vs(qqnump,"Tabs",qqchi,-1,4))'="" X Vs(qqnump,"Tabs",qqchi,-1,4) ;I $G(qqend) Q:$Q "" Q  ;есть общее действие по переключению
 I 'virt,$G(Vs(qqnump,"Tabs",qqchi,-1,42)) D   D:$D(progr) ..wP(Sender,"TabIndex",NTab) ;обработка условий видимости;@Dol 16.06.10 TabIndex
 .F qqii=0:1 Q:'$D(Vs(qqnump,"Tabs",qqchi,qqii))  S qqtn8=$G(Vs(qqnump,"Tabs",qqchi,qqii,42)) I qqtn8'="" D  d ..wP(Sender,"TabVisible",''qqtn8,qqii) I 'qqtn8,qqii=NTab,NTab S NTab=0,CTab=$G(Vs(qqnump,"Tabs",qqchi,0,-1)) D ..wP(Sender,"TabIndex",0) ;Если Желаемая невидима, переключимся на закладку 0
 ..N CTab S CTab=$G(Vs(qqnump,"Tabs",qqchi,qqii,-1)),@("qqtn8="_qqtn8) ;@Dol 16.06.10 N CTab
 I NTabOld'="" S qqtn=$G(Vs(qqnump,"Tabs",qqchi,NTabOld,0)) I qqtn'="" D ..csav() D:NTabOld'=NTab OnTabChV(qqtn,0) ;было открыто окно по закладке
 I $G(qqend) Q:$Q "" Q
 D  D:$D(qqnumpold) ..TFormOnClose(0,"Beg")
 .S qqtn8=$G(Vs(qqnump,"Tabs",qqchi,NTab,8)) S:qqtn8'["@" qqtn8=""
 .S qqtn=$G(Vs(qqnump,"Tabs",qqchi,NTab,0)) I qqtn'="" D  Q  ; окно вызывалось ранее
 ..I $G(Vs(qqnump,"Tabs",qqchi,NTab,6)) D  D:$G(progr,0) ..crst(,qqnumpTab,2) Q  ;@Dol 20.07.08
 ...F qqii=1:1:$L(qqtn," ") D ..crst(1,$P(qqtn," ",qqii),2) D OnTabCh8w(1) D:$E(qqtn8w)="@" OnTabChP S:$G(Vo(qqnump,-1,855)) W("ZBtred")=qZBtred,W("Zadm")=qZadm X:$G(Vo(qqnump,-1,23))'="" Vo(qqnump,-1,23) I qqii'=$L(qqtn," ") D qARM.csav() 
 ..F qqii=1:1:$L(qqtn," ") D  D OnTabCh8w(1) D:$E(qqtn8w)="@" OnTabChP
 ...S:$G(Vo($P(qqtn," ",qqii),-1,855)) WS($P(qqtn," ",qqii),"ZBtred")=qZBtred,WS($P(qqtn," ",qqii),"Zadm")=qZadm ;@Dol 26.07.06
 ...I $L(qqtn," ")'=qqii||$G(progr,0) Q:NTabOld=NTab  D OnTabChV($P(qqtn," ",qqii),1) Q
 ...D ..crst(1,$P(qqtn," ",qqii),2)
 .S qqtn=$G(Vs(qqnump,"Tabs",qqchi,NTab,7)) I qqtn=""  Q:$G(Vs(qqnump,"Tabs",qqchi,-1,4))'=""  D qARM.Message("Нет  действия/отображения для "_Sender_" "_NTab) Q
 .I qqtn["(" X qqtn Q
 .;S qqtn8=$G(Vs(qqnumpTab,"Tabs",qqchi,NTab,8)),qqtn80=$G(Vs(qqnumpTab,"Tabs",qqchi,NTab,80)) F qqii=1:1:$L(qqtn," ") D OnTabCh8w() S Vs(qqnumpTab,"Tabs",qqchi,NTab,0)=$S(qqii=1:"",1:Vs(qqnumpTab,"Tabs",qqchi,NTab,0)_" ")_qARM.OpenWindow(,,$S($P(qqtn80," ",qqii)'="":$P(qqtn80," ",qqii),1:$P($G(Vs(qqnump,"Tabs",qqchi,-1,80))," ",qqii)),,,$P(qqtn," ",qqii),$S($L(qqtn," ")'=qqii:1,1:$G(progr,0)),,qqtn8w) ;@Dol 20.07.08 1:0 
 .S qqtn8=$G(Vs(qqnumpTab,"Tabs",qqchi,NTab,8)),qqtn80=$G(Vs(qqnumpTab,"Tabs",qqchi,NTab,80)) F qqii=1:1:$L(qqtn," ") D OnTabCh8w() S Vs(qqnumpTab,"Tabs",qqchi,NTab,0)=$S(qqii=1:"",1:Vs(qqnumpTab,"Tabs",qqchi,NTab,0)_" ")_$$OnTabOpenWindow($G(Vs(qqnumpTab,"Tabs",qqchi,NTab,0)),,$S($P(qqtn80," ",qqii)'="":$P(qqtn80," ",qqii),1:$P($G(Vs(qqnump,"Tabs",qqchi,-1,80))," ",qqii)),,,$P(qqtn," ",qqii),$S($L(qqtn," ")'=qqii:1,1:$G(progr,0)),,qqtn8w) ;@Dol 25.05.11
 X:$G(Vs(qqnumpTab,"Tabs",qqchi,-1,5))'="" Vs(qqnumpTab,"Tabs",qqchi,-1,5)  ;;maslova 22.04.2011
 Q:$Q $S($G(Vs(qqnumpTab,"Tabs",qqchi,NTab,0))="":"",1:$P(Vs(qqnumpTab,"Tabs",qqchi,NTab,0)," ",$L(Vs(qqnumpTab,"Tabs",qqchi,NTab,0)," "))) Q  ;@Dol 20.07.08 возврат последнего окна
 ;позиция окна
OnTabCh8w(No)
 S qqtn8w=$P(qqtn8," ",qqii) S:qqtn8w="" qqtn8w=$P($G(Vs(qqnumpTab,"Tabs",qqchi,-1))," ",qqii) Q:$G(No)  S:$E(qqtn8w)="@" @("qqtn8w="_$E(qqtn8w,2,30000)) Q
OnTabChV(qqtnn,qqtnnv)  ;видимость/невидимость окна и его потомков
 N iiii,iiip F iiii=1:1:$L(qqtnn," ") D:'qqtnnv ..wP("Q"_$P(qqtnn," ",iiii),"Visible",qqtnnv) D:qqtnnv ..wM("Q"_$P(qqtnn," ",iiii),"Show") S iiip="" F  S iiip=$O(Vs($P(qqtnn," ",iiii),"parent",iiip)) Q:iiip=""  D OnTabChV(iiip,qqtnnv)
 Q
 ;смена позиции окна 
OnTabChP N child,childz S @("child="_$E(qqtn8w,2,30000)) Q:child=""  S child=$TR(child,","," ") D
 .I $E(child)="*" S childz=1,child=$E(childz,2,30000) ;25.05.11  с учетом * - относительно первого окна закладки
 .I $P(child," ")["%" S child=$P(child," ")_"   "_$P(child," ",3,25) Q
 .I $P(child," ")=-1 S child=-1_" "_child Q
 .N qqci,qqnump S qqnump=$S('$G(childz):qqnumpTab,1:$P(qqtn," ")),qqci="" F  S qqci=$O(Vc(qqnump,qqci)) Q:qqci=""  Q:Vc(qqnump,qqci,0)=$P(child," ")  ;25.05.11 qqnumpTab-> $S('$G(childz):qqnumpTab,1:$P(qqtn," "))
 .S child=qqci_" "_child
 D ..wM("Q"_$P(qqtn," ",qqii),"SetChildPos",$ZSTRIP($P(child," ",1,3),"<>W"),$P(child," ",6),$P(child," ",4),$P(child," ",5)) Q
OnTabOpenWindow(p1,p2,p3,p4,p5,p6,p7,p8,p9) ;25.05.11 открытие окна с учетом * - относительно первого окна закладки
 S p8=$E(p9)="*" I p8,p1 D qARM.crst(1,$P(p1," "),1)
 S p2=qARM.OpenWindow(,,p3,,,p6,p7,,$S('p8:p9,1:$E(p9,2,30000)))
 I p8,p1,p7 D qARM.crst(1,qqnumpTab,1)
 Q p2
]]></Implementation>
</Method>

<Method name="OnTabVisible">
<Description>
Видимость/невидимость закладки. Переработано @Dol 07.12.09
qqnumpTAB - qqnump окна закладки (по умолчанию - текущее)
qqTABg - код группы закладок (по умолчанию 0)
NTab - текущий номер закладки или ее код (см. метод OnTabChange или описание закладок)
Visible =0 или 1

Если NTab не задан или пуст - пересчет видимости всех закладок с заданнными условиями видимости
@Dol 16.06.10 Переделано для возможности использования в условиях CTab (код закладки) и текущего qqnump</Description>
<Internal/>
<FormalSpec>qqnumpTAB:%Library.String,qqTABg:%Library.String=0,NTab:%Library.String,Visible:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(qqnumpTAB)="" qqnumpTAB=qqnump I '$G(Vs(qqnumpTAB,"Tabs",qqTABg,-1,42)) Q:$Q "" Q  ;нет условий видимости или закладок еще нет
 N CTab,qqnump S qqnump=qqnumpTAB I $G(NTab)'="",$E(NTab)'?1N S NTab=$G(Vs(qqnumpTAB,"Tabs",qqTABg,-2,NTab)) d:NTab'=""  Q:$Q "" Q  ;номер по коду
 .I $G(Visible)="" S CTab=$G(Vs(qqnumpTAB,"Tabs",qqTABg,NTab,-1)),qqtn8=$G(Vs(qqnumpTAB,"Tabs",qqTABg,NTab,42)) I qqtn8'="" S @("qqtn8="_qqtn8) d ..wP("Q"_qqnumpTAB_".Tabs"_qqTABg,"TabVisible",''qqtn8,NTab) Q
 .d ..wP("Q"_qqnumpTAB_".Tabs"_qqTABg,"TabVisible",Visible,NTab) Q
 N qqii,qqtn8,NTabt S NTabt=+$G(Vs(qqnumpTAB,"Tabs",qqTABg)) ;текущая закладка
 F qqii=0:1 Q:'$D(Vs(qqnumpTAB,"Tabs",qqTABg,qqii))  S qqtn8=$G(Vs(qqnumpTAB,"Tabs",qqTABg,qqii,42)) D:qqtn8'=""&&$S($G(NTab)'="":NTab=Vs(qqnumpTAB,"Tabs",qqTABg,qqii),1:1)  I $G(NTab)'="",NTab=Vs(qqnumpTAB,"Tabs",qqTABg,qqii) Q
 .S CTab=$G(Vs(qqnumpTAB,"Tabs",qqTABg,qqii,-1)),@("qqtn8="_qqtn8) d ..wP("Q"_qqnumpTAB_".Tabs"_qqTABg,"TabVisible",''qqtn8,qqii) I 'qqtn8,qqii=NTabt,NTabt S Vs(qqnumpTAB,"Tabs",qqTABg)=0 D ..wP("Q"_qqnumpTAB_".Tabs"_qqTABg,"TabIndex",0) ;Если Желаемая невидима, переключимся на закладку 0
 Q:$Q "" Q
 ;S:$G(qqnumpTAB)="" qqnumpTAB=qqnump I '$G(Vs(qqnumpTAB,"Tabs",qqTABg,-1,42)) Q:$Q "" Q  ;нет условий видимости или закладок еще нет
 ;I $G(NTab)'="",$E(NTab)'?1N S NTab=$G(Vs(qqnumpTAB,"Tabs",qqTABg,-2,NTab)) d:NTab'=""  Q:$Q "" Q  ;номер по коду
 ;.I $G(Visible)="" S qqtn8=$G(Vs(qqnumpTAB,"Tabs",qqTABg,NTab,42)) I qqtn8'="" S @("qqtn8="_qqtn8) d ..wP("Q"_qqnumpTAB_".Tabs"_qqTABg,"TabVisible",''qqtn8,NTab) Q
 ;.d ..wP("Q"_qqnumpTAB_".Tabs"_qqTABg,"TabVisible",Visible,NTab) Q
 ;N qqii,qqtn8,NTabt S NTabt=+$G(Vs(qqnumpTAB,"Tabs",qqTABg)) ;текущая закладка
 ;F qqii=0:1 Q:'$D(Vs(qqnumpTAB,"Tabs",qqTABg,qqii))  S qqtn8=$G(Vs(qqnumpTAB,"Tabs",qqTABg,qqii,42)) D:qqtn8'=""&&$S($G(NTab)'="":NTab=Vs(qqnumpTAB,"Tabs",qqTABg,qqii),1:1)  I $G(NTab)'="",NTab=Vs(qqnumpTAB,"Tabs",qqTABg,qqii) Q
 ;.S @("qqtn8="_qqtn8) d ..wP("Q"_qqnumpTAB_".Tabs"_qqTABg,"TabVisible",''qqtn8,qqii) I 'qqtn8,qqii=NTabt,NTabt S Vs(qqnumpTAB,"Tabs",qqTABg)=0 D ..wP("Q"_qqnumpTAB_".Tabs"_qqTABg,"TabIndex",0) ;Если Желаемая невидима, переключимся на закладку 0
 ;Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OnTreeRichEdit">
<Internal/>
<FormalSpec>Sender:%String,Code:%String,Node:%String,Par4:%String,Par5:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 ;$$$FEvent @dima убрал 20101220
 ;;@sas 20091006 Node имя узла, в который сохранен текст 
 ;;перед вызовом метода, или пусто, что означает, что он не сохранен
 ;;Установлена проверка на полное удаление данных из ячейки
 I Vo($P($P(Sender,"."),"Q",2))="XXXRich" s:('$D(MasTxT))&&(Node'="") MasTxT(0)="" Q ""
 I $P(Sender,".")'=("Q"_$G(qqnump)),..ChgWin() Q ""
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 ;D qARM.Message(Sender_"-"_Code_"-"_Node) Q:$Q "" Q
 N X761,ss
 I Code=3 D  Q:$Q "" Q  ; 23.03.09 событие F-клавишам (F1-F12,Node=112-123)
 .I ..GetPar("x730",,$P($G(W("Zpos",2,"d"))," ",2),$P($G(W("Zpos",2,"d"))," ",3),$G(W("Zpos",2,"x")))'="" S ss=..s112() D:ss=-1 ..wM(qwin,"EvClose") Q
 ;I Code=2 D  Q:$Q "" Q  ; событие по началу редактирования
 I Code=2 D  S qqredRE=qqred Q:$Q "" Q  ; событие по началу редактирования; 19.01.10 см ниже
 .N qqdat,qqx S qqdat=$G(qwin(qwin,"FCBUT",$P(Sender,"FCBUT",2))),qqx=$P(qqdat," ",4),qqdat=$P(qqdat," ",1,3) ;=qqci_" "_qqo_" "_qqso_" "_qiii
 .S qqo=$P(qqdat," ",2)
 .S qqw=$P($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx))," "),qqw=$S('$E(qqw):"",$E(qqw)=5:"Zs"_$P(qqdat," ",3)_"c"_qqx,1:$E($P(qqw," "),2,31))
 .I $P(qqdat," ")'=$G(Vc(qqnump)),$G(W("ZBtred")),$G(qqwchg)'="",..EndOP()  Q  ;@Dol 08.04.10 переход на другой экземпляр
 .I $P(qqdat," ")'=$G(Vc(qqnump)) S Vc(qqnump)=$P(qqdat," "),qqc=$G(Vc(qqnump,Vc(qqnump))) I $D(Vt(qqnump,111)),qqo'=-1 D ..Virt(1)
 .I $G(W("Zpos",2,"d"))'=qqdat  S W("Zpos",2,"d")=qqdat K W("Zpos",2,"y") S W("Zpos",2,"x")=qqx,qqwold="",W("Zpos")=2  D ..wpoe(qqdat,,1)
 .S W("Zpos",2,"x")=qqx
 .S qqbut=1+(Code=3)
 .I ..EditTest($$$CurObj,qqw) Q  ;запрет коррекции
 .S %1=..StartEditT2() I %1=-1 D ..wM(qwin,"EvClose") Q
 .I %1=112 S %1=..s112() Q:+$G(W("Zcdrl"))=6  I %1=-1 D ..wM(qwin,"EvClose") Q  ;развертка (большой текст- выход) или выход из формы по развертке-действию (9)
 .D ..wP(Sender,"ReadOnly",qqred="") Q:qqred=""  ;запрет редактирования
 .S X761=..GetPar("X761",,$P(W("Zpos",2,"d")," ",2),$P(W("Zpos",2,"d")," ",3),W("Zpos",2,"x")) S:$E(X761)="@" @("X761="_$E(X761,2,3000))
 .D:$P(X761," ",12)=2 ..wP(Sender,"ShowToolBar",1)
 .S ss=$G(Vo(qqnump,$P(W("Zpos",2,"d")," ",2),0,$P(W("Zpos",2,"d")," ",3),W("Zpos",2,"x"),2)) D:$P(ss,",",13)'="" ..wP(Sender,"Color",$P(ss,",",13))
 .;???D:$P(X761," ",14) ..wP(Sender,"EditorBorder",''($P(X761," ",14)#4)),..wP(,"Flat",$P(X761," ",14)#4>1) ;,..wP(,"BorderStyle",$P(X761," ",14)>3) ;рамка на момент редактирования
 .;S W("ZredB")=2
 .;I qqred'="",$S(+W("Zcdrl")=12:0,+W("Zcdrl")=3:$P(W("Zcdrl")," ",2)'=1,+W("Zcdrl")'=2:1,1:'$P(W("Zcdrl")," ",2)) D   ;D ..wfoc(2,"",qqx,qqdat)  ;очень сомнительное место ;,+W("Zcdrl")'=2:1 - развертка-меню
 ;I $P(qqqq," ",1,2)'=$P(W("Zpos",2,"d")," ",1,2),..EndOP() Q:$Q "" Q
 ;I $P(qqqq," ",1,2)'=$P(W("Zpos",2,"d")," ",1,2) S W("Zpos",2,"d")=$P(qqqq," ",1,3),W("Zpos",2,"x")=$P(qqqq," ",4) K W("Zpos",2,"y") S qqo=$P(qqqq," ",2),qqc=$G(Vc($P(qqqq," ",1))) ;не очень все хорошо - нужно событие по входу в редактироваие
 ;Выход из редактирования
 D  ;пока важно для RichEdit при прямом клике на текст из обычного редактируемого поля - некорректная обработка событий лок. среда некорректна
 .S qqred=qqredRE
 .N qqdat,qqx S qqdat=$G(qwin(qwin,"FCBUT",$P(Sender,"FCBUT",2))),qqx=$P(qqdat," ",4),qqdat=$P(qqdat," ",1,3) ;=qqci_" "_qqo_" "_qqso_" "_qiii
 .S qqo=$P(qqdat," ",2)
 .S qqw=$P($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx))," ")
 .I $G(W("Zpos",2,"d"))'=qqdat  S W("Zpos",2,"d")=qqdat K W("Zpos",2,"y") S W("Zpos",2,"x")=qqx,qqwold="",W("Zpos")=2  D ..wpoe(qqdat,,1)
 .S W("Zpos",2,"x")=qqx
 Q:qqred="" "" N ii,iii,iiii,rtf,tag,sss,ci,tagp,beg,end,ttt
 S X761=..GetPar("X761",,$P(W("Zpos",2,"d")," ",2),$P(W("Zpos",2,"d")," ",3),W("Zpos",2,"x")) S:$E(X761)="@" @("X761="_$E(X761,2,3000))
 D:$P(X761," ",12)=2 ..wP(Sender,"ShowToolBar",0)
 ;???D:$P(X761," ",14) ..wP(Sender,"BorderStyle",$P(X761," ",7)>3) ;..wP(Sender,"EditorBorder",''($P(X761," ",7)#4)),..wP(,"Flat",$P(X761," ",7)#4>1) ;,..wP(,"BorderStyle",$P(X761," ",7)>3) ;рамка на момент редактирования (убрать)
 S ss=$G(Vo(qqnump,$P(W("Zpos",2,"d")," ",2),0,$P(W("Zpos",2,"d")," ",3),W("Zpos",2,"x"),2)) D:$P(ss,",",13)'="" ..wP(Sender,"Color",$P(ss,",",9))
 I Node="" Q:$Q "" Q
 S W("ZredB")=2 ;,qqw=$QS(Node,1),qqred=qqw,W("Zcdrl")="",W("Zdrl")=""
 K W(qqred) S rtf=$P(X761," ",10)
 ;I rtf S MasTxT(0)=$E($P($P(MasTxT(0),"\viewkind4",2,225),"\fs",2,255),3,30000) S:$E(MasTxT(0),1)=" " $E(MasTxT(0),1)="" S ii=$O(MasTxT("")),MasTxT(ii)=$E(MasTxT(ii),1,$L(MasTxT(ii))-1)
 I rtf S MasTxT(0)=$P(MasTxT(0),"\viewkind4",2,225) S:$E(MasTxT(0),1)=" " $E(MasTxT(0),1)="" S ii=$O(MasTxT("")),MasTxT(ii)=$E(MasTxT(ii),1,$L(MasTxT(ii))-1) ;отсечем заголовок и закрывающую скобку
 S iiii=-1,tag=0 F ii=0:1 Q:'$D(MasTxT(ii))  F iii=1:1:$L(MasTxT(ii),$C(13,10)) D
 .I 'rtf S W(qqred,$I(iiii))=$P(MasTxT(ii),$C(13,10),iii) Q
 .S ss=$P(MasTxT(ii),$C(13,10),iii),sss=ss_$C(1)[("\par"_$C(1)) ;уберем лишний \par перед $C(13,10)
 .S:'tag W(qqred,$I(iiii))=$S('sss:ss,1:$E(ss,1,$L(ss)-4))
 .S:tag W(qqred,iiii)=W(qqred,iiii)_$S('sss:ss,1:$E(ss,1,$L(ss)-4)) S tag='sss
 D:rtf=2  ;XML
 .;qqConvXMLRTF см в qW.CRTF
 .F ii=0:1 Q:'$D(W(qqred,ii))  D  S W(qqred,ii)=qW.tagSequenceControl(W(qqred,ii)) ;@Mike 30.05.11 Контроль последовательности тэгов. Пытается исправить, если не удается - удаляет неправильно расставленные тэги.
 ..S sss="",ss=W(qqred,ii),tagp="",beg="",end="" K ttt F  S iii=$F(ss,"\") Q:'iii  D
 ...I $TR($E(ss,iii),"{}\")="" S sss=sss_$E(ss,1,iii-2)_$E(ss,iii),ss=$E(ss,iii+1,30000) Q
 ...S sss=sss_$E(ss,1,iii-2),ss=$E(ss,iii,30000),tag=$P($TR(ss,"\}{ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮЁйцукенгшщзхъфывапролджэячсмитьбюё","                                                                                ")," ")
 ...S ss=$E(ss,$E(ss,$L(tag)+1)=" "+$L(tag)+1,30000)
 ...S ci=$LF(qqConvXMLRTF,tag)  Q:'ci  ;'ci S sss=sss_"\"_tag Q
 ...I " qc qr ql "[(" "_tag_" ") S beg=ci Q  ;цент, лево в начало строки
 ...I " super sub "[(" "_tag_" ") S tagp=tag
 ...I ci#4=1 D  Q
 ....D OnTreeRs() S ttt($I(ttt))=ci+2 I ss[("\"_$LI(qqConvXMLRTF,ci+2)) Q  ;есть завершающий
 ....S ss=ss_"\"_$LI(qqConvXMLRTF,ci+2) ;нет - добавим в конец строки
 ...I $S('$G(ttt):1,tag="nosupersub":tagp="",1:sss'[$LI(qqConvXMLRTF,ci-1)) Q  ;нет начального тега
 ...I $I(ttt,-1),ttt(ttt+1)'=ci S end=$S(tag'="nosupersub":$LI(qqConvXMLRTF,ci+1),tagp'="":$LI(qqConvXMLRTF,$LF(qqConvXMLRTF,tagp)+3),1:"")_end Q  ;неверный порядок тегов
 ...I tag="nosupersub" D:tagp'="" OnTreeRs($LI(qqConvXMLRTF,$LF(qqConvXMLRTF,tagp)+3),end) S end="" Q  ;спец.случай - общий завершающий тег
 ...D OnTreeRs(,end) S end="" Q
 ..S W(qqred,ii)=sss_ss I beg'="" S W(qqred,ii)=$LI(qqConvXMLRTF,beg+1)_$S($E(W(qqred,ii))=" ":"",1:" ")_W(qqred,ii)_$S($E(W(qqred,ii),$L(W(qqred,ii)))=" ":"",1:" ")_"</p>"
 I ..EndEdit(,,1,,1)   ;без перевывода ???рестарт редактирования
 ;D qARM.Message(qqw_" "_Code_"-"_Node_"-"_$G(String))
 K W("ZredB") S qqred=""
 Q:$Q "" Q
OnTreeRs(tagpp,eee) S:$G(eee)'="" ss=eee_ss S sss=sss_$S(sss="":"",$E(sss,$L(sss))=" ":"",1:" ")_$S($D(tagpp):tagpp,1:$LI(qqConvXMLRTF,ci+1))_$S(ss="":"",$E(ss)=" ":"",1:" ") Q
 ///????eee
]]></Implementation>
</Method>

<Method name="OpenCFX">
<Internal/>
<FormalSpec>qqpar1:%String,Arg1:%Library.String,Dx:%Library.String,Dy:%Library.String,Name:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 S:$G(qqpar1)="" qqpar1='$P($G(Vs(qqnump,13,"R"))," ",4)
 S:'$D(Arg1) Arg1=$P($G(Vs(qqnump,13,"R"))," ",2,6)
 S %1=qSYS.CreArDi("A"_qview,1000) D:$L(%1)>1 ..Message($E(%1,2,1000)) I '%1 Q:$Q "" Q
 N ymax,xmax,x,y,mas,xyz,qLL S mas=$P(QDiag," ",3),xyz=$P(QDiag," ",4),ymax=$O(QDiag(""),-1),xmax=$O(QDiag(0,""),-1)
 S qLL=$P("50,100,200,500",",",$P($G(Vs(qqnump,13,"R"))," ",7)+1) ;размер легенды
 N winP S winP=..NewResW() D ..wC("TForm",winP),..wP(,"Width",$S($G(Dx)="":550,1:Dx)),..wP(,"Height",$S($G(Dy)="":400,1:Dy)),..wP(,"Position",4),..wP(,"OnClose",1)
 ;D ..wP(,"FormStyle",3) ;форма всегда верхняя
 D ..wC("TChartfx",winP_".C"),..wM(winP,"Show"),..wP(winP_".C","Align",5)
 D ..wP(winP,"Caption",$S($G(Name)="":"Диаграмма: "_$G(Vo(qqnump,-1)),1:Name))
 D ..wP(winP_".C","Type_",$ZH("AF"_(4+('$P(Arg1," ",2))+(+Arg1=1*2))_0_$S(Arg1<2:2,+Arg1=3:1,+Arg1=2:5,1:4))) ;718082)
 ;D ..wP(,"ChartType",1) ;2)
 I $G(qqpar1)=0 D ..wP(,"ToolBar",0)
 D ..wP(,"RGBBk",256*256*256-1) ;белый фон
 D ..wP(,"CustTool",524230644) ;523968500)
 D ..wP(,"WallWidth",2)
 D ..wP(,"Grid",3)
 D ..wP(,"Title",QDiag(0,0),3)
 D ..wP(,"Title",$S('mas:"",mas=1:"(%норм)",mas=2:"(%взв)",'xyz&(ymax'=1):"(%откл)",1:"(откл)")_$S($P(QDiag," ",5)'="":$P(QDiag," ",5,255),ymax=1:QDiag(1,0)_$P(QDiag," ",5,255),1:""),0)
 ;
 D ..wP(winP_".C","Adm",$TR($P(QDiag," ",1),".",","),0) ;Min
 D ..wP(,"Adm",$TR($P(QDiag," ",2),".",","),1) ;Max
 I '$P(Arg1," ",4) F x=1:1:xmax D ..wP(,"Legend",$TR($E(QDiag(0,x),1,qLL),"_"," "),x-1) ;не длинннее 50 символов, иначе диаграмма рушится
 I mas=1!(mas=2) D ..wP(,"Adm",$TR($J($P(QDiag," ",2)-$P(QDiag," ",1)/10,0,2),".",","),4),..wP(,"LeftGap",$S(mas=2!xyz:1,1:ymax)*7*6+20) D   I 1 ;разрисуем Y-легенду
 .F i=0:1:10 D ..wP(,"YLeg",QDiagYL(i),i)
 E  N n S n=$P(QDiag," ",2)-$P(QDiag," ",1)/10 D  D ..wP(,"Adm",$TR(n,".",","),4)
 .I n["." S %3=$P(n,".",2),%3=$L($P(%3,$E($TR(%3,"0")))),%4=$P($ZABS(n),"."),%4=$S(%4=0:0,1:$L(%4)),n=$S(%4>0:$J(n,0,0),1:$J(n,0,1+%3)) ;округление
 ;I mas=3  D
 ;.S x=-n*5 F i=1:1:10 D   S x=x+n
 ;..I i=5 D ..wP(,"YLeg",QDiagYL(0),x) Q
 ;..D ..wP(,"YLeg",x,x)
 ;I mas=3 D ..wP(,"Adm","20,00",4) ;,..wP(,"LeftGap",$S(mas=2!xyz:1,1:ymax)*7*6+20) D  ;разрисуем Y-легенду
 ;.S x=0 F i=0:2:10 D ..wP(,"YLeg",QDiagYL(i),x) S x=x+1
 ;.S x=1 F i=-2:-2:-10 D ..wP(,"YLeg",QDiagYL(i),-x) S x=x+1
 D ..wM(,"OpenDataEx",1,+ymax,+xmax)
 F y=1:1:ymax  D
 .D ..wP(,"ThisSerie",y-1) I ymax>1,'$P(Arg1," ",5) D ..wP(,"SerLeg",$S($L(QDiag(y,0))>100:$E(QDiag(y,0),1,100)_"...",1:QDiag(y,0)),y-1)
 .F x=1:1:xmax S %1=$TR(QDiag(y,x),".",","),%1=$P(%1," ",$S(mas=1:2,mas=3&('xyz)&(ymax'=1):2,1:1)) D ..wP(,"Value",$P(%1,"%"),x-1)
 ;D:ymax>1 ..wP(,"ThisSerie",ymax),..wP(,"SerLeg"," ",ymax) ;ошибка в диаграмме (так все серии будут видны)
 ;D ..wM(,"qFonts","Arial Cyr") ;для NT
 D ..wM(,"CloseData",1)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenCFXNEW">
<Description>
    @AKA 08.02.2011
OpenCFXNEW - метод для вывода графиков в ChartFX 6.2</Description>
<Internal/>
<FormalSpec>qqpar1:%String,Arg1:%Library.String,Dx:%String,Dy:%String,Name:%Library.String,masRef:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 //*************************************************************************
 //                         Новый пар-р метода                              
 //*************************************************************************
 // masRef  -   название массива с данными (по умолчанию ^||CFX)            
 //             если masRef="", то сначала вызывается метод, конвертирующий 
 //             QDiag в ^||CFX                                              
 //*************************************************************************
 //                     Структура массива с данными                         
 //*************************************************************************
 //^||CFX(0,0) - название оси X                                             
 //^||CFX(0,n) - значения по X                                              
 //^||CFX(numb,ID,0) - название серии                                       
 //^||CFX(numb,ID,N) - значения серии по Y                                  
 //     numb -  последовательная нумерация (1...50)                         
 //     ID   -  группировка серий значений (0...50)                         
 //             серии с одним ID, будут располагаться на одном графике      
 //     N    -  порядковый номер значения  (1...5000)                       
 //*************************************************************************
 //                     Глобальные настройки                                
 //*************************************************************************
 //^||CFX(ID,"Grid")        [0,1]   -   горизонтальные линии на графике     
 //^||CFX("AllowDrag")      [0,1]   -   редактирование графика              
 //^||CFX("DataEditor")     [0,1]   -   таблица с данными                   
 //^||CFX("AllowEdit")      [0,1]   -   редактирование таблицы с данными    
 //^||CFX("SerLegBox")      [0,1]   -   легенда                             
 //^||CFX("Scrollable")     [0,1]   -   прокрутка по оси Х                  
 //^||CFX("ToolBar")        [0,1]   -   тулбар                              
 //^||CFX("BackColor")      [RGB]   -   цвет фона                           
 //^||CFX("PointLabels")    [0,1]   -   подписи значений точек              
 //^||CFX("Chart3D")        [0,1]   -   отображать серии в 3Д               
 //^||CFX("Cluster")        [0,1]   -   разделение серий на кластеры в 3Д   
 //^||CFX("Titles")         [текст] -   заголовок графиков                  
 //^||CFX("AxisX.Format")   [0-8]   -   формат оси X                        
 //^||CFX("AxisY.Format")   [0-8]   -   формат оси Y                        
 //                             0   >   without format (по умолчанию)       
 //                             1   >   Number                              
 //                             2   >   Currency                            
 //                             3   >   Scientific                          
 //                             4   >   Percentage                          
 //                             5   >   Date                                
 //                             6   >   LongDate                            
 //                             7   >   Time                                
 //                             8   >   DateTime                            
 //*************************************************************************
 //                         Настройки серий                                 
 //*************************************************************************
 //^||CFX(numb  ,"Series.Gallery")  [0-20]  -   тип серии                   
 //^||CFX("Gallery")                [0-20]  -   глобальное свойства для     
 //всего экземпляра chart'а, задавать обязательно! должен совпадать с типом 
 //серии с индексом 0...но не уверен...:=) иначе неправильно считается      
 //масштаб по оси Х                                                         
 //                                     0   >   Bar (по умолчанию)          
 //                                     1   >   Lines                       
 //                                     2   >   Bar                         
 //                                     3   >   Area                        
 //                                     4   >   Scatter                     
 //                                     5   >   Pie                         
 //                                     6   >   Curve                       
 //                                     7   >   Pareto                      
 //                                     8   >   Step                        
 //                                     9   >   HiLowClose                  
 //                                     10  >   Surface                     
 //                                     11  >   Radar                       
 //                                     12  >   Cube                        
 //                                     13  >   Doughnut                    
 //                                     14  >   Pyramid                     
 //                                     15  >   Bubble                      
 //                                     16  >   OpenHiLowClose              
 //                                     17  >   Candlestick                 
 //                                     18  >   Contour                     
 //                                     19  >   CurveArea                   
 //                                     20  >   Gantt                       
 //^||CFX(numb  ,"Series.Color")    [RGB]   -   цвет серии                  
 //^||CFX(numb  ,"Series.LineWidth")[px]    -   толщина серии               
 //^||CFX(numb  ,"Series.LineStyle")[0-4]   -   стиль линии                 
 //                                     0   >   Solid (по умолчанию)        
 //                                     1   >   Dash                        
 //                                     2   >   Dot                         
 //                                     3   >   DashDot                     
 //                                     4   >   DashDotDot                  
 //*************************************************************************
 //                     Дополнительные элементы в графиках                  
 //*************************************************************************
 // ID  -   координатная плоскость      [0-50]                              
 // №   -   порядковый номер элемента   [0-50]                              
 // 1)  если относительно Y, то ID совпадает с ID из массива (например если 
 //     ID=0, то элемент будет распологаться на 1-м графике)                
 // 2)  если относительно X, то ID = -1                                     
 // 3)  для Sections № считается от 0 для каждого ID                        
 // 4)  для Stripes № считается последовательно от 0 независимо от ID       
 // 5)  для ConstantLines аналогично как и для Stripes                      
 //                                                                         
 //Sections                                                                 
 // ^||CFX(ID,№,"Sections")                 [0,1]   -   видимость           
 // ^||CFX(ID,№,"Sections.From")        [знач-ие]   -   знач-ие от          
 // ^||CFX(ID,№,"Sections.To")          [знач-ие]   -   знач-ие до          
 // ^||CFX(ID,№,"Sections.BackColor")       [RGB]   -   цвет фона секции    
 // ^||CFX(ID,№,"Sections.TextColor")       [RGB]   -   цвет текста         
 // ^||CFX(ID,№,"Sections.Gridlines")       [0,1]   -   линии сетки         
 // ^||CFX(ID,№,"Sections.Grid.Color")      [RGB]   -   цвет линий сетки    
 // ^||CFX(ID,№,"Sections.Grid.Width")      [px]    -   толщина линий сетки 
 // ^||CFX(ID,№,"Sections.FontStyle")       [...]   -   стиль шрифта секции 
 //                                             0   >   Regular             
 //                                             1   >   Bold                
 //                                             2   >   Italic              
 //                                             4   >   Underline           
 //                                             8   >   Strikeout           
 //Stripes                                                                  
 // ^||CFX(ID,№,"Stripes")                  [0,1]   -   видимость           
 // ^||CFX(ID,№,"Stripes.From")         [знач-ие]   -   от                  
 // ^||CFX(ID,№,"Stripes.To")           [знач-ие]   -   до                  
 // ^||CFX(ID,№,"Stripes.Color")            [RGB]   -   цвет зоны           
 //ConstantLines                                                            
 // ^||CFX(ID,№,"ConstantLines")=1          [0,1]   -   видимость           
 // ^||CFX(ID,№,"ConstantLines.Value")  [знач-ие]                           
 // ^||CFX(ID,№,"ConstantLines.Color")      [RGB]   -   цвет линии          
 // ^||CFX(ID,№,"ConstantLines.Text")       [текст] -   подпись линии       
 // ^||CFX(ID,№,"ConstantLines.TextColor")  [RGB]   -   цвет подписи        
 // ^||CFX(ID,№,"ConstantLines.Width")      [px]    -   толщина линии       
 // ^||CFX(ID,№,"ConstantLines.Alignment")  [0-2]   -   выравнивание текста 
 //                                             0   >   слева (по умолчанию)
 //                                             1   >   центр               
 //                                             2   >   справа              
 //*************************************************************************

    ;S:$G(qqpar1)="" qqpar1='$P($G(Vs(qqnump,13,"R"))," ",4)
    S:'$D(Arg1) Arg1=$P($G(Vs(qqnump,13,"R"))," ",2,6)
    N mas S mas=$s($g(masRef)'="":masRef,1:"^mtempCFX($J)")
    I $g(masRef)="" D  Q:'%1
    .   S %1=qSYS.CreArDi("A"_qview,1000) 
    .   D:$L(%1)>1 qARM.Message($E(%1,2,1000)) 
    .   D QDiagConverter
    I '$d(@mas@(0,0)) D qARM.Message("Массив с данными пустой.") Q

    N winP S winP=qARM.NewResW()
    N id,N,maxN,maxNum,maxID,i,num,ind,ind1,ind2,ind3
    D qARM.wC("TForm",winP),qARM.wP(,"Width",$s($g(Dx)="":800,1:Dx))
    D qARM.wP(,"Caption",$S($G(Name)="":"Диаграмма: "_$G(Vo(qqnump,-1)),1:Name))
    D qARM.wP(,"Height" ,$s($g(Dy)="":600,1:Dy))
    D qARM.wP(,"Position"   ,4)
    D qARM.wP(,"OnClose"    ,1)
    D qARM.wC("TChartfx62"  ,winP_".C")
    D qARM.wP(,"Align"      ,5)
    D qARM.wP(,"TopGap"     ,50)
    D qARM.wP(,"BottomGap"  ,50) 
    D qARM.wP(,"CrossHairs" ,1)
    D qARM.wP(,"Grid"       ,$s($g(@mas@(0,"Grid"))'="":@mas@(0,"Grid"),1:1))
    D qARM.wP(,"Zoom"       ,1)
    D qARM.wP(,"Gallery"    ,$s($g(@mas@("Gallery"))'="":@mas@("Gallery"),1:0))
    I $g(@mas@("Titles"))'="" D
    .   D qARM.wP(,"Titles.Text",@mas@("Titles"),0)
    .   D:$g(@mas@("Titles.TextColor"))'="" qARM.wP(,"Titles.TextColor",@mas@("Titles.TextColor"),0)
    .   D:$g(@mas@("Titles.Font.Size"))'="" qARM.wP(,"Titles.Font.Size",@mas@("Titles.Font.Size"),0)
    D qARM.wP(,"ToolBar"        ,$s($g(@mas@("ToolBar"))'="":       @mas@("ToolBar")    ,1:1))
    D qARM.wP(,"BackColor"      ,$s($g(@mas@("BackColor"))'="":     @mas@("BackColor")  ,1:256*256*256-1))
    D qARM.wP(,"DataEditor"     ,$s($g(@mas@("DataEditor"))'="":    @mas@("DataEditor") ,1:1))
    D qARM.wP(,"AllowDrag"      ,$s($g(@mas@("AllowDrag"))'="":     @mas@("AllowDrag")  ,1:0))
    D qARM.wP(,"AllowEdit"      ,$s($g(@mas@("AllowEdit"))'="":     @mas@("AllowEdit")  ,1:0))
    D qARM.wP(,"SerLegBox"      ,$s($g(@mas@("SerLegBox"))'="":     @mas@("SerLegBox")  ,1:1))
    D qARM.wP(,"LegendBox"      ,$s($g(@mas@("LegendBox"))'="":     @mas@("LegendBox")  ,1:0))
    D qARM.wP(,"Scrollable"     ,$s($g(@mas@("Scrollable"))'="":    @mas@("Scrollable") ,1:0))
    D qARM.wP(,"Chart3D"        ,$s($g(@mas@("Chart3D"))'="":       @mas@("Chart3D")    ,1:0))
    D qARM.wP(,"Cluster"        ,$s($g(@mas@("Cluster"))'="":       @mas@("Cluster")    ,1:0))
    D qARM.wP(,"PointLabels"    ,$s($g(@mas@("PointLabels"))'="":   @mas@("PointLabels"),1:0))
    D qARM.wP(,"AxisX.LabelsFormat.Format"  ,$s($g(@mas@("AxisX.Format"))'="":@mas@("AxisX.Format"),1:0))
    D qARM.wP(,"AxisY.DataFormat.Format"    ,$s($g(@mas@("AxisY.Format"))'="":@mas@("AxisY.Format"),1:0))
    ;D qARM.wP(,"DataEditorObj.HideXValues"  ,$s($g(@mas@("AxisX.Format"))=0:1,1:0))
    F id=0:1:50  D
    .   I id=0 S maxN=0 F N=1:1:5000 Q:'$d(@mas@(id,N))  S maxN=$i(maxN)
    .   I (id>0) D
    ..      F num=0:1:50 D 
    ...     F N=1:1:maxN D
    ....        I ($d(@mas@(id,num,N))) D
    .....           S maxID=id
    .....           S:num>$g(maxNum) maxNum=num 
    I $g(maxID)=""  S maxID=1
    I $g(maxNum)="" S maxNum=0
    D qARM.wM(,"OpenData",1,$s(maxID>1:(maxID-1),1:1),maxN)
    D qARM.wM(,"OpenData",6,$s(maxID>1:(maxID-1),1:1),maxN)
    D qARM.wP(,"AxisX.Title.Text",@mas@(0,0))
    I $g(maxNum)=0 D
    .   I $d(@mas@(maxNum,"Panes.Title.Text")) D
    ..      D qARM.wP(,"Panes.Separation"   ,40     ,maxNum)
    ..      D qARM.wP(,"Panes.Title.Text"   ,@mas@(maxNum,"Panes.Title.Text"),maxNum)
    ..      I $d(@mas@(maxNum,"Panes.Title.TextColor")) D qARM.wP(,"Panes.Title.TextColor",@mas@(maxNum,"Panes.Title.TextColor"),maxNum)
    ..      I $d(@mas@(maxNum,"Panes.Title.Font.Size")) D qARM.wP(,"Panes.Title.Font.Size",@mas@(maxNum,"Panes.Title.Font.Size"),maxNum)
    I $g(maxNum)>0 D
    .   F i=0:1:(maxNum-1) D
    ..      D qARM.wP(,"Axis.Pane"          ,(i+1)  ,(i+3))
    ..      D qARM.wP(,"Axis.Position"      ,0      ,(i+3))
    ..      D qARM.wP(,"Axis.Gridlines"     ,$s($g(@mas@((i+1),"Grid"))'="":@mas@((i+1),"Grid"),1:1)        ,(i+3))
    ..      D qARM.wP(,"Panes.Separation"   ,40     ,i) 
    ..      I $d(@mas@(i,"Panes.Title.Text"))       D qARM.wP(,"Panes.Title.Text"       ,@mas@(i,"Panes.Title.Text")        ,i)
    ..      I $d(@mas@(i,"Panes.Title.TextColor"))  D qARM.wP(,"Panes.Title.TextColor"  ,@mas@(i,"Panes.Title.TextColor")   ,i)
    ..      I $d(@mas@(i,"Panes.Title.Font.Size"))  D qARM.wP(,"Panes.Title.Font.Size"  ,@mas@(i,"Panes.Title.Font.Size")   ,i)
    .   I $d(@mas@(maxNum,"Panes.Title.Text")) D
    ..      D qARM.wP(,"Panes.Separation"   ,40     ,maxNum)
    ..      D qARM.wP(,"Panes.Title.Text"   ,@mas@(maxNum,"Panes.Title.Text"),maxNum)
    ..      I $d(@mas@(maxNum,"Panes.Title.TextColor")) D qARM.wP(,"Panes.Title.TextColor",@mas@(maxNum,"Panes.Title.TextColor"),maxNum)
    ..      I $d(@mas@(maxNum,"Panes.Title.Font.Size")) D qARM.wP(,"Panes.Title.Font.Size",@mas@(maxNum,"Panes.Title.Font.Size"),maxNum) 
    F id=1:1:50 D
    .   I $g(@mas@((id-1),"ConstantLines"))=1 D ConstantLines(id-1)
    .   I $g(@mas@((id-1),"Stripes"))=1 D Stripes((id-1))
    .   F num=0:1:50 D
    ..      I (id=1) D 
    ...         I ($g(@mas@(-1,num,"Sections")))        D Sections(-1,num)
    ...         I ($g(@mas@(-1,num,"ConstantLines")))   D ConstantLines(-1,num)
    ...         I ($g(@mas@(-1,num,"Stripes")))         D Stripes(-1,num)
    ..      I ($g(@mas@((id-1),num,"Sections")))        D Sections((id-1),num)
    ..      I ($g(@mas@((id-1),num,"ConstantLines")))   D ConstantLines((id-1),num)
    ..      I ($g(@mas@((id-1),num,"Stripes")))         D Stripes((id-1),num)
    ..      F N=1:1:maxN D:($d(@mas@(id,num,N)))&($d(@mas@(0,N))) 
    ...         D qARM.wP(,"Value", @mas@(id,num,N),id-1,N-1)
    ...         I $g(@mas@("AxisX.Format"))=0   D qARM.wP(,"XValue",N,id-1,N-1),qARM.wP(,"Axis.Label",@mas@(0,N),2,N-1),qARM.wP(,"Legend",@mas@(0,N),N-1)
    ...         I $g(@mas@("AxisX.Format"))'=0  D qARM.wP(,"XValue",@mas@(0,N),id-1,N-1) D:$g(@mas@("AxisX.Labels")) qARM.wP(,"Axis.Label",@mas@(0,N),2,N-1) D:$g(@mas@("Legend")) qARM.wP(,"Legend",@mas@(0,N),N-1)
    ...         D qARM.wP(,"SerLeg",@mas@(id,num,0) ,id-1)
    ...         I $g(@mas@(id,"Series.Gallery"))'=""    D qARM.wP(,"Series.Gallery"     ,@mas@(id   ,"Series.Gallery")  ,id-1)
    ...         I $g(@mas@(id,"Series.Color"))'=""      D qARM.wP(,"Series.Color"       ,@mas@(id   ,"Series.Color")    ,id-1)
    ...         I $g(@mas@(id,"Series.LineWidth"))'=""  D qARM.wP(,"Series.LineWidth"   ,@mas@(id   ,"Series.LineWidth"),id-1)
    ...         I $g(@mas@(id,"Series.LineStyle"))'=""  D qARM.wP(,"Series.LineStyle"   ,@mas@(id   ,"Series.LineStyle"),id-1)
    F id=1:1:50 D
    .   F num=0:1:50 D
    ..      I (num>0)&($d(@mas@(id,num,0))) D
    ...         D qARM.wP(,"Series.YAxis",(num+2),(id-1))
    D qARM.wM(,"CloseData",6)
    D qARM.wM(,"CloseData",1)
    D qARM.wM(winP,"Show")
    K @mas
    Q:$Q "" Q
 
Stripes(ind1,ind2)
    S ind3=ind1
    I ind1=-1   S ind3=2
    I ind1>0    S ind3=ind1+2
    D qARM.wP(,"Stripes.Axis",ind3,ind2)
    I $g(@mas@(ind1,ind2,"Stripes.From"))'=""   D qARM.wP(,"Stripes.From"   ,@mas@(ind1,ind2,"Stripes.From")    ,ind2)
    I $g(@mas@(ind1,ind2,"Stripes.To"))'=""     D qARM.wP(,"Stripes.To"     ,@mas@(ind1,ind2,"Stripes.To")      ,ind2)
    I $g(@mas@(ind1,ind2,"Stripes.Color"))'=""  D qARM.wP(,"Stripes.Color"  ,@mas@(ind1,ind2,"Stripes.Color")   ,ind2)
    Q
ConstantLines(ind1,ind2)
    S ind3=ind1
    I ind1=-1   S ind3=2
    I ind1>0    S ind3=ind1+2
    D qARM.wP(,"ConstantLines.Axis",ind3,ind2)
    I $g(@mas@(ind1,ind2,"ConstantLines.Value"))'=""        D qARM.wP(,"ConstantLines.Value"        ,@mas@(ind1,ind2,"ConstantLines.Value")         ,ind2)
    I $g(@mas@(ind1,ind2,"ConstantLines.Color"))'=""        D qARM.wP(,"ConstantLines.Color"        ,@mas@(ind1,ind2,"ConstantLines.Color")         ,ind2)
    I $g(@mas@(ind1,ind2,"ConstantLines.Text"))'=""         D qARM.wP(,"ConstantLines.Text"         ,@mas@(ind1,ind2,"ConstantLines.Text")          ,ind2)
    I $g(@mas@(ind1,ind2,"ConstantLines.TextColor"))'=""    D qARM.wP(,"ConstantLines.TextColor"    ,@mas@(ind1,ind2,"ConstantLines.TextColor")     ,ind2)
    I $g(@mas@(ind1,ind2,"ConstantLines.Alignment"))'=""    D qARM.wP(,"ConstantLines.Alignment"    ,@mas@(ind1,ind2,"ConstantLines.Alignment")     ,ind2)
    I $g(@mas@(ind1,ind2,"ConstantLines.Width"))'=""        D qARM.wP(,"ConstantLines.Width"        ,@mas@(ind1,ind2,"ConstantLines.Width")         ,ind2)
    I $g(@mas@(ind1,ind2,"ConstantLines.OutsideText"))'=""  D qARM.wP(,"ConstantLines.OutsideText"  ,@mas@(ind1,ind2,"ConstantLines.OutsideText")   ,ind2)
    I $g(@mas@(ind1,ind2,"ConstantLines.Style"))'=""        D qARM.wP(,"ConstantLines.Style"        ,@mas@(ind1,ind2,"ConstantLines.Style")         ,ind2)
    Q
Sections(ind1,ind2)
    S ind3=ind1
    I ind1=-1   S ind3=2
    I ind1>0    S ind3=ind1+2
    I $g(@mas@(ind1,ind2,"Sections.From"))'=""          D qARM.wP(,"Axis.Sections.From"         ,@mas@(ind1,ind2,"Sections.From")       ,ind3,ind2)
    I $g(@mas@(ind1,ind2,"Sections.To"))'=""            D qARM.wP(,"Axis.Sections.To"           ,@mas@(ind1,ind2,"Sections.To")         ,ind3,ind2)
    I $g(@mas@(ind1,ind2,"Sections.BackColor"))'=""     D qARM.wP(,"Axis.Sections.BackColor"    ,@mas@(ind1,ind2,"Sections.BackColor")  ,ind3,ind2)
    I $g(@mas@(ind1,ind2,"Sections.FontStyle"))'=""     D qARM.wP(,"Axis.Sections.FontStyle"    ,@mas@(ind1,ind2,"Sections.FontStyle")  ,ind3,ind2)
    I $g(@mas@(ind1,ind2,"Sections.TextColor"))'=""     D qARM.wP(,"Axis.Sections.TextColor"    ,@mas@(ind1,ind2,"Sections.TextColor")  ,ind3,ind2)
    I $g(@mas@(ind1,ind2,"Sections.Gridlines"))'=""     D qARM.wP(,"Axis.Sections.Gridlines"    ,@mas@(ind1,ind2,"Sections.Gridlines")  ,ind3,ind2)
    I $g(@mas@(ind1,ind2,"Sections.Grid.Color"))'=""    D qARM.wP(,"Axis.Sections.Grid.Color"   ,@mas@(ind1,ind2,"Sections.Grid.Color") ,ind3,ind2)
    I $g(@mas@(ind1,ind2,"Sections.Grid.Width"))'=""    D qARM.wP(,"Axis.Sections.Grid.Width"   ,@mas@(ind1,ind2,"Sections.Grid.Width") ,ind3,ind2)
    Q
QDiagConverter
    N id,N,num,date,datetime,xLabel
    F id=0:1:50  D
    .   I id=0 F N=0:1:5000 Q:'$d(QDiag(id,N))  D 
    ..      S ^mtempCFX($J,id,N)=$tr(QDiag(id,N),"~",";")
    ..      S xLabel=$p(QDiag(id,N),"~")
    ..      ;I ($l($e(xLabel,1,8))=8)&($e(xLabel,1,8)?8N) D 
    ...     ;   S date=1
    ...     ;   I ($l($e(xLabel,9,12))=4)&($e(xLabel,9,12)?4N) S datetime=1
    ...     ;   D DateConverter(id,N)
    .   I (id>0) D
    ..      S num=0 F N=0:1:5000 Q:'$d(QDiag(id,N))  D
    ...         S:N=0 ^mtempCFX($J,id,num,N)=QDiag(id,N)
    ...         S:N>0 ^mtempCFX($J,id,num,N)=$p(QDiag(id,N)," ")
    S ^mtempCFX($J,"AxisX.Format")=0
    S ^mtempCFX($J,"ToolBar")=0
    S ^mtempCFX($J,"SerLegBox")=0
    S ^mtempCFX($J,"DataEditor")=0
    ;S ^mtempCFX($J,"Titles")="Диаграмма CFX"
    ;S ^mtempCFX($J,"Titles.Font.Size")=18
    S ^mtempCFX($J,"Scrollable")=0
    I $g(date) S ^mtempCFX($J,"AxisX.Format")=5
    I $g(datetime) S ^mtempCFX($J,"AxisX.Format")=8
    I $p($g(Vs(qqnump,13,"R"))," ",2)=0 S ^mtempCFX($J,"Gallery")=0
    I $p($g(Vs(qqnump,13,"R"))," ",2)=1 S ^mtempCFX($J,"Gallery")=20
    I $p($g(Vs(qqnump,13,"R"))," ",2)=2 S ^mtempCFX($J,"Gallery")=5
    I $p($g(Vs(qqnump,13,"R"))," ",2)=3 S ^mtempCFX($J,"Gallery")=1
    I $p($g(Vs(qqnump,13,"R"))," ",2)=4 S ^mtempCFX($J,"Gallery")=4
    I '$p($g(Vs(qqnump,13,"R"))," ",3) S ^mtempCFX($J,"Chart3D")=1,^mtempCFX($J,"Cluster")=1
    I '$p($g(Vs(qqnump,13,"R"))," ",4) S ^mtempCFX($J,"ToolBar")=1
    I '$p($g(Vs(qqnump,13,"R"))," ",5) S ^mtempCFX($J,"LegendBox")=1
    I '$p($g(Vs(qqnump,13,"R"))," ",6) S ^mtempCFX($J,"DataEditor")=1
    Q
DateConverter(id,N)
    N date,time
    S date=$e(xLabel,1,8),time=$e(xLabel,9,12) 
    I (time'="") D 
    .   S time=$e(time,1,2)_":"_$e(time,3,4)
    .   S time=$ztimeh(time,2)
    S date=$zdateh(date,8),time=$s(time'="":time,1:$p($h,",",2))
    S ^mtempCFX($J,id,N)=(date-21549)+((time)/86400)
    Q
]]></Implementation>
</Method>

<Method name="OpenCHelp">
<Description>
Выдача окна пояснений по компонентам qWORD.
$E(comp) = W - понятие, O -объект, V - отображение
затем, код компоненты. Для понятия - кодпонятия_"_"_кодобъекта
Если comp=2, то пояснения по текущему понятию.</Description>
<Internal/>
<FormalSpec>comp:%String,Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $G(Vo(qqnump))="XXX0" S comp="VXXX0" ;пояснения для пояснений
 I comp=1 D   ;ячейка дерева объектов
 .I $G(W("Zpos",1,"x"))=1 S comp="WX798" Q
 .I $G(W("Zpos",1,"x"))>0 D ..OpenDHelp("1,0,"_W("Zpos",1,"x")) S comp="" Q
 .S comp=$P($G(W("Zpos",1,"d"))," ",2)
 .I comp="" S comp="O"_$P($G(W("Zpos",1,"d"))," ",1) S:comp="O" comp="V"_Vo(qqnump) I 1
 .E  S comp="W"_comp_"_"_$P(W("Zpos",1,"d")," ",1)
 I comp=2 D  ;ячейка дерева экземпляров
 .N qqX D  ;@dol 8.12.03
 ..I $D(Arg1) S qqX=Arg1 Q
 ..S qqX=$G(W("Zpos",2,"x"),-1)
 .S %1=..GetPar(174) ;I $P(%1," ",3)'="" S comp="W"_$P(%1," ",3) Q
 .I '$D(W("Zpos",2,"d")) S comp=$S($P(%1," ",3)'="":"W"_$P(%1," ",3),1:"") Q
 .N qqo S qqo=$P(W("Zpos",2,"d")," ",2)
 .;S comp=$S(qqo=""!(qqo=-1):$S($P(%1," ",1)'="":"W"_$P(%1," ",1),1:"V"_Vo(qqnump)),qqX<0:$S($P(%1," ",2)'="":"W"_$P(%1," ",2),1:"O"_qqo),1:$S($P(%1," ",1)'="":"W"_$P(%1," ",1),1:"WZs"_$P(W("Zpos",2,"d")," ",3)_"c"_qqX_"_"_qqo))
 .S comp=$S(qqo="":$S($P(%1," ",1)'="":"W"_$P(%1," ",1),1:"V"_Vo(qqnump)),qqX<0:$S($P(%1," ",2)'="":"W"_$P(%1," ",2),1:"O"_qqo),1:$S($P(%1," ",1)'="":"W"_$P(%1," ",1),1:"WZs"_$P(W("Zpos",2,"d")," ",3)_"c"_qqX_"_"_qqo))
 .I comp'="",$E(comp)'="V" D  ;@dol 23.07.03
 ..D
 ...I $E(comp)="O" S Vs("par","Name")=..GetName(,qqo) Q
 ...S Vs("par","Name")=..GetPar(7100,,qqo,$P(W("Zpos",2,"d")," ",3),qqX) Q:$TR(Vs("par","Name")," ")'=""
 ...I $E(comp,1,3)'="WZs" S Vs("par","Name")=..GetName(,qqo,$E(comp,2,255))
 ..N qqref,qqtr,qqo,qqvv S qqvv=$G(Vo(qqnump,$P(W("Zpos",2,"d")," ",2),889)) S:qqvv="" qqvv=Vo(qqnump) S qqo=$S($E(comp)="O":"CxObj",1:"Xx"),qqtr=+$G($$$Tree),$$$Tree=1,qqref=$S($E(comp)="O":$NA(^Q(1,"XView",qqvv)),1:$NA(^Q(1,"XView",qqvv,"CxObj",$P(W("Zpos",2,"d")," ",2),"Xy",$P(W("Zpos",2,"d")," ",3)))) ;@dol 16.06.04 qqvv
 ..S Vs("par","Thlp")=$S($E(comp)="O":qW.GT("CxObj","Thlp",$P(W("Zpos",2,"d")," ",2)),1:qW.GT("Xx","Thlp",qqX)),$$$Tree=qqtr
 .I $E($G(Vs("par","Thlp")))="@" S Vs("par","Thlp")="Аналог "_$E($P(Vs("par","Thlp")," "),2,255)_" "_$TR(qW.GetWoc($S($E(comp)="O":"CxObj",1:"CxWoc"),$E($P(Vs("par","Thlp")," "),2,255)),"_"," ")_$C(13,10)_qW.GT($S($E(comp)="O":"CxObj",1:"CxWoc"),"Thlp",$E($P(Vs("par","Thlp")," "),2,255)) ;@dol 10.11.03 ссылка на описание
 I comp="" D ..Message("Нет фокуса на ячейке") Q:$Q "" Q
 ;
 I $E(comp,2,5)="" S comp=comp_$S($E(comp)="V":Vo(qqnump),$E(comp)="O":qqo,1:qqw)
 I $E(comp,2,5)="XXX0",$G(Vo(qqnump))'="XXX0" D ..OpenVHelp() Q:$Q "" Q  ;D ..OpenWindow(,,,,,"XXX0") Q "" ; Help по приложению
 S Vo("par",-1,73)=3 ;Выход по потере фокуса 
 I '$G(qqXBNHelp) D ..OpenWindow(,,",,0,11 1 10",,,"###sysC"_comp) Q:$Q "" Q
 D qARM.wM("-qARM","HintWindow",600,400,1,qSYS.TextHelpRTF(,comp)) Q:$Q "" Q  ;@Sveta 23.05.05
]]></Implementation>
</Method>

<Method name="OpenDHelp">
<Description>
Вызов раздела документации.
part - идентификатор раздела (через запятую).</Description>
<Internal/>
<FormalSpec>part:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N ref,iref
 I $P(part,",",2)>99,$P(part,",",2)<105 D  Q:$Q "" Q  ;кнопки дополнительной панели
 .S ref="^Q(1,""XView"","""_Vo(qqnump)_""",""XMenu"","_($P(part,",",2)-101)_")"
 .I '$D(@ref) S @ref="" ;подправим пропущенные пункты
 .S Vs("par",99,"Pic")=1
 .D ..OpenWindow(,,",,0,11 1 20","XMenu"_" "_(104-$P(part,",",2))_"  "_ref_" XMenu",,"XXXXVMenu")
 S ref="^Q(1" F iref=1:1:$L(part,",") S ref=ref_",""XDoc"_$S(iref'=1:"H",part>9:"S",1:"H")_iref_""","_$P(part,",",iref)
 S ref=ref_")",Vs("par",99,"Pic")=1
 D ..OpenWindow(,,",,0,11 1 20","XDoc"_$S(iref'=1:"H",part>9:"S",1:"H")_iref_" "_$P(part,",",iref)_"  "_ref_" XDoc"_$S(iref'=1:"H",part>9:"S",1:"H")_iref,,"XXX"_$S(part>9:"S",1:"")_"Docw") Q:$Q "" Q  ;,1) ???
]]></Implementation>
</Method>

<Method name="OpenDate">
<Description>
Вызов окна календаря с возможностью выбора даты
Date - начальная дата (не задана - текущая)
qqw - код понятия куда возвращается выбранная дата. Т.е дата возвращается в W(qqw).
Если режим редактирования и не Z*-понятие, то добавляется в qqwchg.
Xec - действие (по Xecute) выполняемое после выбора.</Description>
<Internal/>
<FormalSpec>Date:%Library.String,qqw:%Library.String,Xec:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S Vo("par",-1,23)="S W(""ZBtred"")=1,W(""ZZxcute"")=""S qqend=1"",W(""ZZdate"")=$S($G(qqp4)="""":$ZD($H,8),1:qqc) D qW.oZZdate()"
 S Vo("par",-1,73)=1,Vo("par",-1,72)="0 "_$S($G(qqw)="":"",1:"S W("""_qqw_""")=WS(qqnumpold,""ZZdate"")"_$S($E(qqw)="Z":"",1:" S:$G(W(""ZBtred"")) qqwchg=qqwchg_"" ""_"""_qqw_""""))_$S($G(Xec)="":"",1:" "_Xec)
 D qARM.OpenWindow(,,",,0,11,,1,,,,0,3",$G(Date),,"XXXDate") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenDialog">
<Description>
Метод вызывается клиентом по завершению выбора файлов (Открыть) в окне диалога.
Выбранные файлы в qARM("qpars",N) где N=0,1... порядковые номера выборов.</Description>
<Internal/>
<FormalSpec>Sender:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 D ..Value($G(qxecuted),"X")
 Q ""
]]></Implementation>
</Method>

<Method name="OpenDoc">
<Description><![CDATA[
Редактор текста (документа).
qqpar1 - ссыка на массив, или код понятия ???
qqpar2 = 1 с возможностью редактирования, 2 - модификация без подтверждения
qqpar3 = dx,dy. (1 - во весь экран). Для развертки берутся из параметров, для Richnew - Параметры окна см X129.
qqpar4 - заголовок окна
qqpar5 - фонт и размер символа 9через запятую). Для развертки берутся из параметров. //в Richnew не работает
qqpar6 - 0 или не задан RichText old, Richnew - 3
1 - MSWord
2 - MSWordPad
Пример Richnew:
в методе qARM.s112
D ..OpenDoc(,$P(W("Zdrl")," ",4), $P(W("Zdrl")," ",1), ..GetName(,$$$CurObj,qqw), $P(W("Zdrl")," ",3), $P(W("Zdrl")," ",5), $P(W("Zdrl")," ",6),,,,,$S('$G(W("ZBtred")):0,$P(W("Zdrl")," ",4)=0:0,1:1)_" 2 0% 0% 100% 100% 1 3 1 "_$P(W("Zdrl")," ",9)_" 0 1 0")
qqpar7 - ограничение на длину слова (в символах). По умолчанию - 150   //в Richnew не работает
для Richnew qqpar9 - параметр Кнопки выхода, 
           qqpar10   - Действие по выбору
           qqpar11   - Действие по невыбору.
qqpar12 - параметры стиля ячейки ввода Richnew X761
Варианты вывода и сохранения данных в qqpar12 работают в формате: 
хранение->вывод->сохранение
XML->RTF->XML
RTF->RTF->RTF
qsec - массив для WP]]></Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String,qqpar3:%String,qqpar4:%String,qqpar5:%Library.String,qqpar6:%Library.String,qqpar7:%Library.String,qsec:%Library.String,qqpar9:%Library.String,qqpar10:%Library.String,qqpar11:%Library.String,qqpar12:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 s:(+$G(qqpar6)=0)&&(+$G(qqXBREnew)=1) qqpar6=3
 ;;@Sas 20091019 вставил $G(Vo(qqnump)) ибо народ запускает этот метод при постдействии
 i $G(Vo(qqnump))="XXXRich" q ""
 I $G(qqpar3)=1 S qqpar3=qARM("Screen","Width")_","_qARM("Screen","Height") ;@Dol 05.04.11 во весь экран
 S qqpar3=$G(qqpar3),qqpar5=$G(qqpar5) s qqpar6=$S($G(qqXBOpenDoc)=1:2,1:$G(qqpar6,0)) 
 D:$G(qqpar1)'=""
 .I $G(qqred)'="" N q743 S q743=..GetPar(743,,$$$CurObj,qqw) I q743 D ..wM("-qARM","ChangeLanguage",$S(q743=1&(qqlang=1)!(q743=3):"00000419",1:"00000409")) ;рус англ OOOOO409
 .I $G(qqpar6)'=3 I $G(qqpar3)="" S qqpar3=$P($S($G(qqred)'="":W("Zldrl"),$G($$$CurObj)="":"",1:..GetPar(73,,$$$CurObj,qqw))," ")
 .I $G(qqpar5)="" S qqpar5=$P($S($G(qqred)'="":W("Zldrl"),$G($$$CurObj)="":"",1:..GetPar(73,,$$$CurObj,qqw))," ",3) ;@Dol 26.02.10 ???? 
 I $G(qqpar1)="" S qqpar1=$S(qqred=""!($E(qqw,1,2)="TB"):qW.GT(qqo,qqw,qqc,-1),1:"W(qqw)"),qqpar1=$NA(@qqpar1) S:$G(qqpar2)="" qqpar2=$S(qqred=qqw:$E(qqw,1,2)'="TB"+1,1:0)
 i $G(qqpar6)'=3 N winP G:$G(qqpar6)=2 OpenDocWp S winP=..NewResW() S:'qqpar3 qqpar3="470,200"
 I $G(qqpar6)'=3 I $G(qqXBwsize),'$P($G(Vo(qqnump,-1,29)),",",21),$P($G(qqX155),",",2)>8 S qqpar3=..wsize(qqpar3) ;@Dol 21.07.09
 
 ;;запуск нового rich
 G:$G(qqpar6)=3 RichNew
 D:+$G(qqpar6)=0
 .I $TR($G(qqpar5)," ")="" D ..wC("TRichForm",winP,'$G(qqpar2),"","") I 1  ;@Dima ,"","")
 .E  D ..wC("TRichForm",winP,'$G(qqpar2),$TR($P(qqpar5,","),"_"," "),$P(qqpar5,",",2)) ;с фонтом
 .D ..wP(,"Width",$S(qqpar3<470:470,1:+qqpar3)),..wP(,"Height",$S($P(qqpar3,",",2)<100:100,1:+$P(qqpar3,",",2))),..wP(,"Position",4),..wP(,"OnClose",1)
 D:$G(qqpar6)=1
 .D qARM.wC("TMSWord",winP,$S($P(qqpar3,",",2)<100:100,1:+$P(qqpar3,",",2)),$S(qqpar3<470:470,1:+qqpar3),$TR($P($G(qqpar5),","),"_"," "),$P($G(qqpar5),",",2))
 ;.;D ..wP(,"OnClose",1)
 D ..wP(winP,"MaxWord",$S('$G(qqpar7):150,1:qqpar7)) ;@Dol 19.12.05
 N envb d ..wM("-qARM","BufferClear")
 I $E(qqpar1,1,2)="W(","TY"'[$E(qqw),$P(W("Zdrl")," ",2)="" S @qqpar1@(0)=$G(@qqpar1) ;07.04.08 $P(W("Zdrl")," ",2)="" если не редактирование строк объекта@Dol 08.03.08 для редактирование нетекстовых понятий
 s envb=$O(@qqpar1@(""),-1)
 d ..wM(,"Buffer"_$S(envb>0:"",1:1),qqpar1,$S(envb="":0,1:envb))
 D ..wP(winP,"Caption",$S($G(qqpar4)'="":qqpar4,1:"Текст"))
 ;не работает D ..wP(winP_".RE","ReadOnly",'$G(qqpar2))
 D:'$G(qqpar6) ..wM(winP,"Show")
 ;D ..wM(winP_".RE","Text","")
 D ..wM(winP,"ReadV") ;:$D(@qqpar1)>1
 I $G(qqpar6)=1 D:'$G(qqpar2) ..wM(winP,"MakeReadOnly") D ..wP(winP,"Visible",1)
 I $G(qqpar2) S W("ZredB")="1 "_winP_" "_$G(qqpar2)_" "_qqpar1
 Q:$Q "" Q
RichNew
 ;@Sas 20091006 открытие Rich в контейнере
 //имя окна
 s:$G(qqpar4)="" qqpar4=..GetName(,Vs(qqnump,"CurObj"),qqw)
 s Vo("par",-1)=$S(qqpar4'="":"-"_qqpar4,1:"-RichEditText")
 //параметры окна, авторазмеры, max строк в ячейке
 S qqpar3=$S($G(qqpar3)'="":qqpar3,1:"340,200,0,11,2,1")
 //qqpar2 - аналог qqpar4 OpenWindow
 s qqpar21=$S($G(qqpar2)'="":qqpar2,1:"1 XXXRichEdit 1")
 //qqpar8
 ;автовыбор всегда
 s Vo("par",-1,73)=2
 s Vo("par",-1,720)=$G(qqpar9,$S(+$G(qqpar2)=0:0,1:1))
 //s Vo("par",-1,22)=$S($G(qqpar10)'="":qqpar10,1:$S($G(qqpar2):"m "_qqpar1_"=MasTxT",1:""))
 ;действие по невыбору сброс изменений
 s Vo("par",-1,722)=$G(qqpar11,"K W(""ZredB"") S qqred=""""")
 ;проверять если данные в массиве W, то создавать ^mtempRichEdit($J,"TRichEdit")
 k ^mtempRichEdit($J,"TRichEdit")
 n qqpar01
 s qqpar01=qqpar1
 i $E(qqpar1,1,2)="W(" d
 .i $E(qqpar1,4)="T" m ^mtempRichEdit($J,"TRichEdit")=@qqpar1 
 .e  s ^mtempRichEdit($J,"TRichEdit",0)=@qqpar1
 s qqpar1="^mtempRichEdit("_$J_",""TRichEdit"")"
 //параметры встроенного rich
 s Vo("par","XXXRichEdit",0,0,0,60)="RE"
 n x,qqcW
 
 s qqpar12=$S($G(qqpar12)'="":qqpar12,1:$G(W("ZBtred"),0)_" 2 0% 0% 100% 100% 1 3 1  0 1 0")
 

 //преобразование XML в RTF
 i $G(qqpar12)'="" i $P(qqpar12," ",10)=2 d
 .s qqcW="",x=-1 f  s qqcW=$O(@qqpar01@(qqcW)) q:qqcW=""  d
 ..s @qqpar1@($i(x))=qW.CRTF(@qqpar01@(qqcW),,1)
 ..s:@qqpar1@(x)'="" @qqpar1@(x)=$TR(@qqpar1@(x),"_"," ")
 
 s Vo("par","XXXRichEdit",0,0,0,61)=$S($G(qqpar12)'="":qqpar12,1:$G(W("ZBtred"),0)_" 2 0% 0% 100% 100% 1 3 1  0 1 0")
 ;действие по выходу
 I $G(qqpar2) S W("ZredB")="2 "_qwin_" "_$G(qqpar2)_" "_qqpar01_" "_qqw_" "_$P(Vo("par","XXXRichEdit",0,0,0,61)," ",10)
 
 s Vo("par",-1,72)="0 D:$G(W(""ZredB""))'="""" qARM.EditDocRE()"
 
 s Vo("par",-1,23)="k ^mtempRichEdit("_$J_"_qqnump) m ^mtempRichEdit("_$J_"_qqnump,""TRichEdit"")="_qqpar1_" k ^mtempRichEdit("_$J_",""TRichEdit"")"  ;;_" d qARM.wC(""TTreeRichEdit"",qwin_"".RICH1"",qwin_"".T2"",""AA XXXRichEdit 0"",1,""0%"",""100%""),..wP("".."",""Visible"")"
 //s Vo("par",-1,23)="k ^mtempRichEdit("_$J_"_qqnump) s W(""ZredB"")="""_"1 "_qwin_" "_$G(qqpar2)_" "_qSYS.dblqw(qqpar01)_""" m ^mtempRichEdit("_$J_"_qqnump,""TRichEdit"")="_qqpar1_" k ^mtempRichEdit("_$J_",""TRichEdit"")"  ;;_" d qARM.wC(""TTreeRichEdit"",qwin_"".RICH1"",qwin_"".T2"",""AA XXXRichEdit 0"",1,""0%"",""100%""),..wP("".."",""Visible"")"
 d qARM.csav()
 D ..OpenWindow(,,qqpar3,qqpar21,,"XXXRich")
 Q:$Q "" Q
 ;@vol20101004 открытие WordPad
OpenDocWp
 N winP S winP="QVWordpad"_$TR($ZTS,".,")
 d ..wC("TForm",winP)
 d ..wC("TqARMSRGraphVDisp",winP_".vg1")
 d ..wM("..","0InitInterfaces")
 d ..wM("..","SetServerDispatch")

 d ..wM("..","GetICSingleDocTemplate.VolCreateWordPad",-1)
 d ..wM("..","0SetObjRef",0) //Obj(0) - CSingleDocTemplate
 d ..wM("..","GetICSingleDocTemplate.OpenDocumentFile","",1)

 d ..wM("..","AppAddDocTemplate",0)
 d ..wM("..","ShowMainWindow",0)

 d ..wM("..","GetICMemFile.VolCreate",-1) //Obj(1) - CMemFile
 d ..wM("..","0SetObjRef",1)
 
 n x
 i $L($O(@qqpar1@(""),-1)) s x=@qqpar1@($O(@qqpar1@(""),-1)) d
 .i $E(x,1,2)=$C(3,4) d
 ..s:'$D(qsec(8)) qsec(8)=$Li(x,1)
 ..s:'$D(qsec(2)) qsec(2)=$Li(x,2)
 ..s:'$D(qsec(3)) qsec(3)=$Li(x,3)
 ..s:'$D(qsec(4)) qsec(4)=$Li(x,4)
 ..s:'$D(qsec(5)) qsec(5)=$Li(x,5)
 
 /* 
 qsec(0) -> SignerName
 qsec(1) -> CertStoreName
 qsec(2) -> IsEncoded
 qsec(3) -> docyment type
 qsec(4) -> radix
 qsec(5) -> code page
 qsec(6) -> read only
 qsec(7) -> Modified Flag
 qsec(8) -> IsSigned
 qsec(9) -> Global save as
 qsec(10) -> SetSaveDocEnable

 $LB(x1,x2,x3,x4,x5)
 x1 -> 1 -signed
 x2 -> 1 -encoded
 x3 -> docyment type
 x4 -> radix 16
 x5 -> code page cp
 
 sample:
 n sec s sec(0)="sasha",sec(1)="My",sec(2)=1,sec(3)=5,sec(4)=16,sec(5)="cp1251"
 d ..wM("..","GetICMemFile.Write","{\rtf1\ansi\ansicpg1251\deff0\deflang1049{\fonttbl{\f0\fswiss\fcharset204{\*\fname Arial;}Arial CYR;}{\f1\fmodern\fprq1\fcharset204{\*\fname Courier New;}Courier New CYR;}{\f2\fmodern\fprq1\fcharset0 Courier New;}} {\colortbl ;\red255\green0\blue0;} \viewkind4\uc1\pard\b\f0\fs32\'cf\'e0\'f8\'e0\b0\fs20  \i\f1\'f0\'f3\'eb\'e5\'e7 \'f4\'ee\'f0\'e5\'e2\'e0 \i0\f0\'ed\'ee \'ee\'ed \cf1\ul\b\i\f1\fs36\'\par}") 
 
 */
 
 ;vol20101123
 i $D(@qqpar1)>1  d ..wM("..","GetICMemFile.WriteByRef",qqpar1,'$D(qsec),'$D(qsec)) i 1
 e  d ..wM("..","GetICMemFile.Write"," ") 
  
 i $G(qsec(3))=4 d ..wM("..","GetICMemFile.zUtoA")
 d ..wM("..","GetICMemFile.SeekToBegin")
 i ($E($G(x),1,2)=$C(3,4))!($L($G(qsec(8)))) d ..wM("..","GetICMemFile.decryptStreem",$G(qsec(2),0)) i $G(qsec(3))=4 d ..wM("..","GetICMemFile.zUtoA")

 d ..wM("..","GetICArchive.VolCreate",-1,1,1) //Obj(2) - CArchive
 d ..wM("..","0GetMainWin")
 d ..wM("..","GetICFrameWnd.GetActiveDocument")
 d ..wM("..","GetICWordPadDoc.SetSaveToServer",1)
 d ..wM("..","GetICWordPadDoc.SetBufferSize",15000)
 d ..wM("..","GetICWordPadDoc.SetWinName",winP)
 d ..wM("..","GetICWordPadDoc.SetVarName",$G(qsec(9),$NA(^mtempWP($J))))
 d ..wM("..","GetICWordPadDoc.SetNewDocType",$G(qsec(3),$S(@qqpar1@($O(@qqpar1@("")))["{\":4,1:5)),5) ; 5 -TEXT, 4-RTF
 d ..wM("..","GetICWordPadDoc.SetDocType",$G(qsec(3),5),0) ; 5 -TEXT 4 -RTF
 d ..wM("..","GetICWordPadDoc.SetSaveDocEnable",$G(qsec(10),1))
 
 d:$L($G(qsec(0))) ..wM("..","GetICWordPadDoc.SetvsecSignerName",qsec(0)) 
 d:$L($G(qsec(1))) ..wM("..","GetICWordPadDoc.SetvsecCertStoreName",qsec(1)) ; My
 d:$L($G(qsec(2))) ..wM("..","GetICWordPadDoc.SetvsecIsEncoded",qsec(2))  ;0/1
 
 d ..wM("..","GetICWordPadDoc.Serialize",2)
 d ..wM("..","GetICRichEditDoc.SetModifiedFlag",0)
 //sas 20090727
 d:+$G(qqpar2)=0 ..wM("..","GetICRichEditDoc.SetReadOnly",1)
 I $G(qqpar2) S W("ZredB")="1 "_winP_" "_$G(qqpar2)_" "_qqpar1
 I $D(qsec(6)) d ..wM("..","GetICRichEditDoc.SetReadOnly",qsec(6))
 I $D(qsec(7)) d ..wM("..","GetICRichEditDoc.SetModifiedFlag",qsec(7))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenDsnDialog">
<Description>
Выбор DSN
action - действие выполняемое после выбора
mode - режим вывода: 1 - системные, 2 - пользовательские, 3 - все
Внутри действия action будет определена переменная DSN, содержащая выбранную строку</Description>
<Internal/>
<FormalSpec>action:%String,mode:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 do qARM.wM("-qARM", "SelectDSN", mode, action)

 q:$q "" q
]]></Implementation>
</Method>

<Method name="OpenEvent">
<Description>
Выполнение строки Arg1 в рамках события</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S qqxoevent=$G(Arg1)  ;@dol 26.05.04 Был массив (qqnump)
 D qARM.wM(qwin,"UserEvent",1)
 Q ""
]]></Implementation>
</Method>

<Method name="OpenFile">
<Description>
Открытие файла qqpar2 средствами базовой ОС. Возможно с предварительным созданием из массива qqpar1
qqpar1 - Возможны варианты:
       = "" - текущий ресурс ячейки (X76). Если файл - qqpar2 не учитывается
       = ссылка на массив
qqpar2       - имя файла (если без директории, то берется  qWEB.ClientPath() - директория qARM.exe\имямашины
             - если не задан, то tmp. Расширение определяется по имени файла в значении массива @qqpar1 или в последем индексе
qqpar3 =1 - только создание</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String,qqpar3:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(qqpar1,"???")="" D  I qqpar1=""  Q:$Q "" Q
 .S qqpar1=..GetPar(76,,qqo,$P(W("Zpos",2,"d")," ",3),W("Zpos",2,"x")) S:$E(qqpar1)="-" qqpar1=$E(qqpar1,2,30000) S:$E(qqpar1)="@" @("qqpar1="_$E(qqpar1,2,10000)) S:$E(qqpar1)="-" qqpar1=$E(qqpar1,2,30000)
 .I $E(qqpar1)="M" S qqpar1=$E($P(qqpar1,")",1,$L(qqpar1,")")-1)_")",3,3000) Q
 .I $E(qqpar1)="F" S qqpar2=$P($E(qqpar1,3,30000),",") Q
 .D ..Message("Недопустимый тип ресурса "_qqpar1,"OpenFile") S qqpar1=""
 I $D(qqpar1),$E($G(qqpar1))'="F" S qqpar1=$NA(@qqpar1) D:$G(qqpar2)'["."  S:$E(qqpar2,2)'=":" qqpar2=qWEB.ClientPath()_qqpar2 D ..wM("-qARM","FileFastSave",qqpar1,qqpar2)
 .N file S file=$G(@qqpar1) S:file'["." file=$QS(qqpar1,$QL(qqpar1)) S qqpar2=$S($G(qqpar2)="":"tmp",1:qqpar2)_$S($P(file,".",$L(file,"."))="":"",1:"."_$P(file,".",$L(file,"."))) ;если имя в вершине или в индексе;@Dol 26.05.08
 I $G(qqpar3)  Q:$Q "" Q  ;только загрузка в файл
 i $E(qqpar2,2)'=":" i $E($TR(qqpar2,"/","\"),1,2)'="\\" S qqpar2=qWEB.ClientPath()_qqpar2
 
 D qARM.wM("-qARM","ShellExecute",0,"open",$P(qqpar2,"\",$L(qqpar2,"\")),"",$P(qqpar2,"\",1,$L(qqpar2,"\")-1),1)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenFolderDialog">
<Description>
Вызов окна выбора папки.
Arg1 - действие по Xcute, выполняемое по завершению выбора ( см. метод FolderDialog). Выбранная папка помещается в qARM("qpars",0)
Arg2 - начальная папка, например "C:\" 
Arg3 - если есть, то имя узла для записи списка файлов выбранной папки. Разделитель имен файлов - "*"</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S qxecuted=$G(Arg1)
 I '$D(qwin("TFolderDialog")) D ..wC("TFolderDialog","OpenFolderD") S qwin("TFolderDialog")=1
 i $G(Arg3)'="" d ..wP("OpenFolderD","FileList",Arg3)
 D ..wM("OpenFolderD","Execute",Arg2)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenHelp">
<Description>
вывод Help'a (*.chm)</Description>
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Arg1)="" S Arg1="C:\qWORD\Tree\qWORD.chm" ;явный путь!! Нехорошо!
 ;D ..wM("-qARM","WinExec","HH "_Arg1,9) ;HH-start
 D qARM.wM("-qARM","ShellExecute",0,"open",Arg1,"",$E(qARM("ClientPath"),1,$L(qARM("ClientPath"))-1),1)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenIE">
<Description>
Запись массива qqpar1 в файл qqpar2 с вызовом IE (если qqpar3=1).
Параметры:
    qqpar1 - ссылка на массив, в котором находятся данные;
             если равен числу, то формируется ссылка $$$tmpGl(qqpar1,$J); где $$$tmpGl - макрос, возвращающий имя временного глобала
             для вывода в файл значению qqpar1 присваивается значение 0, которое после вывода равно ""
    qqpar2 - полный путь к файлу; если равен "", то формируется файл temp.xml в директории, где лежит qarm.exe (см. метод qWEB.ClientPath()).
    qqpar3 - равен 1 - вызывается IE, иначе просто выход
    qqpar4 - определяет видимость IE (по умолчанию (0) IE видим)</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String,qqpar3:%String,qqpar4:%String=0</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 G:$G(qqpar1)="" OpenIEbeg
 S:qqpar1?1.N qqpar1=$na($$$tmpGl(qqpar1,$j)) ; 15.12.2008 Kokarev  было: "^CacheTemp("_qqpar1_",$J)"
 I $G(qqpar2)="" S qqpar2=qWEB.ClientPath()_"tmp.xml"
 S qqpar1=$NA(@qqpar1) I $G(qqpar3),qqWEB G OpenIEbeg
 S @qqpar1=0
 ;Параметры FileFastSave: qqpar1 - идентификатор, qqpar2 - путь к файлу
 D ..wM("-qARM","FileFastSave",qqpar1,qqpar2) ;после этого вызывается (по инициативе клиента) метод VLoadData
 I '$G(qqpar3) Q:$Q "" Q
OpenIEbeg  d ..wC("TOleIExplorer","IE5") D ..wP(,"AddressBar",0),..wP(,"MenuBar",0),..wP(,"ToolBar",0)
 D ..wP(,"Visible",'qqpar4)
 d ..wM("IE5","Navigate",$S('qqWEB:qqpar2,1:$P($P(qARM("CntStr"),"["),":",2,255)_"\scripts\mgwms32.dll?MGWLPN=qARM&MGWRTN=ewww^_qfe1&P1="_$J_"&MGWNS="_$ZU(5)))
 I qqpar4 d ..wM("IE5","Refresh")
 d ..wM("IE5","Destroy")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenLoadFile">
<Description>
Выбор и загрузка файла (со стороны клиента) в понятие qqw (Y* или T*) соответствующего экземпляра объекта (индексы 0,1,2...
@Dima 25.03.08    В вершину ЗАПИСЫВАЕТСЯ ИМЯ ФАЙЛА
XDo - действие (по Xcute) после завершения загрузки (например, "D qARM.wqqotree()" )

size - длина; 0 - весь файл; -1 - построчно текстовый файл</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqw:%Library.String,qqc:%Library.String,XDo:%Library.String,size:%Library.String=0</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G($$$Tree) N Glo S Glo=$NA(@$$$GloRef@(qqo,qqc,qqw)) D qARM.OpenWinDialog("K "_Glo_" S W(""X368"")=qARM(""qpars"",0),qqwchg=qqwchg_""X368"" D qARM.ReadClientFile(qARM(""qpars"",0),"_size_","""_qSYS.dblqw(Glo)_""","""")"_$S($G(XDo)="":"",1:",qARM.Wait("""_qSYS.dblqw(XDo)_""")")) Q:$Q "" Q
 I $G(Vo(qqnump,qqo,2))=6 N Glo S Glo=$NA(@Vo(qqnump,qqo,33)@(qqc,qqw)) D qARM.OpenWinDialog("K "_Glo_" S W(""X368"")=qARM(""qpars"",0),qqwchg=qqwchg_""X368"" D qARM.ReadClientFile(qARM(""qpars"",0),"_size_","""_qSYS.dblqw(Glo)_""","""")"_$S($G(XDo)="":"",1:",qARM.Wait("""_qSYS.dblqw(XDo)_""")")) Q:$Q "" Q  ;14.09.05 @Dol Для массивов в новой системе проектирования
 D qARM.OpenWinDialog("K ^Q(1,"""_qqo_""","""_qqc_""","""_qqw_""") D qARM.ReadClientFile(qARM(""qpars"",0),"_size_",""^Q(1,"""""_qqo_""""","""""_qqc_""""","""""_qqw_""""")"","""")"_$S($G(XDo)="":"",1:",qARM.Wait("""_qSYS.dblqw(XDo)_""")")) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenLoadFileDo">
<Description>
Выбор файла, затем построковая загрузка с выполнением метода metod
Считанная строка в переменной FileBlk
Метод должен вернуть 1 для продолжеения, или -1 для прекращение обработки файла</Description>
<Internal/>
<FormalSpec>metod:%Library.String,dir:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ D ..OpenWinDialog("D qARM.wC(""TFileStream"",""stream1"",qARM(""qpars"",0),0),qARM.wM(""stream1"",""ReadLine"",-1,"""_$G(metod)_"""),qARM.wM(""stream1"",""Destroy"")","Text files (*.txt)|*.TXT|All files |*.*;",,$G(dir))
]]></Implementation>
</Method>

<Method name="OpenMedia">
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N winP S winP=..NewResW() D ..wC("TForm",winP) ;,..wP(,"Width",450),..wP(,"Height",350),..wP(,"Position",4)
 D ..wP(,"OnClose",1)
 D ..wP(,"FormStyle",3) ;форма всегда верхняя
 ;D ..wC("TForm","AF1"),
 D ..wM(,"Show")
 D ..wC("TMsMediaPlayer",".MPlayer")
 D ..wP(,"Align",5),..wP(,"AutoSize",1)
 D ..wM(,"Open","http:\\"_qARM("ClientIP")_"\scripts\qARM.asp?R=QMRes&N=c:\qwordo\qword\qdsmall7.avi&A=0&S="_$ZU(5))
 ;&tmp7=t2zvszsolgabjc")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenOC">
<Description>
Вызов диаграммы Objective Chart (MFC)
qqpar1=1 - наличие панели инструментов (меню)
Arg1 - тип диаграммы</Description>
<Internal/>
<FormalSpec>qqpar1:%Library.String,Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 S:$G(qqpar1)="" qqpar1='$P($G(Vs(qqnump,13,"R"))," ",4)
 S:'$D(Arg1) Arg1=$P($G(Vs(qqnump,13,"R"))," ",2,3)
 S Arg1=$P($S($P(Arg1," ",2):"30000 20000 40000 1F0000 230000",1:"F0000 100000 D0000 110000 90000")," ",Arg1+1) ;вид
 S %1=qSYS.CreArDi("A"_qview,1000) D:$L(%1)>1 ..Message($E(%1,2,1000)) I '%1 Q:$Q "" Q
 N ymax,xmax,x,y,mas,xyz S mas=$P(QDiag," ",3),xyz=$P(QDiag," ",4),ymax=$O(QDiag(""),-1),xmax=$O(QDiag(0,""),-1)
 N winP S winP=..NewResW(),qwin(winP)=1 ;признак диаграммы OC
 ;D ..wC("TForm",winP),..wP(,"Width",550),..wP(,"Height",400),..wP(,"Position",4),..wP(,"OnClose",1)
 ;;;;D ..wP(,"FormStyle",3) ;форма всегда верхняя
 ;D ..wC("TChartfx",winP_".C"),..wM(winP,"Show"),..wP(winP_".C","Align",5)
 ;D ..wP(winP,"Caption","Диаграмма: "_$G(Vo(qqnump,-1)))
 ;
 d ..wC("TForm",winP) ;,..wP(,"Width",550),..wP(,"Height",400),..wP(,"Position",4),..wP(,"OnClose",1)
 D ..wP(winP,"Caption","Диаграмма: "_$G(Vo(qqnump,-1)))
 ;D ..wP("..","Visible",1)
 ;G OpenOC1 ;
 ;//for SDI

 d ..wC("TqARMSRGraphVDisp",winP_".vg1")
 d ..wM("..","0InitInterfaces")

 d ..wM("..","GetICSingleDocTemplate.VolCreateSRG",-1)
 d ..wM("..","0SetObjRef",0) //Obj(0) - CSingleDocTemplate
 d ..wM("..","GetICSingleDocTemplate.OpenDocumentFile","",1)

 d ..wM("..","AddCurObj"),..wM("..","AddCurObj") // Obj(2) - GraphDocExe
 d ..wM("..","GetICGraphDoc.GetmGraph")
 d ..wM("..","AddCurObj") //Obj(3) - SRGraph

 d ..wM("..","AppAddDocTemplate",0)

 ;//for graph begin
 d ..wM("..","1GetISRGraph")
 d ..wM("..","KillGraph")
 d ..wM("..","SetFeedbackLogging",1)
 d ..wM("..","AddComponent2",53528)
 d ..wM("..","0AddCurObj") //Obj(4) - SRGDisplay
 ;//for graph end
 ;//font begin
 d ..wM("..","0SetObjRef",4)
 d ..wM("..","GetISRGraphTitle.SetFont",8,1,"Arial Cyr") ;размер, тип
 d ..wM("..","GetISRGraphComponent.GetStyle.SetGraphStyle",$ZH(Arg1)) ;2293760) ;196608)
 ;//font end
 ;//data begin
 d ..wM("..","SetObjRef",3)
 N x,y 
 F y=1:1:ymax F x=1:1:xmax d ..wM("..","GetISRGraph.SetValue",x-1,y-1,$TR($P(QDiag(y,x)," ",$S(mas=1:2,mas=3:2,1:1)),".",","),0)
 ;F y=1:1:ymax d ..wM("..","SetObjRef",3) d ..wM("..","GetISRGraph.GetSafeData.SetAnnotation1",xmax-1,y-1,QDiag(y,0),0,1)
 ; F y=1:1:ymax d ..wM("..","SetObjRef",3) d ..wM("..","GetISRGraph.SetHeader",y-1,QDiag(y,0))
 F x=1:1:xmax d ..wM("..","SetObjRef",3) d ..wM("..","GetISRGraph.GetSafeData.SetAnnotation1",x-1,0,QDiag(0,x),0,1)
 ;//data end    
 d ..wM("..","ShowMainWindow",0)
 Q:$Q "" Q
 ;G OpenOC1

 ;//for graph begin
 d ..wM("..","1GetISRGraph")
 d ..wM("..","KillGraph")
 d ..wM("..","SetFeedbackLogging",1)
 d ..wM("..","AddComponent2",53528)
 d ..wM("..","0AddCurObj") //Obj(4) - SRGDisplay
 ;//for graph end
 ;//font begin
 d ..wM("..","0SetObjRef",4)
 d ..wM("..","GetISRGraphTitle.SetFont",8,1,"Arial Cyr") ;размер, тип
 d ..wM("..","GetISRGraphComponent.GetStyle.SetGraphStyle",2293760) ;196608)
 ;//font end
 ;//data begin
 d ..wM("..","SetObjRef",3)
 N x,y 
 F y=1:1:ymax F x=1:1:xmax d ..wM("..","GetISRGraph.SetValue",x-1,y-1,$TR($P(QDiag(y,x)," ",$S(mas=1:2,mas=3:2,1:1)),".",","),0)
 ;F y=1:1:ymax d ..wM("..","SetObjRef",3) d ..wM("..","GetISRGraph.GetSafeData.SetAnnotation1",xmax-1,y-1,QDiag(y,0),0,1)
 ; F y=1:1:ymax d ..wM("..","SetObjRef",3) d ..wM("..","GetISRGraph.SetHeader",y-1,QDiag(y,0))
 F x=1:1:xmax d ..wM("..","SetObjRef",3) d ..wM("..","GetISRGraph.GetSafeData.SetAnnotation1",x-1,0,QDiag(0,x),0,1)
 ;//data end
 d ..wM("..","0SetObjRef",0)
 d ..wM("..","GetIMDIFrameWndExe.ShowWindowSRG")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenPic">
<Description>
вывод картинки qqpar1 в окно
;qqpar2 - заменяемое имя последней директории
;qqpar3 - заголовок</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String,qqpar3:%String,qqpar4:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(qqpar1)="" qqpar1=..GetPar(76,,qqo,$P(W("Zpos",2,"d")," ",3),W("Zpos",2,"x")) ;@dol 16.1.04
 S:$E(qqpar1)="@" @("qqpar1="_$E(qqpar1,2,10000)) ;@Dima&@Dol 24.10.05
 d qARM.wM("-qARM","PicWin",$S($E(qqpar1)="F":qqpar1,$E(qqpar1)="M":"M,"_$NA(@$E($P(qqpar1,")",1,$L(qqpar1,")")-1)_")",3,1000)),$E(qqpar1)="^":"M,"_$NA(@qqpar1),1:qqpar1),$S($G(qqpar3)="":qqpar1,1:qqpar3)) ;!!!появляется где угодно
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenPicEdit">
<Description>
Редактор bmp-картинок
Res - загружаеый ресурс (M,глоб_ссылка, F,файл)
Edit=1 - только редактирование (без экспорта)</Description>
<Internal/>
<FormalSpec>Res:%Library.String,Edit:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ D ..OpenWindow(,,,$G(Res),$G(Edit),"XXXXPictEdit") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenQueryPar">
<Description>
Диалоговый ввод параметров
cond - список параметров в формате диалоговых условий запроса (понятие XQcond)
condZ - начальные значения (через ~). Если диапазон - начало-конец (через -)
condDo - Действие по кнопке OK (выполняется по Xcute). Если в действии вызов окна, то в qARM.OpenWindow необходимо установить седьмой параметр в 1 (возврат контекста).
par3 - параметр 3 (параметры окна) для окна ввода.
Введенные параметры будут находится (в момент действия по кнопке) в W("Z"_номерпараметра). Для диапазона в W("Za"_номерпараметра) и W("Zb"_номерпараметра)
После действия (или при потере фокуса) форма закрывается.
Используется автоматически формируемое отображение sysQ. См. метод qSYS.sysView.</Description>
<Internal/>
<FormalSpec>cond:%Library.String,condZ:%Library.String,condDo:%Library.String,par3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(par3)="" par3="200,100,0,11,,,30,40"
 D qARM.OpenWindow(,,par3,,,"###sysQ") Q:$Q "" Q  ;передача через cond (см. qSYS.SysView()
]]></Implementation>
</Method>

<Method name="OpenReadFile">
<Description>
Запись файла (с клиента!!!) в массив.
file - спецификация файла на клиенте (!!!).
mas - ссылка на поддерево массива. Ниже будут созданы индексы 0, 1, 2 с содержимым файла размером size
size - размер считанной порции
Например, D qARM.OpenReadFile("c:\aaa\test.doc",$NA(^Q(1,qqo,qqc,"Ypic")),255),32000)</Description>
<Internal/>
<FormalSpec>file:%Library.String,mas:%Library.String,size:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ Q ""
]]></Implementation>
</Method>

<Method name="OpenText">
<Description>
Ввод строки текста.</Description>
<Internal/>
<FormalSpec>Text:%String,Xec:%String,Capt:%String,Width:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 S qxecute1=$G(Xec)
 d qARM.wM("-qARM","Input",$G(Capt,"Строка"),$G(Text)) ;@dima 17.03.05
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenTimer">
<Description>
Выполнение действия Arg1 по событию таймера через time миллисекунд.

Следует использовать ТОЛЬКО в случае уверенности в том, что действие контекстонезависимо
и все используемые переменные, объекты и т.д. будут существовать на момент его выполнения.

! НЕ СЛЕДУЕТ использовать в целях выполнения действия вне текущего события - 
для этого предназначен метод Wait !

Таймер создается как потомок текущего окна, и если оно будет закрыто до его срабатывания, 
таймер будет уничтожен и действие НЕ будет выполнено.
</Description>
<Internal/>
<FormalSpec>time:%String,Arg1:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$D(qwin(qwin,"Timer")) D ..wC("TTimer",qwin_".Timer") S qwin(qwin,"Timer")=1
 S qqxtimer=$G(Arg1)
 D ..wP(qwin_".Timer","Interval",time),..wP(,"Enabled",1) ;,..wP(,"OnTimer",1)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenVHelp">
<Description>
Пояснения по текущему отображению</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 D:0
 .S Vt(qqnump,1)=0 D ..wcre() ;перевывод с номерами полей
 D ..OpenWindow(,,,,,"XXX0") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenWinColorDialog">
<Description>
Вызов окна выбора цвета.
Arg1 - действие по Xcute, выполняемое по завершению выбора ( см. метод ColorDialog).
Выбранный цвет в qARM("qpars","сolor")
Arg2 - цвет по умолчанию при входе в диалог.</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S qxecuted=$G(Arg1)
 I '$D(qwin("TqColorDialog")) d ..wC("TqColorDialog","Opencl") S qwin("TqColorDialog")=1
 D ..wP("Opencl","Color",$G(Arg2,0)),..wP(,"Options.+",6),..wM(,"qExecute") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenWinColorDialogMenu">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 S Z=$S(Z="Цвет_символа":8,1:9)
 D qARM.OpenWinColorDialog("S W(""X72"")=qW.G(""X72""),$P(W(""X72""),"","","_Z_")=qARM(""qpars"",""color""),qqwchg=qqwchg_"" X72""",+$P(qW.G("X72"),",",Z))
 Q 1
]]></Implementation>
</Method>

<Method name="OpenWinDialog">
<Description>
Вызов окна выбора файлов.
Arg1 - действие по Xcute, выполняемое по завершению выбора ( см. метод OpenDialog).
Выбранные файлы в qARM("qpars",N) где N=0,1... порядковые номера выборов.
Filter - определяет список типов файлов, например  'Text files (*.txt)|*.TXT|All files |*.*;'
id - директория по умолчанию
de - расширение по умолчанию
save - диалог сохранения файла (по умолчанию - открытия)
mode - выбор только одного файла (по умолчанию - множественный выбор)
dialog -заголовок диалогового окна</Description>
<Internal/>
<FormalSpec>Arg1:%String,Filter:%Library.String="",id:%Library.String="",de:%Library.String="",fn:%Library.String="",save:%Library.String,mode:%Library.String,dialog:%Library.String=""</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 S qxecuted=$G(Arg1)
 n dlg,name s dlg=$S($G(save):"TqSaveDialog",1:"TqOpenDialog"),name=$S($G(save):"Save1",1:"Open1")
 I '$D(qwin(dlg)) d ..wC(dlg,name) d:$G(save) ..wP(name,"Options.+",1) S qwin(dlg)=1 ; TDV 21.11.2005 - добавлен параметр mode
 i $G(mode) d ..wP(name,"Options.-",6)
 e  d ..wP(name,"Options.+",6)
 d ..wP(,"Filter",Filter)
 i id'="" d ..wP(,"InitialDir",id)
 d ..wP(,"DefaultExt",de)
 i fn'="" d ..wP(,"FileName",fn)
 d ..wP(,"Title",dialog)
 d ..wM(,"qExecute") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenWindow">
<Description><![CDATA[
Вызов экранной формы формы на интерпретацию (создание окна).
после вызова: $$$Relind_qview - ссылка на релевантные
Vo(qqnump) - код отображения
qqpar1=1 - вызов в режиме дизайнирования
qqpar3 - X129_" "_X162_" "_X163  (Параметры окна, авторазмеры, мах строк в ячейке) . Создается Vo("par",-1,29),Vo("par",-1,62), Vo("par",-1,63)
  Если перед вызовом окна присвоено S qqMaximizeOnShow=1, то оно открывается на весь экран. Аналог параметра окна X129 (20)
qqpar4 - список через пробел:
1 - код экземпляра;
2 - код объекта;
3 - признака включения редактирования ;1 - режим ввода;  0 - удаляется кнопка перехода в редактирование на верхней панели инструментов. Аналогичный эффект  - Set W("ZBtred")="00" в действии по входу в отображение.
4 - глобальная ссылка (если физическое дерево)
5 - код объекта фиксации.
6 =1 - признак жесткой фиксации
7 =1 - признак неснимаемой фиксации

qqpar5=-1 - сброс переченя релевантных.
qqpar5=0 - вход в режим уточнения, если перечень релевантных существует.
qqpar5=1 - запуск поиска по текушему поисковому образу (..Find()). Если qqpar5=2 - добавление
При поиске:
$P(qqpar5," ",2)=1 - выход из формы, если ничего не найдено (qqpar5="1 1").
$P(qqpar5," ",3)=1  - остаться в режиме Выбор (иначе - Уточнение)
Для передачи поискового образа  перед вызовом окна нужно заполнить Vs("par",8,qqo,qqw)=условие 

qqpar6 - код вызываемого отображения.
qqpar7=1 - возврат контекста вызова.

nsp - вызов отображения из другого NameSpace

child - встраивание в окно-родитель. Содержит (через запятую, но можно и пробел) описание места встраивания:
- (Y1) код объекта окна-родителя (не задан - текущий);
- номер строки объекта (не задана - текущая. Но только если не задан объект)
- (X1) номер колонки встраивания (от 0 )
- (x2) кол-во колонок
- (Y2) кол-во занимаемых строк. Если не указано, то занимаются все строки объекта и его потомков.
- =1 - использовать дерево объектов (по умолчанию - дерево экземпляров). Позиция начала и конца д.б. указаны в %

Возможно указание размеров в процентах от размера области дерева
в следующих сочетаниях (параметр = число_"%"):
Y2 и X2 в этом случае трактуются как ПОЗИЦИИ конца (НЕ размер)
Возможно указание размеров в процентах от размера области дерева (параметр = "NN%")
или в пикселях от начала ("NNpx") или от конца ("-NNpx") области
или и того, и другого ("NN%+NNpx","NN%-NNpx"), в следующих сочетаниях:
(Здесь "%" означает, что размер указан в процентах и/или в пикселях.
Эта таблица показывает только возможные сочетания параметров, но не их порядок.)

Y1% Y2% X1% X2%
Y1  Y2% X1% X2%
Y1  Y2% X1  X2%
Y1  Y2% X1  X2
Y1  Y2  X1% X2%
Y1  Y2  X1  X2%

(!!!) ИСПОЛЬЗОВАНИЕ главного меню во встраиваемых окнах недопустимо.

При встаивании создается узел qwin(qwin,"child")=qqnump_окна-родителя
Для окна-родителя создается узел qwin(qwin,"parent",qqnump_потомка)=""
Вызов (ОрenWindow) окнон-потомков  можно вставить в действие по входу основного окна (!!!) обязательно после D qARM.wcre() и обязательно с установленным qqpar7=1.
Можно вызывать и через D qARM.Wait("D qARM.OpenWindow(....)") 
Взаимодействие связанных окон можно делать через D qARM.WrWin.
qqnumpT содержит qqnump окна с последним редактированием/позиционированием (для распознования в событиях главного меню и кнопок панели инструментов).
Метод qARM.GetBqqnump - Получение qqnump базового окна (для текущего встроенного)

Параметр constr. Если не задан, в окне строятся дерево объектов и экземпляров.
                 constr="TPicEditForm" - рисовалка картинок. Пример использования - см. метод OpenPicEdit
Параметр Centr=1 - вывод окна по центру экрана (аналог X129 (6)=2 )
***********************************************************************************

Каждой новой экранной форме отображения присваивается номер окна (qqnump=0-49). Имя
окна qwin="Q"_qqnump.
Создается локальная среда отображения.
Vo(qqnump) - параметры отображения (см. qARM.GetPar). Начальный набор при открытии
создается в qSYS.CreVo.
Vs(qqnump) - состояние отображения (см. qARM.SaveView или пояснение к системному
объекту базы XViewStat).
Vt(qqnump) - временные (рабочие) переменные
Vt(qqnump,0)- признак наличия постоянных условий
Vc(qqnump) - содержимое дерева экземпляров (см. qW.gForm)
W(qqw) - массив значений понятий при редактировании объектов отображения. При смене
отображения записывается в WS(" "_qqnump). См. методы qARM.crest, qARM.csav. 

Если перед вызовом существуют Vo("par"), Vs("par") то их узлы замещают соответствующие
узлы из Vo(qqnump), Vs(qqnump). Используется для динамического изменения параметров.
Например, Set Vo("par",-1,29)="200,400,0" - установка размеров окна (X129)
Описание Vo, Vs см. Документация/Локальная среда
Правило соответствия кодов понятий и значений узлов для Vo (где *
последующие цифры в коде понятия).
X1*, x1* - описания параметров отображения. Замещает Vo(qqnump,-1,*)
X3*, x3* - описания параметров печати. Замещает Vo(qqnump,3,*)
X5*, x5* - описания параметров объекта. Замещает Vo(qqnump,qqo,*)
X7*, x7* - описания параметров ячейки. Замещает Vo(qqnump,qqo,0,y,x,*)

Vo("par") переписывается в Vo(qqnump) после загрузки объектов отображения (см.метод qSYS.CreVo)
Vs("par") переписывается в Vs(qqnump) после загрузки объектов отображения (см.метод qSYS.CreVo)
sas 20100707 Vt("par") переписывается в Vt(qqnump) после загрузки объектов отображения (см.метод qSYS.CreVo)

Vs("par",1,qqo)=1 - зачеркивает объект
Vs("par",1,qqo,qqw)=1 - зачеркивает понятие и предшествующую константу (если она есть)
Vs("par",1,qqo,qqw_"*")=1 - зачеркивает строку с понятием qqw
Vs("par",1,y,x)=1 - зачеркивает ячейку (???)

Vs("par",1,qqo)=-1 - блокирует вывод объекта и всех его потомков

Vs("par",1,qqo,N)=2 - зачеркивает строку N
Vs("par",1,qqo,0)=-2 - зачеркивает все строки объекта, кроме первой .

Vs("par",5) - модификатор структуры объектов отображения. Может содержать:

Vs("par",5,qqo)=1 - не включать объект с кодом qqo (и все его потомки) в формируемое отображение;
Vs("par",5,qqo,qqw)=1 - не включать ячейку понятия в формируемое отображение. Сопутствующая (предшествующая) ячейка константы не включается тоже.
Vs("par",5,qqo,y)=1 - не включать строку (кроме 0 !!!)
Vs("par",5,qqo,y,x)=1 - не включать ячейку строки
Vs("par",5,qqo,имя_строки)=1 - не включать строку (кроме 0 !!!) с заданным именем (cм. понятие X61)
где y, x  - номера строк и ячеек по описанию в отображении (!!!).

Vs("par",5)=ObjRef - Объектная ссылка (список кодов объектов через запятую) для включаемых в формируемое отображение. Включаются только объекты из объектной ссылки и потомки последнего в ссылке (если не стоит -1). Vs("par",5,qqo) и Vs("par",5,qqo,qqw) учитываются.
Примеры:
S Vs("par",5)="3" - только объект 3 и все его потомки
S Vs("par",5)="3,-1" - только объект 3
S Vs("par",5)="3,4" - объект 3, затем 4 и все его потомки

Vs("par",2,qqo,qqc)=1 - разворачивает при начальном выводе свернутый но не выведенный экземпляр объекта.
Vs("par",2",qqo)=1 - все экземпляры.
Vs("par",2)=1 - все объекты и экземпляры
В действии по входу или в любых других ситуациях перед перевыводом через qARM.wcre можно заполнять Vs(qqnump,"Estat").

!!!Если из модифицированного отображения вызывается его печать (Печать/текущее отображение), то печатная форма модифицируется тоже.


Для вызова первого окна масив qARM содержит:
qARM("Password") - введенный пароль (сразу уничтожается)
qARM("ClientPath") - полная ссылка на директорию, откуда запущен qARM.exe
qARM("Pars",1) = par1 (в qARM.ini)  Должен содержать ссылку на файл документации по приложению
qARM("Pars",2) = par2 - код отображения. В этом случае при входе вводится только пароль
qARM("Pars",3) = par3 - зарезервирован (пока не используется)
qARM("Pars",4-9) = par4-9 - свободны - могут использоваться приложением
par1 и далее должны указываться пустыми, если задан parN

В массив qwin добавляется узел: qwin(qwin,"GloWRef")=<коды отображений через запятую> (GloWRef - Global Window Reference - глобальная оконная ссылка)
@rda 20110214 для вертикального расположения деревьев размер высчитывается относительно вертикального разм. окна]]></Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String,qqpar3:%String,qqpar4:%String,qqpar5:%String,qqpar6:%String,qqpar7:%String,nsp:%Library.String,child:%Library.String,constr:%Library.String,Centr:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(constr)="" constr="TFormTree" ;@Dima&Dol 14.03.07
 D ..wP("-qARM","Cursor",-11)
 S qqParent=" "_$G(qqnump)_" "_$G(qqw) S:$TR(qqParent," ")="" qqParent="" ;??? если из запроса, то qqnump="Q"; см LoadView - в Zparent - реальное
 N qqWS,qviewpre S qqWS=" "_$G(qqnump),qviewpre=$G(qview) I qqWS'=" " D ..csav() ;сохрним в WS текущее состояние
 
 N qqoView
 S qqoView=$S($g(qqpar6)'[$C(1):"XView",1:$P($g(qqpar6),$C(1))) S:$g(qqpar6)[$C(1) qqpar6=$P($g(qqpar6),$C(1),2,255) ;Маслова 06.08.2010
 
 D:$G(nsp)'=""
 .ZN nsp X "S qUSER=##class(qUSER).%New()"
 .D qSYS.BaseIni() ;смена NameSpace
 K W,N ;,qqdbl
 S qql=1 ;слой
 I $G(qqpar2)="" D  ;поиск свободного окна (только если уже есть какое-либо окно);@Dol 21.07.09 100 окон
 .F qqpar2=1:1:100 Q:'$D(qwin("Q"_qqpar2))
 .Q:qqpar2<100  S qqpar2=$S('qqnump:1,qqnump=99:1,1:qqnump+1)
 S qqnump=qqpar2
 ;
 S qqp4=$G(qqpar4),qqp5=$G(qqpar5) ;;$G(qqpar6)
 ;sas 20090410
 s qqp6=$S($G(qqpar6)'="":qqpar6,1:qqp6)
OpenWinBeg ;
 S (qqred,qqwchg)=""
 S $$$ReFind=0,$$$RelNum=0,$$$Relind=0
 ;
 S qqc=""
 S W("ZBtred")=''$P(qqp4," ",3)
 ;I $G(qARM("Password"))'="" S qqp6=qARM("Password") S:$G(qARM("Pars",2))'="" qqp6=qARM("Pars",2)_" "_qqp6 S quser=$P(qqp6," ",2),qqp6=$P(qqp6," ") K qARM("Password") I $S(quser="":1,quser="#"&($D(^Q(1,"XUser"))<10):0,quser="U":0,1:'$D(^Q(1,"XUser",quser))) D ..Message("Незарегистрированный пользователь"),..wM("-qARM","Terminate") Q  ;par2 в qARM.INI может содержать код отображения, тогда вводится только пароль
 /*@sas 20090410
 I $G(qARM("Password"))'="" N error,qqp66 D  I $G(error) Q:$Q "" Q
 .I $G(^Q(1,"XBase",0,"XBLg"))'="" X ^("XBLg") K:$G(error)'=0 qARM("Password") Q:$G(error)'=0  ;@dol 19.05.04
 .S qqp6=qARM("Password") S:$P($G(qARM("Pars",2)),"~")'="" qqp6=$P(qARM("Pars",2),"~")_" "_qqp6 D  K qARM("Password")
 ..I $L(qqp6," ")>1 S quser=$P(qqp6," ",2),qqp6=$P(qqp6," ") Q
 ..S quser=qqp6,qqp6=""
 .S:qW.GG("XBase","XFpw",0) quser=$TR($ZCVT(quser,"U"),"ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ","QWERTYUIOP[]ASDFGHJKL;'ZXCVBNM,.") ;упрощенный пароль
 .I $S(quser="":1,quser="#"&($D(^Q(1,"XUser"))<10):0,quser="U":0,1:'$D(^Q(1,"XUser",quser))) D ..Message("Незарегистрированный пользователь"),..wM("-qARM","Terminate") S error=1 Q
 .I $D(^Q(1,"XUser",quser,"XRulsUsr"))>1 S qruls=$P($G(qARM("Pars",2)),"~",2) I $S(qruls="":1,1:qW.GG("XUser","XRef",quser)'=qruls) D  Q  ;есть несколько ролей и задана неосновная
 ..I qqp6="",qruls="" S qqp6=$S($G(qqp66)'="":qqp66,1:"XXXRulsCh") Q  ;вызов окна выбора Роли
 ..I qruls=""||'$D(^Q(1,"XUser",quser,"XRulsUsr",qruls)) D ..Message($S(qruls="":"Отсутствует",1:"Незарегистрированная")_" роль"),..wM("-qARM","Terminate") S error=1 Q
 ..N i,qq K qARM("Pars",2) F i=2:1:6 D:$G(qARM("Pars",i))=""
 ...S qq=$G(^Q(1,"XUser",quser,"XRulsUsr",qruls,$S(i=2:"XView",1:"Xpar"_i))) I qq'="" S qARM("Pars",i)=qq Q
 ...S qq=qW.GG("XRuls",$S(i=2:"XView",1:"Xpar"_i),qruls) I qq'="" S qARM("Pars",i)=qq Q
 ..S:qqp6="" qqp6=$P($G(qARM("Pars",2)),"~")
 .S:qqp6="" qqp6=qW.GG("XUser","XView",quser) S qruls=qW.GG("XUser","XRef",quser) I qqp6="" S:qruls'="" qqp6=qW.GG("XRuls","XView",qruls) Q:qqp6=""  ;нет отображения
 .S qARM("Pars",2)=qqp6 N i,qq F i=3:1:6 D:$G(qARM("Pars",i))=""
 ..S qq=qW.GG("XUser","Xpar"_i,quser) I qq'="" S qARM("Pars",i)=qq Q
 ..Q:qruls=""  S qq=qW.GG("XRuls","Xpar"_i,qruls) I qq'="" S qARM("Pars",i)=qq Q
 */;;;;;;I $E(qqp6)="N",$L(qqp6)>7 S qqp6=$E(qqp6,2,4)_$E(qqp6,8,255) ;старый код отображения;;;вроде уже больше не нужен
 /*
 ;@Sveta 23.03.03 Пароль и журнал регистрации
 I qqnump=0 N error D  I $G(error) Q:$Q "" Q  ;Запись регистрации
 .I $G(qARM("My"))="%%CANCEL" D ..wM("-qARM","Terminate") S error=1 q
 .I $G(quser)="" S error=1 D ..Message("Не введен пользователь"),..wM("-qARM","Terminate") q
 .I $G(qARM("My"))="%%NEWMY" I $G(quser)="#" D ..Message("Пароль для пользователя # не заводится"),..wM("-qARM","Terminate") S error=1 q
 .I $G(qARM("My"))="%%NEWMY" S error=1 S qARM("Password")=quser d qARM.wC("TNewMy","NEWMYOBJ","Смена пароля пользователя "_quser),qARM.wM(,"Destroy"),..wM("-qARM","Terminate") q
 .I $G(qARM("My"))'="%%NEWMY" i $G(qARM("My"))'="" S qARM("My",0)=$G(qARM("My")) i $G(^Q(1,"XUser",quser,"XMy"))'=qSYS.Encrypt("qARM(""My"")") D ..Message("Неверный пароль"),..wM("-qARM","Terminate") s error=1 q
 .I $G(qARM("My"))'="%%NEWMY" i $D(^Q(1,"XUser",quser,"XMy"))>0 S qARM("My",0)=$G(qARM("My")) i $G(^Q(1,"XUser",quser,"XMy"))'=qSYS.Encrypt("qARM(""My"")") D ..Message("Неверный пароль"),..wM("-qARM","Terminate") s error=1 q
 .I +$G(^Q(1,"XBase",0,"XBaseLog")) D  Q:$G(error)
 ..N qq S qq=$tr($ZDT($H,8)," :","")
 ..I $D(^QLog(quser)) N begin S begin=$O(^QLog(quser,""),-1) D  Q:qq=""
 ...I $P(^QLog(quser,begin)," ")'=qARM("ComputerName"),$P(^QLog(quser,begin)," ",2)="",$e(begin,1,8)=$e(qq,1,8) S error=1,qq="" D ..Message("Пользователь "_quser_" уже зарегистрирован"),..wM("-qARM","Terminate") q
 ...I $P(^QLog(quser,begin)," ")=qARM("ComputerName"),$P(^QLog(quser,begin)," ",2)="",$e(begin,1,8)=$e(qq,1,8) S:$L($G(^QLog(quser,$e(begin,1,8))))<32700 ^QLog(quser,$e(begin,1,8))=qARM("ComputerName")_" "_$S($P($G(^QLog(quser,$e(begin,1,8)))," ",2)="":"",1:$P($G(^QLog(quser,$e(begin,1,8)))," ",2)_"~")_$e(begin,9,14)_":*"_$e(qq,9,14) K ^QLog(quser,begin) 
 ..S:qq'="" ^QLog(quser,qq)=qARM("ComputerName"),qARM("Begin")=qq
 ;
 
 ;;@sas&dima 20090408
 ;I +$G(^Q(1,"XBase",0,"XBaseLog")) D  Q:$G(error)
 I (+$G(^Q(1,"XBase",0,"XBaseLog")))&('$g(^Q(1,"XUser",quser,"XBaseLogIgnor"))) D  Q:$G(error)  ;@Pav 20090605
 .N qq S qq=$tr($ZDT($H,8)," :","")
 .I $D(^QLog(quser)) N begin S begin=$O(^QLog(quser,""),-1) D  Q:qq=""
 ..I $P(^QLog(quser,begin)," ")'=qARM("ComputerName"),$P(^QLog(quser,begin)," ",2)="",$e(begin,1,8)=$e(qq,1,8) S error=1,qq="" D ..Message("Пользователь "_quser_" уже зарегистрирован"),..wM("-qARM","Terminate") q
 ..I $P(^QLog(quser,begin)," ")=qARM("ComputerName"),$P(^QLog(quser,begin)," ",2)="",$e(begin,1,8)=$e(qq,1,8) S:$L($G(^QLog(quser,$e(begin,1,8))))<32700 ^QLog(quser,$e(begin,1,8))=qARM("ComputerName")_" "_$S($P($G(^QLog(quser,$e(begin,1,8)))," ",2)="":"",1:$P($G(^QLog(quser,$e(begin,1,8)))," ",2)_"~")_$e(begin,9,14)_":*"_$e(qq,9,14) K ^QLog(quser,begin) 
 .S:qq'="" ^QLog(quser,qq)=qARM("ComputerName"),qARM("Begin")=qq
 */
  
 ;;@sas 20090623 версия упрощенная, чтобы не происходила ошибка STRINGSTACK на 4
 I (+$G(^Q(1,"XBase",0,"XBaseLog")))&('$g(^Q(1,"XUser",quser,"XBaseLogIgnor"))) D  Q:$G(error)  ;@Pav 20090605
 .N qq,jobN S qq=$tr($ZDT($H,8)," :","")
 .I $D(^QLog(quser)) N begin S begin=$O(^QLog(quser,""),-1) D  Q:qq=""
 ..S jobN=$P(^QLog(quser,begin)," ",3) I jobN="" S jobN="A" ;@ank 20110214
 ..I $P(^QLog(quser,begin)," ")'=qARM("ComputerName"),$P(^QLog(quser,begin)," ",2)="",$e(begin,1,8)=$e(qq,1,8),$D(^$JOB(jobN))'=0 S error=1,qq="" D ..Message("Пользователь "_quser_" уже зарегистрирован"),..wM("-qARM","Terminate") q  ;@ank 20110214 add $D(^$JOB(jobN))'=0
 ..I $P(^QLog(quser,begin)," ")=qARM("ComputerName") d
 ...i $P(^QLog(quser,begin)," ",2)="" d 
 ....n begindat s begindat=$e(begin,1,8) i begindat=$e(qq,1,8) d
 .....i $L($G(^QLog(quser,begindat)))<32700 
 ......s ^QLog(quser,begindat)=qARM("ComputerName")_" "_$S($P($G(^QLog(quser,begindat))," ",2)="":"",1:$P($G(^QLog(quser,begindat))," ",2)_"~")_$e(begin,9,14)_":*"_$e(qq,9,14) 
 .....K ^QLog(quser,begin) 
 ..I $L(begin)=14,$E(begin,1,8)=$E(qq,1,8),jobN'="A",$D(^$JOB(jobN))=0 K ^QLog(quser,begin)  ;@ank 20110214
 .S:qq'="" ^QLog(quser,qq)=qARM("ComputerName")_"  "_$J,qARM("Begin")=qq	;@ank 20110214 добавил $J
 
 
 I $E(qqp6,4,6)'="sys",$S($G(qqp6)="":1,1:'$D(^Q(1,qqoView,$P(qqp6," ")))) D  Q:$Q "" Q
 .I qqnump=0 D ..Message("Нет отображения "_$P(qqp6," ")),..wM("-qARM","Terminate") Q
 .D ..Message("Нет отображения "_$P(qqp6," "))
 .D ..crst($P(qqWS," "),$P(qqWS," ",2)) S qwin="Q"_qqnump
 ;
 S qview=$P(qqp6," ")_$S(quser="#":"",quser="U":" "_$J,1:" "_quser)
 ;
 I qqnump=0,quser="U" D  ;очистка отображений текущего внешнего пользователя
 .K ^Q("V"_qview) ;состояние отображения
 .K ^Q(0_qview),^Q(1_qview) ;перечни релевантных
 .K ^Q("A"_qview) ;аналитика
 ;
 S W("Zadm")=0 ;режим Пользователь/Администратор
 S W("ZBt0")=0 ;режим редактирования объектов
 S W("Znsort")=1 ;сортировка по первому слову
 S W("Zbasmod")=0 ;признак модификации записей
 ;
 Set qwin="Q"_qqnump
 S W("Zfont")=$G(qqscrfont,"8,7,7") ;надо что-то придумать
 I $D(qqpar3) S:$P(qqpar3," ")'="" Vo("par",-1,29)=$P(qqpar3," ") S:$P(qqpar3," ",2)'="" Vo("par",-1,62)=$P(qqpar3," ",2) S:$P(qqpar3," ",3)'="" Vo("par",-1,63)=$P(qqpar3," ",3)
 N qqdx,qqdy,qqdx0,qqdy0,qq,q,qqx0,qqy0,qTBright,qqq
 D:'$D(qwin(qwin))
 .K W("Zsform")
 .;Вычисление размеров 
 .S q=$E(qwin,2)'=0&$D(qwin("Q0"))*20+($G(qARM("Screen","Width"),800)>640*($G(qARM("Screen","Width"),600)\20))
 .S qq=$G(Vo("par",-1,29)) K Vo(qqnump,-1,29) S:qq="" qq=..GetPar(129,qqoView_$C(1)_$P(qqp6," "))
 .S qq=$S($E(qq)="@":..Value($E(qq,2,10000)),$E(qq)'="R":qq,qqnump="R":$E(qq,2,1000),1:"") ;@dol 1.07.04 @
 .S:$P(qq,",",19)'="" constr=$P(qq,",",19) ;@Dol 16.03.07
 .;пересчет процентов
 .F qqdx=1:1:2,7,8 S qqdy=$P(qq,",",qqdx) I qqdy["%" S qqdy=$S(qqdx#2:$G(qARM("Screen","Width"),800),1:$G(qARM("Screen","Height"),600))*qqdy/100\1,$P(qq,",",qqdx)=qqdy
 .S qqx0=$P(qq,",",7) I qqx0="",qqnump'=0,$D(qwin("Q0")),'$P(qq,",",6) S qqx0=20
 .S qqy0=$P(qq,",",8) I qqy0="",qqnump'=0,$D(qwin("Q0")),'$P(qq,",",6) S qqy0=20
 .I $P(qq,",",4) S W("Zsform")=+$P(qq,",",4) I W("Zsform")>99,$P($G(qARM("Ver","qARMProj1.ocx")),".",2)'>4 S W("Zsform")=+$E(W("Zsform"),2,3) ;@Dol 15.05.07 >99 ;сокращенная форма (1-без верхних тулбаров, 2 - без тулбаров ввода, 11- без всех тулбаров )
 .S qqdx0=$S($P(qq,",")="":qARM("Screen","Width")-q,1:$P(qq,",")) S qqdx0=$S($E($G(W("Zsform")))=1&(qqdx0<80):80,$E($G(W("Zsform")))=1:qqdx0,qqdx0<300:300,1:qqdx0) ;желаемая ширина
 .S qqdy0=$S($P(qq,",",2)="":qARM("Screen","Height")-q,1:$P(qq,",",2)) S qqdy0=$S($G(W("Zsform"))=11&(qqdy0<50):50,$G(W("Zsform"))=11:qqdy0,qqdy0<350:350,1:qqdy0) ;желаемая высота
 .S qqq=$S($P(qq,",",3)="":"",$P(qq,",",3)["%":$S($P(qq,",",22)#2=0:qqdx0,1:qqdy0)*$P(qq,",",3)/100\1,1:$P(qq,",",3)) I qqq'="" S:qqq>($S($P(qq,",",22)#2=0:qqdx0,1:qqdy0)-40) qqq=$S($P(qq,",",22)#2=0:qqdx0,1:qqdy0)-40 ;желаемая ширина дерева объектов ;?200 @rda 20110214 для вертикального расположения деревьев размер высчитывается относительно вертикального разм. окна
 .I $G(child)'="" S child=$TR(child,","," ") D  S qwin(qwin,"child")=$P(qqParent," ",2),qwin("Q"_qwin(qwin,"child"),"parent",qqnump)=""  D ..wC(constr,qwin,$S('$G(W("Zsform")):3,$G(W("Zsform"))>99:3,W("Zsform")=1:2,W("Zsform")=11:0,W("Zsform")>9:2,1:3),"Q"_qwin(qwin,"child")_".T"_$S($P(child," ",7)=1:1,1:2),$ZSTRIP($P(child," ",1,3),"<>W"),$P(child," ",6),$S($P(child," ",4)["%"!1:$P(child," ",4),1:+$P(child," ",4)),$S($P(child," ",5)["%"!1:$P(child," ",5),1:+$P(child," ",5)),+$P(qq,",",22))
 ..S $P(qq,",",11)=0 ;@Dol 19.08.08 S:$P(qq,",",13)="" $P(qq,",",13)=1 ;@Dol 13.07.08 убрать обрамление для встренных окон
 ..;OlgaS 12.11.2008 - встраивание окна в конкретный экземпляр $p(child," ",2)=номер строки~qqci
 ..I $P(child," ")="" N qpos S qpos=$G(WS($P(qqParent," ",2),"Zpos",2,"d")) I qpos'="" S child=$S($P(child," ",2)="":qpos_" "_$P(child," ",3,4),1:$P(qpos," ",1,2)_" "_$p($p(child," ",2),"~",1)_" "_$p(child," ",3,4)) Q
 ..I $P(child," ")["%" S child=$P(child," ")_"   "_$P(child," ",3,25) Q
 ..I $P(child," ")=-1 S $p(child," ",2)=$p($p(child," ",2),"~",1),child=-1_" "_child Q
 ..N qqci,qqnump,nstr s nstr=$p(child," ",2),qqci=$p(nstr,"~",2),nstr=$p(nstr,"~",1)
 ..i qqci="" S qqnump=$P(qqParent," ",2),qqci="" F  S qqci=$O(Vc(qqnump,qqci)) Q:qqci=""   Q:Vc(qqnump,qqci,0)=$P(child," ")
 ..S $p(child," ",2)=nstr,child=qqci_" "_child ;I qqci="" S qMessage="Объект "_$P(child," ")_" для встраивания не найден"
 .D:$G(child)="" ..wC(constr,qwin,$S('$G(W("Zsform")):3,$G(W("Zsform"))>99:3,W("Zsform")=1:2,W("Zsform")=11:0,W("Zsform")>9:2,1:3),"","","","","",$P(qq,",",22)) ;@Dima 31.08.10 22
 .I $G(W("Zsform"))>99 d ..wP(qwin,"TBF1Visible",1),..wP(qwin,"TBFVisible",0) ;@Dol 15.05.07 ТБ поиск над деревом объектов
 .I $G(W("Zsform"))=2 D ..wP(qwin_".TBM.b21","Visible",0) ;запрет перехода в редактирование 
 .I $P(qq,",",5)=1 D ..wP(qwin,"FormStyle",3) ;форма всегда верхняя
 .D ..wP(qwin,"ViewCode",$G(qqpar6)) ; _" "_qqnump) ;@Dima 20101117 убран qqnump ; Для CTRL+Alt+Bs ( показ текущего окна)
 .D:$G(child)=""
 ..I $G(qqXBwsize),'$P(qq,",",21),$P($G(qqX155),",",2)>8 S qqdx0=..wsize(qqdx0_","_qqdy0),qqdy0=$P(qqdx0,",",2),qqdx0=$P(qqdx0,",",1) ;@Dol 21.07.09
 ..D ..wP(qwin,"Width",qqdx0),..wP(,"Height",qqdy0) ;@dima 18.01.07  ..wP(,"Height",qqdy0-(30*($G(W("Zsform"))'=11)))
 ..I $P($G(Vo(qqnump,-1,29)),",",20)||$G(qqMaximizeOnShow) K qqMaximizeOnShow D ..wP(qwin,"MaximizeOnShow",1) ; @dima 20081010 окно на полный экран ;@Dol 03.02.11 ||$G(qqMaximizeOnShow) K qqMaximizeOnShow
 ..Q:$G(Centr)  Q:$P(qq,",",6)=2  ;@Dol 07.05.08 по центру экрана
 ..N qqp S qqp=$G(qqParent) I qqp'="","QWP"[$P(qqp," ",2) D
 ...F  S qqp=$G(Vt($P(qqp," ",2),"ZparentW")) Q:$TR(qqp," ")=""  Q:"QWP"'[$P(qqp," ",2)
 ..S:$P(qqp," ",2)'?1.N qqp="" I $E(qwin,2)'=0,$P(qqp," ",2)=0,$G(Vo(0))="XXXRulsCh" Q  ; @dol 17.8.03 из окна выбора роли
 ..I $E(qwin,2)'=0,qqx0="@"!$P(qq,",",6),qqp'="" S:qqx0="@" qqx0="" S:qqy0="@" qqy0="" D ..wP(".","Position",0),..wM(qwin,"RPosT@","Q"_$P(qqp," ",2)_".T2",4,22+$S($D(^Q(1,"XView",Vo($P(qqp," ",2)),"XMenu",8)):19,1:0),$S($G(qqy0)'="":+qqy0,1:$G(WS($P(qqp," ",2),"Zpos",2,"y"),0)),$S($G(qqx0)'="":+qqx0,1:$G(WS($P(qqp," ",2),"Zpos",2,"x"),0))) Q  ;@dol 26.02.04
 ..I $E(qwin,2)'=0,qqp'="" D ..wP(".","Position",0),..wM(,"RPos@","Q"_$P(qqp," ",2),+qqx0,+qqy0) Q
 ..I $E(qwin,2)=0||'$D(qwin("Q0")),qqx0'=""!(qqy0'="") D ..wP(".","Position",0),..wP(qwin,"Left",+qqx0),..wP(,"Top",+qqy0) Q
 .D:$P(qq,",",9)'="" ..wbuttb($Tr($P(qq,",",9),";"," "),,,0) ;удаляемые кнопки
 .S W("ZotSt")=$P(qq,",",10) ;отступ в дереве экземпляров
 .S:$P(qq,",",15) W("ZoBLeV")=$P(qq,",",15)
 .I $G(W("Zsform"))'=11 S:$P(qq,",",16) qTBright=1 ;@Dima&@Dol - тулбар перемещений справа ;,$G(W("Zsform"))'=1
 .D:$P(qq,",",11)'=""&&'$G(qqpar1) ..wP(qwin,"BorderStyle",+$P(qq,",",11)) ;стиль обрамления окна (0-bsNone, 1-bsSingle,2- bsSizeable,3- bsDialog,4- bsToolWindow,5- bsSizeToolWin) ;@Dol 20.08.10 &&'$G(qqpar1) - не дизайнирование
 .I $G(qqXBWStyle),$P(qq,",",11)'=0 S:$P(qq,",",12)="" $P(qq,",",12)=2 S:$P(qq,",",13)="" $P(qq,",",13)=2 S:$P(qq,",",14)="" $P(qq,",",14)=0 ;S:$P(qq,",",16)="" $P(qq,",",16)=2
 .; @dima перенесено в qARMProj1 //////////////////////////////////////
 .I $G(constr,"TFormTree")'="TFormTree" d ..wP(qwin,"OnClose",1) S qwin(qwin)="" Q  ;@Dima 9.01.08
 .d qARM.wM(qwin,"F1",$P(qq,",",12),$P(qq,",",13),$S($P(qq,",",14)="":1,1:$P(qq,",",14)),qqXBColor)
 .d ..wP(qwin_".T1","OnAutoDragging",1),..wP(qwin_".T2","OnAutoDragging",1)
 .D:$P(qq,",",18)'="" ..wP(qwin_".T2","NoFocusStyle",$P(qq,",",18))
 .d ..wP(qwin,"OnClose",1)
 .S q=$G(Vo("par",-1,63)) S:q="" q=..GetPar(163,qqoView_$C(1)_$P(qqp6," ")) D:q ..wP(qwin_".T2","ItemLines",q) ;строк в ячейке
 .S qwin(qwin)=""
 I $G(W("Zsform"))=10||($G(W("Zsform"))=4) S:$G(W("Zsform"))'=4 W("Zsform")=1 D ..wbuttb("6 7 8 3 17",,,0),..wP(qwin_".TBV","Visible",0) ;@Dol 11.07.05 оставлен перевывод ( 9 )
 I $G(W("Zsform"))#100=12 S:W("Zsform")<100 W("Zsform")=1 D ..wbuttb("98 1 2 3 4 5 9 17",,,0) ;только ||, <|
 I $P($G(qq),",",17)'="" D ..wP(qwin_".T2","Scrollbars",$P(qq,",",17)) ; #dima 20101015 $G()
 N qMessage ;для вывода сообщения из действия
 ;;;;;@Dol 11.09.07??? устарело;S qwin(qwin,"GloWRef")=$S(qwin="Q0":$P(qqp6," "),1:$G(qwin("Q"_($P(qqParent," ",2)),"GloWRef"))_","_$P(qqp6," ")) ;;предшествующие отображения
 I $G(qqpar1) S W("ZBt0")=1 ;@Dol 11.09.07 вызов в режиме дизайнирования
 I $G(qqXBwids),$G(constr,"TFormTree")="TFormTree" D qARM.wP(qwin_".T2","ScaleColumns",1)  ;@Dima 28.02.08
 S %1=..LoadView(qqoView_$C(1)_$P(qqp6," "),$G(qqp5)) ;результат действия по загрузке отображения
 I %1'="" D:qqnump'=0  D:%1'?1.N ..Message(%1) Q:$Q "" Q  ;????Q:qqnump'=0
 .D ..wM("Q"_qqnump,"Destroy") K qwin("Q"_qqnump)
 .D ..crst("",$P(qqWS," ",2)) S qwin="Q"_qqnump
 I $$$Tree,$G(W("Zsform"))'=11,$G(W("Zsform"))'=1 D:Vo(qqnump)'["zz"&&(Vo(qqnump)'["sysA") ..wbuttb(64,,,0),..wP(qwin_".TBS","Visible",0) D ..wbuttb("63 62",,,0),..wbuttb("401 41",,0) ;в дереве пока искать нельзя
 I $P(qq,",",11)'=0,$G(Vo(qqnump,-1,64))="" D ..wwww("Ztitle") ;@Dol 19.07.08
 I $G(constr,"TFormTree")="TFormTree" D ..ViEdit() D
 .I $E($P(qq,",",3))=0 D:$G(W("Zsform"))'=11&&($G(W("Zsform"))'=10) ..wP(qwin_".TBV.b8","Down",1),..wM(qwin,"ShowTrees",2),..wM(qwin,"ShowTrees",2) D ..wM(qwin,"ShowTrees",0) Q  ;D ..wM(qwin,"s1308@") Q  ;только экземпляры
 .I $P(qq,",",3)="100%" D ..wM(qwin,"ShowTrees",1) Q  ; D ..wM(qwin,"s1306@") Q  ;только объекты
 .I qqq="" D ..wM(qwin,"ShowTrees",2) Q
 .D ..wM(qwin,"SplitterMove",qqq)
 I $G(Vo(qqnump,-1,19))=4 D:$P(qq,",",18)'=0 qARM.wP(qwin_".T2","CellRectFocused",1) ;@Dima&@Dol 31.07.08
 D:$G(W("Zsform"))=3||($G(W("Zsform"))=4) ..wbuttb("62 63 64",,,0) ;только редактирование ;22,20,23
 D:$G(qTBright) ..wP(qwin,"TBPosition",1) ;@Dima&@Dol - тулбар перемещений справа
 D:'$G(W("ZBt0")) ..MenuCre() ;@dol 18.01.08 '$G(W("ZBt0")) ;закладки, меню
 ;I $G(qqXBwids),$G(constr,"TFormTree")="TFormTree" D qARM.wP(qwin_".T2","ScaleColumns",1) D:$G(W("ZoBLeV")) qARM.wP(,"GuaranteedItemLevel",$G(W("ZoBLeV"))) ;@Dima 28.02.08
 I $G(Vo(qqnump,-1,62)) D ..wM(qwin,"qResize",$TR(Vo(qqnump,-1,62),"123","312")) D:$G(constr,"TFormTree")="TFormTree" ..wpoe(,1) ;;@Dol&@Dima 04.02.09 qResize
 D:$G(child)="" ..wM(qwin,"qReplace") D ..wM(qwin,$S($P(qq,",",5)=2:"ModalShow",1:"Show")) ;@Dima 23.08.07 ModalShow
 I '$G(qqpar7),$G(constr,"TFormTree")="TFormTree" D ..wM(qwin_".T"_($P($G(qq),",",3)'="100%"+1),"SetFocus") ;не очень хорошо
 I $G(Vo(qqnump,-1,663))'="" D
 .I '$P(Vo(qqnump,-1,663),",",2) D ..wM(qwin_".T2","MakeSplitterOptimal") Q  ;@dol 29.11.06
 .D ..wP(qwin_".T2","SplitterOffset",$P(Vo(qqnump,-1,663),",",2))
 I $G(Vo(qqnump,-1,720)),$G(Vc(qqnump))'="",Vc(qqnump)'="AA",$G(constr,"TFormTree")="TFormTree" D ..wM(qwin_".T2","MakeRowVisible","") ;@Dol 10.10.08 при кнопках выхода
 I $G(W("ZoBLeV")),$G(constr,"TFormTree")="TFormTree" D ..wM(qwin_".T2","M9",1,0,"00"),..wM(,"M6","",1) ;D:$G(Vc(qqnump))'="" ..wM(qwin_".T2","M9",1,0,Vc(qqnump)_" "_Vc(qqnump,Vc(qqnump),0)_" 0");??? может стать на место??? @dol 10.02.08 - убрать лишнюю строку
 I $G(qMessage)'="" D ..Message(qMessage)
 I $G(qqpar7) S qqpar7=qqnump D ..csav(),..crst("",$P(qqWS," ",2),1) ;возврат контекста
 I W("ZBt0") S W("ZBt0")=0,W("Zadm")=1 D ..T1ColHButton(0) ;@Dol 11.09.07 вызов в режиме дизайнирование
 Q:$Q $S('$G(qqpar7):qqnump,1:qqpar7) Q  ;@Dol 11/07/05 возврат номера окна
]]></Implementation>
</Method>

<Method name="Print">
<Description>
Печать отображения viewpr.
Если Arg2=1 или режим администратора, вызывается меню для приемника печатной формы.
X130 - набор параметров печати - не указан, используется заданный по умолчанию
NoWin=1 - печать в текущем контексте (не создается отображение с qqnump="P")
NoWin=2 - печать в текущем контексте с переносом его в qqnump="P". Текущий контекст НЕ меняется. 
                  Очень полезно при установленном флаге формированя заголовков граф (т. к. в этом случае в отображение вставляются стоки!!!)
NoWin 10,20 - аналогично 1,2  - не загружаются пармаетры печати (берутся из Vo(qqnump,-1,3,par) ), действие по входу в печать не выполняется ;@Dol 05.03.10
OpenFile - (1 или пусто) - открывать файл, 0 - нет
x320 - приёмник печатной формы, можно задавать несколько через пробел - выбор через меню
spaceBefore = -1 - вызов окна для задания отступа сверху в основной области печати в мм</Description>
<Internal/>
<FormalSpec>viewpr:%String,Arg2:%String,X130:%Library.String,NoWind:%Library.String,OpenFile:%String,Cont:%String,x320:%String,spaceBefore:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 ;D ..wP("-qARM","Cursor",-11)
 i $G(viewpr)="" s viewpr=$g(Vo(qqnump,-1,-1))_$s($g(Vo(qqnump,-1,-1))'="":$C(1),1:"")_Vo(qqnump)
 e  D  Q:viewpr=""
 .I $E(viewpr,4,6)'="sys",$g(viewpr)'[$C(1) n viewPr s viewPr=viewpr D  D:viewpr="" qARM.Message("НЕТ отображения "_$g(viewPr))
 ..i $g(^Q(1,"XBase",0,"XBviorg"))'="" n usl s usl="s viewpr="_^Q(1,"XBase",0,"XBviorg")_"("""_viewpr_""")" x usl
 ..i $g(viewpr)'[$C(1) s viewpr=$s($d(^Q(1,"XView",viewPr)):viewPr,1:"")
  
 N qqoView
 S qqoView=$S($g(viewpr)'[$C(1):"XView",1:$P($g(viewpr),$C(1))) S:$g(viewpr)[$C(1) viewpr=$P($g(viewpr),$C(1),2,255) ;Маслова 06.08.2010
 
 I '$G(Cont),'$G(NoWind) I viewpr=Vo(qqnump),$D(Vs(qqnump,5)) M Vs("par",5)=Vs(qqnump,5) ;@dol 5.10.02 есть модификация текущей формы? хорошо ли модтфицировать печатную форму???
 I '$G(Cont),'$G(NoWind) D ..SaveView(1,"",qqoView_$C(1)_viewpr) ;заполнили $$$tmpGl("q",$Job); где $$$tmpGl - макрос, возвращающий имя временного глобала
 I '$G(Cont),$G(Arg2)'=0,$G(W("Zadm"))!$G(Arg2)!(..GetPar("x320",qqoView_$C(1)_$P(viewpr," "))="") D ..MenuWoc("x320","x320",..GetPar("x320",qqoView_$C(1)_$P(viewpr," ")),1,"D qARM.Print("""_qqoView_$C(1)_$g(viewpr)_""",,"""_$G(X130)_""","""_$G(NoWind)_""","""_$G(OpenFile)_""",1,+$E(qqchoice,7,8))") Q:$Q "" Q  ;"D qWEB.Print($J,"""_$G(X130)_""",$E(qqchoice,7),"""_$G(OpenFile)_""",,"""_$G(NoWind)_""")") Q:$Q "" Q
 I '$G(Cont) N menu S menu=0 D  I menu Q:$Q "" Q  ; tdv 20110302 - выбор приёмника печати из списка
 .I $G(x320)'="",x320'[" " Q
 .N codeList set codeList=$get(x320)
 .I codeList="" S codeList=..getPrintParam(qqoView_$C(1)_$P(viewpr," "),$G(X130),"x320",$G(NoWind)) I codeList'[" " Q 
 .N valueList S valueList=qW.GetWoc("Cx320",codeList)
 .S menu=1 D qARM.MenuWoc("x320","x320",,1,"D qARM.Print("""_qqoView_$C(1)_$g(viewpr)_""",,"""_$G(X130)_""","""_$G(NoWind)_""","""_$G(OpenFile)_""",1,$P("""_codeList_""","" "",+$E(qqchoice,7,8)+1))",,"("" ""_"""_valueList_"""_"" "")[("" ""_Z_"" "")")
 I ($G(spaceBefore)=-1) D qARM.wM("-qARM","InputEx","Отступ печати","Отступ сверху в основной области печати (в мм)","","D qARM.Print("""_qqoView_$C(1)_$g(viewpr)_""",,"""_$G(X130)_""","""_$G(NoWind)_""","""_$G(OpenFile)_""",1,"_ $S($D(x320):""""_x320_"""",1:"")_",Input)",50,32) Q:$Q "" Q  ; tdv 20100316  
 I $E($G(NoWind))=2 N qqnumpP,mmm  D ..csav() S qqnumpP=qqnump,qqnump="P" K qwin("QP","child") M qwin("QP","child")=qwin(qwin,"child") F mm="Vo","Vs","Vt","Vc" K @mm@("P") M @mm@("P")=@mm@(qqnumpP) M @mm@("P")=@mm@("par") K @mm@("par") ;@Dol 7.01.08 Перенос контекста ;06.04.10 par
 D  D:%1'="" ..Message(%1) 
 .I $D(x320) S %1=qWEB.Print($J,$G(X130),x320,$G(OpenFile),,$G(NoWind),$G(spaceBefore)) Q
 .S %1=qWEB.Print($J,$G(X130),,$G(OpenFile),,$G(NoWind),$G(spaceBefore))
 I $E($G(NoWind))=2 D qARM.crst(,qqnumpP,1)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="ProjVerNotOlder">
<Description>
Возвращает 1, если версия продукта указанная или новее.
(Если узла qARM("Ver") нет (вызов из GManager), возвр. 1)</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String=0,Arg2:%Library.String=0,Arg3:%Library.String=0,Arg4:%Library.String=0</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 q:$D(qARM("Ver"))=0 1
 n v1,v2,v3,v4
 d:$G(qARM("Ver","PRODUCT"))=""
 . ;old
 .s v1=$P(qARM("Ver","qARMProj1.ocx"),".",1)
 .s v2=$P(qARM("Ver","qARMProj1.ocx"),".",2)
 .s v3=$P(qARM("Ver","qARMProj1.ocx"),".",3)
 .s v4=$P(qARM("Ver","qARMProj1.ocx"),".",4)
 d:$G(qARM("Ver","PRODUCT"))'=""
 . ;new
 .s v1=$P(qARM("Ver","PRODUCT"),".",1)
 .s v2=$P(qARM("Ver","PRODUCT"),".",2)
 .s v3=$P(qARM("Ver","PRODUCT"),".",3)
 .s v4=$P(qARM("Ver","PRODUCT"),".",4)
 q:(v1>Arg1) 1
 q:(v1=Arg1)&(v2>Arg2) 1
 q:(v1=Arg1)&(v2=Arg2)&(v3>Arg3) 1
 q:(v1=Arg1)&(v2=Arg2)&(v3=Arg3)&(v4'<Arg4) 1
 q 0
]]></Implementation>
</Method>

<Method name="Question">
<Description>
Запрос ответа на вопрос.
Ответ немодален. произойдет по событию
question - текст вопроса.
yes  - вариант умолчания (1-да, 0-нет).
qqpar3=qxecute0,qqpar4=qxecute1 - действия по вопросам Нет/Да.
type - тип 
0 - "OK",
1 - "OK","Cancel",
2 - "Yes","No","Cancel";
3 - "Yes","No" (по умолчанию)

tv= - вид 
0 - Warning,
1 - Error,
2 - Information,
3 - Confirmation, 
4 - Custom;

fontsize -  относительное изменение размеров шрифта (+ увеличение, - умменьшение). Например, +2 - увеличить на 2 (пикселя?) относительно текущего фонта по умолчанию.


Использована "ShowMessagePos" (описание см. метод ..Message)</Description>
<Internal/>
<FormalSpec>question:%String,yes:%String,qqpar3:%String,qqpar4:%String,type:%Library.String=3,tv:%Library.String,fontsize:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(W("Zmesb")) W !,"Вопрос: "_$G(question)_" "_$S($G(yes):"Да",1:"Нет") Q:$Q $G(qqpar2) Q  ;вывод на текущее у-во для WebLink
 I $G(qqnump)'="","PQW"[$G(qqnump) N qwin S qwin="Q"_$P(qqParent," ",2) ;@dima 22.01.08: $G(qqnump)'=""
 S qxecute0=$G(qqpar3),qxecute1=$G(qqpar4) 
 D ..wG("-qARM","ShowMessagePos",qwin,$G(question,"Вопрос")_" ?","Вопрос",$S($G(tv)="":3,1:tv),type,'$G(yes)+2,$G(fontsize)) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="QuestionM">
<Description>
Вопрос через меню (аналог Question)
Добавлена возможность множественных выборов
qustion - тексты выборов (через ~)
qqpar3 - действие по Отказ
qqpar4-qqpar8 - действия по выборам</Description>
<Internal/>
<FormalSpec>question:%Library.String,yes:%Library.String,qqpar3:%Library.String,qqpar4:%Library.String,qqpar5:%Library.String,qqpar6:%Library.String,qqpar7:%Library.String,qqpar8:%Library.String,qqpar9:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S qxecute0=$G(qqpar3),qxecute1=$G(qqpar4),qxecute2=$G(qqpar5),qxecute3=$G(qqpar6),qxecute4=$G(qqpar7),qxecute5=$G(qqpar8),qxecute6=$G(qqpar9)
 D ..MenuEx(8,,$G(question,"Вопрос")_$S($L($G(question),"~")=1:" ?",1:""))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="RT">
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[ q ..RuntimeAction(Arg1,1)
]]></Implementation>
</Method>

<Method name="ReadClientFile">
<Description>
Чтение файла на стороне клиента в массив.
file - имя файла
size - длина; 0 - весь файл; -1 - построчно текстовый файл
var - имя массива @Dima 25.03.08    В вершину ЗАПИСЫВАЕТСЯ ИМЯ ФАЙЛА 
erract - действие при ошибке открытия файла
(При загрузке таким способом картинок в глобал не нужно вызывать ClearBMPCache) @dima</Description>
<Internal/>
<FormalSpec>file:%Library.String,size:%Library.String,var:%Library.String,erract:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S var=$NA(@var) I var["^Q(",$QL(var)<4 D ..Message("Недопустимо. Запись в массив базы "_var,"qARM.ReadClientFile") Q  ;@Dol 20.07.07
 d ..wC("TFileStream","ClRdStrm",file,64,erract),..wM(,"ReadFile",size,var),..wM(,"Destroy")
 q
]]></Implementation>
</Method>

<Method name="RecCor">
<Description>
Корректировать экземпляр объекта.
Возвращает 1 если коррекция успешна.
cdtu - разрешить изменение даты времени коррекции</Description>
<Internal/>
<FormalSpec>qObj:%String,qqccor:%String,cdtu:%String=1</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I qqwchg="" Q:$Q "" Q 
 S:$G(qObj)="" qObj=$$$CurObj I qObj=-1 S qqwchg="" Q:$Q 1 Q  ;ввод постоянных строк???
 I $G(qqccor)="" S:$G(Vc(qqnump,Vc(qqnump)))'="" qqc=Vc(qqnump,Vc(qqnump)) I 1 ;@dol 14.02.03 при режиме "выводе пустых" qqc изменяется!!!
 E  N qqc S qqc=qqccor
 I ..qqtime(qObj) D RecCorEr Q:$Q "" Q 
 I ..RecVer(2,qObj)'="" D RecCorEr Q:$Q "" Q  ;правило проверки перед коррекцией
 I $G(Vo(qqnump,qObj,2))>2,Vo(qqnump,qObj,2)'=6 Q:$Q 1 Q  ;блокировка для виртуальных ???
 N qqver,qKey,qKeyqqc0
 S qKey=..GetPar(522,,qObj) ;список ключевых
 I qKey'="" D  I qKey'="" Q:$Q "" Q  ;проверка на ключевые
 .S qKeyqqc0="" I qKey[":" S qKeyqqc0=$P(qKey,":"),qKey=$P(qKey,":",2),qKeyqqc0=$S($D($$$ObjLqqc(qKeyqqc0)):$$$ObjLqqc(qKeyqqc0),1:qW.GG("CxObj","X50",qKeyqqc0)) S:qKeyqqc0'="" qKeyqqc0=$E(qqc,1,qKeyqqc0) ;@dol 20.09.04 ключевые относительно вершины
 .N qqw,qi,qqz,qqz1,qKey0 S qqz="",qqz1=0,qKey0=qKey F qi=1:1:$L(qKey," ") S qqw=$P(qKey," ",qi) D:qqw'="" 
 ..I " "_qqwchg_" "'[(" "_qqw_" ") S W(qqw)=qW.GG(qObj,qqw,qqc) I 1
 ..E  S qqz1=1
 ..S qqz=qqz_" "_$G(W(qqw))
 .I 'qqz1,$TR(qqz," ")'="" S qKey="" Q  ;ключевые есть, но они не корректировались
 .I $TR(qqz," ")="" D RecCorEr,..Message("Нет значений у ключевых понятий",,1) Q
 .S qKey=qW.Key(qObj,qKey,"",,,,,,,,qKeyqqc0) Q:qKey=""  I qKey=qqc S qKey="" Q  ;нет или текущий
 .S qqver=..GetPar(523,,qObj) ;отображение контроля (в текущей группе отображений !!!!) $P(qqver," ")=1 - запуск поиска
 .;;;;;;;;;;;@sveta для варианта 4 - вызов отображения XXXCorKey
 .I $P(qqver," ")'="" D
 ..S:$P(qqver," ",2)<3 Vo("par",-1)=$S($P(qqver," ",2)=1:"-ПРОСМОТР",1:"-ВЫБОР из")_" совпадений для "_qqz
 ..I '$P(qqver," ",2)!($P(qqver," ",2)=2) D  ;Выбор
 ...S Vo("par",-1,64)="" ;обобщение для вывода заголовка
 ...S Vo("par",-1,22)="" ;блокировка действия по выходу
 ...S Vo("par",-1,73)=0 ;выбор по ДА
 ...N qqdel S qqdel=1 F qi=1:1:$L(qKey0," ") S qqw=$P(qKey0," ",qi) I qqw'="",qW.GG(qObj,qqw,qqc)'="" S qqdel=0 Q  ;проверка допустимости удаления текущего экземпляра
 ...S Vo("par",-1,72)=1_$S('qqdel:"",1:"  K qqFCor S qqwchg="""" D qW.rDel("""_qObj_""","""_qqc_"""),qARM.wcre()") ;переход по выбору (если выбор - уничтожить текущую)
 ..I $P(qqver," ",2)=1 D  ;только просмотр
 ...S Vo("par",-1,64)="" ;обобщение для вывода заголовка
 ...S Vo("par",-1,22)="" ;блокировка действия по выходу
 ...S Vo("par",-1,73)=3 ;автоматический невыбор
 ...S Vo("par",-1,72)=0 ;ничего не делать по выходу
 ..I $P(qqver," ",3) D  ;поисковый образ
 ...F qi=1:1:$L(qKey0," ") S qqw=$P(qKey0," ",qi) S:qqw'="" Vs("par",8,qObj,qqw)=$G(W(qqw))
 .D RecCorEr
 .N qviewver S qviewver=$S($L($P(qqver," "))>3&&$D(^Q(1,"XView",$P(qqver," "))):$P(qqver," "),1:$E(Vo(qqnump),1,3)_$P(qqver," ")) ;@dol 9.03.04 отображение проверки
 .I $P(qqver," ",2)=2!($P(qqver," ",2)=3),$G(qqFCor)'=(qqc_" "_qqz) S qqFCor=qqc_" "_qqz D qARM.OpenWindow(,"R",,qKey_" "_qObj,$S($P(qqver," ",3):1,1:""),qviewver) Q  ;безусловный выбор (первый раз)
 .N qqdel S qqdel=1 F qi=1:1:$L(qKey0," ") S qqw=$P(qKey0," ",qi) I qqw'="",qW.GG(qObj,qqw,qqc)'="" S qqdel=0 Q  ;проверка допустимости удаления текущего экземпляра    
 .S Vs("CorKey",2)="S Vo(""par"",-1,64)="""",Vo(""par"",-1)=""ВЫБОР из существующих ""_"""_qqz_""" S Vo(""par"",-1,73)=0,Vo(""par"",-1,22)="""",Vo(""par"",-1,72)="_$S('qqdel:"""0 K qqFCor S qqwchg="""""""",qqc=qqcold D qARM.wcre()""",1:"""0 K qqFCor S qqwchg="""""""",qqc=qqcold D qW.rDel("""""_qObj_""""","""""_qqc_"""""),qARM.wcre()""")
 .F qi=1:1:$L(qKey0," ") S qqw=$P(qKey0," ",qi) S:qqw'="" Vs("CorKey",2)=Vs("CorKey",2)_" S Vs(""par"",8,"""_qObj_""","""_qqw_""")="""_$G(W(qqw))_""""
 .K qqFCor S Vs("CorKey","qqz")=qqz,Vs("CorKey",1)="",Vs("CorKey",3)="K Vo(""par""),Vs(""par"") D qW.rCor("""_qObj_""","""_qqc_""","""_qqwchg_""") S qqwchg="""""_$S('$G($$$Tree)&cdtu:",Vc(qqnump,Vc(qqnump),5)=$G(qqtime)",1:"")_" D ..RecPost(2,"""_qObj_""")" ;@dol 25.03.04 RecPost
 .S Vs("CorKey",2)=Vs("CorKey",2)_" D qARM.OpenWindow(,""R"",,"""_qKey_" "_qObj_""","_$S($P(qqver," ",3):1,1:"")_","""_qviewver_""")" D ..OpenWindow(,,,,,"XXXCorKey") Q  ;@Dol 10.01.08 _" D qARM.OpenWindow(,""R"",, ; отображение R - катастрофа
 .;;;;;;;;;;;;далее старый текст
 .I $P(qqver," ")'="" D  ;@dol 27.01.02 подготовка вызова отображения контроля (ПРОСМОТРА!!!)
 ..S:$P(qqver," ",2)'=3 Vo("par",-1)=$S($P(qqver," ",2)=1:"-ПРОСМОТР",1:"-ВЫБОР из")_" совпадений для "_qqz
 ..I '$P(qqver," ",2)!($P(qqver," ",2)=2) D  ;Выбор
 ...S Vo("par",-1,64)="" ;обобщение для вывода заголовка
 ...S Vo("par",-1,22)="" ;блокировка действия по выходу
 ...S Vo("par",-1,73)=0 ;выбор по ДА
 ...N qqdel S qqdel=1 F qi=1:1:$L(qKey0," ") S qqw=$P(qKey0," ",qi) I qqw'="",qW.GG(qObj,qqw,qqc)'="" S qqdel=0 Q  ;проверка допустимости удаления текущего экземпляра
 ...S Vo("par",-1,72)=1_$S('qqdel:"",1:"  K qqFCor S qqwchg="""" D qW.rDel("""_qObj_""","""_qqc_"""),qARM.wcre()") ;переход по выбору (если выбор - уничтожить текущую)
 ..I $P(qqver," ",2)=1 D  ;только просмотр
 ...S Vo("par",-1,64)="" ;обобщение для вывода заголовка
 ...S Vo("par",-1,22)="" ;блокировка действия по выходу
 ...S Vo("par",-1,73)=3 ;автоматический невыбор
 ...S Vo("par",-1,72)=0 ;ничего не делать по выходу
 ..I $P(qqver," ",3) D  ;поисковый образ
 ...F qi=1:1:$L(qKey0," ") S qqw=$P(qKey0," ",qi) S:qqw'="" Vs("par",8,qObj,qqw)=$G(W(qqw))
 .;D RecCorEr,..Question("Существует "_qqz_$C(13,10)_"Ввести "_..RecObj(qObj)_$S($P(qqver," ")="":"",1:$C(13,10)_" (нет - "_$S($P(qqver," ",2)=1:"ПРОСМОТР",1:"ВЫБОР из")_" совпадений)"),1,$S($P(qqver," ")="":"",1:"D qARM.OpenWindow(,""R"",,"""_qKey_" "_qObj_""","_$S($P(qqver," ",3):1,1:"")_","""_$E(qview,1,3)_$P(qqver," ")_""")"),"D qW.rCor("""_qObj_""","""_qqc_""","""_qqwchg_""") S qqwchg=""""") Q  ;@dol 27.01.02
 .D RecCorEr
 .I $P(qqver," ",2)=2!($P(qqver," ",2)=3),$G(qqFCor)'=(qqc_" "_qqz) S qqFCor=qqc_" "_qqz D qARM.OpenWindow(,"R",,qKey_" "_qObj,$S($P(qqver," ",3):1,1:""),$E(qview,1,3)_$P(qqver," ")) Q  ;безусловный выбор (первый раз)
 .K qqFCor D ..Question("Существует "_qqz_$C(13,10)_$S($P(qqver," ")="":"Вернуться к редактированию",1:$S($P(qqver," ",2)=1:"ПРОСМОТР",1:"ВЫБОР из")_" существующих")_" (Да,Yes) или ВВОД (Нет,No) ",1,"K Vo(""par""),Vs(""par"") D qW.rCor("""_qObj_""","""_qqc_""","""_qqwchg_""") S qqwchg="""""_$S('$G($$$Tree)&cdtu:",Vc(qqnump,Vc(qqnump),5)=$G(qqtime)",1:""),$S($P(qqver," ")="":"",1:"D qARM.OpenWindow(,""R"",,"""_qKey_" "_qObj_""","_$S($P(qqver," ",3):1,1:"")_","""_$E(qview,1,3)_$P(qqver," ")_""")")) Q  ;@dol 27.01.02
 I qqc'[" ",..RecVerNoDef(qObj) Q:$Q "" Q  ;@dol 18.02.03 проверка на обязательность значений @Dol 20.02.04 qqc'[" "
 S qqver=qW.rTmpVer(qObj,qqc,2) I qqver'="" D ..RecTmp(qqver) ;темпоральная коррекция
 N qqwchgold,qqwch I $E(qqc,$L(qqc))=" " N err S qqwchgold=qqwchg D  D:'$D(err)&&(..GetPar("X1191")) qW.gRel("+",qObj,qqc,,1) G:$D(err) RecCorErr ;D ..Message($S($L(err," ")=1:"Попытка ввода виртуального объекта "_err,1:"Объект "_$S('$G(W("Zadm")):"",1:"("_err_") ")_"введен другим пользователем")) D:$L(err," ")>1 ..wqqotree($P($P(err,"qqci=",2)," "),,$P($P(err,"qqc=",2)," "),1) S qqwchg="" Q:$Q 0 Q  ;@dol 26.07.04 qqwchg="" ;20.05.04 доввод отсутствующих экземпляров + обработка ввода другим пользователем ;@dol 18.02.04 $E(qqc,$L(qqc))=" ",$G(Vo(qqnump,-1,87))'=""||($G(Vo(qqnump,qObj,87))'="")
 .N qqcii,qqcc,qqo,qqfo S qqc="" F qqcii=2:2:$L(Vc(qqnump)) D  Q:$D(err)
 ..S qqcc=Vc(qqnump,$E(Vc(qqnump),1,qqcii)) I $E(qqcc,$L(qqcc))'=" " S qqc=qqcc Q
 ..S qqfoc=$G(Vc(qqnump,$E(Vc(qqnump),1,qqcii),6)) I qqfoc'="" D  Q:$D(err)  ;есть зачеркнутые
 ...N qqoi,qqoo,qqooc F qqoi=1:1:$L(qqfoc,"~") S qqoo=$P(qqfoc,"~",qqoi),qqoi=qqoi+1,qqooc=$P(qqfoc,"~",qqoi) D  Q:$D(err)
 ....I $E(qqooc,$L(qqooc))'=" " S qqc=qqooc Q  ;@Dol 13.11.03 было ... вместо ....
 ....D RecCorLeer(qqoo) Q:$D(err)  S $P(Vc(qqnump,$E(Vc(qqnump),1,qqcii),6),"~",qqoi)=qqc I $$RecCorv(qqoo,qqc) ;@dol 2.04.04
 ..S qqo=Vc(qqnump,$E(Vc(qqnump),1,qqcii),0)
 ..D RecCorLeer(qqo) Q:$D(err)
 ..S Vc(qqnump,$E(Vc(qqnump),1,qqcii))=qqc,Vc(qqnump,$E(Vc(qqnump),1,qqcii),5)=$$RecCorv(qqo,qqc) ;@dol 2.04.04
 ..I qqcii=$L(Vc(qqnump)) D
 ...S qqZN=qqc N qqc S qqc=qqZN D ..RecPost(1,qqo) ;@dol 19.02.03
 S qqwch=qW.rCor(qObj,qqc,qqwchg,,cdtu,)  ;qqtime устанавливается;@Dol 20.12.07 qqwch
 I $G(Vo(qqnump,qObj,2))=6," "_qqwchg_" "[(" C "),W("C")'="" S qqc=W("C") D ..wqqotree(Vc(qqnump),,qqc,,1) ;@Dol 31.05.05 редактирование кодов экземпляров для массивов
 S qqwchg="" ;нельзя для RecNewD но сделан спец.параметр
 I $D(qqwchgold) S qqwchgold=qARM.RecNewD(qObj,qqc,,qqwchgold)!qARM.RecNewP(qObj,"",qqc,1) D:qqwchgold ..wqqotree(Vc(qqnump),,,,1) ;перевывод, если были значения по умолчанию при выводе пустых (неявный ввод) ;@dol 18.02.04 ,,qqwchgold
 S qqwchg=""
 I '$G($$$Tree),cdtu,$G(qqtime)'="" S Vc(qqnump,Vc(qqnump),5)=$G(qqtime) ;D:$E(qObj)="v"  ;если есть синонимы
 ;.N qqci S qqci="" F  S qqci=$O(Vc(qqnump,qqci)) Q:qqci=""  I $S($E(Vc(qqnump,qqci,0))'="v":Vc(qqnump,qqci,0)=$E(qObj,3,255),1:$E(Vc(qqnump,qqci,0),3,255)=$E(qObj,3,255)),Vc(qqnump,qqci)=qqc S Vc(qqnump,qqci,5)=qqtime
 I '$G($$$Tree),$$RecCorv(qObj,qqc) ;@dol 2.04.04 ;!!!!23.06.04 $G(qqtime)'="" ?????
 I $D(Vo(qqnump,qObj,11,"@ZXXadd")),$G(Vc(qqnump))'="" S Vt(qqnump,"ZXXadd",qObj,Vc(qqnump))="" D ..wwwwZXXadd(qObj) ;@dol 19.05.03 кнопка ввода
 ;надо перевывести обобщения
 N qqw,qqwl S qqw="@",qqwl="" F  S qqw=$O(Vo(qqnump,qObj,11,qqw)) Q:qqw=""  I $E(qqw)="@"||($E(qqw)="H"),qqw'="@ZXXadd"," "_qqwch_" "'[(" "_qqw_" ") D  ;@Dol 23/09/05 +H*
 .S qqwl=qqwl_" "_qqw I $E(qqw)="H"," "_qqwch_" "[(" "_$E(qqw,$E(qqw,2)?1n+2,255)_" ") S W(qqw)=qW.GG(qObj,qqw,qqc) ;@Dol 20.12.07 если изменились значения понятий, их характеристики нужно записать в W для перевывода
 I $G(Vo(qqnump,qObj,2))=6 S:$D(Vo(qqnump,qObj,11,"CC")) qqwl=qqwl_" CC" S:$D(Vo(qqnump,qObj,11,"C")) qqwl=qqwl_" C",W("C")=qqc ;@Dol 29.03.05 для массива нужно перевывести и CC
 D:qqwl'="" ..wwww($E(qqwl,2,32000)) 
 ; и выражения ???
 D ..RecPost(2,qObj) ;постдействие
 Q:$Q 1 Q
 ;@Dol 14.02.07 обработка ошибок
RecCorErr D:'$D(Vo(qqnump,-1,200)) ..GetPar("X1200") I Vo(qqnump,-1,200)'="" N qqend,qqo,qqt,qqcerr,qqoerr,qqcierr S qqo=qObj,qqoerr=$P(err," "),qqt=10*($L(err," ")=1)+1,qqcierr=$P($P(err,"qqci=",2)," "),qqcerr=$P($P(err,"qqc=",2)," ") X Vo(qqnump,-1,200) I $D(qqend),qqend'=-1 Q qqend
 S qqwchg="" D:$S(Vo(qqnump,-1,200)'="":$G(qqend)'=-1,1:1) ..Message($S($L(err," ")=1:"Попытка ввода виртуального объекта "_err,1:"Объект "_$S('$G(W("Zadm")):"",1:"("_err_") ")_"введен другим пользователем"),,,$G(qqXBMesTime)) D:$L(err," ")>1 ..wqqotree($P($P(err,"qqci=",2)," "),,$P($P(err,"qqc=",2)," "),1) Q:$Q 0 Q
 ;
RecCorEr D ..wpoe(Vc(qqnump)_" "_$$$CurObj_" 0") Q  ;неудачна - вернемся на корректируемый объект
RecCorLeer(qqo)
 I $G(Vo(qqnump,qqo,2))=1 S:$G(Vs(qqnump,"Virt",qqo))'="" Vs(qqnump,"Virt",qqo)=qqc Q  ;@dol 28.02.04 для встроенных
 I $G(Vo(qqnump,qqo,280))="",$G(Vo(qqnump,qqo,2))=2||($G(Vo(qqnump,qqo,2))=6),$S($G(Vo(qqnump,qqo,2))=6:1,$G(Vo(qqnump,-1,87)):$G(Vo(qqnump,qqo,87))=0,1:'$G(Vo(qqnump,qqo,87))) S qqc=$P(qW.rNew(qqo,$S($G(Vo(qqnump,qqo,2))'=6:$TR(qqcc," "),1:qqcc))," ") D:qqo'=qObj  S:$G(Vs(qqnump,"Virt",qqo))'="" Vs(qqnump,"Virt",qqo)=qqc Q  ;@dol 18.02.04 без вывода пустых
 .N qqwchg S qqwchg="" D qARM.RecNewD(qqo,qqc,,qqwchgold)
 I $S('$G(Vo(qqnump,qqo,2)):0,Vo(qqnump,qqo,2)=2:$S($G(Vo(qqnump,qqo,29))="":1,$D(Vt(qqnump,529,qqo)):1,Vo(qqnump,qqo,29)["qW.gOrderSort":0,1:$P(Vo(qqnump,qqo,29)," ")["("),1:1) S err=qqo Q
 N qqcc1,qqcc2 I $G(Vo(qqnump,qqo,280))="",$L($TR(qqc," "))=$$$ObjLqqc(qqo) G:$D(^Q(1,qqo,$TR(qqc," "))) RecCorLE G RecCorLD ;@dol 15.03.04 желаемый код
 S qqcc2=qW.gOrder(1,qqo,"",qqc) G:qqcc2'="" RecCorLE
 I $G(Vo(qqnump,qqo,2)),Vo(qqnump,qqo,29)'="*" D
 .I $P(Vo(qqnump,qqo,29)," ",2)'="" S qqc=..Value($P(Vo(qqnump,qqo,29)," ",2,255)) Q  ;S @("qqc="_$P(Vo(qqnump,qqo,29)," ",2,255)) Q
 .S qqcc1=$P(Vo(qqnump,qqo,29)," ") S:'($D($$$ObjLqqc(qqcc1))#2) $$$ObjLqqc(qqcc1)=$G(^Q(1,"CxObj",qqcc1,"X50"),255) S qqc=$E(qqc,1,$$$ObjLqqc(qqcc1)) ;длина кода
RecCorLD
 S qqc=$P(qW.rNew(qqo,qqc)," ") D:qqo'=qObj  S:$G(Vs(qqnump,"Virt",qqo))'="" Vs(qqnump,"Virt",qqo)=qqc ;@dol 21.1.04
 .N qqwchg S qqwchg="" D qARM.RecNewD(qqo,qqc,,qqwchgold) ;@dol 15.03.03 значения по умолчанию
 Q:$G(Vo(qqnump,qqo,280))=""  ;@dol 10.02.03 далее обработка темпоральной коррекции
 I $E(Vo(qqnump,qqo,280))="@",Vo(qqnump,qqo,280)'="@" Q
 I $G(Vt(qqnump,"ZTmpqqc"))'="" S $P(Vt(qqnump,"ZTmpYT")," ",2)=1,Vt(qqnump,"ZTmpYT",qqo)=$E(qqc,$$$ObjLqqc(qqcc1)+1,255) ;вершина темпоральной коррекции 
 Q
RecCorv(qObj,qqc,qqtime)    ;перезапись синонимов
 N qqo S qqo=$S($E(qObj)="v":$E(qObj,3,255),1:qObj)
 S:'$D(qqtime) qqtime=$G(^Q(1,qqo,qqc,"X"))
 ;Q:$E(qObj)'="v" qqtime ;если есть синонимы
 N qqci S qqci="" F  S qqci=$O(Vc(qqnump,qqci)) Q:qqci=""  I $S(Vc(qqnump,qqci,0)=qObj:0,$E(Vc(qqnump,qqci,0))'="v":Vc(qqnump,qqci,0)=qqo,1:$E(Vc(qqnump,qqci,0),3,255)=qqo) D
 .I Vc(qqnump,qqci)=qqc S Vc(qqnump,qqci,5)=qqtime Q  ;D:W("Zadm") ..Message("Обновлен Vc qqci="_qqci_" qqo="_Vc(qqnump,qqci,0)) Q
 .I Vc(qqnump,qqci)[" ",$S($G(Vo(qqnump,Vc(qqnump,qqci,0),2))=2:$P($G(Vo(qqnump,Vc(qqnump,qqci,0),29))," ")'["(",1:'$G(Vo(qqnump,Vc(qqnump,qqci,0),2))) S Vc(qqnump,qqci,5)=qqtime S Vc(qqnump,qqci)=qqc ;D:W("Zadm") ..Message("Обновлен Vc qqci="_qqci_" qqo="_Vc(qqnump,qqci,0)_" qqc="_qqc)
 Q qqtime
RecCorLE S err=qqo_" qqc="_qqcc2_" qqci="_$E(Vc(qqnump),1,qqcii) Q  ;@dol 27.09.03 порождаемый экземпляр уже кто-то ввел !!!
]]></Implementation>
</Method>

<Method name="RecDel">
<Description>
        Удалить объект по объектной ссылке.

Arg3=1 - блокировать лог.удаление</Description>
<Internal/>
<FormalSpec>qOref:%String,con:%String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I '$G(W("ZBtred")) D ..Message("Не установлен режим ввода",,,$G(qqXBMesTime)) Q:$Q "" Q
 I $G(qOref)="",$G($$$CurObj)=-1 D ..Message("Не определен удаляемый объект",,,$G(qqXBMesTime)) Q:$Q "" Q  ;@dol
 ;I '$G(con),$G($$$CurObj)'="",$G(Vo(qqnump,$$$CurObj,2))=1,$L(Vc(qqnump))>2 F  S Vc(qqnump)=$E(Vc(qqnump),1,$L(Vc(qqnump))-2) I $G(Vo(qqnump,Vc(qqnump,Vc(qqnump),0),2))'=1 S $$$CurObj=Vc(qqnump,Vc(qqnump),0) Q  ;@Dol 17.06.05 перемещение по встроенным
 I '$G(con),$G($$$CurObj)'="",$G(Vo(qqnump,$$$CurObj,2))=1,$L(Vc(qqnump))>2 d  ;@Dol 21.02.08
 .N qqcii S qqcii=Vc(qqnump) S:0 qqoi=$$$CurObj F  S Vc(qqnump)=$E(Vc(qqnump),1,$L(Vc(qqnump))-2) Q:Vc(qqnump)=""  I $G(Vo(qqnump,Vc(qqnump,Vc(qqnump),0),2))'=1,Vc(qqnump,Vc(qqnump),0)=$E($$$CurObj,3,255) S $$$CurObj=Vc(qqnump,Vc(qqnump),0) Q  ;@Dol 17.06.05 перемещение по встроенным;@Dol 17.05.11 ?qqoi
 .I Vc(qqnump)="" S Vc(qqnump)=qqcii
 N qObj,qqc,qOref1,qqo,qqver,qqq,del
 S:$G(qOref)="" qOref=Vc(qqnump) S (qqo,qObj)=$G(Vc(qqnump,qOref,0)),qqc=$G(Vc(qqnump,qOref)) I qqo="" Q:$Q "" Q  ;@dol 22.04.08 !!! что-то не так, но иногда бывает
 G:$G(con) RecDelcon
 S qqq=..RecVerOp(qObj,3) I qqq D:$L(qqq)=1||($L($TR(qqq," "))'=1) ..Message($S($L(qqq)=1:"Запрещено удаление "_..RecObj(qObj),1:$E(qqq,2,32000)),,,$G(qqXBMesTime)) Q:$Q "" Q  ;@dol 6.11.03
 ;I ..RecVerOp(qObj,3)  D ..Message("Запрещено удаление "_..RecObj(qObj)) Q:$Q "" Q
 I $E(qqc,$L(qqc))=" ",$G(Vo(qqnump,-1,87))'=""||($G(Vo(qqnump,qObj,87))'="") D ..Message("Не существует экземпляр "_..RecObj(qObj),,,$G(qqXBMesTime)) Q:$Q "" Q  ;игнорирование удаления для несуществующего объекта (x187)
 I ..RecVer(3,qObj)'="" Q:$Q "" Q  ;правило проверки перед удалением
 I $S($G($$$Tree):0,$G(Vo(qqnump,qObj,2))>2:0,1:$L(qqc)<3),'W("Zadm") D ..Message("Удаление "_..RecObj(qObj)_" только в режиме администратора",,,$G(qqXBMesTime)) Q:$Q "" Q  ;слишком много может быть удалено
 S qOref1=..RecObj(qObj,3) I qOref1'=""!($L(qqc)<3) D  Q:$Q 1 Q  ;для большого (предположительно) поддерева вопрос задается всегда
 .;проверка на удаление поддерева ????
 .I qARM.GetPar("X5222",,qObj)'="" s del=1 I '$G(Arg3),@Vo(qqnump,qObj,222) D  Q  ;@Dol 19.12.07 лог.удаление
 ..D ..QuestionM("Удалить логически "_qOref1_$S('$G(W("Zadm")):"",1:"~Удалить из базы"),1,"","D qARM.RecDel("""_qOref_""",1)","D qARM.RecDel("""_qOref_""",1,1)") ;в режиме Администратор предоставлять выбор удаления Логически/физически
 .D ..QuestionM("Удалить "_$S($G(del):"из базы ",1:"")_qOref1,1,"","D qARM.RecDel("""_qOref_""",1,1)")
RecDelcon
 I $G(Vo(qqnump,qObj,2))>2 D  I Vo(qqnump,qObj,2)'=6 Q:$Q 1 Q 
 .;;I $G(Vo(qqnump,qObj,2))=6 S:'$D(Vo(qqnump,qObj,33)) Vo(qqnump,qObj,33)=qARM.GetPar("X533",,qObj) K @Vo(qqnump,qObj,33)@(qqc) Q  ;для массива
 .;;Далее @Misuno обработка триггеров для массива
 .I $G(Vo(qqnump,qObj,2))=6 S:'$D(Vo(qqnump,qObj,33)) Vo(qqnump,qObj,33)=qARM.GetPar("X533",,qObj) d  Q  ;для массива
 ..n qqlw s qqlw=""
 ..I '$D(Vo(qqnump,qObj,243)) S Vo(qqnump,qObj,243)=qARM.GetPar("X5243",,qObj),Vo(qqnump,qObj,248)=qARM.GetPar("X5248",,qqo)
 ..I Vo(qqnump,qObj,248)'="" N qqend,qqo s qqo=qObj X Vo(qqnump,qqo,248) I $G(qqend) Q  ;@Misuno 17.03.07 триггер ДО
 ..K @Vo(qqnump,qObj,33)@(qqc) 
 ..D:$G(Vo(qqnump,qObj,243))'=""   ;@Misuno 17.03.07 (триггер После)
 ...I Vo(qqnump,qObj,243)["(" n qqo s qqo=qObj X Vo(qqnump,qqo,243) ;@Misuno 17.03.07 @Dol 28.02.06 пользовательский методобработки согласованных изменений
 .D ..Message("Удаление виртуальных объектов запрещено",,,$G(qqXBMesTime)) Q  ;блокировка для виртуальных ???
 I '$G($$$Tree) S qqver=qW.rTmpVer(qObj,qqc,3) I qqver'="",..RecTmp(qqver,qObj) K W("Zpos",2) D ..wqqotree(,,qqc) D ..RecPost(1,qObj) Q:$Q "" Q  ;темпоральная коррекция
 K W("Zpos",2)
 D ..RecDelOref(qOref,1,$G(Arg3))
 S qqwchg="" ;на всякий случай
 D ..RecPost(3,qObj) ;постдействие
 Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="RecDelOref">
<Description>
Удаление из дерева экземпляров на экране и в массиве Vc(qqnump) поддерева qOref.
Если Arg2=1 - то и из базы.
Arg3=1 - блокировка лог.удаления (всегда физическое)
После удаления производится позиционирование или перевывод.
</Description>
<Internal/>
<FormalSpec>qOref:%String,Arg2:%String=0,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qOref1,qOref2,qOref3,qi,qObj,qObj1,qqso
 S qObj=Vc(qqnump,qOref,0),qOref1=qOref,qi=0,qObj1=qObj
 I Arg2,qW.rDel(qObj,Vc(qqnump,qOref),,,,,,,$G(Arg3))=10 D  I $G(qi) Q:$Q "" Q  ;@Dol 21.04.05 логическое удаление
 .I '$G(Vt(qqnump,0))||($G(Vo(qqnump,qObj,27))="") S qi=1 D ..wqqotree() Q
 .I $G($$$ReFind) D qW.gRel("-",qObj,Vc(qqnump,qOref))
 F  D  S qOref1=$O(Vc(qqnump,qOref1)) Q:$E(qOref1,1,$L(qOref))'=qOref  S qObj1=Vc(qqnump,qOref1,0)
 .K Vc(qqnump,qOref1)
 S qOref3=qOref_" "_qObj_" 0" D  ;Позиционирование
 .S qOref1=$E($O(Vc(qqnump,qOref),-1),1,$L(qOref))
 .I qOref1'="",qObj=Vc(qqnump,qOref1,0) S qOref=qOref1 Q  ;предыдущий объект такой же
 .S qOref2=$O(Vc(qqnump,qOref)) I qOref2'="",qObj=Vc(qqnump,qOref2,0) S qOref=qOref2 Q  ;следующий объект такой же
 .S qOref=$S(qOref1'="":qOref1,1:qOref2) ;предыдущий не меньшего уровня иерархии
 I $G(Vs(qqnump,7))=qObj S $P($$$CondFind," ",10,11)=qqc_" "_qqc,$$$CurObj=qObj D qARM.wcre() Q:$Q "" Q
 I qOref="" D ..wcre() Q:$Q "" Q  ;S qqc="" D ..Wait("S qqc="""" D qARM.wcre()") Q "" ;????S qqc=""
 I $P(qOref3," ",2)'=qObj,$G(Vt(qqnump,0)),$G(Vo(qqnump,qObj,27))'=""!($G(Vo(qqnump,qObj,28))'="")!($G(Vo(qqnump,-1,67))'="") S qqc=Vc(qqnump,qOref) D ..wcre() Q:$Q "" Q
 S qqc=Vc(qqnump,qOref),(qObj,$$$CurObj)=Vc(qqnump,qOref,0) I $G(Vc(qqnump,qOref,1),1) S Vc(qqnump)=qOref  D  D ..wpoe(qOref_" "_qObj_" 0")  Q:$Q "" Q  ;обект активен ;@dol 19.02.03 ..wqqotree
 .I $P(qOref3," ",2)'=qObj,$G(Vo(qqnump,-1,87))'=""!($G(Vo(qqnump,$P(qOref3," ",2),87))'="") D  Q
 ..I $L($P(qOref3," "))=2 D ..wcre() Q
 ..D ..wqqotree($S($L(qOref)<$L($P(qOref3," ")):qOref,1:$E($P(qOref3," "),1,$L($P(qOref3," "))-2)),,,,1) Q
 .D ..wM(qwin_".T2","M9",1,0,qOref3,0,0) ;найти и свернуть
 .D ..wM(,"M6","",0)
 .D:$D(Vt(qqnump,9,"FCBUT")) ..ButtonDestr(),..wwwwFCBUT()
 .I $D(Vo(qqnump,qObj,11,"@ZXXadd")) S Vt(qqnump,"ZXXadd",qObj,qOref)="" D ..wwwwZXXadd(qObj) ;@dol 19.05.03 кнопка ввода
 D ..wcre()  Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="RecDelRel">
<Description>
Удаление перечня релевантных текущего (!!!) объекта
qOref - задавать НЕ рекомендуется. Реально это qqci ( см. описание массива Vc). По умолчанию используется текущее положение в дереве экземпляров
con - НЕ задавать. Исползуется в методе для продолжения после вопросов.

NoReFind=1 - вне зависимости от включеннго режима уточнения, иначе удаление допускается только в режиме уточнения</Description>
<Internal/>
<FormalSpec>qOref:%String,con:%String,NoReFind:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qObj,qqc,qOref1,qqo
 S:$G(qOref)="" qOref=Vc(qqnump) S (qqo,qObj)=Vc(qqnump,qOref,0),qqc=Vc(qqnump,qOref)
 G:$G(con) RecDelRelcon
 I $G(Vo(qqnump,qObj,2))>2 D ..Message("Запрещено для виртуальных") Q:$Q 1 Q  ;блокировка для виртуальных ???
 I '$G(NoReFind),'$$$ReFind D ..Message("Не режим уточнения") Q:$Q 1 Q 
 I ..GetPar(530,,qObj)  D ..Message("Запрещено удаление "_..RecObj(qObj)) Q:$Q 1 Q 
 I ..RecVer(3,qObj)'="" Q:$Q "" Q  ;правило проверки перед удалением ;было закомментировано ???@dol 1.10.02
 I $L(qqc)<3,'W("Zadm") D ..Message("Удаление "_..RecObj(qObj)_" только в режиме администратора") Q:$Q "" Q  ;слишком много может быть удалено
 D ..QuestionM("Удалить по перечню релевантных "_..RecObj(qObj),1,"","D qARM.RecDelRel("""_qOref_""",1)") Q:$Q 1 Q
RecDelRelcon
 K W("Zpos",2) D qW.rDel(qObj,"",1)
 S qqc="" D ..wcre() Q:$Q 1 Q  ;@Dol 10/04/06
 ;S qOref1=$E(qOref,1,$L(qOref)-2) I qOref1="" D ..RecRel(1,qOref) Q:$Q 1 Q 
 ;S $$$CurObj=Vc(qqnump,qOref1,0),qqc=$E(qqc,1,$$$ObjLqqc($$$CurObj)) D ..wcre() Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="RecIns">
<Description>
Вставить новый экземпляр объекта Arg1 после текущего.
Возвращает 1 если ввод успешен.
qqNL=1 - запустить ввод, если qqc с пробелом (используется для виртуальных)
Before=1 - вставить перед текущим
Если для объекта указано Подтверждение ввода, то задается вопрос о вставке Перед/После.

Используется qW.rInc.

Вставка - сдвиг в базе всех экземпляров поддрева - может работать весьма долго. </Description>
<Internal/>
<FormalSpec>qObjNew:%Library.String,qOref:%Library.String,cont:%Library.String,qqNL:%Library.String,Before:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$G(W("ZBtred")) D ..Message("Не установлен режим ввода",,,$G(qqXBMesTime)) Q:$Q "" Q
 N qqco,qqci1,qqci2,qObj,qqo,qqpos,qrefr,qqcold,qqq
 I '$G(cont),$G(qObjNew)=""||(qObjNew=$G($$$CurObj)),$G($$$CurObj)'="",$G(Vo(qqnump,$$$CurObj,2))=1 F  S Vc(qqnump)=$E(Vc(qqnump),1,$L(Vc(qqnump))-2) I $G(Vo(qqnump,Vc(qqnump,Vc(qqnump),0),2))'=1 S $$$CurObj=Vc(qqnump,Vc(qqnump),0) Q  ;@Dol 17.06.05 перемещение по встроенным
 ;qrefr=1 - необходим перевывод, иначе - вставка в текущее дерево и в Vc(qqnump) 
 S:$G(qObjNew)="" qObjNew=$G($$$CurObj) I qObjNew=""!(qObjNew=-1) S qObjNew=$P($O(Vo(qqnump,-1,6,"")),",") I qObjNew="" D ..Message("Нет объектов в отображении") Q:$Q "" Q
 S:$G(qOref)="" qOref=$G(Vc(qqnump),0)
 S qqo=qObjNew ;!!!! чтобы работал GG
 N qObj S qObj=$G(Vc(qqnump,qOref,0)),qqc=$G(Vc(qqnump,qOref)) ;текущий объект и код его экземпляра
 I qObj'=qObjNew Q ..RecNew(qObjNew,qOref,,$G(qqNL)) ;если не текущий объект, то переход на обычный ввод
 I $G(cont) G RecInsC:cont=1
 S qqq=..RecVerOp(qObjNew,1) I qqq D:$L(qqq)=1||($L($TR(qqq," "))'=1) ..Message($S($L(qqq)=1:"Запрещена вставка "_..RecObj(qObjNew),1:$E(qqq,2,32000)),,,$G(qqXBMesTime)) Q:$Q "" Q  ;@dol 6.11.03
 I '$G(qqNL),$E(qqc,$L(qqc))=" ",$G(Vo(qqnump,-1,87))'=""||($G(Vo(qqnump,qObjNew,87))'="") D:0 ..Message("Ввод нового экземпляра бессмысленен без коррекции (пустого) текущего",,,$G(qqXBMesTime)) Q:$Q "" Q  ;игнорирование ввода для несуществующего объекта (x187)
 I ..RecVer(1,qObjNew)'="" Q:$Q "" Q  ;правило проверки перед вводом
 S qqci1=..RecObj(qObjNew,1) I qqci1'="" D   Q:$Q 1 Q
 .I '$D(Before) D ..QuestionM("Вставить "_qqci1_" после~Вставить перед",1,"","D qARM.RecIns("""_qObjNew_""","""_qOref_""",1)","D qARM.RecIns("""_qObjNew_""","""_qOref_""",1,,1)") Q
 .D ..QuestionM("Вставить "_qqci1,1,"","D qARM.RecIns("""_qObjNew_""","""_qOref_""",1,,"_''Before_")") Q  ;@Dol 4.04.08
RecInsC ;продолжение после вопроса
 I $G(Vo(qqnump,qObjNew,2))>2||($G($$$Tree)) D ..Message("Запрещен ввод для виртуального объекта") Q:$Q 1 Q  ;блокировка для виртуальных ???
 I $G($$$ObjLqqc(qObjNew),255)=255 D ..Message("Запрещен ввод для объектов с незаданной длиной кода") Q:$Q 1 Q
 S qqver=qW.rTmpVer(qObjNew,qqc) I qqver'="",..RecTmp(qqver,qObjNew,1)
RecInsC0 ;@Dol 21.05.08 переделано (изменяется Vc в qW.rIns )
 S qqco=qqc,qrefr=1
 S qqci1=$S($G(Before):"",1:$$RecInsT(qqco)) ;@Dol 21.05.08 перед вроде тоже можно???
 I qqci1="" S qrefr=1 I 1  ;нужен перевывод
 E  S qqci1=$$RecInsI(qqci1) D
 .I qqci1="" S qrefr=1 Q  ;перевывод
 .S qrefr=0 ;вставка
 S qqc=qW.rIns(qObjNew,qqc,,$G(Before),qqci1) I qqc="" S qqc=qqco Q:$Q "" Q
 I $D(qqcold) S qqco=qqcold
 D:$G(Vo(qqnump,qObjNew,280))="@"  ;'="" @dol 04.01.06;;;@dol 10.02.03 далее обработка темпоральной коррекции
 .N qqcc1 S qqcc1=$P(Vo(qqnump,qObjNew,29)," ") S:'($D($$$ObjLqqc(qqcc1))#2) $$$ObjLqqc(qqcc1)=$G(^Q(1,"CxObj",qqcc1,"X50"),255)
 .I $G(Vt(qqnump,"ZTmpqqc"))'="" S $P(Vt(qqnump,"ZTmpYT")," ",2)=1,Vt(qqnump,"ZTmpYT",qObjNew)=$E(qqc,$$$ObjLqqc(qqcc1)+1,255) ;вершина темпоральной коррекции 
 D ..RecNewD(qObjNew,qqc)
 ;S qqci1=$S($G(Before):"",1:$$RecInsT(qqco))
 ;I qqci1="" S qrefr=1 I 1  ;нужен перевывод
 ;E  S qqci1=$$RecInsI(qqci1) D
 ;.I qqci1="" S qrefr=1 Q  ;перевывод
 ;.S qrefr=0 ;вставка
 D ..RecNewP(qObjNew,"",qqc,qrefr)
 I $G(Vs(qqnump,7))=qObjNew S qrefr=1,$P($$$CondFind," ",10,11)=qqc_" "_qqc
 I ..GetPar("X1191") D qW.gRel("+",qObjNew,qqc,,1) ;@dol 17.12.03 поместить в релевантные
 I qrefr||$G(Vo(qqnump,qObjNew,28)) S $$$CurObj=qObjNew D ..wcre() G RecInsEn  ;перевывод
 I $D(qqcold),qqcold[" " D ..wqqotree(,,qqc,,1) G RecInsEn
 D ..wP(qwin_".T2","BulkUpdate",1)
 D qW.gForm(qql,qObjNew,qqc,100,qqci1) ;вставка
 D ..wwwwZXXadd(qObjNew) D:$D(Vt(qqnump,9,"FCBUT")) ..ButtonDestr(),..wwwwFCBUT()
 D ..wpoe(Vc(qqnump)_" "_qObjNew_" 0"),..wP(qwin_".T2","BulkUpdate",0,1)
RecInsEn I $D(Vs(qqnump,7)),$G(Vo(qqnump,-1,62)) D ..wM(qwin,"qResize",$TR(Vo(qqnump,-1,62),"123","312")),..wM(qwin,"qReplace"),..wpoe(,1) ;если есть фиксация и авторазмеры
 K W("Zpos",2,"y"),W("Zpos",2,"x")
 D ..RecPost(1,qObjNew) ;постдействие
 Q:$Q 1 Q
RecInsT(qqco) ;проверим наличие предыдущего кода в дереве и возврат qOref для него
 S qqci1=qOref,(qqci1,qqci2)=$E(qqci1,1,$L(qqci1)-2)
 F  S qqci1=$O(Vc(qqnump,qqci1)) Q:qqci1=""  Q:$S(qqci2="":0,1:$E(qqci1,1,$L(qqci2))'=qqci2)  I Vc(qqnump,qqci1,0)=qObjNew,Vc(qqnump,qqci1)=qqco S qqco="" Q
 Q $S(qqco="":qqci1,1:"")
RecInsI(qqci1) ;вставка Oref нового объекта (возвращает Oref или пусто, если вставить невозможно) 
 S qqci2=$A(qqci1,$L(qqci1))+1 D  Q $S($D(Vc(qqnump,qqci1)):"",1:qqci1)
 .I qqci2<126 S $E(qqci1,$L(qqci1))=$C(qqci2) Q
 .S $E(qqci1,$L(qqci1)-1,$L(qqci1))=$C($A(qqci1,$L(qqci1)-1)+1,65)
]]></Implementation>
</Method>

<Method name="RecNew">
<Description>
Новый экземпляр объекта Arg1.
Возвращает 1 если ввод успешен.
qqNL=1 - запустить ввод, если qqc с пробелом (используется для виртуальных)
NoRed=1 - игнорировать отсутствие режима ввода; @Dol 03.11.09</Description>
<Internal/>
<FormalSpec>qObjNew:%String,qOref:%String,cont:%String,qqNL:%Library.String,NoRed</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I '$G(W("ZBtred")),'$G(NoRed),'$G(cont) D ..Message("Не установлен режим ввода",,,$G(qqXBMesTime)) Q:$Q "" Q  ;@Dol 03.11.09 '$G(NoRed),'$G(cont)
 N qqco,qqci1,qqci2,qnumber,qObj,qqo,qqpos,qrefr,qqcold,qqq,qX5310,qX5311
 ;I '$G(cont),$G(qObjNew)=""||(qObjNew=$G($$$CurObj)),$G($$$CurObj)'="",$G(Vo(qqnump,$$$CurObj,2))=1 F  S Vc(qqnump)=$E(Vc(qqnump),1,$L(Vc(qqnump))-2) I $G(Vo(qqnump,Vc(qqnump,Vc(qqnump),0),2))'=1 S $$$CurObj=Vc(qqnump,Vc(qqnump),0) Q  ;@Dol 17.06.05 перемещение по встроенным
 I '$G(cont),$G(qObjNew)=""||(qObjNew=$G($$$CurObj)),$G($$$CurObj)'="",$G(Vo(qqnump,$$$CurObj,2))=1,$L(Vc(qqnump))>2 d  ;@Dol 21.02.08 ;@Dol 17.05.11 было '$G(con)
 .N qqcii S qqcii=Vc(qqnump) S:0 qqoi=$$$CurObj F  S Vc(qqnump)=$E(Vc(qqnump),1,$L(Vc(qqnump))-2) Q:Vc(qqnump)=""  I $G(Vo(qqnump,Vc(qqnump,Vc(qqnump),0),2))'=1,Vc(qqnump,Vc(qqnump),0)=$E($$$CurObj,3,255) S $$$CurObj=Vc(qqnump,Vc(qqnump),0) Q  ;@Dol 17.06.05 перемещение по встроенным;;@Dol 17.05.11 ?qqoi
 .I Vc(qqnump)="" S Vc(qqnump)=qqcii
 ;qrefr=1 - необходим перевывод, иначе - вставка в текущее дерево и в Vc(qqnump) 
 S:$G(qObjNew)="" qObjNew=$G($$$CurObj) I qObjNew=""!(qObjNew=-1) S qObjNew=$P($O(Vo(qqnump,-1,6,"")),",") I qObjNew="" D ..Message("Нет объектов в отображении") Q:$Q "" Q
 S:$G(qOref)="" qOref=$G(Vc(qqnump),0)
 S qqo=qObjNew ;!!!! чтобы работал GG
 N qObj S qObj=$G(Vc(qqnump,qOref,0)),qqc=$G(Vc(qqnump,qOref)) ;текущий объект и код его экземпляра
 S qnumber=..GetPar(520,,qObjNew) ;количество объектов
 I $G(cont) G RecNewC:cont=1,RecNewC2:cont=2,RecNewC3
 ;I ..GetPar(530,,qObjNew)  D ..Message("Запрещен ввод "_..RecObj(qObjNew)) Q ""
 S qqq=..RecVerOp(qObjNew,1) I qqq D:$L(qqq)=1||($L($TR(qqq," "))'=1) ..Message($S($L(qqq)=1:"Запрещен ввод "_..RecObj(qObjNew),1:$E(qqq,2,32000)),,,$G(qqXBMesTime)) Q:$Q "" Q  ;@dol 6.11.03
 I '$G(qqNL),$E(qqc,$L(qqc))=" ",$G(Vo(qqnump,-1,87))'=""||($G(Vo(qqnump,qObjNew,87))'="") D:0 ..Message("Ввод нового экземпляра бессмысленен без коррекции (пустого) текущего",,,$G(qqXBMesTime)) Q:$Q "" Q  ;игнорирование ввода для несуществующего объекта (x187)
 I ..RecVer(1,qObjNew)'="" Q:$Q "" Q  ;правило проверки перед вводом
 S qqci1=..RecObj(qObjNew,1) I qqci1'="" D  I qX5310,qqci2'="" D ..QuestionM("Ввести "_qqci1_"~Ввести "_..RecObj(qqci2)_$S('qX5311:"",1:"~-~Вставить "_qqci1_" после~Вставить перед"),1,"","D qARM.RecNew("""_qObjNew_""","""_qOref_""",1)","D qARM.RecNew("""_qqci2_""","""_qOref_""",1)","","D qARM.RecIns("""_qObjNew_""","""_qOref_""",1)","D qARM.RecIns("""_qObjNew_""","""_qOref_""",1,,1)") Q:$Q 1 Q  ;@Dol 20.07.07 иерархический ввод; 20.12.07 вставка
 .S qX5310=..GetPar("X5310",,qObjNew) S:$E(qX5310)="@" @("qX5310="_$E(qX5310,2,30000)) ;иерархич ввод
 .S qX5311=..GetPar("X5311",,qObjNew) S:$E(qX5311)="@" @("qX5311="_$E(qX5311,2,30000)) ;вставка
 .I qX5310 N qqoii F qqoii=1:1 S qqci2=$P($G(Vo(qqnump,qObjNew,"xObj"))," ",qqoii) Q:qqci2=""  Q:'$G(Vo(qqnump,qqci2,2))  ;@Dol 11.11.08 поиск возможного иерархического ввовда
 I (qnumber=1&(qObj=qObjNew)) D ..Message("Возможен только один экземпляр "_..RecObj(qObjNew),,,$G(qqXBMesTime)) Q:$Q "" Q
 I qqci1'="" D ..QuestionM("Ввести "_qqci1_$S('qX5311:"",1:"~-~Вставить "_qqci1_" после~Вставить перед"),1,"","D qARM.RecNew("""_qObjNew_""","""_qOref_""",1)","","D qARM.RecIns("""_qObjNew_""","""_qOref_""",1)","D qARM.RecIns("""_qObjNew_""","""_qOref_""",1,,1)") Q:$Q 1 Q  ;@Dol 20.12.07 вставка
RecNewC ;продолжение после вопроса
 I $G(Vo(qqnump,qObjNew,2))=6 S:'$D(Vo(qqnump,qObjNew,33)) Vo(qqnump,qObjNew,33)=qARM.GetPar("X533",,qObjNew) S:$E(Vo(qqnump,qObjNew,33),1,2)="@@" Vo(qqnump,qObjNew,33)=..Value($E(Vo(qqnump,qObjNew,33),3,30000)) S qqci1=..GetPar(521,,qObjNew) S:qqci1 qqcold=qqc,qqc=$O(@Vo(qqnump,qObjNew,33)@(""),-1)+1 G:qqci1 RecNewC0 D ..OpenText($S(qObj'=qObjNew:0,1:$TR(qqc," ")),"D qARM.RecNew("""_qObjNew_""","""_qOref_""",3)","Код экземпляра") Q:$Q 1 Q  ;массив
 I $G(Vo(qqnump,qObjNew,2))>2 D ..Message("Запрещен ввод для виртуального объекта",,,$G(qqXBMesTime)) Q:$Q 1 Q  ;блокировка для виртуальных ???
 I $$$Tree S:$G($$$GloRef)="" $$$GloRef="^Q(1)" I qObj'=qObjNew S:qObj'="" $$$GloRef=$NA(@$$$GloRef@(qObj,qqc)),qqc=0 ;если вводится новый экземпляр нижнего уровня в дереве
 I '$$$Tree,qObj=qObjNew S qqver=qW.rTmpVer(qObjNew,qqc) I qqver'="",..RecTmp(qqver,qObjNew,1)
 I '$$$Tree,$G($$$ObjLqqc(qObjNew),255)=255,'..GetPar(521,,qObjNew) D ..OpenText($S(qObj'=qObjNew:0,1:$TR(qqc," ")),"D qARM.RecNew("""_qObjNew_""","""_qOref_""",2)","Код экземпляра") Q:$Q 1 Q 
RecNewC0
 ;N $ET S $ET="S ^ee=$ZE,$EC="""""
 I qObj=qObjNew!($L($G($$$ObjRef(qObjNew)),",")=1) D  G RecNewEn ;Q 1 ;если вводится новый экземпляр текущего объекта
 .S qqc=qW.rNew(qObjNew,qqc,$$$ObjLqqc(qObjNew)'=255) ;возврат нового кода и предыдущего)
 .S qqco=$P(qqc," ",2),qqc=$P(qqc," ") I $D(qqcold) S qqco=qqcold
 .D:$G(Vo(qqnump,qObjNew,280))="@"  ;'="" @dol 04.01.06;;;@dol 10.02.03 далее обработка темпоральной коррекции
 ..;I $E(Vo(qqnump,qObjNew,280))="@",Vo(qqnump,qObjNew,280)'="@" Q
 ..N qqcc1 S qqcc1=$P(Vo(qqnump,qObjNew,29)," ") S:'($D($$$ObjLqqc(qqcc1))#2) $$$ObjLqqc(qqcc1)=$G(^Q(1,"CxObj",qqcc1,"X50"),255)
 ..I $G(Vt(qqnump,"ZTmpqqc"))'="" S $P(Vt(qqnump,"ZTmpYT")," ",2)=1,Vt(qqnump,"ZTmpYT",qObjNew)=$E(qqc,$$$ObjLqqc(qqcc1)+1,255) ;вершина темпоральной коррекции 
 .D ..RecNewD(qObjNew,qqc)
 .S qqci1=$$RecNewT(qqco) ;$S($D(qqcold):"",1:$$RecNewT(qqco)) ;если код задан в диалоге, лучше все перевывести 
 .I qqci1="" S qrefr=1 I 1  ;нужен перевывод;?????@Dol 20.07/05 ||($G(Vs(qqnump,7))=qObjNew) - не было и наверное не нужно
 .E  S qqci1=$$RecNewI(qqci1) D
 ..I qqci1="" S qrefr=1 Q  ;перевывод
 ..S qrefr=0 ;вставка
 .D ..RecNewP(qObjNew,qqci1_"AA",qqc,qrefr)
 .I $G(Vs(qqnump,7))=qObjNew S qrefr=1,$P($$$CondFind," ",10,11)=qqc_" "_qqc
 .I ..GetPar("X1191") D qW.gRel("+",qObjNew,qqc,,1) ;@dol 17.12.03 поместить в релевантные
 .I qrefr||$G(Vo(qqnump,qObjNew,28)) S $$$CurObj=qObjNew D ..wcre() Q  ;перевывод
 .I $D(qqcold),qqcold[" " D ..wqqotree(,,qqc,,1) Q
 .D ..wP(qwin_".T2","BulkUpdate",1)
 .D qW.gForm(qql,qObjNew,qqc,100,qqci1) ;вставк
 .D ..wwwwZXXadd(qObjNew) D:$D(Vt(qqnump,9,"FCBUT")) ..ButtonDestr(),..wwwwFCBUT() ;@Dol 21.05.08 add(qObjNew)
 .D ..wpoe(Vc(qqnump)_" "_qObjNew_" 0"),..wP(qwin_".T2","BulkUpdate",0,1)
RecNewC1 ;вставка объекта нижнего уровня
 N qOrefo,qOrefo1,i S qrefr=0
 ;I $L($$$ObjRef(qObjNew),",")=1
 S qqci1=$L($$$ObjRef(qObjNew),",")-$L($$$ObjRef(qObj),",")
 I qqci1>2 G RecNewE
 I qqci1=2 D  G:'qqci1 RecNewE
 .S qqci1=$P($$$ObjRef(qObjNew),",",$L($$$ObjRef(qObj),",")+1) ;объект предыдущего уровня
 .I $D(Vo(qqnump,qqci1,11)) S qqci1=0  Q
 .S qqc=$P(qW.rNew(qqci1,qqc,0)," ") D RecNewR(qqci1) S (qOrefo,qOref)=qOref
 .I $D(Vc(qqnump,qOref)),'qrefr S qrefr=1
 .S:'qrefr Vc(qqnump,qOref)=qqc,Vc(qqnump,qOref,0)=qqci1 S qqci1=1 ;если недостающий объект не имеет понятий, то его вполне можно ввести
 ;
 S:qnumber="" qnumber=1 F qnumber=1:1:qnumber D
 .S qqc=$P(qW.rNew(qObjNew,qqc,0)," ")
 .D:$G(Vo(qqnump,qObjNew,280))="@"  ;'="" @dol 04.01.06  ;@dol 10.02.03 далее обработка темпоральной коррекции
 ..;I $E(Vo(qqnump,qObjNew,280))="@",Vo(qqnump,qObjNew,280)'="@" Q
 ..N qqcc1 S qqcc1=$P(Vo(qqnump,qObjNew,29)," ") S:'($D($$$ObjLqqc(qqcc1))#2) $$$ObjLqqc(qqcc1)=$G(^Q(1,"CxObj",qqcc1,"X50"),255)
 ..I $G(Vt(qqnump,"ZTmpqqc"))'="" S $P(Vt(qqnump,"ZTmpYT")," ",2)=1,Vt(qqnump,"ZTmpYT",qObjNew)=$E(qqc,$$$ObjLqqc(qqcc1)+1,255) ;вершина темпоральной коррекции 
 .I qnumber=1 D RecNewR(qObjNew) S qOrefo1=qOref I 1
 .E  S $E(qOref,$L(qOref))=$C($A(qOref,$L(qOref))+2)
 .I $D(Vc(qqnump,qOref)),'qrefr S qrefr=1 
 .S:'qrefr Vc(qqnump,qOref)=qqc,Vc(qqnump,qOref,0)=qObjNew
 .D ..RecNewD(qObjNew,qqc)
 .D ..RecNewP(qObjNew,qOref,qqc,qrefr)
 I ..GetPar("X1191") D qW.gRel("+",qObjNew,Vc(qqnump,qOrefo1),,1) ;@dol 17.12.03 поместить в релевантные
 I $G(Vs(qqnump,7))=qObjNew S qqc=Vc(qqnump,qOrefo1),$P($$$CondFind," ",10,11)=qqc_" "_qqc,$$$CurObj=qObjNew D ..RecPost(1,qObjNew) D ..wcre() Q:$Q 1 Q
 I qrefr||$G(Vo(qqnump,qObjNew,28)) S $$$CurObj=qObjNew D ..wcre(),..RecPost(1,qObjNew) Q:$Q 1 Q  ;ввод первого или если только последний экземпляр
 D ..wP(qwin_".T2","BulkUpdate",1)
 I $G(qOrefo)'="" D qW.gForm(qql,Vc(qqnump,qOrefo,0),Vc(qqnump,qOrefo),100,qOrefo) I 1
 E  D qW.gForm(qql,qObjNew,Vc(qqnump,qOrefo1),100,qOrefo1)
 D ..wwwwZXXadd(qObjNew) D:$D(Vt(qqnump,9,"FCBUT")) ..ButtonDestr(),..wwwwFCBUT() ;@dol 21.05.08 add(qObjNew
 S Vc(qqnump)=qOrefo1,qqc=Vc(qqnump,qOrefo1)
 D ..wpoe(Vc(qqnump)_" "_qObjNew_" 0"),..wP(qwin_".T2","BulkUpdate",0,1)
RecNewEn I $D(Vs(qqnump,7)),$G(Vo(qqnump,-1,62)) D ..wM(qwin,"qResize",$TR(Vo(qqnump,-1,62),"123","312")),..wM(qwin,"qReplace"),..wpoe(,1) ;если есть фиксация и авторазмеры
 K W("Zpos",2,"y"),W("Zpos",2,"x")
 ;I $D(Vo(qqnump,qObjNew,11,"@ZXXadd")) S W("@ZXXadd",qObjNew)=qqc D ..wwww("@ZXXadd") ;@dol 18.05.03 кнопка ввод
 D ..RecPost(1,qObjNew) ;постдействие
 Q:$Q 1 Q 
RecNewE
 S Vc(qqnump)=qOref D ..wpoe(Vc(qqnump)_" "_$$$CurObj_" 0"),..Message("Нет объекта верхнего уровня") Q:$Q "" Q
 ;
RecNewT(qqco) ;проверим наличие предыдущего кода в дереве и возврат qOref для него
 S qqci1=qOref,(qqci1,qqci2)=$E(qqci1,1,$L(qqci1)-2)
 F  S qqci1=$O(Vc(qqnump,qqci1)) Q:qqci1=""  Q:$S(qqci2="":0,1:$E(qqci1,1,$L(qqci2))'=qqci2)  I Vc(qqnump,qqci1,0)=qObjNew,Vc(qqnump,qqci1)=qqco S qqco="" Q
 Q $S(qqco="":qqci1,1:"")
RecNewI(qqci1) ;вставка Oref нового объекта (возвращает Oref или пусто, если вставить невозможно) 
 S qqci2=$A(qqci1,$L(qqci1))+1 D  Q $S($D(Vc(qqnump,qqci1)):"",1:qqci1)
 .I qqci2<126 S $E(qqci1,$L(qqci1))=$C(qqci2) Q
 .S $E(qqci1,$L(qqci1)-1,$L(qqci1))=$C($A(qqci1,$L(qqci1)-1)+1,65)
RecNewR(qObjNew) ;получение ссылки
 I $E($O(Vc(qqnump,qOref)),1,$L(qOref))'=qOref S qOref=qOref_"AA" Q  ;нет подчиненных объектов
 N q1,q2,q3,q4,q5 S q3=Vc(qqnump,qOref,0)
 S q2="",q4="" F  S q2=$O(Vo(qqnump,q3,0,q2)) Q:q2=""  I $G(Vo(qqnump,q3,0,q2))'="" S q4=q4_","_Vo(qqnump,q3,0,q2)
 S q4=q4_"," ;список подчиненных объектов
 S q1=qOref,q5="" F  S q1=$O(Vc(qqnump,q1)) Q:q1=""  Q:$E(q1,1,$L(qOref))'=qOref  I $L(qOref)+2=$L(q1) S q2=Vc(qqnump,q1,0) D  Q:q2=""  S q5=q1
 .I $L($P(q4,","_q2_","))>$L($P(q4,","_qObjNew_",")) S q2=""
 I q2="",q5="" S qOref=$E(q1,1,$L(q1)-1)_$C($A(q1,$L(q1))-10) Q
 I $G(Vc(qqnump,q5))[" " S qOref=q5 Q  ;@dol 1.12.03
 I q1="" S qOref=$E(q5,1,$L(q5)-1)_$C($A(q5,$L(q5))+5) Q
 S qOref=$E(q5,1,$L(q5)-1)_$C($A(q5,$L(q5))+1) Q
RecNewC2 ;продолжение после ввода кода экземпляра
 I qObjNew="CxObj"||(qObjNew="CxWoc") N qq S qq=$S($D(^Q(1,"CxObj",Text))||$D(^Q(1,"CxWoc",Text)):"Существует "_$S($D(^Q(1,"CxObj",Text)):"Объект "_Text_" "_^Q(1,"CxObj",Text),1:"Понятие "_Text_" "_^Q(1,"CxWoc",Text)),'qSYS.VerXMLName(Text,qObjNew="CxObj"+1):"Некорректное XML-имя",1:"") I qq'="" D ..Message(qq) Q:$Q "" Q  ;спец. случай ввода кода объекта или понятия
 ;I qW.GG(qObjNew,"CC",Text)'="" D ..Message("Экземпляр существует") Q:$Q "" Q
 I $D(^Q(1,qObjNew,Text)) D ..Message("Экземпляр существует") Q:$Q "" Q
 N qq S qq=..GetPar("X74",,qObjNew,"C") I qq'="" D  I qq'="",$E(qq)'?1N  D ..Message(qq) Q:$Q "" Q
 .N qqo,Z S Z=Text,qqo=qObjNew S qq=..Value(qq)
 S qqcold=qqc,qqc=Text G RecNewC0
RecNewC3 ;продолжение после ввода кода экземпляра для массива
 I $D(@Vo(qqnump,qObjNew,33)@(Text)) D ..Message("Существует "_Text) Q:$Q "" Q
 ; S @Vo(qqnump,qObjNew,33)@(Text)=""
 S qqcold=qqc,qqc=Text G RecNewC0
]]></Implementation>
</Method>

<Method name="RecNewD">
<Description>
Умолчания для понятий экземпляра qqc объекта qqo.
qqwchg - текущеее.
Заполняется массив W(qqw) и изменяется qqwchg.
Выполняется действие перед вводом, коррекцией.
Производится коррекция и qqwchg сбрасывается.</Description>
<Internal/>
<FormalSpec>qqo:%String,qqc:%String,Arg1:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqw,qqz,qqt S qqt=1,qqw="" G:..GetPar("X5870",,qqo)=2 RecNewDD ;@Dol 17.10.07 варант вывода значений по умолчанию
 I $D(Vo(qqnump,qqo,0))<10 D  I 1 ;объекта нет в отображении
 .N qqwo,qqwl S qqwo=$G(^Q(1,"CxObj",qqo,"xWoc")) ;взяли список понятий объекта
 .F qqwl=1:1:$L(qqwo," ") S qqw=$P(qqwo," ",qqwl) D:qqw'=""&&(qqw'[":") RecNewDqqw ;@Dol 06.03.09 &&(qqw'[":")
 E  F  S qqw=$O(Vo(qqnump,qqo,11,qqw)) Q:qqw=""  D:qqw'[":" RecNewDqqw ;@Dol 06.03.09 qqw'[":"
 ;Действия перед вводом
RecNewDD S qqz=..GetPar(525,,qqo) I qqz'="" D ..Value(qqz,"X")
 I $G(qqwchg)'="" D qW.rCor(qqo,qqc,qqwchg) S qqwchg="" Q:$Q 1 Q  ;без учета коррекции; tdv+Dol 20091109 - c учетом коррекции
 Q:$Q 0 Q 
RecNewDqqw I $G(Arg1),$D(W(qqw)) Q
 I " "_$G(qqwchg)_" "[(" "_qqw_" "),$G(W(qqw))'="" Q  ;@dol 5.11.02 были забыты существующие значения
 I " "_$G(Arg2)_" "[(" "_qqw_" ") Q  ;@dol 18.02.04
 S qqz=..GetPar(75,,qqo,qqw) Q:qqz=""  ;весьма спорно. остаются старые значения, но появляется возможность задать значения перед вводом
 I qqz'="" S qqwchg=$S($G(qqwchg)="":"",1:qqwchg_" ")_qqw S:$E(qqz)="@" @("qqz="_$E(qqz,2,30000))
 K:qqz="" W(qqw) S:qqz'="" W(qqw)=qqz Q
]]></Implementation>
</Method>

<Method name="RecNewP">
<Description>
Порождение автоматически порождаемых потомков экземпляра объекта.
refr=1 - не обновлять локальный массив содержимого дерева (qqci в этом случае не нужен). </Description>
<Internal/>
<FormalSpec>qqo:%String,qqci:%String,qqc:%String,refr:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqso,qqop,qqz,qqn,qqavto,qqobjlist
 I $G(Vo(qqnump,qqo,2))=6 Q:$Q 0 Q  ;@dol 17.04.04 - для массива не инадо
 S qqavto=..GetPar(521,,qqo) I 'qqavto Q:$Q 0 Q
 I qqavto=1 D  Q:$Q 1 Q  ;автопорождение по локальному описанию
 .S qqso=0 F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""  S qqop=$G(Vo(qqnump,qqo,0,qqso)) I qqop'="",..GetPar(521,,qqop) D RecNewPdo
 ;автопорождение по глобальному описанию (умолчания для значений понятий не обрабатываются????)
 S qqobjlist=$G(^Q(1,"CxObj",qqo,"xObj")) I qqobjlist'="" F qqso=1:1:$L(qqobjlist," ") S qqop=$P(qqobjlist," ",qqso) I qqop'="",..GetPar(521,,qqop) D RecNewPdo
 Q:$Q 1 Q
RecNewPdo
 S qqn=..GetPar(520,,qqop) S:qqn="" qqn=1 ;кол-во экземпляров
 I '($D($$$ObjLqqc(qqop))#2) S $$$ObjLqqc(qqop)=$G(^Q(1,"CxObj",qqop,"X50"),255) ;длина кода
 F qqn=1:1:qqn D 
 .S qqz=$P(qW.rNew(qqop,qqc,0,$G(HrologPr))," ") ;@dol 9.02.02 $G(HrologPr) - для вызова из qW.rNewPr
 .I ..GetPar("X1191") D qW.gRel("+",qqop,qqz,,1) ;@dol 7.1.04 поместить в релевантные
 .I 'refr S Vc(qqnump,qqci)=qqz,Vc(qqnump,qqci,0)=qqop
 .;I qqavto'=2 
 .D ..RecNewD(qqop,qqz) ;????
 .D ..RecNewP(qqop,qqci_"AA",qqz,refr)
 .I 'refr S $E(qqci,$L(qqci))=$C($A(qqci,$L(qqci))+2)
 Q
]]></Implementation>
</Method>

<Method name="RecObj">
<Description>
Выдает имя объекта Arg1.
Если Arg2=1, имя выдается  если необходмо подтверждение операции ввода, удаления.</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qqq I $G(Arg2) S qqq=..GetPar(531,,Arg1) S:$E(qqq)="@" qqq=..Value($E(qqq,2,30000)) I $S('qqq:1,qqq=1:0,Arg2=3:qqq'=3,Arg2=1:qqq'=2,1:0) Q:$Q "" Q  ;не задавать вопрос (Arg2=1 - ввод, 3-уд)
 S qqq=$G(Vo(qqnump,Arg1)) I $E(qqq)="@"!(qqq="") S qqq=qW.GetWoc("CxObj",Arg1)
 Q:$Q qqq Q
]]></Implementation>
</Method>

<Method name="RecPost">
<Internal/>
<FormalSpec>qqt:%Library.String,qqo:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 D ..Value(..GetPar(5240,,qqo),"X") ;постдействие
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="RecRaz">
<Description>
            Вызов развертки для понятия только что отредактированной ячейки.</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqtr S qqtr=qqw'="ZfI9"+1 ;номер дерева
 S qqred=qqw,%1=..s112(,qqtr) D:qqred'=""
 .;не вызвано другое окно
 .D:"168"'[(+W("Zcdrl")) ..wfoc(qqtr,W("Zpos",qqtr,"y"),W("Zpos",qqtr,"x"))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="RecRel">
<Description>
Включение/исключение (Arg1=+/-) экземпляра в перечень релевантных. 
Arg1=0 - удаление перечня релевантных.
Arg1=1 - переключение режима выбор/уточнение.
qOref - индекс в Vc(qqnump)</Description>
<Internal/>
<FormalSpec>Arg1:%String,qOref:%String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $G($$$Tree) Q:$Q "" Q
 I ..EndOP() Q:$Q "" Q
 S:$G(qOref)="" qOref=Vc(qqnump)
 N qObj,qi,qqci S qObj=$G(Vc(qqnump,qOref,0)) I qObj'="",$G(Vo(qqnump,qObj,244)),"+-"[Arg1 Q:$Q "" Q  ;@dol 3.07 04.05.05 запрет отметки
 S qqc=$G(Vc(qqnump,qOref))
 I $G(Vo(qqnump,-1,821))'="" D:'$G(Arg2)  Q:$Q "" Q  ;@Dol 21.08.08 понятие для релевантных
 .D:$E(Vo(qqnump,-1,821),1,4)="ZTMP"  ;переключение флагов
 ..I Arg1'=0,'$D(^Q($$$Relind_qview,qObj)) S $$$RelNum=qW.gRel(Arg1,qObj,qqc,qOref)
 ..I Arg1'=0 S ^Q($$$Relind_qview,qObj,qqc,Vo(qqnump,-1,821))='$G(^Q($$$Relind_qview,qObj,qqc,Vo(qqnump,-1,821))) D RecRelS(qOref,-1) Q
 ..;I "+-"[Arg1 S ^Q($$$Relind_qview,qObj,qqc,Vo(qqnump,-1,821))=$S(Arg1="+":1,1:0) D RecRelS(qOref,-1) Q
 ..N qOref,flag S qOref="",flag=1 F  S qOref=$O(Vc(qqnump,qOref)) Q:qOref=""  I '$G(^Q($$$Relind_qview,Vc(qqnump,qOref,0),Vc(qqnump,qOref),Vo(qqnump,-1,821))) S flag=0 Q  ;@Dol 08.09.08
 ..I flag S qOref="" F  S qOref=$O(Vc(qqnump,qOref)) Q:qOref=""  I $G(^Q($$$Relind_qview,Vc(qqnump,qOref,0),Vc(qqnump,qOref),Vo(qqnump,-1,821)))  K ^Q($$$Relind_qview,Vc(qqnump,qOref,0),Vc(qqnump,qOref),Vo(qqnump,-1,821)) D RecRelS(qOref,-1) ;сброс всех
 ..I 'flag S qOref="" F  S qOref=$O(Vc(qqnump,qOref)) Q:qOref=""  I '$G(^Q($$$Relind_qview,Vc(qqnump,qOref,0),Vc(qqnump,qOref),Vo(qqnump,-1,821))) S ^Q($$$Relind_qview,Vc(qqnump,qOref,0),Vc(qqnump,qOref),Vo(qqnump,-1,821))=1 D RecRelS(qOref,-1) ;установка всех
 ..D qARM.wP(qwin_".T2","RowColPictureH@1",$P(Vo(qqnump,-1,194)," ",'flag+1),0)
 .I ..GetPar("X182")'="" N qqo S qqo=qObj D ..Value(Vo(qqnump,-1,82),"X")
 I 'Arg1,qqc[" " D ..Message("Экземпляр не существует") Q:$Q "" Q  ;@dol 16.12.03
 I ..GetPar("X1192"),$S(Arg1="+":0,Arg1="-":$G(^Q($$$Relind_qview,qObj))<2,Arg1=1:$$$ReFind,1:1) D ..Message("Выход из релевантных блокирован") Q:$Q "" Q  ;@dol 21.12.03
 ;@Dol 21.12.06 зачем удаление ;;;K W("Zpos",2,"y"),W("Zpos",2,"x") ;????
 I 'Arg1 D:$E($P($$$CondFind," "),1,4)="ZTMP"  S $$$RelNum=qW.gRel(Arg1,qObj,qqc,qOref)
 .S $P($$$CondFind," ")="" K W("Zosrt") D ..wbut(2) ;@dol 29.09.03 сброс сортировки
 .N but S but="ZBs" F  S but=$O(W(but)) Q:$E(but,1,3)'="ZBs"  K W(but)
 I Arg1=1 Q:'$$$RelNum  D  G RecRelend ;переключение выбор/уточнение
 .I $$$ReFind S $$$ReFind=0 D ..wfot(-3),..wcre() Q
 .S $$$ReFind=1 D
 ..I qObj="" S (qObj,$$$CurObj)="",qqc="" Q
 ..I '$D(^Q($$$Relind_qview,qObj)) S (qObj,$$$CurObj)="",qqc="" Q
 ..I '$D(^Q($$$Relind_qview,qObj,qqc)) S qqc=$O(^Q($$$Relind_qview,qObj,qqc))
 .D ..wfot(-2),..wcre()
 I Arg1=0 D  G RecRelend ;сброс
 .I $$$ReFind S $$$ReFind=0,Arg1=1 D ..wfot($S($G(Vs(qqnump,7))="":"",1:-3)),..wcre() Q
 .S qOref="" F  S qOref=$O(Vc(qqnump,qOref)) Q:qOref=""  D RecRelS(qOref,0)
 I Arg1="+" D  G RecRelend
 .F qi=2:2:$L(qOref) D RecRelS($E(qOref,1,qi),1)
 .Q:'$G(Vs(qqnump,99,"Find"))  ;отметка поддерева
 .S qqci=qOref F  D RecRelS(qqci,1) S qqci=$O(Vc(qqnump,qqci)) Q:$E(qqci,1,$L(qOref))'=qOref
 I Arg1="-",$$$ReFind,'$P($$$RelNum," ",2) S $$$ReFind=0,Arg1=1 D ..wfot(-3),..wcre() G RecRelend
 I Arg1="-",$$$ReFind,'$G(Vo(qqnump,Vc(qqnump,qOref,0),40)) S $$$RelNum=1 D ..Wait("D qARM.RecDelOref("""_qOref_""",0)") Q:$Q "" ;@Dol 15.02.06 учет сброса релевантных D ..OpenTimer(200,"D qARM.RecDelOref("""_qOref_""",0)") Q:$Q "" Q  ;G RecRelend
 I Arg1="-" S $$$RelNum=1 D  
 .S qqci=qOref F  D RecRelS(qqci,0) S qqci=$O(Vc(qqnump,qqci)) Q:$E(qqci,1,$L(qOref))'=qOref
RecRelend
 ;S $$$RelNum=+$$$RelNum
 S $$$RelNum=$D(^Q($$$Relind_qview))>1 D:$E($G(W("Zsform")))'=1||($G(W("Zsform"))>99)
 .I Arg1>0 D ..wP(qwin_$S($G(W("Zsform"))<100:".TBC",1:".T1.TBC")_".b401","Down",$$$ReFind),..wP(qwin_$S($G(W("Zsform"))<100:".TBC",1:".T1.TBC")_".b402","Down",'$$$ReFind)
 .D ..wP(qwin_$S($G(W("Zsform"))<100:".TBN",1:".T1.TBN")_".b41","Caption",$J($G(^Q($$$Relind_qview,$$$CurObj)),7))
 I $G(Vo(qqnump,-1,88))'=1,'$G(Vo(qqnump,-1,80)),$G(Vo(qqnump,-1,194))'="" D ..wP(qwin_".T2","RowColPictureH@1",$P(Vo(qqnump,-1,194)," ",''$$$RelNum+1),0) ;@Dol 23.01.07 заголовок колонки релевантных
 I '$G(Arg2),..GetPar("X182")'="" N qqo S qqo=qObj D ..Value(Vo(qqnump,-1,82),"X") ;действие по изменению релевантных
 Q:$Q "" Q
RecRelS(qqci,qset) ;переустановка отметки
 I qset'=-1 Q:+$G(Vc(qqnump,qqci,2))=qset  S Vc(qqnump,qqci,2)=qset Q:'$G(Vc(qqnump,qqci,1),1)
 D:'$G(Vo(qqnump,Vc(qqnump,qqci,0),244))  ;@Dol 04.05.05 запрет отметки
 .D ..wM(qwin_".T2","M9",1,0,qqci_" "_Vc(qqnump,qqci,0)_" 0")
 .D:$G(Vo(qqnump,-1,194))'="" ..wP(,"M5",$S($G(Vo(qqnump,-1,821))'="":$P(Vo(qqnump,-1,194)," ",''$G(^Q($$$Relind_qview,Vc(qqnump,qqci,0),Vc(qqnump,qqci),Vo(qqnump,-1,821)))+1),Arg1="+":$P(Vo(qqnump,-1,194)," ",2),1:$P(Vo(qqnump,-1,194)," ",1)),"",0) 
 .I $D(Vo(qqnump,Vc(qqnump,qqci,0),11,"ZTMPN")) D ..wwww("ZTMPN",,,Vc(qqnump,qqci,0),Vc(qqnump,qqci)) ;@dol 21.06.03;@dol 6.08.04 :$G(Vo(qqnump,-1,194))'=""
 I Arg1="-",$E($O(Vo(qqnump,Vc(qqnump,qqci,0),11,"ZTMP")),1,4)="ZTMP" D  ;есть временные понятия в перечне релевантных
 .N qqw S qqw="ZTMP" F  S qqw=$O(Vo(qqnump,Vc(qqnump,qqci,0),11,qqw)) Q:$E(qqw,1,4)'="ZTMP"  K W(qqw) D ..wwww(qqw,,,Vc(qqnump,qqci,0),Vc(qqnump,qqci))
 I Arg1="+",$D(Vo(qqnump,Vc(qqnump,qqci,0),11,"ZTMPFRel")) S W("ZTMPFRel")=1 D ..wwww("ZTMPFRel",,,Vc(qqnump,qqci,0),Vc(qqnump,qqci)) ;@Dol 3.02.06 
 I $D(Vo(qqnump,Vc(qqnump,qqci,0),11,"@ZTMP")) N ZTMP S ZTMP=Arg1 D ..wwww("@ZTMP",,,Vc(qqnump,qqci,0),Vc(qqnump,qqci)) ;@Dol 16.02.06 обобщение по изменению отметки релевантных (возвращает значение по умолчанию см.qW.oZTMP)
 Q
]]></Implementation>
</Method>

<Method name="RecRelAll">
<Description>
Включить в релевантные все экземпляры
Arg1=0 (или не задан) все экземпляры текущего объекта
Arg1=1 - все видимые на экране (вместе с потомками)
Arg1=2 - переключение все/сброс по левой кнопке</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$G(Arg1) D  Q
 .N qqcc,qqc0 S qqc0=$$$ObjRef($$$CurObj),qqc0=$P(qqc0,",",$L(qqc0,",")-1),qqc0=$S(qqc0="":"",$G(Vs(qqnump,qqc0,2))<2:$E(qqc,1,$$$ObjLqqc(qqc0)),1:Vs(qqnump,"Virt",qqc0))
 .S qqcc="" F  S qqcc=qW.gOrder(1,$$$CurObj,qqcc,qqc0) Q:qqcc=""  D qW.gRel("+",$$$CurObj,qqcc,,1)
 .D qARM.wwrefr(,,1)
 I $G(Arg1)=1 D  Q  ;Включить в релевантные все видимые на экране экземпляры текущего объекта
 .N qqq,qqqc S qqq=$G(Vs(qqnump,99,"Find")),Vs(qqnump,99,"Find")=$P(qqchoice,"_",2)-1
 .S qqqc="" F  S qqqc=$O(Vc(qqnump,qqqc)) Q:qqqc=""  D ..RecRel("+",qqqc) S qqqc=$E(qqqc,1,2)_"яяяяяяя"
 .S Vs(qqnump,99,"Find")=qqq
 I $G(Arg1)=2 D  Q  ;переключение все/сброс
 .I $G(qqbut)=2 S qqend=1 Q  ; tdv 20110420 добавлено $G()
 .I qW.gRel("",$$$CurObj) D ..RecRel(0),..wP(qwin_".T2","RowColPictureH@1",$P(Vo(qqnump,-1,194)," ",1),0) Q
 .D ..RecRelAll(),..wP(qwin_".T2","RowColPictureH@1",$P(Vo(qqnump,-1,194)," ",2),0)
 Q
]]></Implementation>
</Method>

<Method name="RecRev">
<Description>
        Откат. Восстановление для текущей записи измененных понятий из базы.</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqw,i,qObj S qObj=$$$CurObj
 F i=1:1:$L($G(qqwchg)," ") S qqw=$P(qqwchg," ",i) I qqw'=""  S W(qqw)=qW.GG(qObj,qqw,qqc) D ..wwww(qqw,1)
 S qqwchg="" Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="RecTmp">
<Description>
Создание копии для темпорального поддерева
Заменяетсся текущий qqc и $$$ID. Подменяются коды экземпляров в текущем поддереве.
qObj - текущий объект</Description>
<Internal/>
<FormalSpec>qqver:%Library.String,qObj:%Library.String,Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqoo,qqcc,qqccc,qqcii,qqci S qqoo=$P(qqver," ",1),qqcc=$P(qqver," ",2)
 I $G(Arg1),$G(qObj)=qqoo Q:$Q "" Q  ;@dol 10.02.03 блокировка для ввода новой вершины
 S qqccc=$P(qW.rNew(qqoo,qqcc)," ") I $G(qObj)=qqoo S $$$CurObj=qObj G RecTmpEnd
 D qW.rCopyTree(qqoo,qqccc,qqoo,qqcc)
 F qqcii=$L(Vc(qqnump)):-2:2 S qqci=$E(Vc(qqnump),1,qqcii) Q:Vc(qqnump,qqci,0)=qqoo
 S qqcii=qqci F  K:0 Vc(qqnump,qqci,5) S $E(Vc(qqnump,qqci),1,$L(qqccc))=qqccc,Vc(qqnump,qqci,5)=$G(^Q(1,Vc(qqnump,qqci,0),Vc(qqnump,qqci),"X")),qqci=$O(Vc(qqnump,qqci)) Q:$E(qqci,1,$L(qqcii))'=qqcii
RecTmpEnd S $E(qqc,1,$L(qqccc))=qqccc,Vs(qqnump,"ID")=qqc
 I $G(Vt(qqnump,"ZTmpqqc"))="" Q:$Q $G(qObj)=qqoo Q  ;??????
 S $P(Vt(qqnump,"ZTmpYT")," ",2)=1
 N qqcc1 S qqcc1=$P(Vo(qqnump,qqoo,29)," ") S:'($D($$$ObjLqqc(qqcc1))#2) $$$ObjLqqc(qqcc1)=$G(^Q(1,"CxObj",qqcc1,"X50"),255)
 S Vt(qqnump,"ZTmpYT",qqoo)=$E(qqccc,$$$ObjLqqc(qqcc1)+1,255)
 ;I $G(qObj)=qqoo S Vs(qqnump,"ID")=Vt(qqnump,"ZTmpqqc") Q 1 ;для перевывода
 Q:$Q $G(qObj)=qqoo Q
]]></Implementation>
</Method>

<Method name="RecVer">
<Description>
         Проверка перед вводом/коррекцией/удалением (qqt=1/2/3).</Description>
<Internal/>
<FormalSpec>qqt:%String,qObj:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 ;@Misuno 20.01.06
 N qval,qqo,qKey,qKw,i
 S qqo=qObj,qval=..Value(..GetPar(524,,qObj)) I qval="" Q:$Q "" Q  ;@dol 22.02.03 ?qqo
 i qqt=2,$g(qval)="" S qKey=..GetPar(522,,qObj)  d:qKey'=""  ;проверка на ключевые
 .s qKey=$s(qKey[":":$p(qKey,":",2),1:qKey)
 .f i=1:1:$l(qKey," ") s qKw=$p(qKey," ",i) i qKw'="",qW.GE(qKw)="" s qval="2 Пустое ключевое значение" 
 ;
 I "12"'[$E(qval) D:qval'=0 ..Message(qval,,,$G(qqXBMesTime)) Q:$Q 1 Q 
 I $E(qval,2,1000)="" D:qqt=2 ..RecRev() Q:$Q 1 Q
 I $E(qval)=2 D:$E(qval,2,1000)'="" ..Message($E(qval,2,1000),,,$G(qqXBMesTime)) D:qqt=2 ..RecRev() Q:$Q 1 Q
 S qqwchg="",qqc=$E(qval,2,1000) D ..wcre() Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="RecVerNoDef">
<Description>
 проверка на обязательность непустых значений</Description>
<Internal/>
<FormalSpec>qqo:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(qqo)="" qqo=$$$CurObj ;????S qqc=Vc(qqnump,Vc(qqnump))
 N qqw,qqver S qqver="" S qqw="" F  S qqw=$O(Vo(qqnump,qqo,11,qqw)) Q:qqw=""  I $E(qqw)'="@",..GetPar("X740",,qqo,$P(Vo(qqnump,qqo,11,qqw)," "),$P(Vo(qqnump,qqo,11,qqw)," ",2))||(" "_..GetPar("X5223",,qqo)_" "[(" "_qqw_" ")),qW.GE(qqw)="" S qqver=qqver_$C(13,10)_$S($G(W("Zadm")):qqw_" ",1:"")_qW.GetWoc("CxWoc",qqw)
 I qqver="" Q:$Q "" Q
 D ..wpoe(Vc(qqnump)_" "_$$$CurObj_" 0"),..Message("Не введены значения для:"_qqver) Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="RecVerOp">
<Internal/>
<FormalSpec>qqo:%Library.String,qqt:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqq
 ;из отображения
 I '$D(Vo(qqnump,-1,20)) D ..GetPar("X120")  I $G(qruls)'="",$D(^Q(1,"XRuls",qruls,"XViewStat",Vo(qqnump),"Ref1")) S Vo(qqnump,-1,200)=^("Ref1") ;@22.07.03 с учетом роли
 S qqq=Vo(qqnump,-1,20) S:$E(qqq)="@" qqq=..Value($E(qqq,2,30000)) I $S('qqq:0,+qqq=1:1,qqt=1:+qqq=2,qqt=3:+qqq=3,1:0) Q 1_$E(qqq,2,32000)
 S qqq=$G(Vo(qqnump,-1,200)) I qqq'="" S:$E(qqq)="@" qqq=..Value($E(qqq,2,30000)) I $S('qqq:0,+qqq=1:1,qqt=1:+qqq=2,qqt=3:+qqq=3,1:0) Q 1_$E(qqq,2,32000)
 ;из объекта
 I '$D(Vo(qqnump,qqo,30)) D ..GetPar("X530",,qqo) I $G(qruls)'="",$D(^Q(1,"XRuls",qruls,"XViewStat",$S($G(Vo(qqnump,qqo,889))'="":Vo(qqnump,qqo,889),1:Vo(qqnump)),"CxObj",qqo,"Ref1")) S Vo(qqnump,qqo,300)=^("Ref1") ;@22.07.03 с учетом роли
 S qqq=Vo(qqnump,qqo,30) S:$E(qqq)="@" qqq=..Value($E(qqq,2,30000)) I $S('qqq:0,+qqq=1:1,qqt=1:+qqq=2,qqt=3:+qqq=3,1:0) Q 1_$E(qqq,2,32000)
 S qqq=$G(Vo(qqnump,qqo,300)) S:$E(qqq)="@" qqq=..Value($E(qqq,2,30000)) I $S('qqq:0,+qqq=1:1,qqt=1:+qqq=2,qqt=3:+qqq=3,1:0) Q 1_$E(qqq,2,32000)
 Q 0
]]></Implementation>
</Method>

<Method name="RedTest">
<Description>
Проверка возможности редактирования ячейки</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqy:%Library.String,qqx:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqpar1,qqz,qqw
 S qqz=$G(Vo(qqnump,qqo,0,qqy,qqx)) Q:qqz="" 0
 S qqpar1=..GetPar("X731",,qqo,qqy,qqx) I $E(qqpar1)="@" D
 .S qqw=$S('qqz:"",$E(qqz)=5:"Zs"_qqy_"c"_qqx,1:$E($P(qqz," "),2,31))
 .S qqpar1=..Value($E(qqpar1,2,30000))
 Q:qqpar1=-1 0
 I "2346"[$E(qqz) Q 1 ;@Dol 13.01.05 Добавлена кнопка ( 6 )
 Q:qqpar1'="" 1
 Q 0
]]></Implementation>
</Method>

<Method name="RepeatedTimer">
<Description>
Выполнение действия Arg3 по событию таймера 
через каждые Arg2 миллисекунд в цикле Arg4 =1
(по умолчанию 1, 0 - выполняется как qARM.OpenTimer один раз).
Если Arg1=0 действие не выполняется.
Для остановки цикла  должно быть d qARM.wP(qwin_".Timer","Enabled",0),
иначе цикл бесконечный.
Следует использовать ТОЛЬКО в случае уверенности в том, что действие контекстонезависимо
и все используемые переменные, объекты и т.д. будут существовать на момент его выполнения.

! НЕ СЛЕДУЕТ использовать в целях выполнения действия вне текущего события - 
для этого предназначен метод Wait !

Таймер создается как потомок текущего окна, и если оно будет закрыто до его срабатывания, 
таймер будет уничтожен и действие НЕ будет выполнено.
</Description>
<Internal/>
<FormalSpec>Arg1:%String=1,Arg2:%String,Arg3:%String,Arg4:%String=1</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 i $G(qwin)="" q             //sasha 20080715
 i $G(Arg3)="" d qARM.Message("Отсутствует действие по таймеру!") q
 I '$D(qwin(qwin,"Timer")) d qARM.wC("TTimer",qwin_".Timer") S qwin(qwin,"Timer")=1
 d qARM.wP(qwin_".Timer","Enabled",Arg1)
 d qARM.wP(,"Interval",Arg2)
 d qARM.wP(,"Action",Arg3)
 d qARM.wP(,"Repeated",Arg4)
]]></Implementation>
</Method>

<Method name="ResetSrt">
<Description>
Сброс сортировки</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 I $P($$$CondFind," ")="" Q:$Q "" Q
 S W("Zosrt")="",$P($$$CondFind," ",1,5)="    " D ..wipa(),..wbut(2),..wfot(),..wcre(),..T2ColHButtonClr()
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Resize">
<Description>
Пересчет авторазмеров, если они заданы</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[ D:$G(Vo(qqnump,-1,62)) ..wM(qwin_".T2","RecalcHorizontalExtent"),..wM(qwin,"qResize",$TR(Vo(qqnump,-1,62),"123","312")) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="RestView">
<Description>
Восстановление состояния отображения (если query=1)</Description>
<Internal/>
<FormalSpec>query:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(query)=1 D  Q:$Q "" Q
 .M Vs(qqnump)=^Q("V"_qview,"XObjStat") K Vs(qqnump,"Tabs")
 .M W=Vs(qqnump,"Z*") K Vs(qqnump,"Z*")
 ;для состояния отображения в запросе
 S:'$D(query) query=qqc
 K Vs(qqnump) M Vs(qqnump)=^Q(1,"XQuiry",query,"XObjStat") K Vs(qqnump,"Tabs")
 K Vt(qqnump,0) M Vt(qqnump,0)=Vs(qqnump,"Vt") ;учет постоянных условий наследуется
 S W("Zadm")=+$G(Vs(qqnump,"Zadm")) ;режим администратора наследуется печатной формой
 S W("ZBtred")=+$G(Vs(qqnump,"ZBtred"))
 D
 .S $$$ReFind=$G($$$ReFind,0)
 .S $$$RelNum=$G($$$RelNum,0)
 .S qqc=$G($$$ID,"")
 .S $$$Relind=$G($$$Relind,0)
 .S $$$CurObj=$G($$$CurObj,"")
 .S $$$CondFind=$G($$$CondFind,"")
 .I $$$CondFind'="" S $$$CondFind=" "_$P($$$CondFind," ",2,6)_"  "_$P($$$CondFind," ",8,11),$P($$$CondFind," ",5)="" ;востановим старый контекст убрав упорядоченность
 .K W("Zosrt")
 D ..wcro(),..MenuAn("AFD"),..wcre() Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="RestView8">
<Description>
Восстановление сохраненного поискового образа</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[ K Vs(qqnump,8) M Vs(qqnump,8)=^Q("V"_qview,"XObjStat",8) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="RestoreArray">
<Description><![CDATA[
20090731 @Dima Восстановление поддерева из массива строк. 
В качестве входного и выходного массива используется @Node.
Структура исходной строки:
$L(node1)_" "_node1_$L(node2)_" "_node2_$L(data)_" "_data_ и т.д.
node2'="" -> @Node@(node1,node2)=data
node2="" -> @Node@(node1)=data
Строка может быть разрезана на подузлы исходного массива как угодно.
$L(data) не более 15700.]]></Description>
<Internal/>
<FormalSpec>Node:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 k ^mtempRstArr($J) ; результат ; @dima 20100602
 n SrcSub ; посл. считанный подузел
 n Str ; считанная часть данных
 n NoData s NoData=0 ; все данные считаны
 n node1,node2,data,node1len,node2len,datalen
 s SrcSub=$O(@Node@("")),Str=@Node@(SrcSub)
RestoreArrayL1
 i 'NoData,$L(Str)<16000 d  ; т.к. исходный массив нарезан по 16000
 .s SrcSub=$O(@Node@(SrcSub)) 
 .i SrcSub="" s NoData=1 
 .e  s Str=Str_@Node@(SrcSub)
 s node1len=$P(Str," "),node1=$E(Str,$L(node1len)+2,$L(node1len)+1+node1len),Str=$E(Str,$L(node1len)+node1len+2,65536)
 s node2len=$P(Str," "),node2=$E(Str,$L(node2len)+2,$L(node2len)+1+node2len),Str=$E(Str,$L(node2len)+node2len+2,65536)
 s datalen=$P(Str," "),data=$E(Str,$L(datalen)+2,$L(datalen)+1+datalen),Str=$E(Str,$L(datalen)+datalen+2,65536)
 i node2="" s ^mtempRstArr($J,node1)=data
 e  s ^mtempRstArr($J,node1,node2)=data
 i NoData&&(Str="") k @Node m @Node=^mtempRstArr($J) k ^mtempRstArr($J) q  
 g RestoreArrayL1
]]></Implementation>
</Method>

<Method name="RestoreDirTree">
<Description>
Используется при восстановлении дерева каталогов с файлами, считанного с помощью
qARM.wM("-qARM","ReadDirTree",...)</Description>
<Internal/>
<FormalSpec>nod:%Library.String,dir:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 q:'$D(nod) ""
 s:$E(dir,$L(dir))="\" $E(dir,$L(dir))=""
 n d,DirN s DirN=dir
 n data,c,ts s c=1,data(c)=""
 d RDTRest(nod,1)
 i qARM.ProjVerNotOlder(3,9,4,0) k ^mtempRDT($J) m ^mtempRDT($J)=data
 e  d qSYS.Compress("data",$NA(^mtempRDT($J))) //old
 q $NA(^mtempRDT($J))

RDTRest(node,first)
 i 'first s d=DirN n DirN s DirN=d_"\"_$E($QS(node,$QL(node)),3,256)
 n a s a="" f  s a=$O(@node@(a)) q:a=""  d
 .i $E(a)="D" d RDTRest($NA(@node@(a)),0)
 .;i $E(a)="F" i $G(qARM("Vista+"))||($P(a,"~",2)'="DHTMLED.MSI") s ts=$NA(@node@(a))_$C(13)_DirN_"\"_$P(@node@(a),$C(13),1)_$C(13)_$P(@node@(a),$C(13),2)_$C(13)_$P(@node@(a),$C(13),3)_$C(13)_$P(@node@(a),$C(13),4)_$C(13)_$P(@node@(a),$C(13),5)_$C(13) s:$L(data(c))+$L(ts)>16000 data($I(c))="" s data(c)=data(c)_ts ; Этот файл выгружается только под vista+ @dima 20101103 ;не понадобилось @dima 20101229
 .i $E(a)="F" s ts=$NA(@node@(a))_$C(13)_DirN_"\"_$P(@node@(a),$C(13),1)_$C(13)_$P(@node@(a),$C(13),2)_$C(13)_$P(@node@(a),$C(13),3)_$C(13)_$P(@node@(a),$C(13),4)_$C(13)_$P(@node@(a),$C(13),5)_$C(13) s:$L(data(c))+$L(ts)>16000 data($I(c))="" s data(c)=data(c)_ts
 q
]]></Implementation>
</Method>

<Method name="RuntimeAction">
<Description>
Выполнить действие Arg1, результат отражается на клиенте прямо во время работы метода Cache.
@20100427
sync=0 или не задано:
  - ТОЛЬКО для выполнения действий, связанных с внешним видом окна отображения (например, перевывод).
  - НЕ ГАРАНТИРУЕТСЯ, что каждое обращение к данному методу будет обработано
    (кроме того, частота обработки ограничена: не чаще 2 секунд).
  - Протокол, сформированный действием, выполняется на клиенте асинхронно, одновременно
    с дальнейшей работой Cache.
sync=1:
  - Действие работает модально, Cache простаивает, пока клиент обрабатывает протокол.
  - Действие гарантированно будет выполнено.
  - Возвращает результат последнего вызова wG (свойства или функции)
  - Действие вызывается достаточно медленно.

!!! НЕЛЬЗЯ вызывать методы, содержащие такие wC/wM/wP, которые имеют дополнительные
    внутренние обращения к Cache.
!!! Не работает с SSH.</Description>
<Internal/>
<FormalSpec>Arg1:%String,sync:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    ; через SSH: с sync=0 просто не сработает (=>игнорируем), с sync=1 зависнет (=>выдаём ошибку)
    i $E($G(qARM("CntStr")),1,3)="SSH" d:$G(sync) ..Message("RuntimeAction не поддерживает SSH") q 
    
    s:$P($H,",",1)'=$P($G(RTaTime),",",1) RTaTime=""
    i '$G(sync),$G(RTaTime)'="",$P($H,",",2)-$P(RTaTime,",",2)<2 q  ; Ограничение частоты вызова
    s RTaTime=$H
    
    k qruntimeprot,wMet8Old
    s runtimeact=1 ; флаг для wMet - писать протокол в qruntimeprot, а не в qprotstr
    x Arg1
    s runtimeact=0  
    
    n %IRTRes
    d:$G(qruntimeprot(1))'=""
    .n i,dev s dev=$IO u $P
    .f i=1:1:qruntimeprot w "!&"_$S($G(sync):"I",1:"U")_"R"_$S(i=qruntimeprot:"F",i=1:"I",1:"P")_..wzero(qruntimeprot(i)) ; wzero(), т.к. Write не поддерживает $C(0)
    .u dev
    .k qruntimeprot
    q:$Q $G(%IRTRes) q
]]></Implementation>
</Method>

<Method name="SRColWidth">
<Description>
Размеры колонок и состояния зачеркнутости ;усовершенствовано 21.10.10
Op="S" - сохранить; "R" - восстановить (сработает только после qARM.wcre) ;"D" - умолчания (восстановить по описанию отображения) ; "T" - тестировать наличие сохраненного состояния; "K" - удалить сохраненное состояние
mas - ссылка на массив сохранения. ^Qstat по умолчанию
index - идекс узла сохранения. По умолчанию - текущее qview ( код_отображения код_пользователя)
!!! Если mas - число, то это qqnump окна для операций с размерами
wcre=1 - перевывести после восстановления
No1=1 - сохранять только размеры (без зачеркивания). Более предпочтительный вариант - зачеркивание может быть и динамическим.
  В действие по входу (по первой загрузке) после qARM.wcre (!!!) нужно вставить вызов восстановления</Description>
<Internal/>
<FormalSpec>Op:%Library.String,mas:%Library.String,index:%Library.String,wcre:%Library.String,No1</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqnumpWW S qqnumpWW=qqnump S:$G(Op)="" Op="R" I $G(mas)?1.n S qqnumpWW=mas,mas="^Qstat",index=$G(WS(qqnumpWW,"Zvars","qview")) I index'="","RD"[Op D qARM.crst(1,qqnumpWW,2)
 S:$G(mas)="" mas="^Qstat" S:$G(index)="" index=qview
 I $E(Op)="T" Q:$Q ''$D(@mas@(index)) Q
 I $E(Op)="K" K @mas@(index) Q:$Q 1 Q
 I $E(Op)="S" K @mas@(index) D   Q:$Q 1 Q  ;сохранение
 .I '$G(No1) M @mas@(index,1)=Vs(qqnumpWW,1) K @mas@(index,1,-1)
 .M @mas@(index,"ColWidth")=Vs(qqnumpWW,"ColWidth")
 I $E(Op)="R",$D(@mas@(index))<10 Q:$Q "" Q
 N sss I '$G(No1) M sss=Vs(qqnump,1,-1) K Vs(qqnump,1) M Vs(qqnump,1,-1)=sss 
 K Vs(qqnump,"ColWidth") I $E(Op)="D" K W("ZBtredo") D:$G(wcre) ..wipa(),..wcro(),..wcre() Q:$Q "" Q  ;сброс
 I '$G(No1) M Vs(qqnump,1)=@mas@(index,1)
 M Vs(qqnump,"ColWidth")=@mas@(index,"ColWidth") ;восстановление (только после wcre !!!!)
 D:$G(Vo(qqnump,-1,9))  I $G(wcre) S W("ZBtredo")=W("ZBtred")  D ..wcro(),..wcre()
 .F sss=0:1:Vo(qqnump,-1,9) D:$D(Vs(qqnump,"ColWidth",sss)) ..wP(qwin_".T2","ColumnWidth",+$G(Vs(qqnump,"ColWidth",sss),30),sss)
 Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="SaveToClipbrd">
<Description>
Копирование текущего поддерева в буфер обмена
см ..TestPaste</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqw,mas S qqw=$O(Vo(qqnump,qqo,10,"")) S:qqw'="" qqw=qW.GG(qqo,Vo(qqnump,qqo,10,qqw),qqc) S qqw=$P($P(qARM("CntStr"),":",2),"[")_":"_$P(qARM("CntStr"),":",3)_" "_qqo_" "_..wcroCell(qqo)_" ("_qqw_")"
 S mas=$NA(^mtempQW(qARM("ComputerName")))
 K @mas@(2) D qW.StreemExp($NA(@mas@(2)),$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)),qqc,,,,,1,,0) ;@Dol 25.09.08 сохранялось по описанию объекта. теперь все физически существующие в объекте. Проблема с характеристиками - переносятся только при копировании объекта ww ;;;$S(qqo="w"||(qqo="ww"):0,1:1)) ;@Dol 01.11.07 ;,,,);@Dol 7.01.08 ww
 S @mas@(0)="K "_$NA(@mas@(2))
 S @mas@(1)="X qBuFfXec" ;действие после восстановления. См. ..TestPaste
 D ..wM("-qARM","SaveToClipbrd",$NA(@mas@(2)),mas,qqw) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="SaveView">
<Description>
Сохранить состояние текущего  отображения.
Если qqpar1=1, то сохраняется и положение в базе.
qqmas - ссылка на массив для сохранения состояния. Если задан, то туда сохраняется 
все (включая $$$CurObj).
qviewnext - новое (вызываемое) отображение (для печати через WEBLINK)
Если массив не задан, то состояниие сохраняется в объект XObjStat
^Q("V"_кодотобр_" "_кодпользователя,"XObjStat")

Объект для хранения состояния отображения (массив Vs).
Описание узлов поддерева состояния:
1 - зачеркнутые объекты
код_объекта = 1 - зачеркнут
2, - свернутые в дереве экземпляров (!!!) объекты
код_объекта = 1 - свернут в дереве экземпляров
3, - свернутые объекты
код_объекта = 0/1 (развернут/свернут)
4, - раскрытые (по понятиям) объекты
код_объекта = 0/1 (закрыта/раскрыта)
7 - активность объектов (если узел не существует, то все объекты активны). Используется при фиксации - 
активные фиксируются
= код_объекта_вершины_дерева_фиксации
код_объекта = 1 активный объект
8 - дерево поиска
код_объекта
код_понятия = поисковый_образ
12 - аналитические срезы
= код_объекта_" "_код_понятия - главная анаитика (сейчас не используется)
код_объекта
код_понятия
1 = название
2 = выражение относительно Z для вычисления среза характеристики. если не задано, значение 
понятия
3 = если "A", то срез
4 = если "D"_N, то характеристика (вычисляются 6-9)
5 = Num (кол-во)
6 = Sum
7 = Min
8 = Max
9 = Mid
13 - диаграмма. Узлы 0, 1 используются для определения серий диаграммы (вывода значений нескольких 
характеристик).  
0      
код_объекта_" "_код_понятия_" "_(5-9) = номер_серии _Y(1-N)
1
номер_серии_Y = код_объекта_" "_код_понятия_" "_(5-9)

Узлы 2,3 используются в варианте нескольких (пока двух) аналитик. При построении диаграммы в это случае 
учитывается только Y1. В качестве серии в этом случае используются значения второй аналитики.
2
код_объекта_" "_код_понятия = номер_аналитики
3
номер_аналитики = код_объекта_" "_код_понятия   
"P" = порог включения точки в диаграмму (процент необходимого количества значений в выборке 
относительно их общего значения
"M" = 1 - масштабирование нормированием
= 2 - масштабирование взвешиванием
"S" = 1 - сортировать по серии 1
"R"  - приемник (диаграммы 0 - CFX,1 - VRML, таблицы 2-IE, 3 - Word, 4 - Excel)

Следующие узлы хранят состояние управляющих переменных.(макры в %qWORD.INC)
"ReFind" - режим поиска 0/1 - Выбор/уточнение (qqfls)
"CurObj" - текущий объект
"Relind" - индекс перечня релевантных (qqrn)
"RelNum" - Количество (сейчас уже просто наличие релевантных)
"CondFind" - Строка условий поиска (qqydrs)
"ID" - текущий код экземпляра (qqc)
"GloRef" - Текущая глобальная ссылка для дерева

99 - наборы параметров текущего отображения
"Pic"=1 - вывод картинок
"Find"=0/1 - поиск(отметка) экземпляров/поддерева 
1 =1 - учитывать одинаковые понятия в разных объектах 
2 - максимальное количество экземпляров (если не задано - ищутся все) 
"Anal" =0/1 - аналитика по значениям/словам значений
0 =1 - учет пустых значений</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqmas:%String,qviewnext:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
    
 N qqoView
 S qqoView=$S($g(qviewnext)="":"",$g(qviewnext)'[$C(1):"XView",1:$P($g(qviewnext),$C(1))) S:$g(qviewnext)[$C(1) qviewnext=$P($g(qviewnext),$C(1),2,255) ;Маслова 06.08.2010 
    
 S $$$ID=qqc
 D:$D(Vc(qqnump))>1 ..Estat() ;@dol 2.4.03
 I $D(qqmas) D  Q:$Q "" Q  ;для формирования печатной формы
 .S:qqmas="" qqmas=$na($$$tmpGl("q",$j)) ;15.12.2008 Kokarev;  было: "^CacheTemp(""q"",$J)"
 .K @qqmas@("XObjStat") S @qqmas=$g(qqoView)_$s($g(qqoView)="":"",1:$C(1))_$G(qviewnext)_" "_qview
 .I $E(qview,4,6)="sys" K @qqmas@("Vo") M @qqmas@("Vo")=Vo(qqnump)  ;под вопоросом (нужно не всегда)
 .K:'$D(Vs(qqnump,12)) Vs(qqnump,14),Vs(qqnump,15) ;@dol 22.01.03 мусор
 .K Vs(qqnump,808) ;@Dol 1.12.04 уничтожение рабочего массива поиска по всем объектам
 .M @qqmas@("XObjStat")=Vs(qqnump) K @qqmas@("XObjStat","Tabs")
 .I $G(qviewnext)'="",qviewnext'=Vo(qqnump) K @qqmas@("XObjStat","ColWidth") ; tdv 7.6.2006 если отображение печати не совпадает с текущим - ширину колонок не переносим
 .S @qqmas@("XObjStat","ZBtred")=$G(W("ZBtred"))
 .S @qqmas@("XObjStat","Zadm")=$G(W("Zadm")) ;режим администратора наследуется печатной формой
 .M @qqmas@("XObjStat","Vt")=Vt(qqnump,0) ;учет постоянных условий наследуется
 .;@dol 22.01.03 контроль соотвествия Vs(qqnump,8),Vs(qqnump,12) текущему описанию отображения (выражения поиска и аналитики)
 .K @qqmas@("XObjStat","UserPar") ;пользовательские параметры (?для Олега?)
 .N qqo,qqw,qq,qqq F qq=8,12 S qqo="" F  S qqo=$O(Vs(qqnump,qq,qqo)) Q:qqo=""  D
 ..I '$D(Vo(qqnump,qqo)) S qqq=1 K @qqmas@("XObjStat",qq,qqo) Q
 ..S qqw="" F  S qqw=$O(Vs(qqnump,qq,qqo,qqw)) Q:qqw=""  D
 ...I '$D(Vo(qqnump,qqo,11,qqw))," "_$G(Vo(qqnump,qqo,7))_" "'[(" "_qqw_" ")," "_$G(Vs(qqnump,"X57",qqo))_" "'[(" "_qqw_" ") K @qqmas@("XObjStat",qq,qqo,qqw) S qqq=1 ;@Dol 06.05.09 X57
 .I $G(qqq) D
 ..F qq=8,12 K:$D(@qqmas@("XObjStat",qq))=1 @qqmas@("XObjStat",qq)
 ..K:'$D(@qqmas@("XObjStat",12)) @qqmas@("XObjStat",14),@qqmas@("XObjStat",15) ;мусор
 Q:'$G(qqpar1)
 ;сохранение состояние
 K ^Q("V"_qview,"XObjStat")
 K Vs(qqnump,808) ;@Dol 1.12.04 уничтожение рабочего массива поиска по всем объектам
 K Vs(qqnump,"Z*") S qqpar1="Z" F  S qqpar1=$O(W(qqpar1)) Q:$E(qqpar1)'="Z"  I $E(qqpar1,1,4)'="ZTMP"," Zpos ZBt0 ZBtredo Zbasmod ZoBLeV ZotSt Zomod Zosrt ZdoX122 "'[(" "_qqpar1_" ") M Vs(qqnump,"Z*",qqpar1)=W(qqpar1) ;сохранение Z*-понятий
 K:'$D(Vs(qqnump,12)) Vs(qqnump,14),Vs(qqnump,15) M ^Q("V"_qview,"XObjStat")=Vs(qqnump) ;K:'$D(Vs(qqnump,12)) Vs(qqnump,14),Vs(qqnump,15) ;@dol 22.01.03 мусор
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="SaveView8">
<Description>
Сохранение состояния поискового образа</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[ K ^Q("V"_qview,"XObjStat",8) M ^Q("V"_qview,"XObjStat",8)=Vs(qqnump,8) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="SetBLOB">
<Internal/>
<FormalSpec>Glb:%String,Node:%String,Arg3:%String,Sp:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 n ref,i 
 s Sp=$TR(Sp,"'",""),Arg3=$TR(Arg3,"'",""),Node=$TR(Node,"'","")
 s Glb="^|Sp|"_$S(Arg3:"%",1:"")_$TR(Glb,"'","")
 s ref=$NA(@Glb@(Node))
 ;d:0
 ;.s ^tmmZZZa("N")=$G(Node)
 ;.s ^tmmZZZa("G")=$G(Glb)
 ;.s ^tmmZZZa("ref")=$G(ref)
 ;.s ^tmmZZZa("A")=$G(Arg3)
 i '$D(@ref@(..BLOBcs)) Q:$Q 0 Q
 f i=0:1  q:'$D(@ref@(i))  d ..BLOB.Write(@ref@(i)) s ..BLOBcs=..BLOBcs+$L(@ref@(i))
 s ..BLOBcs=..BLOBcs\32000
 Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="SetPar">
<Description>
           Запись параметров отображения в локальный массив.</Description>
<Internal/>
<FormalSpec>qqpar:%String,qqval:%String,nump:%String,qqObj:%String,y:%String,x:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 N qqsys,qqpn,qt
 ;если имя параметра задано неполностью
 I $E(qqpar)?1.N S qt=$E(qqpar),qqpn=$E(qqpar,2,10),qqpar=$S(qt=1:$S(qqpn=21!(qqpn=61)!(qqpn=87)!(qqpn=65):"x",1:"X"),qt=5:$S(qqpn=2!(qqpn=21)!(qqpn=32):"x",1:"X"),qt=7:$S(qqpn=0!(qqpn=10)!(qqpn=30)!(qqpn=7)!(qqpn=42)!(qqpn=43):"x",1:"X"),1:"X")_qqpar I 1 ;!(qqpn=31) ;;;;????? не согласовано с GetPar
 E  S qt=$E(qqpar,2),qqpn=$E(qqpar,3,10)
 I $G(nump)'="" N qqnump S qqnump=nump
 I qt=1 D  Q:$Q "" Q  ;параметры отображения
 .I qqpn=1 S Vo(qqnump,-1)=qqval Q  ;имя отображения
 .S Vo(qqnump,-1,qqpn)=qqval Q
 I qt=3 D  Q:$Q "" Q  ;параметры печати
 .S Vo(qqnump,-1,3,qqpn)=qqval Q
 I qt=2 D  Q:$Q "" Q  ;параметры запроса (x - номер запроса)
 .S y=+$G(y)
 .S Vo(qqnump,-1,2,y,qqpn)=qqval
 S:$G(qqObj)="" qqObj=$$$CurObj ;текущий объект
 I qt=5 D  Q:$Q "" Q  ;параметры объекта
 .I qqpn=1 S Vo(qqnump,qqObj)=qqval Q  ;имя объекта
 .S Vo(qqnump,qqObj,qqpn)=qqval Q
 I qt=6 D  Q:$Q "" Q  ;параметры строки объекта
 .I qqpn=0 S Vo(qqnump,qqObj,0,y)=qqval Q  ;ссылка на объект-потомок
 I $G(y)="",$G(x)="" S y=+$P($G(W("Zpos",2,"d"))," ",3),x=+$G(W("Zpos",2,"x"))
 N qqw I $G(x)="" S qqw=y,y=Vo(qqnump,qqObj,11,qqw),x=$P(y," ",2),y=$P(y," ") I 1
 I qt=7 D  Q:$Q "" Q  ;параметры ячейки объекта
 .I qqpn=1 S Vo(qqnump,qqObj,0,y,x)=+$E($G(Vo(qqnump,qqObj,0,y,x)))_qqval Q  ;содержимое ячейки
 .I qqpn=0 S $E(Vo(qqnump,qqObj,0,y,x),1)=qqval Q  ;тип ячейки
 .S Vo(qqnump,qqObj,0,y,x,qqpn)=qqval Q
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="SetZMAS">
<Description>
Установить значение (Z) для ZMAS*-понятия (qqw) объекта (qqo).
Значение в массиве. Ссылка на массив - см. параметры ячейки\Спец.пар\Виртуальное значение). Ссылка может содержать Vs(qqnump,"Virt",qqo) или что-то подобное, тогда корректно сработает только на текущей строке.
Если Z не здано, то возвращает значение ;@Dol 08.08.0 + усложнение синтаксиса
Возвращает Пусто !!!! (для использования в правилах проверки!!!)</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqcZM:%Library.String,qqw:%Library.String,Z:%Library.String,wrt</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $D(qqcZM) N qqc S qqc=qqcZM
 I '$D(Vt(qqnump,"mas",qqo,qqw)) S Vt(qqnump,"mas",qqo,qqw)=qARM.GetPar("X753",,qqo,qqw) I qSYS.PSYN(Vt(qqnump,"mas",qqo,qqw)," ",2) S Vt(qqnump,"mas",qqo,qqw,1)=qSYS.PSYN(Vt(qqnump,"mas",qqo,qqw)," ",2),Vt(qqnump,"mas",qqo,qqw,2)=qSYS.PSYN(Vt(qqnump,"mas",qqo,qqw)," ",3),Vt(qqnump,"mas",qqo,qqw)=qSYS.PSYN(Vt(qqnump,"mas",qqo,qqw)," ",1) S Vt(qqnump,"mas",qqo,qqw,2)=$S(Vt(qqnump,"mas",qqo,qqw,2)="":" ",Vt(qqnump,"mas",qqo,qqw,2)?1.n:$C(Vt(qqnump,"mas",qqo,qqw,2)),1:Vt(qqnump,"mas",qqo,qqw,2))
 I '$D(Z) S Z=$G(@Vt(qqnump,"mas",qqo,qqw)) Q:'$D(Vt(qqnump,"mas",qqo,qqw,1)) Z Q $P(Z,Vt(qqnump,"mas",qqo,qqw,2),Vt(qqnump,"mas",qqo,qqw,1))
 I '$D(Vt(qqnump,"mas",qqo,qqw,1)) K:Z="" @Vt(qqnump,"mas",qqo,qqw) S:Z'="" @Vt(qqnump,"mas",qqo,qqw)=Z I 1
 E  S $P(@Vt(qqnump,"mas",qqo,qqw),Vt(qqnump,"mas",qqo,qqw,2),Vt(qqnump,"mas",qqo,qqw,1))=Z
 D:$G(wrt) ..wwww(qqw,,,qqo,qqc) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="SetZTMP">
<Description>
Установить значение (Z) для ZTMP*-понятия (qqw) объекта (qObj).

Z="" - удаление из перечня релевантных</Description>
<Internal/>
<FormalSpec>qObj:%Library.String,qqc:%Library.String,qqw:%Library.String,Z:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqci
 I Z="" K ^Q($$$Relind_qview,qObj,qqc,qqw) K W(qqw) I 1
 E  D  D:'$D(^Q($$$Relind_qview,qObj,qqc)) ..RecRel("+",qqci,1) S ^Q($$$Relind_qview,qObj,qqc,qqw)=Z,W(qqw)=Z  ;запись в перечень
 .S qqci="" F  S qqci=$O(Vc(qqnump,qqci)) Q:qqci=""  I Vc(qqnump,qqci,0)=qObj,Vc(qqnump,qqci)=qqc Q
 I ..GetPar("X182")'="" N qqo,Arg1 S qqo=qObj,Arg1="+" X Vo(qqnump,-1,82) ;@dol 9.03.03 действие по изменению релевантных
 D ..wwww(qqw,1,,qObj,qqc) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Setdpwin">
<Description>
Динамическая переустановка:
X180=1\0 - НЕ выводить\выводить колонку релевантных
X188=1\0 - показывать/НЕ показывать заголовки колонок
X129o17 - вариант скролирования (0 - запрет,1-г, 2-в, 3- г+в, 4-постоянно г, 5 -пост. в, 6 - пост. г+в)

!!! после переустановки скроллирования необходим перевывод.</Description>
<Internal/>
<FormalSpec>X180:%Library.String,X188:%Library.String,X129o17:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(X180)'="" S Vo(qqnump,-1,80)=''X180 D ..wP(qwin_".T2","RowHeaderAppearance",'X180) D:'X180 ..wP(,"RowHeaderWidth",16)
 I $G(X188)'="" S Vo(qqnump,-1,88)=X188 D ..wP(qwin_".T2","ColHeaderAppearance",''X188)
 I $G(X129o17)'="" D ..wP(qwin_".T2","Scrollbars",X129o17)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Sort">
<Description>
Включение невидимой сортировки.
qqo - код объекта сортировки
qqw - код понятия сортировки
Value - ТОЛЬКО при наличии релевантных и режима уточнение. Позволяет сделать сортировку по значениям выражения (возможно использовать  qqo,qqc). Код понятия в этом случае может задаваться любой.
Arg1=1 сделать объект сортировки текущим.
Beg=1 встать в начало (по  включенной сортировке)
Nowr - не выводить на экран. Используется при задании метода в действии по входу в печатную форму.
!!! Для использования в печатных формах (если печать релевантных) лучше писать S Vs(qqnump,"ReFind)=1 D qARM.Sort ...
!!! т. е. принудительно установить режим уточнения.

далее для построение локального словаря (см. метод qW.CreSortV)
qqc0 - текущая общая часть кода экземпляра (по умолчанию - зона фиксации)
SortV - индекс словаря (переносится в Vs(qqnump,"SortV") ). По умолчанию - ссылка на текущий перечень релевантных
SortVn =1 - НЕ создавать ссылки на экземпляры( переносятся в Vs(qqnump,"SortVn") ). Будут использоваться ссылки словаря понятия qqw
New=1 - обновить словарь. Иначе, если он уже есть, то не строится.

Например, для организации временного словаря по зоне фиксации: D qARM.Sort("S15","s113",,,,,,"",,1)</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqw:%Library.String,Value:%Library.String,Arg1:%Library.String,Beg:%Library.String,Nowr:%Library.String,qqc0:%Library.String,SortV:%Library.String,SortVn:%Library.String,New:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(Arg1) $$$CurObj=qqo
 S $P($$$CondFind," ")=qqw,$P($$$CondFind," ",5)="",$P($$$CondFind," ",6)=""
 K Vs(qqnump,"SortV"),Vs(qqnump,"SortVn") I $D(SortV) S:$G(qqc0)="" qqc0=$P($$$CondFind," ",10) D qW.CreSortV(qqw,qqo,$G(Value),qqc0,$G(SortV),$G(SortVn),$G(New)) ;@Dol 27/06/06
 S:0 qqc="" S W("Zosrt")=qqo S Vt(qqnump,7)=$G(Vs(qqnump,7)) K:..GetPar("X1193") Vs(qqnump,7) ;@dol 10.1.04
 I $G(Vs(qqnump,"SortV"))="",$$$ReFind||qARM.GetPar("X1199") D qW.RelWoc(qqw,W("Zosrt"),$G(Value))
 I $G(Beg) S W(qqw)="",qqc="" I 1
 E  S W(qqw)=qW.GG(qqo,qqw,qqc)
 I '$G(Nowr) S:$G(qqXBwids) W("ZBtredo")="" D ..wcre() 
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="SplitterBar">
<Description>
Вроде не нужен</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N k S k=..GetPar("X1663") I k'=""  ;@Dol 7.10.06 сплиттер
 .D ..wP(qwin_".T2","SplitterBar",1),..wP(,"SplitColumn",+k) D:$P(k,",",3) ..wP(,"SplitterWidth",$P(k,",",3))
 .D:$P(k,",",2) ..wP(,"SplitterOffset",$P(k,",",2)) ;D:'$P(k,",",2) ..wM(,"MakeSplitterOptimal")
 .D ..wP(,"OpenEnded",1) ;последняя колонка левой части расширяется
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="StartEdit">
<Description>
Инициирование редактирования с заданными параметрами.
X731 - вариант редактирования (см.понятие X731);
x730 - тип развертки
X73 - параметры развертки
Red=1 - принудительная установка режима редактирования

Метод предназначен для динамического формирования сложных вариантов развертки.
!!!Может вызываться из развертки-действия или правила проверки. Для правила проверки необходимо исклбючить вариант зацикливания.</Description>
<Internal/>
<FormalSpec>X731:%Library.String,x730:%Library.String,X73:%Library.String,Red:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Red),$G(W("ZBtred")) K Red
 I $G(Red) S W("ZBtred")=1 N qqnumpRr S qqnumpRr=qqnump ;@Dol 20.10.09
 D
 .I $D(X73) S %1=..StartEditT2($G(X731),$G(x730),$G(X73)) Q
 .I $D(x730) S %1=..StartEditT2($G(X731),$G(x730)) Q
 .S %1=..StartEditT2($G(X731)) Q
 S qqredS=qqred ;будет использоваться как флаг, если вызвано из правила проверки (чтобы не сбросить qqred)
 I %1=-1 D ..wM(qwin,"EvClose") S:$G(Red) W("ZBtred")=0 Q:$Q "" Q
 I %1=112 S %1=..s112() G:+$G(W("Zcdrl"))=6 StartEdE I %1=-1 D ..wM(qwin,"EvClose") S:$G(Red) W("ZBtred")=0 Q:$Q "" Q  ;развертка (большой текст- выход) или выход из формы по развертке-действию (9)
 I qqred'="",$S(+W("Zcdrl")=12:0,+W("Zcdrl")=3:1,+W("Zcdrl")'=2:1,1:'$P(W("Zcdrl")," ",2)) D ..wfoc(2,"",W("Zpos",2,"x"),W("Zpos",2,"d")) ;очень сомнительное место ;,+W("Zcdrl")'=2:1 - развертка-меню
 S qqredS=qqred
StartEdE I $G(Red) S:qqnumpRr=qqnump W("ZBtred")=0 S:qqnumpRr'=qqnump WS(qqnumpRr,"ZBtred")=0 ;@Dol 20.10.09 м.б. другое окно
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="StartEditT1">
<Description>
              Редактирование граф 1-9 дерева объектов.</Description>
<Internal/>
<FormalSpec>qqspec:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qqx,qqy,qqdat,qqo
 S qqdat=W("Zpos",1,"d"),qqy=W("Zpos",1,"y"),qqx=W("Zpos",1,"x"),qqo=$P(qqdat," ")
 I 'W("ZBt0"),'qqy D  Q:$Q "" Q  ;@Dol 26.05.06 редактирование поискового образа и выражений аналитики в строке 0. Будут использованы как шапка и подвал
 .I qqx'=1,qqx'=2 Q
 .S W("Zcdrl")="",(W("Zdrl"),W("Zldrl"))="",qqw="ZfI9",qqred=qqw D ..wfoc(1,qqy,qqx)
 D
 .;ввод поискового образа
 .I $L(qqdat," ")=1,qqx=1  D  D ..wP(qwin_".T1","M4",$S($D(Vs(qqnump,8,qqo)):"Bor",1:"Red0"),qqy,1) Q  ;поиск объекта
 ..I '$D(Vs(qqnump,8,qqo)) S Vs(qqnump,8,qqo)="" Q
 ..N qqw S qqw="" F  S qqw=$O(Vs(qqnump,8,qqo,qqw)) Q:qqw=""  D ..wM(qwin_".T1","M9",1,qqy,qqo_" "_qqw,"","","",1)
 ..K Vs(qqnump,8,qqo) K:$D(Vs(qqnump,8))<10 Vs(qqnump,8)
 .I $L(qqdat," ")=1,qqy Q:qqx'=4  S Vs(qqnump,12,qqo)='$G(Vs(qqnump,12,qqo))  D ..wP(qwin_".T1","M4",$S($G(Vs(qqnump,12,qqo)):"Bor",1:"Red0"),qqy,4) Q  ;объект для ссылок
 .S qqw="ZfI9",qqred=qqw
 .S %2=$P(qqdat," ",2) ;код понятия
 .I qqx>1 D  Q
 ..I qqx=2 D  Q  ;выражение аналитик
 ...I $G(qqbut)'=2 S W("Zcdrl")="1 0",(W("Zdrl"),W("Zldrl"))=$S($G(Vo(qqnump,qqo,2))>2:"",$E(qqo)'="v":qqo_":",1:$E(qqo,3,255)_":")_%2_"         2     0" S:$P(qARM("Ver","qARMProj1.ocx"),".",2)>4 W(qqw)=$G(Vs(qqnump,12,qqo,%2,2))_$S($G(Vs(qqnump,12,qqo,%2,1))=""&&($G(Vs(qqnump,12,qqo,%2,17))="")&&($G(Vs(qqnump,12,qqo,%2,18))=""):"",1:$C(13,10)_$G(Vs(qqnump,12,qqo,%2,1))_$C(13,10)_$G(Vs(qqnump,12,qqo,%2,17))_$C(13,10)_$G(Vs(qqnump,12,qqo,%2,18))) Q  ;@Dol 23.09.10 18
 ...S qqred="" D ..wP(qwin_".T1","List",$G(Vs(qqnump,12,qqo,%2,2))_$S($G(Vs(qqnump,12,qqo,%2,1))=""&&($G(Vs(qqnump,12,qqo,%2,17))="")&&($G(Vs(qqnump,12,qqo,%2,18))=""):"",1:$C(13,10)_$G(Vs(qqnump,12,qqo,%2,1))_$C(13,10)_$G(Vs(qqnump,12,qqo,%2,17))_$C(13,10)_$G(Vs(qqnump,12,qqo,%2,18))),qqy,qqx) Q  ;просто перевывод (для вызова из меню)  ;@Dol 23.09.10 18
 ..S qqred=""
 ..I qqx>4 Q:$G(Vs(qqnump,12,qqo,%2,4))=""  D  Q  ;num,...
 ...;S Vs(qqnump,13)=Vs(qqnump)_" "_%2_" "_qqx
 ...S %1=qqo_" "_%2_" "_qqx
 ...S %4=$G(Vs(qqnump,13,0,%1))
 ...I '%4 D  Q  ;новый Y
 ....S (%3,Vs(qqnump,13,0,%1))=$O(Vs(qqnump,13,1,""),-1)+1,Vs(qqnump,13,1,%3)=%1 S:$G(qqspec) Vs(qqnump,13,0,%1,1)=$G(qqspec) ;@Dol 22.09.10 qqspec
 ....D ..wP(qwin_".T1","M4","CY",qqy,qqx,0),..wP(,"M1",%3_$S('$D(Vs(qqnump,13,0,%1,1)):":",1:"-")_" "_$G(Vs(qqnump,12,qqo,%2,qqx)),qqy,qqx)
 ...;сотрем текущий и сменим номера остальным
 ...K Vs(qqnump,13,0,%1),Vs(qqnump,13,1,%4)
 ...D ..wP(qwin_".T1","M4","Red0",qqy,qqx,0),..wP(,"M1",$G(Vs(qqnump,12,qqo,%2,qqx)),qqy,qqx) 
 ...F  S %4=$O(Vs(qqnump,13,1,%4)) Q:%4=""  D
 ....S %1=Vs(qqnump,13,1,%4),Vs(qqnump,13,0,%1)=%4-1
 ....K Vs(qqnump,13,1,%4) S Vs(qqnump,13,1,%4-1)=%1
 ....D ..wM(,"M9",1,0,$P(%1," ",1,2),"","",(%4-1)_$S('$D(Vs(qqnump,13,0,%1,1)):":",1:"-")_" "_$G(Vs(qqnump,12,$P(%1," "),$P(%1," ",2),$P(%1," ",3))),$P(%1," ",3))
 ..I qqx=3 D  Q  ;аналитический срез
 ...S %4=$G(Vs(qqnump,13,2,qqdat)) I '%4 S (%3,Vs(qqnump,13,2,qqdat))=$O(Vs(qqnump,13,3,""),-1)+1,Vs(qqnump,13,3,%3)=qqdat,(%1,Vs(qqnump,12,qqo,%2,3))="A"_%3,Vs(qqnump,12,qqo,%2,3,1)=$G(qqspec),Vs(qqnump,12)=$G(Vs(qqnump,13,3,1)) D ..wP(qwin_".T1","M4","CA",qqy,3,0),..wP(,"M1",$E(%1,2,3)_$S($G(qqspec):"*",1:""),qqy,3) Q
 ...I $G(Vs(qqnump,12,qqo,%2,3,1))'=$G(qqspec) S Vs(qqnump,12,qqo,%2,3,1)=$G(qqspec) D ..wP(qwin_".T1","M1",$E(Vs(qqnump,12,qqo,%2,3),2,3)_$S($G(Vs(qqnump,12,qqo,%2,3,1)):"*",1:""),qqy,3) Q  ;@Dol 23.03.08 управление подсчетом сумм
 ...;сотрем текущий и сменим номера остальным
 ...K Vs(qqnump,13,2,qqdat),Vs(qqnump,13,3,%4),Vs(qqnump,12,qqo,%2,3)
 ...D ..wP(qwin_".T1","M4","Red0",qqy,3,0),..wP(,"M1","",qqy,3)
 ...F  S %4=$O(Vs(qqnump,13,3,%4)) Q:%4=""  S %1=Vs(qqnump,13,3,%4),Vs(qqnump,13,2,%1)=%4-1,Vs(qqnump,12,$P(%1," "),$P(%1," ",2),3)="A"_(%4-1) K Vs(qqnump,13,3,%4) S Vs(qqnump,13,3,%4-1)=%1 D ..wM(,"M9",1,0,%1,"","",%4-1,3)
 ...S Vs(qqnump,12)=$G(Vs(qqnump,13,3,1))
 ..I qqx=4 D  D ..wP(qwin_".T1","M4",$S($G(Vs(qqnump,12,qqo,%2,4))="":"Red0",1:"CD"),qqy,4,0),..wP(qwin_".T1","M1",$S($G(Vs(qqnump,12,qqo,%2,4,1))=1:"*",$G(Vs(qqnump,12,qqo,%2,4,1))=2:"u",$G(Vs(qqnump,12,qqo,%2,4,1))=3:"l",$G(Vs(qqnump,12,qqo,%2,4,1))=4:"-",$G(Vs(qqnump,12,qqo,%2,4,1))=5:"n",1:""),qqy,4) Q  ;агрегаты
 ...I $G(qqspec)'=-1,$G(Vs(qqnump,12,qqo,%2,4))="" S Vs(qqnump,12,qqo,%2,4)="D",Vs(qqnump,12,qqo,%2,4,1)=$G(qqspec) Q
 ...I $G(qqspec)'=-1,$D(qqspec) S:$G(Vs(qqnump,12,qqo,%2,4,1))'=$G(qqspec) Vs(qqnump,12,qqo,%2,4,1)=$G(qqspec) Q
 ...I $G(qqspec)'=-1,'$D(qqspec),$G(Vs(qqnump,12,qqo,%2,4,1)) Q
 ...K Vs(qqnump,12,qqo,%2,4) S Vs(qqnump,12,qqo,%2)=0 F %5=5:1:11 D  K Vs(qqnump,12,qqo,%2,%5) D ..wP(qwin_".T1","M1","",qqy,%5,"",$S(%5<10:16777215,1:12632256))
 ....S %1=qqo_" "_%2_" "_%5,%4=$G(Vs(qqnump,13,0,%1)) Q:'%4
 ....;уберем Y диаграмм сотрем текущий и сменим номера остальным
 ....K Vs(qqnump,13,0,%1),Vs(qqnump,13,1,%4) D ..wP(qwin_".T1","M4","Red0",qqy,%5,0),..wP(,"M1",$G(Vs(qqnump,12,qqo,%2,%5)),qqy,%5) 
 ....F  S %4=$O(Vs(qqnump,13,1,%4)) Q:%4=""  D
 .....S %1=Vs(qqnump,13,1,%4),Vs(qqnump,13,0,%1)=%4-1
 .....K Vs(qqnump,13,1,%4) S Vs(qqnump,13,1,%4-1)=%1
 .....D ..wM(,"M9",1,0,$P(%1," ",1,2),"","",(%4-1)_": "_$G(Vs(qqnump,12,$P(%1," "),$P(%1," ",2),$P(%1," ",3))),$P(%1," ",3))
 ...;S %1="" F  S %1=$O(Vs(qqnump,13,0,%1)) Q:%1=""  D
 ...;.D ..wM(qwin_".T1","M9",1,0,$P(%1," ",1,2),"","",$G(Vs(qqnump,12,$P(%1," "),$P(%1," ",2),$P(%1," ",3))),$P(%1," ",3)),..wP(,"M4","Red0","",$P(%1," ",3),0)
 ...;K Vs(qqnump,13,0),Vs(qqnump,13,1)
 .;поисковый образ
 .;разборка с разверткой
 .N qqwr S qqwr=..GetPar("X7801",,qqo,%2) S:$E(qqwr)="@" @("qqwr="_$E(qqwr,2,3000)) S:qqwr["(" @("qqwr="_qqwr) ;@Dol 13.10.08 словарь условий поиска
 .S W("Zcdrl")=$S(qqwr'="":"1 0","@MXTL"[$E(%2):" -1",1:"1 0")
 .S W("Zpdrl")=0,W("Zosn1")=""
 .S (W("Zdrl"),W("Zldrl"))=$S(qqwr'="":qqwr,1:$S($G(Vo(qqnump,qqo,2))>2:"",%2[":":"",$E(qqo)'="v":qqo_":",1:$E(qqo,3,255)_":")_%2)_"         2     0 !!"  ;%2_" *" ;флаг развертки по большому словарю
 .I $G(Vs(qqnump,8,qqo,%2))=""!($G(qqbut)=2) D  I $G(qqbut)=2 D ..wM(,"M9",1,0,qqo),..wP(,"M4",$S($D(Vs(qqnump,8,qqo)):"Bor",1:"Red0"),"",1) Q  ;qqbut=2 не бывает, сделано для простоты сброса из меню
 ..I $G(qqbut)=2 D  S qqred="" I 1
 ...I $G(Vs(qqnump,8,qqo,%2))="" S W(qqw)="*",Vs(qqnump,8,qqo,%2)="*" Q
 ...K Vs(qqnump,8,qqo,%2) K:$D(Vs(qqnump,8))<10 Vs(qqnump,8) S W(qqw)=" "
 ..E  S W(qqw)=$S($E(%2)="@":"*",$E(%2)="T":"",1:qW.GG(qqo,%2,qqc))
 ..I W(qqw)'="" S:$TR(W(qqw)," ")="" W(qqw)="" D ..wP(qwin_".T1","List",W(qqw),qqy,qqx) S:W(qqw)'="" Vs(qqnump,8,qqo,%2)=W(qqw) Q
 .S W(qqw)=$G(Vs(qqnump,8,qqo,%2))
 .//I $G(qqdbl),$P(W("Zcdrl")," ",2)'=-1 S W("Zcdrl")=$S($G(qqdbl)=2:21,1:1)_" 2" S:qqdbl=2 (W("Zdrl"),W("Zldrl"))=$S(%2'[":":qqo_":"_%2,1:%2)_",ZTMPN       ,3       0 !!" D qARM.Wait("I qARM.s112(,1)") ;развертка сразу, если правая кнопка ;!!      1
 .//sasha 20080723 (в ячейке условие при щелчке открывалась развертка) вписана проверка для флага
 .I $G(Vt(qqnump,"Nodbl"))=1 I $G(qqdbl),$P(W("Zcdrl")," ",2)'=-1 D  S qqred="" ;@Dol 19.11.09 S qqred="" и ниже в Wait
 ..I qqwr'="" N %2 S %2=qqwr
 ..S W("Zcdrl")=$S($G(qqdbl)=2:21,1:1)_" 2" S:qqdbl=2 (W("Zdrl"),W("Zldrl"))=$S(%2'[":":qqo_":"_%2,1:%2)_$S($E(%2,$L(%2))=",":"ZTMPN,",1:",ZTMPN")_"       30,3  2     0 !!      2" D qARM.Wait("N qqred S qqred="""_qqred_""" I qARM.s112(,1)") ;развертка сразу, если правая кнопка ;@Dol 19.11.09
 D:qqred'="" ..wfoc(1,qqy,qqx)
 I qqred'="" Q:$Q "" Q
 D ..wwde() D:$$$CurObj'=qqo ..wP(,"MultiSelect",1),..wM(,"M9",1,0,$$$CurObj,1),..wP(,"Selected",0,qqy) Q:$Q "" Q   ;фокус не на колонку объектов
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="StartEditT2">
<Description>
qqbut=3 - принудительный вход в редактеривоние вне заввисимости от описанного стиля

Всегда вызывается как функция</Description>
<Internal/>
<FormalSpec>X731:%Library.String,x730:%Library.String,X73:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $D(X731)||$D(x730)||$D(X73) N qqdat,qqx,qqy,qqbut S qqdat=$G(W("Zpos",2,"d"),"? ? ?"),qqy=$G(W("Zpos",2,"y"),"?"),qqx=$G(W("Zpos",2,"x"),"?"),qqbut=1
 I $G(Vs(qqnump,1,$P(qqdat," ",2),$P(qqdat," ",3),qqx)) Q:$Q "" Q  ;зачеркнуто понятие (или константа связанная с ним)
 N qqmessage D  I $G(qqmessage)'="" D ..Message(qqmessage,,,$G(qqXBMesTime)) S qqred="" Q:$Q "" Q  ;@Dol 22.10.07 ,,10)
 .N qqpar1,qqpar2
 .;S qqpar1=..GetPar(730,,$P(qqdat," ",2),$P(qqdat," ",3),qqx)_" "_..GetPar(731,,$P(qqdat," ",2),$P(qqdat," ",3),qqx)
 .I $G(qruls)'="",'$D(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,310)) S Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,310)=$G(^Q(1,"XRuls",qruls,"XViewStat",$S($G(Vo(qqnump,$P(qqdat," ",2),889))'="":Vo(qqnump,$P(qqdat," ",2),889),1:Vo(qqnump)),"CxObj",$P(qqdat," ",2),"CxWoc",$S($G(qqw)="":"??",1:qqw),"Ref2"))
 .S qqpar1=$S('$D(X731):..GetPar("X731",,$P(qqdat," ",2),$P(qqdat," ",3),qqx),1:X731) I $E(qqpar1)="@" S qqpar1=..Value($E(qqpar1,2,30000)) I qqpar1'="",qqpar1'=-1,"012"'[qqpar1 S qqmessage=qqpar1 Q  ;@dol 2.11.02 обработка косвенности
 .;;I qqpar1=-1 S W("Zcdrl")="0 -1" Q  ;@Dol 1.06.07 при запрете дальше ничего не нужно;Изьято- есть побочные эффекты
 .I $G(qruls)'="",qqpar1'=-1,Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,310)'="" S qqpar1=Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,310) I $E(qqpar1)="@" S qqpar1=..Value($E(qqpar1,2,30000)) I qqpar1'="",qqpar1'=-1,"012"'[qqpar1 S qqmessage=qqpar1 Q  ;@dol 2.11.02 обработка из роли
 .S qqpar1=$S('$D(x730):..GetPar(730,,$P(qqdat," ",2),$P(qqdat," ",3),qqx),1:x730)_" "_qqpar1
 .S qqpar2=$S('$D(X73):..GetPar(73,,$P(qqdat," ",2),$P(qqdat," ",3),qqx),1:X73)
 .D ..GetPar(744,,$P(qqdat," ",2),$P(qqdat," ",3),qqx) ;маска
 .D ..GetPar(745,,$P(qqdat," ",2),$P(qqdat," ",3),qqx) ;ограничение ввода
 .D ..GetPar("X746",,$P(qqdat," ",2),$P(qqdat," ",3),qqx) ;@Dol 13.10.05 зона выделения
 .D ..GetPar("X747",,$P(qqdat," ",2),$P(qqdat," ",3),qqx) ;@Dol 12.10.07 универсальная маска
 .I $G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,84))'="" D ..GetPar("x710",,$P(qqdat," ",2),$P(qqdat," ",3),qqx) ;@Dol 20.07.04 Образец
 .I $E(qqw,1,3)="ZZR",$L(qqw)>3,qqpar1<8,$P(qqpar2," ")="" S $P(qqpar2," ")=$E(qqw,4,20) ;развертка для константы
 .I "05"[$E($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx),0)),qqpar1=" ",qqpar2="" S qqpar1=-1 ;для константы и выражения редактирование по умолчанию запрещено
 .I $E($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx)))=4,..GetPar("X1203") S qqpar1="2 1",qqpar2="Сброс(умолчания)~-~"_$S($G(qqpar2)="":"нет~да",1:$TR(qqpar2," ","~")),Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,4)="qARM.Value(""S Z=$L($P("""""_"~"_qqpar2_"~"_""""",""""~""""_Z_""""~""""),""""~"""")-3 S:Z<0 Z="""""""""",""X"")_1" ;@Dol 06.11.09 флаг с умолчаниями ;,..GetPar("X75",,$P(qqdat," ",2),$P(qqdat," ",3),qqx)'=""
 .I $E(qqw)="T",qqpar1=" " S qqpar1=6 ;умолчание для текста
 .I $P(qqpar1," ")="" D
 ..I $E(qqw,1,3)="dat",$G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,10))="" S Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,10)=1 ;@Dol 20.01.06 присваивание явного типа ;;;S $P(qqpar1," ")=3 S:$P(qqpar1," ",2)="" $P(qqpar1," ",2)=0 Q  ;@dol 11.03.04 dat* - DATA, если явно не переопределен тип
 ..I $E($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,10)))=1 S $P(qqpar1," ")=3 S:$P(qqpar1," ",2)="" $P(qqpar1," ",2)=0 Q 
 .S W("Zcdrl")=$P(qqpar1," ")_" "_$P(qqpar1," ",2) ;???+$P(qqpar1," ")_" "_(+$P(qqpar1," ",2))
 .S:$E(qqpar2)="@" qqpar2=..Value($E(qqpar2,2,511))
 .S (W("Zdrl"),W("Zldrl"))=$G(qqpar2)
 .I $E(qqw,1,2)="TB",'$P(W("Zcdrl")," ") S (qqpar1,W("Zcdrl"))="6 1" ;большой текст
 .S W("Zpdrl")=0 ;флаг развертки по большому словарю
 .S W("Zosn1")="" ;общая основа для побуквенного выбора большой развертки
 .;;;;; @Dol 20.01.06 явный тип присвоен выше ;;;;I $E(qqw,1,3)="dat",qqpar1="",$G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,10))="" S (qqpar1,W("Zcdrl"))="3" ;неявная дата
 .;запрет развертки или редактирования или выход (-2)
 .I +qqpar1<0!($P(qqpar1," ",2)<0) Q
 .I 'qqpar1 S:W("Zdrl")="" (W("Zdrl"),W("Zldrl"))=" *" Q
 .;!!!меню по умолчанию - только развертка (для совместимости со старым вариантом) ;;$P(W("Zcdrl")," ",3)=1 - тип данных PARAMS
 .I +qqpar1=2 S:$P(qqpar1," ",2)="" $P(W("Zcdrl")," ",2)=1 S:$G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,10))="P" $P(W("Zcdrl")," ",3)=1 Q
 .I +qqpar1=12 S:$P(qqpar1," ",2)=""||($P(qqpar1," ",2)>1) $P(W("Zcdrl")," ",2)=1 S:$G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,10))="P" $P(W("Zcdrl")," ",3)=1 Q  ;@Dol 29.09.08 меню-редактирование всегда только развертка
 .;дата
 .;;;;;;I +qqpar1=3 S $P(W("Zcdrl")," ",2)=1 Q  ;было еще S W("Zldrl")="sdat" - какой-то атавизм
 .;деревянная с явно заданным списком
 .I +qqpar1=4 S:W("Zldrl")[$C(13,10) W("Zldrl")=$TR(W("Zldrl"),$C(13,10),"~") Q  ;список значений можно задавать построчно
 .;деревянная с формируемым по словарю списком
 .I +qqpar1=5 Q
 .;рисунок
 .I +qqpar1=7 D  Q
 ..I W("Zldrl")'="",$E(W("Zldrl"))'="\" Q
 ..S qqpar1=..GetPar(76,,$P(qqdat," ",2),$P(qqdat," ",3),qqx) I qqpar1'="","MRF"'[$E(qqpar1) S qqpar1=..Value(qqpar1)
 ..S W("Zldrl")=$S($E(W("Zldrl"))'="":W("Zldrl")_" ",1:"")_qqpar1
 .;Media
 .I +qqpar1=10 D  Q
 ..;S qqpar1=..GetPar(76,,$P(qqdat," ",2),$P(qqdat," ",3),qqx) S:qqpar1'="" qqpar1=..Value(qqpar1)
 .;большой текст
 .I +qqpar1=6,$P($G(Vo(qqnump,-1,55)),",",2),$P(W("Zdrl")," ",3)="" S $P(W("Zdrl")," ",3)=","_$P($G(Vo(qqnump,-1,55)),",",2) Q  ;@Dol 21.07.09
 .I +qqpar1>5 Q
 ;S W("Zmask")=$S($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,44))'="":Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,44),$G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,10))=1:1,1:"") ;для даты 
 ;
 I W("Zcdrl")=" ",qqw'="","@XLMH"[$E(qqw)||(qqw[":") S $P(W("Zcdrl")," ",1)=-1,qqbut=1
 ;
 I $G(qqbut)=3 S qqbut=1 I $G(W("ZBtred")),qqw'="",$E(qqw,1,3)'="ZZR",$S($P(W("Zcdrl")," ",2)<0||($P(W("Zcdrl")," ",2)=1):$G(W("Zadm")),1:1) S $P(W("Zcdrl")," ",2)=0 S:"6"[$E(+W("Zcdrl")) $P(W("Zcdrl")," ",1)=0 ;принудительное редактирование
 ;
 I $G(qqbut)=2||($G(qqarea)=10),+$P(W("Zcdrl")," ",2)=0 S $P(W("Zcdrl")," ",2)=2 ;по правой кнопке сразу развертка;@dol 14.03.03 и по картинке - тоже
 I W("Zcdrl")<-1 D:$G(qwin(qwin,"child"))'="" qARM.GetBqqnump(1) Q:$G(qqbut)=2 "" S:$D(W("Zdomod")) W("Zdomod")=2 S:..GetPar("x173")'="" Vo(qqnump,-1,73)=2 K qqdbl Q -1 ;выход (без вопросов);Q:'$G(qqdbl)&$G(qqbut)=2
 I +W("Zcdrl")=11 Q 112 ;Help по понятию
 I 'W("ZBtred"),"679"[$E(W("Zcdrl"))||(+W("Zcdrl")=10)&('W("ZBtred")) Q:$P(W("Zcdrl")," ",2)=-1 "" Q 112 ;@Dol 27.04.08 -1 ;большой текст или картинка @dol 29.02.04
 I 'W("ZBtred"),qqw'="ZTMPFRel" Q:qqw=""!($G(qqbut)'=2) "" S W("Zcdrl")=11,W("Zldrl")="" Q 112 ;пояснения по понятию
 Q:qqw="" ""
 ;I $E(qqw,1,3)="dat" S $P(W("Zcdrl")," ")=3
 I $E($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx)))'=5 D  Q:$P(W("Zcdrl")," ",2)<0 "" Q:qqw="" "" I $E(qqw,1,3)="ZZR"!($P(W("Zcdrl")," ",2)=1) S qqred=qqw,qqzsav=$G(W(qqw)) Q 112 ;@dol 10.03.04 для выражений нет умолчаний
 .I $E(qqw,1,3)="ZZR" D  Q  ;ячейка константы с разверткой
 ..S:W("Zcdrl")="" W("Zcdrl")="2 1" ;"5 2"
 ..S W(qqw)="",qqZN=qqw N qqw S qqw=$E(qqZN,4,20) Q:qqw=""
 ..I " "_qqwchg_" "'[(" "_qqw_" ") S qqwchg=qqwchg_" "_qqw,W(qqw)=qW.GG(qqo,qqw,qqc)
 .I $E(qqw,1,2)="TB" S W(qqw,1)="<Текст>" Q
 .K N(qqw) I $E(qqw,1,3)'="@ZL",$E(qqw,1,3)'="@ZX"," "_qqwchg_" "'[(" "_qqw_" ") S W(qqw)=qW.GG(qqo,qqw,qqc) I $G(W("ZBtred")),..qqtime(qqo) S qqw="",qqred="" Q
 .;I $G(W(qqw))="",$P(W("Zcdrl")," ",2)'<0,$S($G(Vo(qqnump,$P(qqdat," ",2),870))'=2:1,'$P(W("Zcdrl")," ",2):1,1:+W("Zcdrl")'=9) D   ;!($P(W("Zcdrl")," ",2)<0) D ;@dol 30.01.02 обработка умолчаний для понятий с запретом редактирования убрана;@Dol 05.01.08 блокируется для (Х5780) варианта вывода умолчаний 2 (для существующих экземпляров) для развертки-действия
 .I $G(W(qqw))="",$P(W("Zcdrl")," ",2)'<0,$S($G(Vo(qqnump,$P(qqdat," ",2),870))<2:1,$G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,60))="RE":0,'$P(W("Zcdrl")," ",2):1,+W("Zcdrl")=2:$E($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx)))'=4,1:+W("Zcdrl")'=9) D   ;!($P(W("Zcdrl")," ",2)<0) D ;@dol 30.01.02 обработка умолчаний для понятий с запретом редактирования убрана;@Dol 05.01.08 блокируется для (Х5780) варианта вывода умолчаний 2 и 3 (для существующих экземпляров) для развертки-действия; @Dol 06.11.09 флаг ;3 29.03.10 ;16.06.10 <2 и убрано $G(Vo(qqnump,$P(qqdat," ",2),870))=3:0 ;@Dol 21.06.10 для RE нельзя - текст задваивается
 ..N qqred S qqred=qqw ;@dol 21.04.03 чтобы в условии можно было писать qqred
 ..S qqz=..GetPar(75,,$P(qqdat," ",2),$P(qqdat," ",3),qqx) ;умолчание
 ..Q:qqz=""  I "@Z"'[$E(qqw),qqw'[":"," "_qqwchg_" "'[(" "_qqw_" ") S qqwchg=$S($G(qqwchg)="":"",1:qqwchg_" ")_qqw ;@dol 27.01.02
 ..;;S:$E(qqz)="@" qqz=..Value($E(qqz,2,511)) I "YT"[$E(qqw) D:$D(W(qqw)) ..wwww(qqw) Q
 ..S:$E(qqz)="@" qqz=..Value($E(qqz,2,511)) I "YT"[$E(qqw) S:$E(qqw)="T"&&(qqz'="")&&($D(W(qqw))<10) W(qqw,0)=qqz D:$D(W(qqw)) ..wwww(qqw) Q  ;@Dol 08.12.09 умолчания для текста
 ..K:qqz="" W(qqw) S:qqz'="" W(qqw)=qqz
 ..;D:$P(W("Zcdrl")," ",2)<0 ..wwww(qqw)
 ..I qqz'="" D ..wwww(qqw)
 ;
 I "679"[$E(W("Zcdrl"))||(+W("Zcdrl")=10)&('W("ZBtred")) Q 112 ;большой текст или картинка @dol 29.02.04 ОБРАБОТКА УМОЛЧАНИЙ
 Q:$P(W("Zcdrl")," ",2)<0 ""
 Q:qqw="" "" ;?????
 I $E($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx)))=4 D  Q:qqver'=-1 "" D:$G(qwin(qwin,"child"))'="" qARM.GetBqqnump(1) S:$D(W("Zdomod")) W("Zdomod")=2 S:..GetPar("x173")'="" Vo(qqnump,-1,73)=2 K qqdbl Q -1 ;флаг
 .;I $E(qqw,1,4)="ZMAS" S:'$D(Vt(qqnump,"mas",qqo,qqw)) Vt(qqnump,"mas",qqo,qqw)=qARM.GetPar("X753",,qqo,qqw) S W(qqw)=$G(@Vt(qqnump,"mas",qqo,qqw))  ;@Dol 22.07/05
 .I $E(qqw,1,4)="ZMAS" S W(qqw)=..SetZMAS(qqo,,qqw)  ;@Dol 08.08.10
 .S (Z,W(qqw))='$G(W(qqw)) S:"@Z"'[$E(qqw) qqwchg=qqwchg_" "_qqw ;@dol 17.03.04 @Z;;;S:$E(qqw,1,4)="ZMAS" @Vt(qqnump,"mas",qqo,qqw)=Z
 .S qqver=..GetPar(74,,$P(qqdat," ",2),$P(qqdat," ",3),qqx) I qqver'="",$E(qqver)'?1N S qqver=..Value(qqver)
 .D:'$D(Vo(qqnump,-1,854)) ..GetPar("X1854") S:Vo(qqnump,-1,854)'="" @("qqver="_Vo(qqnump,-1,854)) // общее правило проверки для ячейки типа флаг sasha 20081114
 .I qqver=0 S W(qqw)='$G(W(qqw)) ;веррнули назад
 .I qqver'="",qqver'=1,qqver'=0,qqver'=-1,$E(qqver)'?1N D ..Message(qqver)
 .S Z=W(qqw) I $E(qqw,1,4)="ZTMP",$G(qqc)'="",'$G($$$Tree) D   ;временные понятия, хранимые в перечне релевантных
 ..I 'Z K ^Q($$$Relind_qview,$P(qqdat," ",2),qqc,qqw) D:qqw="ZTMPFRel" ..RecRel("-",$P(qqdat," ",1),1) I 1  ;@Dol 3.02.06 ZTMPFRel
 ..E  D:'$D(^Q($$$Relind_qview,$P(qqdat," ",2),qqc)) ..RecRel("+",$P(qqdat," ",1),1) S ^Q($$$Relind_qview,$P(qqdat," ",2),qqc,qqw)=Z  ;запись в перечень
 ..I ..GetPar("X182")'="" N qqo,Arg1,qObj,qOref S qOref=$P(qqdat," ",1),(qObj,qqo)=$P(qqdat," ",2),Arg1=$S('Z:"-",1:"+") X Vo(qqnump,-1,82) ;@dol 9.03.03 действие по изменению релевантных;@Dol 22.05.06 qObj, Arg1
 .D:$E(qqw,1,4)="ZMAS" ..SetZMAS(qqo,,qqw,Z)  ;@Vt(qqnump,"mas",qqo,qqw)=Z ;S:$E(qqw,1,4)="ZMAS" @Vt(qqnump,"mas",qqo,qqw)=Z
 .D ..wwww(qqw) I $E(qqver)=1,..EndOP() Q  ;@Dol 22.08.02 немедленнная запись измененных значений
 .;@Dol 17.12.07 перемещения после флага
 .I qqver="" G:($P($G(Vo(qqnump,-1,856))," ",1)=1) SEMetTab  Q  ;Q:..GetPar("X179")=2  Q  ;?а вход в редактирование следующей
 .Q:$E(qqver)'?1N  Q:qqver="-3"
 .N qNx S qNx=qqver I $S(qNx'[":":0,+qNx=1:0,1:..EndOP()) Q
 .Q:$S(qNx'[":":0,1:'..Obj($P($E(qNx,2,255),":")))
 .S:qNx[":" qNx=$E(qNx)_$P(qNx,":",2) S:qNx=1&&('..GetPar("X179")) qNx=3 I $E(qNx,2,255)'=""||(+qNx=2)||(+qNx=3) D qARM.NextEdit($S($E(qNx,2,255)="":qqw,1:$E(qNx,2,255)),1) Q
 .Q:($P($G(Vo(qqnump,-1,856))," ",1)'=1)
SEMetTab .d ..wM(qwin_".T2","NextCell",''$P(Vo(qqnump,-1,856)," ",4),0,0,0) Q
 S qqred=qqw,qqzsav=$S($G(qqpt)>1:0,1:$G(W(qqw)))
 I $E(qqw,1,3)="ZZR"!($P(W("Zcdrl")," ",2)>0) Q 112
 I $E($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx)))=5 S @("W(qqw)="_$E(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx),2,32000)) ;@Dol 8.10.07 чтобы работало правильно редактирование выражений для нового дерева
 Q:qqw="" "" ;????
 Q ""
]]></Implementation>
</Method>

<Method name="T1ColHButton">
<Description>
События кнопок заголовков колонок дерева объектов.
qqpar1- номер ряда (от 0 ).</Description>
<Internal/>
<FormalSpec>qqpar1:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $S('W("ZBtred"):0,1:..EndOP()) Q:$Q "" Q
 I qqpar1=0 D  Q:$Q "" Q
 .I 'W("Zadm") D ..wbut(1) K Vs(qqnump,1) D ..wrot("",0),..wcre() Q
 .I '$D(^Q(1,"XView",Vo(qqnump))) D qARM.Message("Описание отображения "_Vo(qqnump)_" сгенерировано "_$S(Vo(qqnump)["sys":" методом qSYS.sysView",1:"")) Q
 .d ..wP("-qARM","Cursor",-11)
 .;D:'W("ZBt0") ..wM(qwin_".T2","OleDragDisable"),..wM(,"OleDropDisable") ;;@Dol 31/10/04;@Dol 12.05.07 изяет - ест копировать/востановить в буфер 
 .;D:W("ZBt0") ..wM(qwin_".T2","OleDragEnable"),..wM(,"OleDropEnable") ;@Dol 31/10/04
 .D:'W("ZBt0") ..ButtonDestr() ;@Dol 14.09.05
 .D ..wP(qwin_".T1","OnAutoEndDragging",'W("ZBt0"))
 .I 'W("ZBt0") D
 ..D:$G(Vo(qqnump,-1,720)) qARM.wM(qwin_".StdBottomBar","Destroy") ;убрать кнопки выхода
 ..N qqchi S qqchi="" F  S qqchi=$O(qwin(qwin,"Tabs",qqchi)) Q:qqchi=""  D ..wM(qwin_".Tabs"_qqchi,"Destroy") K qwin(qwin,"Tabs",qqchi) ;уничтожение старых Tabs
 ..Q:'$D(qwin("Q"_qqnump,"parent"))  N qpp S qpp="" F  S qpp=$O(qwin("Q"_qqnump,"parent",qpp)) Q:qpp=""  D ..wM("Q"_qpp,"Destroy") K qwin("Q"_qpp) ;удаление встроенных окон
 ..K qwin("Q"_qqnump,"parent")
 .I $G(Vo(qqnump,-1,669))'="" D qARM.wP(qwin_".SBM","Visible",W("ZBt0"))
 .I 'W("ZBt0"),qSYS.Redview("SavTmp") Q
 .S W("ZBt0")='W("ZBt0") D:'W("ZBt0") ..wbut(1) D
 ..I W("ZBt0"),$G(Vo(qqnump,-1,"XMod"))'=""||$D(Vs(qqnump,5)) D qSYS.CreVo(Vo(qqnump)) ;перезагрузка модицицированного для редактирования
 ..I W("ZBt0"),$D(Vs(qqnump,5)) M Vs("par",5)=Vs(qqnump,5)
 ..D qSYS.MenuObj(W("ZBt0"))
 ..D ..wP(qwin_".T1","BackColor",$S('W("ZBt0"):qqXBColor,1:256*256*256-1))
 ..D:W("ZBt0") ..wP(,"ColumnBackColor",qqXBColor,0) ;-2147483633,0)
 ..D ..wP(,"GridHorizontalColor",$S(W("ZBt0"):180,1:qqXBColor)),..wP(,"GridVerticalColor",$S(W("ZBt0"):180,1:qqXBColor)) ;было -2147483632
 .I 'W("ZBt0") D ..wipa(),qSYS.CreVo(Vo(qqnump)),..MenuView("",-1),..MenuView(W("Zadm")),..Grid(),..MenuCre()
 .D:W("ZBt0") ..wM(qwin,"ShowTrees",1)
 .D ..wcro()
 .I 'W("ZBt0"),$G(W("Zomod")) S ^Q(1,"XView",Vo(qqnump),"X")=qW.zCnv(1,$H,quser) D qSYS.Verify() ;D:qSYS.Verify() qARM.OpenDoc("qerr",,,"Ошибки") ;@dol 13.01.02 принудительное составление схемы
 .I 'W("ZBt0") D ..wcre(),..wM(qwin,"ShowTrees",2) S qqpar1=..GetPar(129) I $P(qqpar1,",",3)'="",'$P(qqpar1,",",3) D ..wM(qwin,"ShowTrees",0) ;..wM(qwin,"s1308@"),..wM(qwin,"s1307@")
 .D ..wM(qwin_".T"_('W("ZBt0")+1),"SetFocus")
 .I 'W("ZBt0"),$G(W("Zomod")),$D(qerr) D qARM.OpenDoc("qerr",,,"Ошибки") ;S ^Q(1,"XView",Vo(qqnump),"X")=qW.zCnv(1,$H,quser) D:qSYS.Verify() qARM.OpenDoc("qerr",,,"Ошибки") ;@dol 13.01.02 принудительное составление схемы
 D ..wbut(1) I W("ZBt0") Q:$Q "" Q
 ; Сброс_поискового_образа
 I qqpar1=1 K Vs(qqnump,8) D ..wM(qwin_".T1","M8",1),..wP(,"ColumnPictureH@1","Red0",1,0) Q:$Q "" Q
 ; Сброс_аналитик
 I qqpar1=2 D  K Vs(qqnump,12),Vs(qqnump,13),Vs(qqnump,99,"Anal"),Vs(qqnump,120) D ..MenuAn("DA"),..wM(qwin_".T1","M8",2,9),..wP(,"ColumnPictureH@1","Red0",2,0) Q:$Q "" Q
 .N qqo,qqw,j S qqo="" F  S qqo=$O(Vs(qqnump,12,qqo)) Q:qqo=""  S qqw="" F  S qqw=$O(Vs(qqnump,12,qqo,qqw)) Q:qqw=""  D:$G(Vs(qqnump,12,qqo,qqw))
 ..D ..wM(qwin_".T1","M9",1,0,qqo_" "_qqw) F j=6:1:9 D ..wP(,"M1","","",j,"",16777215)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="T2ColHButton">
<Description>
События кнопок заголовков колонок дерева экземпляров (сортировка).
qqpar1- номер ряда (от 0 ).
qqpar1=-1 - сброс сортировки
Для включения из программы.
Find="" ;просто включить
Find ="*" - включить в режиме поиска по шаблону.

@Dol 31.08.06 Сообщения о причине невозможности сортировки выводятся только в режиме Администратор</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqws:%Library.String,Find:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $S('W("ZBtred"):0,1:..EndOP()) Q:$Q "" Q
 I $D(Find) D ..wbut(2,qqpar1,1) ;@Dol 22/10/05
 S qqo=$$$CurObj ;@dol 18.1.04 ????
 I $G(qqws)'="" S qqpar1=$P($G(Vo(qqnump,$$$CurObj,11,qqws))," ",2) I qqpar1="" Q:$Q "" Q  ;упорядочится по понятию
 ;I $G(qqbut)=2 D ..wbut(2) S %1=$P($G(Vs(qqnump,10)),",",qqpar1+1) Q:%1=""  D ..OpenCHelp("W"_%1_"_"_$$$CurObj) Q:$Q "" Q  ;Help по правой кнопке
 I $G(qqbut)=2 D  Q:$Q "" Q
 .I '$G(W("ZBs"_(qqpar1+1))),$E($G(Vo(qqnump)),1,3)'="XXX" D   Q:$G(W("Zosrt"))=""  ;@Dol 13.05.07 сортировка по правой кнопке с последующем вызовом шаблона
 ..N qqbut S qqbut=1 D ..T2ColHButton(qqpar1)
 .I $G(W("ZBs"_(qqpar1+1))) D ..OpenText($P($$$CondFind," ",5)_$P($$$CondFind," ",6),"N t5 S t5=$L($P($TR(Text,""*?"",$C(1,1)),$C(1),1)),$P(Vs(qqnump,""CondFind""),"" "",5)=$E(Text,1,t5),$P(Vs(qqnump,""CondFind""),"" "",6)=$S($E(Text,t5+1,255)="""":"""",1:$TR($ZCVT($E(Text,t5+1,255),""U""),"" "",""_"")) S:$E(Text,t5+1,255)'="""" W(""ZfIlTr"")=$S(t5:t5_""e"",1:"""")_qW.qFindC(,,$E(Text,t5+1,255))_"".e"" S qqc="""" D qARM.wcre()","Ограничение сортировки: Общее_начало*шаблон (= символ|*|?)") Q  ;@Dol 12.05.07 ввод общего начала
 .D ..wbut(2) D ..OpenCHelp(2,qqpar1)  ;Help по правой кнопке
 ;I $D(Vt(qqnump,111)),$S($G(Vo(qqnump,$$$CurObj,2))=6:$S($P($G(Vs(qqnump,10)),",",qqpar1+1)="C":0,$L($$$ObjRef($$$CurObj),",")'=1:1,1:$P($G(Vs(qqnump,10)),",",qqpar1+1)'="C"),$G(Vo(qqnump,$$$CurObj,2))=4:$L($$$ObjRef($$$CurObj),",")'=1,1:'$D(Vt(qqnump,111,0,$$$CurObj))) D ..wbut(2),..Message("Недопустимо для объектов виртуального поддерева") Q "" ;Для С возможна?
 I $G($$$CurObj)=-1||($G($$$CurObj)=""),$G(qqpar1)'=-1,..GetPar("X73",,-1,0,qqpar1)="" D ..wbut(2) Q:$Q "" Q  ;,3)'= @dol 6.10.06
 S Vo(qqnump,$$$CurObj,38)="" ;автосортировку выключим
 D:$D(Vt(qqnump,111)) ..Virt()
 S W("Zosrt")="" ;не очень хорошо
 N qqw S qqpar1=qqpar1+1,qqw="ZBs"_qqpar1 S:qqpar1 W(qqw)='$G(W(qqw))
 D ..T2ColHButtonClr(qqw) ;удалим старые кнопки
 K Vs(qqnump,"SortV"),Vs(qqnump,"SortVn") ;@Dol 16.06.06 ссылка на локальный словарь
 K Vs(qqnump,"NoSortD") ;@Dol 31.08.06 Флаг запрета изменения основы (уточнения). Переустановка может быть в обработке ..T2ColHButtonDo
 I $D(W(qqw)),..T2ColHButtonDo(qqw,W(qqw)) D:'$G(W(qqw)) ..wbut(2) Q:$Q "" Q
 I $G(W(qqw)),$$$CurObj=$G(Vs(qqnump,7)),$G(Vs(qqnump,17)) K W(qqw) D ..wbut(2) D:W("Zadm") ..Message("Недопустимо. Жесткая фиксация") Q:$Q "" Q
 D ..wipa() ;S:'$D(Vs(qqnump,7)) $P($$$CondFind," ",10,11)=""
 I $P($$$CondFind," ",1)="ZTMPN" S $$$ReFind=0,qqc="" ;@dol 15.02.04
 I '$G(W(qqw)) S $P($$$CondFind," ",1,6)="     " D ..wbut(2),..wfot() D:$G(Vt(qqnump,7))'=""   D ..wcre() D:$G(Vo(qqnump,-1,1991)) ..wM(qwin_".T2","SetColRect",-1,-1) Q:$Q "" Q
 .S Vs(qqnump,7)=Vt(qqnump,7) D ..wfot(Vs(qqnump,7)) I ..GetPar("X1193"),Vs(qqnump,7)'="" D ..Fix(Vs(qqnump,7),,,1)
 I $D(Vt(qqnump,111)),$G(Vo(qqnump,$$$CurObj,2))>1,$G(Vs(qqnump,"SortV"))="",$S($G(Vo(qqnump,$$$CurObj,2))=6:$S($P($G(Vs(qqnump,10)),",",qqpar1)="C":0,$L($$$ObjRef($$$CurObj),",")'=1:1,1:$P($G(Vs(qqnump,10)),",",qqpar1)'="C"&&($G(Vs(qqnump,"SortV"))="")),$G(Vo(qqnump,$$$CurObj,2))=4:$L($$$ObjRef($$$CurObj),",")'=1,1:'$D(Vt(qqnump,111,0,$$$CurObj))) D ..wbut(2) D:W("Zadm") ..Message("Для виртуальных - только по коду экземпляра") Q:$Q "" Q  ;Для С возможна? ;@Dol 17.08.06 $G(Vs(qqnump,"SortV"))="" - Нет построенных индексов
 S %1=$S($G(qqws)'="":qqws,1:$P($G(Vs(qqnump,10)),",",$E(qqw,4,5)))
 D  I %1="" S %1=$P($$$CondFind," ") S:%1'="" $P($$$CondFind," ",1,6)="    " D:%1=""&0 ..wP(qwin_".T2","ItemExpandAll",1,0) D:%1'="" ..wP(qwin_".T1","M10",1,0,1000),..wcre() S W(qqw)=0 D ..wbut(2) D:$G(Vo(qqnump,-1,1991)) ..wM(qwin_".T2","SetColRect",-1,-1) Q:$Q "" Q
 .I %1="",$$$ReFind||qARM.GetPar("X1199")||($G(Vs(qqnump,"SortV"))'=""),$E($G(Vo(qqnump,$$$CurObj,0,+$P($G(W("Zpos",2,"d"))," ",3),qqpar1-1)))=5 S %1="Zs"_(+$P($G(W("Zpos",2,"d"))," ",3))_"c"_(qqpar1-1) ;выражение (в режиме уточнения)
 .Q:%1=""  I %1="ZTMPN",'$$$ReFind,$$$RelNum S $$$ReFind=1,qqc="" ;@dol 15.02.04
 .I $G(Vs(qqnump,"SortV"))="" D  Q:%1=""  ;@Dol 21.12.04 X 1199
 ..I '$$$ReFind,$S($G(Vo(qqnump,$$$CurObj,2))'=4:"@TMLXZ"[$E(%1)||(%1[":"&&'qW.TestSort(%1,$$$CurObj)),1:$E(%1)="@") Q:qARM.GetPar("X1199")  D:W("Zadm") ..Message("Для данного типа понятия упорядочивание возможно только для перечня релевантных в режиме уточнения.") S %1="" Q  ;@Dol 25.09.08 %1[":"&&qW.TestSort для qqo:qqw
 ..I %1'="C",%1'="CC",$S($$$ReFind:0,$G(Vo(qqnump,$$$CurObj,2))'=4:$D(^Q(1,$S(%1'[":":%1,1:$P($P(%1,":",2),"{"))))<10,1:$D(^QW(1,%1,0))<10) D:W("Zadm") ..Message("Нет словаря значений. Упорядочить невозможно") S %1="" Q
 .S W(%1)=qW.GG($$$CurObj,%1,qqc),$P($$$CondFind," ")=%1,$P($$$CondFind," ",5)="",$P($$$CondFind," ",6)=$G(Find) ;S:W(%1)="" qqc="" ;@Dol 07.06.06 qqc="" - иначе появлялась пустая строка
 ;;S qqc="" ;@Dol 22.04.06 вывод сначала;@Dol 22.05.06 убран - народу не понравилось
 S W("Zosrt")=$$$CurObj S Vt(qqnump,7)=$G(Vs(qqnump,7)) K:..GetPar("X1193") Vs(qqnump,7)
 S:'$D(Vo(qqnump,-1,1991)) Vo(qqnump,-1,1991)=..GetPar("X11991") D:$G(Vo(qqnump,-1,1991)) ..wM(qwin_".T2","SetColRect",qqpar1-1,8388736) ;@Dol 16.06.10 выделение колонки
 I $G(Vs(qqnump,"SortV"))="" D:$$$ReFind||qARM.GetPar("X1199") qW.RelWoc($P($$$CondFind," "),W("Zosrt"),,$S($G(Vs(qqnump,7))'="":$P($$$CondFind," ",10),1:""))
 ;не надо, вставленов ..wcre ;S:$G(qqXBwids) W("ZBtredo")="" ;@Dol 6.02.08 чтобы прошла переинициализация колонок при их рсширении
 D ..wfot(W("Zosrt")) I $S($G(qqXB11992):..GetPar("X11992")'=0,1:..GetPar("X11992")) Q:$Q "" Q  ;@Dol 24.12.10 Отложенная сортировка;@Dol 29.12.10
 D ..wcre() ;@Dol 28/07/05 $P($$$CondFind," ",10
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="T2ColHButtonClr">
<Description>
Сброс кнопок сортировки</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N but,qqws S but="ZBs" F  S but=$O(W(but)) Q:$E(but,1,3)'="ZBs"  I but'=$G(Arg1),but?1"ZBs"1.N D:$G(W(but)) ..T2ColHButtonDo(but,0) K W(but) ;@Dol N qqws т.к. T2ColHButtonDo его СОЗДАЕТ !!!
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="T2ColHButtonDo">
<Description>
Действие по сортировке для ячейки или колонки (в заголовке колонки)</Description>
<Internal/>
<FormalSpec>qqw:%Library.String,but:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqx,qqz,qqwk S qqwk=qqw,qqx=$P(qqw,"ZBs",2)-1 S W("Zosrt","y")=+$P($G(W("Zpos",2,"d"))," ",3),W("Zosrt","x")=qqx ;@Dol 17.07.05 x y
 S qqz=..GetPar("X785",,$$$CurObj,+$P($G(W("Zpos",2,"d"))," ",3),qqx) I qqz="" S qqz=..GetPar("X11995") ;@Dol 25.03.11 
 I qqz'="" N qqend D T2ColButX(qqz) K:$G(qqend)=1 W(qqwk) Q:$Q $G(qqend) Q  ;@dol Обработка сортировки понятия
 D ..GetPar("X73",,-1,0,qqx) I $G(Vo(qqnump,-1,0,0,qqx,3))="" Q:$Q "" Q
 N qqend D T2ColButX(Vo(qqnump,-1,0,0,qqx,3)) K:$G(qqend)=1 W(qqwk) Q:$Q $G(qqend) Q
T2ColButX(Xec)  S qqw=$S($G(qqws)'="":qqws,1:$P($G(Vs(qqnump,10)),",",$E(qqw,4,5)))
 I qqw="" S qqw=$G(Vo(qqnump,$$$CurObj,0,+$P($G(W("Zpos",2,"d"))," ",3),qqx)) S (qqws,qqw)=$S($E(qqw)="5":"Zs"_(+$P($G(W("Zpos",2,"d"))," ",3))_"c"_qqx,'$E(qqw):"ZZR",1:$E(qqw,2,255)) ;!!!!изменяем qqws
 ;D qARM.Message($G(qqws)_"-"_qqx_"-"_qqw_":"_Xec)
 I Xec=0,but=1 S qqend=1 Q  ;блокировка сортировки
 I $E(Xec)'?1.N X Xec Q  ;действие
 I Xec=1 D qSYS.SortTree() Q  ;включение внутренней сортировки дерева (2,3 - обновляемый словарь,2,4 - без ссылок на экземпляры)
 I "2345"[$E(Xec),but=1,$G(Vs(qqnump,7))'="" D  Q  ;сортировка с локальным словарем при фиксации
 .I $E(Xec,2,5),$L($P(Vs(qqnump,"CondFind")," ",10))<($E(Xec,2,5)+1) Q  ;ограничение на кол-во символов в коде фиксации
 .D qW.CreSortV(qqw,qqo,,$P(Vs(qqnump,"CondFind")," ",10),$P(Vs(qqnump,"CondFind")," ",10),24[$E(Xec),$E(Xec)<4)
 I "67"[$E(Xec),but=1 D  Q  ;сортировка с произвольным локальным словарем при фиксации (6 - обновляемый, 7 - нет)
 .D qW.CreSortV(qqw,$S($E(Xec,2,255)="":"",1:$E(Xec,2,255)_",")_qqo,,"",,0,$E(Xec)=6)
 Q
]]></Implementation>
</Method>

<Method name="TFormOnClose">
<Description>
Закрытие окон
Если qqpar2, то идет цепочка закрытия окна отображения (ответы на вопросы).
Arg1=1 - закрытие при потере фокуса</Description>
<Internal/>
<FormalSpec>Sender:%String,qqpar2:%String,Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 $$$FEvent
 I $G(qqpar2)'="" G @("sclo"_qqpar2) ;идет цепочка закрытия
 I Sender="MesForm" Q:$Q "" Q  ;D ..wM("MesForm","Destroy") Q ""
 i Sender["QVWordpad" K W("ZredB") d ..wM(Sender,"Destroy"),..wP(Sender,"Name","") q:$Q "" q  ;@sas 20081202 @Vol ПЕРЕДЕЛАТЬ ..EditDoc
 I $E(Sender,1,4)="ZRes" D  Q:$Q "" Q
 .I +$G(W("ZredB"))=1,$P(W("ZredB")," ",2)=$P(Sender,".") Q:'..EditDoc()  ;Большой текст
 .d ..wM($P(Sender,"."),"Destroy") k qwin($P(Sender,".")) Q  ;Служебное окно (диаграмма, картинка и т.п)
 I $P(Sender,".")'=("Q"_$G(qqnump))!$G(W("ZredB")),..ChgWin()=1 Q:$Q "" Q  ;????;Обработка смены окна (смена локальной среды)
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 ;
 ;Закрытие окна
 S qqwold="" I $G(qqdbl) K qqdbl Q:$Q "" Q  ;;чтобы избавится от лишнего закрытия (например, открыли окно по двойному щелчку)
 I W("ZBtred") S:qqred'="" qqred="" I ..EndOP() Q:$Q "" Q  ;@dol 5.12.03 ???S:qqred'="" qqred="" 
 G:$E(qview,4,6)="sys" sclo2 D:qqnump=0||(..GetPar("X1198")) ..SaveView(1) ;@dol 7.10.04 X1198
 ; 15.12.2008 Kokarev; было: I '$G(W("Zomod")),$G(^CacheTemp("qview",Vo(qqnump)))=$J K ^CacheTemp("qview",Vo(qqnump)) ; ...
 I '$G(W("Zomod")),$G($$$tmpGl("qview",Vo(qqnump)))=$J K $$$tmpGl("qview",Vo(qqnump)) ;вдруг входили в редактирование (временно. нуно разрешить редактирование только для администрратора)
 I $G(W("Zomod")) D  D:$G(Arg1) ..wM(qwin,"SetFocus") D ..Question("Сохранить отредактированное дерево объектов"_$C(13,10)_"(НЕ ВОССТАНАВЛИВАТЬ старое состояние)",1,"D ..TFormOnClose(0,1)","D ..TFormOnClose(0,2)",2) Q:$Q "" Q  ;три кнопки (с Cancel)
 .I $D(^Q(1,"XView",Vo(qqnump))) S ^Q(1,"XView",Vo(qqnump),"X")=qW.zCnv(1,$H,quser) ;дата коррекции описания отображения
 ;Ликвидация последствий редактирования
sclo1 I $G(W("Zomod")),qSYS.Redview("Rest") D qSYS.Verify()  ;проверка - чтобы восстановить старую схему. ?вывод ошибок
 
 ;
sclo2 I $G(W("Zomod")),qSYS.Redview("Kill")
 
 ;; если отображение создано под оганизацией
 i Vo(qqnump)=("XXX"_$g(Vs(qqnump,"View"))) d qSYS.BrCall235Ex($g(Vs(qqnump,"View") ) ) ;;маслова 01.09.2010
 
 I $G(W("ZdoX122")),..GetPar("X122")'="" D  I Arg1 Q:$Q "" Q  ;@Dol 16.02.07 Постоянное действие по выходу
 .N qqend X Vo(qqnump,-1,22) S Arg1=$G(qqend)=0 S:'Arg1 Vo(qqnump,-1,22)=""
 D ..GetPar("x173") S:Vo(qqnump,-1,73)="" Vo(qqnump,-1,73)=$G(W("Zdomod")) ;стиль выхода
 G:Vo(qqnump,-1,73)=""||(qqnump=0) sclo5
 I ..GetPar(122)=""&(..GetPar(172)="") G sclo5 ;действие по выходу
 G:Vo(qqnump,-1,73)=3 sclo6 G:Vo(qqnump,-1,73)=2 sclo4
 D:$G(Arg1) ..wM(qwin,"SetFocus")
 N qqQu S qqQu=..GetPar("X1196") S:$E(qqQu)="@" @("qqQu="_$E(qqQu,2,30000)) S:qqQu="" qqQu="Выбор"
 I '$G(Arg1) D ..MenuEx(9,,qqQu) Q:$Q "" Q
 D ..Question(qqQu,'Vo(qqnump,-1,73),"D qARM.TFormOnClose(0,6)","D qARM.TFormOnClose(0,4)",2) Q:$Q "" Q  ;;три кнопки (с Cancel)
 ;
sclo4 I Vo(qqnump,-1,72)="" G:$$sfu7(1)=41 sclo5 Q:$Q "" Q
 I ..GetPar(122)'="" I '$$sfu7(1,1) Q:$Q "" Q  ;@dol 4.1.04 добавлено действие по выходу
 ;обработка параметров выхода (новый вариант)
 D sclo50(qqnump)
 N qqnumpold,qqParent,qqcold,qqoold,viewf,ZTMPN,qqTFormOnClose S qqoold=$$$CurObj,qqcold=qqc,qqnumpold=qqnump
 S qqTFormOnClose=1 ;@Dol 10.03.06 флаг Идет закрытие
 S viewf=$$scloviewf() ;старый перечень релевантных
 I "564"[$P(Vo(qqnumpold,-1,72)," "),$E(qqc)'=" ",'$D(^Q(Vs(qqnump,"Relind")_qview)),$G(Vo(qqnump,-1,73))=2,'$G(Vs(qqnump,"EndTb")) D qW.gRel("+",$$$CurObj,qqc,$G(Vc(qqnump),"??")) ;при выборе - текущий экземпляр объекта поместить в релевантные (если он пуст) :@dol 25.02.03 Vo(qqnump,-1,73)=2 - если автоматический выбор;;Vs(qqnump,"EndTb")=Key<0 ;@Dol 2.03.06 Выход по кнопке нижнего тулбара
 S qqParent=$G(Vt(qqnump,"ZparentW")) G:qqParent="" sclo5 G:'$D(qwin("Q"_$P(qqParent," ",2))) sclo5 ;@dol 22.03.04 '$D(qwin
 D ..crst(1,$P(qqParent," ",2),2) ; в ..crst S qqo=$$$CurObj ;@Dol 27.12.07 восстановление qqo ;S qwin="Q"_qqnump D ..wM("Q"_qqnump,"SetFocus")
scloBeg I $P(Vo(qqnumpold,-1,72)," ")=0 D:$TR($P(Vo(qqnumpold,-1,72)," ",2,32000)," ")'="" ..Value($P(Vo(qqnumpold,-1,72)," ",2,32000),"X") S qqred="" Q:$Q "" Q  ;@dol 9.07.04 ??? S qqred="" ;;@dol 20.04.03 выполнение заданного действия
 I 'Vo(qqnumpold,-1,72) Q:$Q "" Q
 ;переустановка экземпляра
 I $P(Vo(qqnumpold,-1,72)," ")=1 D  Q:$Q "" Q
 .S qqc=qqcold S:$P(Vo(qqnumpold,-1,72)," ",2)'="" $$$CurObj=$P(Vo(qqnumpold,-1,72)," ",2)
 .I Vo(qqnumpold,-1,89) D  ;@dol 29.11.02 Возврат релевантных
 ..S $$$Relind=+$G(Vs(qqnumpold,"Relind")),$$$ReFind=+$G(Vs(qqnumpold,"ReFind"))
 .I $P(Vo(qqnumpold,-1,72)," ",3,1000)="" D ..wcre() Q
 .D ..Value($P(Vo(qqnumpold,-1,72)," ",3,1000),"X") ;выполнение заданного действия
 ;перенос значений
 I $P(Vo(qqnumpold,-1,72)," ")=2 D  Q:$Q "" Q
 .D
 ..N qqwvoz S qqwvoz=$G(qqw) N qqwlst,qqew,qqew1,qqew2,qqw,qqwold,qqoo,z,qqew3,qqew4 S qqwlst=$P(Vo(qqnumpold,-1,72)," ",2),(qqew2,qqew4)=""
 ..F qqew=1:1:$L(qqwlst,";") S qqew1=$P(qqwlst,";",qqew) I qqew1'="" D
 ...S qqw=$P(qqew1,",") S:qqw="" qqw=qqwvoz I " "_qqew2_" "'[(" "_qqw_" ") S qqew2=qqew2_" "_qqw S:"@Z"'[$E(qqw)&(qqw'[":") qqew4=qqew4_" "_qqw K W(qqw) ;@Dol 20.01.06 S:qqw="" qqw=qqwvoz
 ...Q:$G(W(qqw))'=""  S z="" F qqew3=2:1:$L(qqew1,",") D
 ....S qqwold=$P(qqew1,",",qqew3) S:qqwold="" qqwold=qqw
 ....S qqoo=qqoold I qqwold[":" S qqoo=$P(qqwold,":"),qqwold=$P(qqwold,":",2) S:qqwold="" qqwold=qqw
 ....S z=z_$S(z="":"",$E(z,$L(z))=" ":"",1:" ")_$$scloGGqqc()
 ....I "TY"[$E(qqw) K W(qqw) M W(qqw)=W(qqwold) ;@dol 5.04.04
 ...S:$TR(z," ")="" z=""
 ...S:"TY"'[$E(qqw) W(qqw)=z Q
 ..S:qqew4'="" qqwchg=qqwchg_" "_qqew4 D ..wwww($E(qqew2,2,3000),1)
 ..I $P(Vo(qqnumpold,-1,72)," ",3) D
 ...I '$G(W("ZBtred")) D ..Message("Не режим ввода") Q
 ...D ..RecCor(,,0) ;откорректировать без изменения даты времени
 .D:$P(Vo(qqnumpold,-1,72)," ",4,1000)'="" ..Value($P(Vo(qqnumpold,-1,72)," ",4,1000),"X") ;выполнение заданного действия
 .D:qqred'="" sclored(qqred)
 ;развертка при редактировании значения
 I $P(Vo(qqnumpold,-1,72)," ")=3 D  Q:$Q "" Q
 .D scloZZR
 .N qqwlst,qqew,qqew1,qqew2,qqwold,qqoo S qqwlst=$P(Vo(qqnumpold,-1,72)," ",2),qqew2="" I $G(W(qqw))'="",$E(W(qqw),$L(W(qqw)))'=" " K W(qqw) ;если последний не пробел
 .F qqew=1:1:$L(qqwlst,",") S qqwold=$P(qqwlst,",",qqew) D
 ..S qqoo=qqoold I qqwold[":" S qqoo=$P(qqwold,":"),qqwold=$P(qqwold,":",2) ;S:qqwold="" qqwold=qqw
 ..S W(qqw)=$S($G(W(qqw))="":"",1:W(qqw)_" ")_$$scloGGqqc()
 .D sclored(qqw,1)
 ;развертка с множественным выбором в релевантные
 I $P(Vo(qqnumpold,-1,72)," ")=4 D  Q:$Q "" Q
 .D scloZZR
 .;N list,qlist,qqew,qqew1,qqew2,qqwold,qqoo,sep S qqwold=$P(Vo(qqnumpold,-1,72)," ",2),sep=$P(Vo(qqnumpold,-1,72)," ",3) S:sep="" sep=" " S:$TR(sep,",")?1.N @("sep=$C("_sep_")") ;@dol 27.11.06 sep с кодами
 .N list,qlist,qqew,qqew1,qqew2,qqwold,qqoo,sep S qqwold=$P(Vo(qqnumpold,-1,72)," ",2),sep=$P(Vo(qqnumpold,-1,72)," ",3) S:sep="" sep=" " S:$TR(sep,",")?1.N @("sep=$C("_sep_")") S:sep'=" " sep=$S($L(sep)=1:" "_sep_" ",1:sep) ;@dol 27.11.06 sep с кодами; @Dol 26.10.09 " "_sep_" "
 .S qqoo=qqoold I qqwold[":" S qqoo=$P(qqwold,":"),qqwold=$P(qqwold,":",2),qqwold=$P(qqwold,",",1) S:qqwold="" qqwold=qqw
 .K W(qqw)
 .;S viewf=$$scloviewf() ;старый перечень релевантных ;старый перечень релевантных
 .I $E(qqcold)=" " K ^|Vt(qqnumpold,"Znsp")|Q(viewf) ;нажата F12 - выход с пустым выбором
 .I $D(^|Vt(qqnumpold,"Znsp")|Q(viewf,qqoo)) D scloZTMPN(qqoo) S qlist="" F  S qlist=$S('$D(ZTMPN(qqoo)):$O(^|Vt(qqnumpold,"Znsp")|Q(viewf,qqoo,qlist)),1:$$scloZord(qqoo)) Q:qlist=""  S list=$S('$D(list):"",1:list_sep)_$$scloGG(qqoo,qqwold,qlist)
 .S W(qqw)=$G(list)
 .;S:" "_qqwchg_" "'[(" "_qqw_" ") qqwchg=qqwchg_" "_qqw D ..wwww(qqw)
 .D sclored(qqw,1)
 ;множественный иерархический выбор с сохранением релевантных (6 - только последний уровень выбора)
 ;    qqw,qqo:qqwold,...;qqw,
 I $P(Vo(qqnumpold,-1,72)," ")=5!($P(Vo(qqnumpold,-1,72)," ")=6) D  Q:$Q "" Q
 .D
 ..N c1,c2,qqwlst,qqew,qqew1,qqew2,qqwold,qqoo,list,qlist,qqw,qqwlst1 S qqwlst1="",qqwlst=$P(Vo(qqnumpold,-1,72)," ",2),qqew2=""
 ..I $E(qqcold)=" " K ^|Vt(qqnumpold,"Znsp")|Q(viewf) ;нажата F12 - выход с пустым выбором
 ..I qqwlst'="" F qqew=1:1:$L(qqwlst,";") S qqwold=$P(qqwlst,";",qqew) D:qqwold'=""
 ...S qqw=$P(qqwold,",") S:qqw[":" qqw=$P(qqw,":",2) S:qqw="" qqw=qqred S qqwold=$P(qqwold,",",2,1000) I " "_qqwlst1_" "'[(" "_qqw_" ") K W(qqw),list S qqwlst1=qqwlst1_" "_qqw ;@dol 12.04.02 ;qqwlist1 используется для корректного выбора по нескольким отличающимся ветвям
 ...D scloZTMPN($P(qqwold,":")) I $$scloi(qqwold,"",$P(Vo(qqnumpold,-1,72)," ")=6)
 ...S W(qqw)=$G(list)
 ...I qqw'="ZfI9" S:" "_qqwchg_" "'[(" "_qqw_" ") qqwchg=qqwchg_" "_qqw D ..wwww(qqw,1) ;qqw'="ZfI9" - не поисковый образ
 .D:qqred'="" sclored(qqred) ;если вызов в качестве развертки
 .I $P(Vo(qqnumpold,-1,72)," ",3)'["N" K W("Y"_Vo(qqnumpold)) M W("Y"_Vo(qqnumpold))=^|Vt(qqnumpold,"Znsp")|Q(viewf) I $G(W("ZBtred"))," "_qqwchg_" "'[(" "_"Y"_Vo(qqnumpold)_" ") S qqwchg=qqwchg_" "_"Y"_Vo(qqnumpold) ;сохраним образ перечня релевантных
 .I $P(Vo(qqnumpold,-1,72)," ",3) D
 ..I '$G(W("ZBtred")) D ..Message("Не режим ввода") Q
 ..D ..RecCor(,,0) ;откорректировать без изменения даты времени
 .D:$P(Vo(qqnumpold,-1,72)," ",4,1000)'="" ..Value($P(Vo(qqnumpold,-1,72)," ",4,1000),"X") ;выполнение заданного действия
 ;множественный иерархический выбор с сохранением релевантных и порождением потомков(8 - только последний уровень выбора)
 ;    qqonew:qqw,qqo:qqwold,...;qqw,
 I $P(Vo(qqnumpold,-1,72)," ")>6,$P(Vo(qqnumpold,-1,72)," ")<11 D  Q:$Q "" Q  ;78910 (9,10 - всегда добавление)
 .N c1,c2,qqwlst,qqew,qqew1,qqew2,qqwold,qqoo,qvief,list,qlist,qqw,qqwlst1,qqonew,qqcnext S qqwlst1="",qqwlst=$P(Vo(qqnumpold,-1,72)," ",2),qqew2=""
 .S qqonew=$P(qqwlst,":",1),qqwlst=$P(qqwlst,":",2,255) ;,qqcnext=qqc
 .S:qqonew="*" qqonew=qSYS.Chiqqw($$$CurObj,$P(qqwlst,","))
 .D:$P(Vo(qqnumpold,-1,72)," ")<9  ;удалим потомков
 ..S c1="" F  S c1=$$$UserOrd(1,qqonew,c1,qqc) Q:c1=""  D:$D(^Q(1,qqonew,c1,"Yo"))>1 qW.rDel(qqonew,c1)
 .S qqcnext=$$$UserOrd(-1,qqonew,"",qqc) S:qqcnext="" qqcnext=qqc ;@dol 20.11.03
 .I $E(qqcold)=" " K ^|Vt(qqnumpold,"Znsp")|Q(viewf) ;Q  ;нажата F12 - выход с пустым выбором
 .I qqwlst'="",$E(qqcold)'=" " F qqew=1:1:$L(qqwlst,";") S qqwold=$P(qqwlst,";",qqew) D:$TR(qqwold," ")'=""
 ..S qqw=$P(qqwold,",") S:qqw[":" qqw=$P(qqw,":",2) S qqwold=$P(qqwold,",",2,1000) ;I " "_qqwlst1_" "'[(" "_qqw_" ") K W(qqw),list S qqwlst1=qqwlst1_" "_qqw ;@dol 12.04.02 ;qqwlist1 используется для корректного выбора по нескольким отличающимся ветвям
 ..I $$scloi(qqwold,"",$P(Vo(qqnumpold,-1,72)," ")=8!($P(Vo(qqnumpold,-1,72)," ")=10),1,,$P(Vo(qqnumpold,-1,72)," ")>8,1)
 .S qqred="" ;@dol 1.03.04 !!!!!!!!!!
 .D qW.rCor($$$CurObj,qqc,"Z",,2) ;@dol 30.10.03 чтобы записалась дата коррекции
 .D:$G(qqtime)'=""   ;@Dol 29.06.04 изменения в Vc для синонимов
 ..N qqci,qqo S qqci="",qqo=$S($E($$$CurObj)="v":$E($$$CurObj,3,255),1:$$$CurObj) F  S qqci=$O(Vc(qqnump,qqci)) Q:qqci=""  I $S(Vc(qqnump,qqci,0)=$$$CurObj:0,$E(Vc(qqnump,qqci,0))'="v":Vc(qqnump,qqci,0)=qqo,1:$E(Vc(qqnump,qqci,0),3,255)=qqo) I Vc(qqnump,qqci)=qqc S Vc(qqnump,qqci,5)=qqtime
 .D ..wqqotree(,,,$D(^Q(viewf))>1) ;$D(W("Yo")))
 .D:$P(Vo(qqnumpold,-1,72)," ",4,1000)'="" ..Value($P(Vo(qqnumpold,-1,72)," ",4,1000),"X") ;выполнение заданного действия
 Q:$Q "" Q
scloZZR
 I $E(qqw,1,3)="ZZR",qqw'="ZZR" S qqw=$E(qqw,4,30),W("Zpos",2,"x")=$G(W("Zpos",2,"x"))+1 S:qqred'="" qqred=qqw
 I qqw="ZZR" S qqw=$S($P(W("Zldrl")," ")'="":$P(W("Zldrl")," "),1:qqw) S:qqred'="" qqred=qqw
 Q  ;????D
sclored(qqwred,wwww)
 I qqred'="",$E(qqred,1,4)="ZMAS" D ..SetZMAS($$$CurObj,,qqw,W(qqwred)) ;S @Vt(qqnump,"mas",$$$CurObj,qqw)=W(qqwred) ;@Dol 28.03.06
 ///@sas 20100121 закомментирован вызов qARM.wwww. Т.к. при выборе из развертки-редактирование, 
 ///при нажатии клавиши ESC в редактируемой ячейке, на экране оставалось значение выбранное в развертке  
 I qqred'="",qqred'="ZfI9",$P(W("Zcdrl")," ",2)'=1 S $P(W("Zcdrl")," ",2)=0 D:0 ..wwww(qqwred) S www=$P($G(Vs(qqnumpold,"CondFind"))," ",5),www=$S(www="":"",$E($G(W(qqwred)),1,$L(www))=www:$L(www),1:"") D ..wfoc(2,,W("Zpos",2,"x"),W("Zpos",2,"d"),www) Q  ;$G(W("Zpos",2,"y") ???? очень сомнительное место ;@dol 8.12.02 qqred=Z9 - для формирования условий поискового образа
 //было так I qqred'="",qqred'="ZfI9",$P(W("Zcdrl")," ",2)'=1 S $P(W("Zcdrl")," ",2)=0 D:$G(wwww) ..wwww(qqwred) S www=$P($G(Vs(qqnumpold,"CondFind"))," ",5),www=$S(www="":"",$E($G(W(qqwred)),1,$L(www))=www:$L(www),1:"") D ..wfoc(2,,W("Zpos",2,"x"),W("Zpos",2,"d"),www) Q  ;$G(W("Zpos",2,"y") ???? очень сомнительное место ;@dol 8.12.02 qqred=Z9 - для формирования условий поискового образа
 I qqred'="" D ..EndEdit($G(W(qqwred)),0) ;если вызов в качестве развертки
 Q
 ;вроде необязательно ;I qqred'="" D ..Wait("D qARM.EndEdit("""_$G(W(qqwred))_""",0)") ;@Dol 19/06/06 без Wait нет позиционирования на следующую ячейку
scloi(qqwlst,qqc0,last,one,qqopre,noYo,wrt)
 Q:qqwlst="" 1 N qii,qqoo,qqwold,cr,qlist,qlistz,qlisti,qlistzz,qqvir,lastlev S qqoo=$P(qqwlst,","),qqwold=$P(qqoo,":",2),qqoo=$P(qqoo,":",1),cr=$P(qqwlst,",",2),qqwlst=$P(qqwlst,",",3,1000) S:cr="" cr=32
 I $G(one) K list,W("Yo") D scloZTMPN(qqoo)
 S qqvir=$S($G(qqopre)="":0,1:$D(^|Vt(qqnumpold,"Znsp")|Q(viewf,qqopre,qqc0,qqoo))) ;если перечень для виртуальных
 S qlist=$S(qqvir:"",1:qqc0) F qii=0:1 S qlist=$S('$D(ZTMPN(qqoo)):$S('qqvir:$O(^|Vt(qqnumpold,"Znsp")|Q(viewf,qqoo,qlist)),1:$O(^|Vt(qqnumpold,"Znsp")|Q(viewf,qqopre,qqc0,qqoo,qlist))),1:$$scloZord(qqoo)) Q:qlist=""  Q:$S(qqc0="":0,qqvir:0,1:$E(qlist,1,$L(qqc0))'=qqc0)  D:'last  S lastlev=$$scloi(qqwlst,qlist,last,,qqoo,$G(noYo),$G(wrt)) D:lastlev&last  I $G(wrt),$S('last:$G(one),1:lastlev) S c2=$S(qqew'=1:c1(qqoo,qlist),1:$P(qW.rNew(qqonew,qqcnext,2)," ")),c1(qqoo,qlist)=c2 S:qqew=1 qqcnext=c2 S list=$S($G(list)="":"",":,;"[$E(list,$L(list)):$E(list,1,$L(list)-1),1:list) S W(qqw)=list D qW.rCor(qqonew,c2,qqw_$S($G(noYo):"",1:" Yo")) K list,W("Yo") ;???@dol 5.12.03 Было c1(qii) и S c2(qii)=c2 D qW.rCor(;;@dol 17.05.04 qW.rNew(qqonew,qqcnext,5)
 .I qqvir,$G(qqopre)'="" S Vs(qqnumpold,"Virt",qqopre)=qqc0 ;@Dol 20.09.06 !!!! восстановление Virt но только на один уровень вверх
 .;S qlistz="" I qqwold'="" F qlisti=1:1:$L(qqwold,"~") S qlistzz=$S($E($P(qqwold,"~",qlisti),1,4)'="ZTMP":qW.GG(qqoo,$P(qqwold,"~",qlisti),qlist),1:$G(^Q(viewf,qqoo,qlist,$P(qqwold,"~",qlisti)))) S:qlistzz'="" qlistz=$S(qlistz="":"",1:qlistz_" ")_qlistzz
 .S qlistz="" I qqwold'="" F qlisti=1:1:$L(qqwold,"~") S qlistzz=$$scloGG(qqoo,$P(qqwold,"~",qlisti),qlist) D:qlistzz'=""
 ..I qlistzz=":",qlistz="" Q  ;убрать ненужное (первое) двоеточие
 ..I $E(qlistzz)="<",$E(qlistzz,$L(qlistzz))=">" Q  ;убрать комментарий ( <...> ) ??? кто-то нарвется
 ..S qlistz=$S(qlistz="":"",1:qlistz_" ")_qlistzz
 .S list=$S('$D(list):"",1:list_$S('qii:" ",cr=33:"!!",cr=13:" "_$C(13,10)_" ",cr=32:" ",1:" "_$C(cr)_" "))_qlistz  ;@dol 8.12.02 cr=33:"!!" - для формирования условий поискового образа
 .I $S('last:$G(one),1:lastlev)||$D(W("Yo")) M W("Yo",qqoo,qlist)=^|Vt(qqnumpold,"Znsp")|Q(viewf,qqoo,qlist) K W("Yo",qqoo,qlist,"ZTMPN") ;S W("Yo",qqoo,qlist)=""
 Q 'qii
scloviewf() Q Vs(qqnumpold,"Relind")_Vo(qqnumpold)_$S($P(qview," ",2)="":"",1:" "_$P(qview," ",2)) ;старый перечень релевантных
scloGG(qqo,qqw,qqc) Q:$E(qqw)="Z" $S($E(qqw,1,4)'="ZTMP":$G(WS(qqnumpold,qqw)),1:$G(^|Vt(qqnumpold,"Znsp")|Q(viewf,qqo,qqc,qqw)))
 I Vt(qqnumpold,"Znsp")=Vt(qqnump,"Znsp") N qqnump S qqnump=qqnumpold Q:qqw'["(" qW.GG(qqo,qqw,qqc) Q @qqw ;@Dol 23/04.05 - @qqw - выражения возврата
 ZN Vt(qqnumpold,"Znsp") X "S qUSER=##class(qUSER).%New()"
 D qSYS.BaseIni() ;смена NameSpace
 D
 .N qqnump S qqnump=qqnumpold
 .S qqw=qW.GG(qqo,qqw,qqc)
 ZN Vt(qqnump,"Znsp") X "S qUSER=##class(qUSER).%New()"
 D qSYS.BaseIni() ;смена NameSpace
 Q qqw
scloGGqqc() ;взять значение с учетом виртуальных
 Q:qqoo="" "" ;@Dol 25.10.04 для выхода из пустой развертки
 Q:qqcold[" " "" ;@Dol 23.01.07 сброс
 I qqoo=qqoold Q $$scloGG(qqoo,qqwold,qqcold) 
 I ","_$G(Vo(qqnumpold,qqoold,5))_","[(","_qqoo_",") N qqi,qqq D  Q:$G(qqq)'="" $$scloGG(qqoo,qqwold,qqq)
 .F qqi=$L(Vc(qqnumpold))-2:-2:2 I Vc(qqnumpold,$E(Vc(qqnumpold),1,qqi),0)=qqoo S qqq=Vc(qqnumpold,$E(Vc(qqnumpold),1,qqi))
 I $G(Vo(qqnumpold,qqoo,2))>1||($G(Vo(qqnumpold,qqoold,2))>1) Q ""
 Q $$scloGG(qqoo,qqwold,$E(qqcold,1,$S($G(Vo(qqnumpold,qqoo,0))'="":Vo(qqnumpold,qqoo,0),1:$$$ObjLget(qqoo)))) ;@Dol 17.10.06 $$$ObjLget если из другого объекта (только выше), длину кода нужно урезать
scloZTMPN(qObj) ;сортировка по ZTMPN
 Q:'$D(^|Vt(qqnumpold,"Znsp")|Q(viewf,"ZTMPNcount",qObj))
 I $D(ZTMPN(qObj)) S ZTMPN(qObj)="" ;уже отсортирован
 N qqcc S qqcc="" F  S qqcc=$O(^|Vt(qqnumpold,"Znsp")|Q(viewf,qObj,qqcc)) Q:qqcc=""  D
 .S:'$D(^|Vt(qqnumpold,"Znsp")|Q(viewf,qObj,qqcc,"ZTMPN")) ^|Vt(qqnumpold,"Znsp")|Q(viewf,qObj,qqcc,"ZTMPN")=$I(^|Vt(qqnumpold,"Znsp")|Q(viewf,"ZTMPNcount",qObj)) ;если нет 
 .S ZTMPN(qObj,^|Vt(qqnumpold,"Znsp")|Q(viewf,qObj,qqcc,"ZTMPN"))=qqcc
 S ZTMPN(qObj)=""
 Q
scloZord(qObj)  S ZTMPN(qObj)=$O(ZTMPN(qObj,ZTMPN(qObj))) Q $S(ZTMPN(qObj)="":"",1:ZTMPN(qObj,ZTMPN(qObj))) ;следующий упорядоченный
 ;выход по невыбору
sclo6 D ..GetPar("X1722") ;@Dol 15.03.06 действие по невыбору
 I Vo(qqnump,-1,72)<2,Vo(qqnump,-1,722)="" G sclo5
 D sclo50(qqnump)
 N qqnumpold,qqParent,qqcold,qqoold S qqoold=$$$CurObj,qqcold=qqc,qqnumpold=qqnump
 S qqParent=$G(Vt(qqnump,"Zparent")) G:qqParent="" sclo5 S:$P(qqParent," ",2)="Q" qqParent=$G(Vt("Q","Zparent"))
 D ..crst("",$P(qqParent," ",2)) S qwin="Q"_qqnump D ..wM("Q"_qqnump,"SetFocus")
 X:Vo(qqnumpold,-1,722)'="" Vo(qqnumpold,-1,722) ;@Dol 15.03.06 действие по невыбору
 I $P(Vo(qqnumpold,-1,72)," ")=3,$P($G(Vs(qqnumpold,"CondFind"))," ",5)'="" S W(qqw)=$P(Vs(qqnumpold,"CondFind")," ",5) D ..wwww(qqw)
 I qqred'="",$P(W("Zcdrl")," ",2)'=1 S $P(W("Zcdrl")," ",2)=0 D   Q:$Q "" Q  ;$G(W("Zpos",2,"y")) ????очень сомнительное место 
 .I qqred'="ZfI9" D ..wfoc(2,,W("Zpos",2,"x"),W("Zpos",2,"d")) Q
 .D ..wfoc(1,,W("Zpos",1,"x"),W("Zpos",1,"d")) ;@Dol 27.02.05 - поисковый образ
 S qqred="" Q:$Q "" Q
 ;
sclo5 D sclo50(qqnump) I '$G(qqLastWin),qqnump'=0,$D(qwin("Q0")) S (qwin,qqnump)="" K W Q:$Q "" Q
 I $G(qqLastWin),$E($O(qwin("Q")))="Q" S (qwin,qqnump)="" K W Q:$Q "" Q  ;@dol 27.05.04 qqLastWin=1 - закрыть приложение по закрытию его последнего окна
 ;действие выполняемое при закрытии qARM.exe sasha 20080526
 X $G(^Q(1,"XBase",0,"XMCrUserEND"))
 ;закрытие последней экранной формы
 F %1=1:1:99,"R" I $D(qwin("Q"_%1)) D sclo50(%1) ;@Dol 21.07.09 49->99
 S %1="ZRes" F  S %1=$O(qwin(%1)) Q:$E(%1,1,4)'="ZRes"  d:qwin(%1) ..wM(%1_".vg1","0DelObj",0) D ..wM(%1,"Destroy")
 D:$D(qwin("MesForm")) ..wM("MesForm","Destroy")
 D ..wM("-qARM","Terminate")
 ;@Sveta 18.03.03 запись в журнал регистрации
 D ..CloseLog()
 ;@ank 13.08.09 повторная проверка при выходе, запись в журнал
 D ..CloseLogANK()
 Q:$Q "" Q
 ;
sclo50(qqnump)  D:$D(qwin("Q"_qqnump,"Timer")) ..wM("Q"_qqnump_".Timer","Destroy")
 D:$D(qwin("Q"_qqnump,"OleD",1)) ..wM(qwin_".T1","VolOleDragDropDisable")
 D:$D(qwin("Q"_qqnump,"OleD",2)) ..wM(qwin_".T2","VolOleDragDropDisable")
 I $D(qwin("Q"_qqnump,"child"))  K qwin("Q"_qwin("Q"_qqnump,"child"),"parent",qqnump) ;@Dol 24.06.05
 I $D(qwin("Q"_qqnump,"parent")) N qpp S qpp="" F  S qpp=$O(qwin("Q"_qqnump,"parent",qpp)) Q:qpp=""  D sclo50(qpp) ;@Dol 24.06.05
 D ..wM("Q"_qqnump,"Free") K qwin("Q"_qqnump) Q  ; @dima 20100714 Destroy->Free
 ;
sfu7(qqpar1,qqpar2) ; выполнение действия по выходу (0-????)
 ;;K W("Zdomod"),Vo(qqnump,-1,73) ;???
 I $G(qqpar2) N qqend D ..Value(..GetPar(122),"X") Q $S('$D(qqend):41,qqend:41,1:"") ;@dol 4.01.04
 K qqParent I $TR($G(Vt(qqnump,"Zparent"))," ")'="" S qqParent=Vt(qqnump,"Zparent") ;форма-родитель??? ZparentW
 N qqend D ..Value(..GetPar(122),"X")
 I '$D(qqend),$D(qqParent) S:$P(qqParent," ",3)'="" W($P(qqParent," ",3))=qqp4 D ..WrWin($P(qqParent," ",2),0,$P(qqParent," ",3)) Q 41
 Q $S('$D(qqend):41,qqend:41,1:"")
]]></Implementation>
</Method>

<Method name="TMenuItemOnClick">
<Description>
Отработка выборов меню.</Description>
<Internal/>
<FormalSpec>Sender:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 I $P(Sender,".")'=("Q"_$G(qqnump))!$G(W("ZredB")),..ChgWin(1) Q "" ;Обработка смены окна (смена локальной среды)
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 i $E($P(Sender,".",2),1,6)="m9User" g m9User
 ;;D ..Message(Sender_" 2="_$G(qqnump)) ;q ""
 N qqchoice S qqchoice=$P($P(Sender,".",2,255),"M",2,255) ;S ^SSS=Sender
 I $G(W("ZBt0")),qqchoice'?1.2N1"w".E,qqchoice'?1N1"u".E,$E(qqchoice)'=9,$P($TR(qqchoice,"_","p"),"p")'=10 D ..Message("Заблокировано.Редактируется отображение") Q ""
 ;
 ;D qARM.Message(qqchoice_" qqw="_$G(qqw)_" qqred="_$G(qqred))
 I qqchoice?1N1"u".E D  Q "" ;Меню пользовательской панели инструментов
 .I W("ZBtred"),..EndOP(1) Q  ;@Dol 2.08.04 - не бывает ???;;;незавершенное редактирование ячейки
 .N qqch,qqchi S qqch=$P(qqchoice,"_")
 .N Ref S Ref=$S(($D(Vs(qqnump,"XMenu"))'=0):$NA(Vs(qqnump,"XMenu")),1:$NA(^Q(1,"XView",Vo(qqnump),"XMenu"))) ; tdv 16.02.2004: Ref - вставка для динамического меню
 .S qqch=$NA(@Ref@(+qqch,"XMenu1",$P(qqch,"u",2)))
 .F qqchi=2:1:$L(qqchoice,"_") S qqch=$NA(@qqch@("XMenu"_qqchi,$P(qqchoice,"_",qqchi)))
 .D ..Value($G(@qqch@("XMenuDo")),"X")
 I qqchoice?1.2N1"w".E D  Q "" ;развертка-словарь
 .I qqred="",$G(qqredS,"?")=$G(qqw,"??") S qqred=qqw ;@Dol 21.05.06 Меню вызвано через StartEdit; $G(? ??
 .I qqchoice?1.2N1"wXU".E,qqred'="" S qqred="" ;@Dol 2.08.04 - не бывает;22.05.07 стояло выше - не работало главное меню после StartEdit
 .I qqred=""  D  Q  ;@dol 16.06.03 для ссылочного меню кнопок панели
 ..I $G(qxecuteMeNu)'="" N qxecuteMeNuDO S qxecuteMeNuDO=qxecuteMeNu K qxecuteMeNu d ..wP("-qARM","Cursor",-11) D ..Value(qxecuteMeNuDO,"X") Q  ;@dol 18.06.03 qxecuteMeNu-чтобы обезопасится ;меню-словарь
 ..Q:..EndOP()
 ..N qqoM,qqcM,qqzM,qqwM S qqwM="XU"_$S(qqchoice["wXU":$E($P(qqchoice,"wXU",2)),1:$P(qqchoice,"w",2,255)) ;;;если больше одной цифры?
 ..I '$D(qwin(qwin,qqwM)) S:qqchoice["wXU" qqwM="XU"_$P(qqchoice,"wXU",2) F  S qqwM=$E(qqwM,1,$L(qqwM)-1) Q:qqwM=""  Q:$D(qwin(qwin,qqwM))  ;S:'$D(qwin(qwin,qqwM)) qqwM=$E(qqwM,1,$L(qqwM)-1) ;@Dol 20.09.05 для кнопок панели с привязкой к меню. См. метод wwwwFCBUT
 ..I qqwM="" D qARM.Message("Для "_qqchoice_" нет описания в qwin("_qwin_")") Q  ;@Dol 31.03.06 и цикл в предыдущей строке
 ..I $E(qqwM,3)="Z" S qqchoice=$P(qqchoice,$S(qqchoice["wXU":qqwM,1:$E(qqwM,3,255)),2),Z=$G(qwin(qwin,qqwM,qqchoice)) D  Q  ;@Dol 29ю01ю06 Для меню на Z*-понятиях выполнение правила проверки
 ...S qqoM=..GetPar("X74",,$$$CurObj,$E(qqwM,3,255)) I qqoM="" D ..Message("Нет действия (правила проверки) для меню "_$E(qqwM,3,255)_" qqo="_qqo_" "_$G(Vo(qqnump))) Q
 ...I @qqoM
 ..S qqoM=$G(qwin(qwin,qqwM,qqchoice,1)),qqcM=$P(qqoM," ",2),qqoM=$P(qqoM," ",1)
 ..D TMenuIM I qqzM'="" D ..Value(qqzM,"X") Q  ;@Dol 25.02.11
 ..D ..Message("Нет действия для меню "_qqchoice_" (qqoM="_qqoM_" qqcM="_qqcM_")") Q
 .;I $E(qqchoice),+W("Zcdrl")=12,$G(qwin(qwin,qqred,$E(qqchoice,$L(qqred)+3,255)))="@@@" S $P(W("Zcdrl")," ",2)=0 D:$P(W("Zcdrl")," ",3) ..wwww(qqred) D ..wfoc(2,"",W("Zpos",2,"x"),W("Zpos",2,"d")) Q  ;вход в редактирование  
 .N sep,end,qqredo S qqredo=$TR($S($E(qqred)'="@":qqred,1:"o"_$E(qqred,2,255)),"_") S:qqredo[":" qqredo=$P($P(qqredo,":",2),"{") S sep=$E($P(W("Zldrl"),"/",2)) S:sep="" sep=" " D  I $G(end)||($P(W("Zcdrl")," ",2)'=1) Q:$P($G(W("Zdrl"))," ",14)&&(+W("Zcdrl")'=12)||($G(end)=2)  S $P(W("Zcdrl")," ",2)=0 D ..wM(qwin_".T2","SetFocus") D:0 ..EndEdit(W(qqred),13,1,1) D:$P(W("Zcdrl")," ",3)||('$G(end)) qARM.wwww(qqred) D qARM.wfoc(2,"",W("Zpos",2,"x"),W("Zpos",2,"d")) Q  ;вход в редактирование  @dol 01.09.03 qqredo;@Dol 15.04.07 добавлено ||($P(W("Zcdrl")," ",2)'=1) - иначе терялся вход в редактирование;@Dol 25.09.08 +W("Zcdrl")'=12 -множ.выб.
 ..I '$E(qqchoice) S W(qqred)="" Q  ;сброс
 ..I $P(W("Zdrl")," ",14) S Z=$G(W(qqred))
 ..I W("Zldrl")["~" D  Q
 ...I +W("Zcdrl")=12||$P(W("Zdrl")," ",14),$G(qwin(qwin,qqredo,$E(qqchoice,$L(qqred)+3,255)))="@@@" S end=1 Q  ;@Dol 24.03.06 Не работало Иное... для меню-редактирования
 ...S W(qqred)=$P(W("Zldrl"),"~",$E(qqchoice,$L(qqred)+3,255)+1) Q
 ..I $P(W("Zdrl")," ",14) S Z=$G(W(qqred))
 ..I '$P(W("Zcdrl")," ",3)!(+W("Zcdrl")=12) N qqw S qqw=$P(W("Zldrl")," ") S:qqw="" qqw=qqred D  Q
 ...I $P(W("Zdrl")," ")[":" D  Q
 ....I $G(qwin(qwin,qqredo,qqchoice))="@@@" S end=1 Q
 ....I $P(W("Zdrl")," ",17) N qqoM,qqcM,qqzM S qqoM=$G(qwin(qwin,qqredo,qqchoice,1)),qqcM=$P(qqoM," ",2),qqoM=$P(qqoM," ",1),qqw=qqred,qqred="" D  S end=2 Q
 .....D TMenuIM I qqzM'="" D ..Value(qqzM,"X") Q  ;@Dol 25.02.11
 .....S qqzM=..GetPar("X74",,qqo,qqw) I qqzM="" D ..Message("Нет Действия для меню qqoM="_qqoM_" qqcM="_qqcM) Q
 .....I ..Value(qqzM)
 ....N i,qq S qq="" F i=1:1:$L(qqchoice,"_") S qq=qq_" "_$G(qwin(qwin,qqredo,$P(qqchoice,"_",1,i)))
 ....S W(qqred)=$E(qq,2,30000) Q
 ...I +W("Zcdrl")=12!$P(W("Zdrl")," ",14),$G(qwin(qwin,qqredo,$E(qqchoice,$L($TR(qqw,"_"))+3,255)))="@@@" S end=1 Q
 ...I '$P(W("Zcdrl")," ",3) D  Q
 ....I '$P(W("Zdrl")," ",17) S W(qqred)=$S($E(qqw)="Z":$G(W(qqw,$G(qwin(qwin,qqredo,$E(qqchoice,$L($TR(qqw,"_"))+3,255))))),1:qW.GetWoc("C"_qqw,$G(qwin(qwin,qqredo,$E(qqchoice,$L($TR(qqw,"_"))+3,255))))) Q
 ....S Z=$S($E(qqw)="Z":$G(W(qqw,$G(qwin(qwin,qqredo,$E(qqchoice,$L($TR(qqw,"_"))+3,255))))),1:qW.GetWoc("C"_qqw,$G(qwin(qwin,qqredo,$E(qqchoice,$L(qqw)+3,255)))))
 ....N qqzM S qqw=qqred,qqzM=..GetPar("X74",,qqo,qqw),end=2,qqred="" I qqzM="" D ..Message("Нет действия для меню") Q
 ....I ..Value(qqzM)
 ...S W(qqred)=$G(qwin(qwin,qqredo,$E(qqchoice,$L($TR(qqw,"_"))+3,255))) Q
 ..S $P(W(qqred),sep,$P(qqchoice,"w"))=$TR($P(qqchoice,"_",2,10),"m","-")
 .I $P(W("Zdrl")," ",14) S qqw=qqred D  Q:..s112()  Q  ;,..wM(qwin_"."_qqred,"Popup") Q  ;..MenuWoc(qqred,W("Zldrl"),W(qqred)) Q  ;меню-добавление в соседнюю ячейку 
 ..I $P(W("Zdrl")," ",14),$E(qqw,1,3)'="ZZR" N qqw S qqw="ZZR"_qqred,W(qqw)=W(qqred),W(qqred)=Z N qqred S qqred=qqw
 ..D ..OnCEClick(1,W(qqred))
 .D ..wM(qwin_".T2","SetFocus"),..EndEdit($TR(W(qqred),$C(9)," "),13,,1) ; @Dol 19.07.09 $TR(,$C(9)
 .;I $L(W("Zldrl")," ")>1 S qqred=qqw D ..MenuWoc(qqw,W("Zldrl"),$G(W(qqw)))
 I $E(qqchoice)=9,$L($P(qqchoice,"_"))<3 S qqchoice=qSYS.TMenuObj(qqchoice) Q "" ;ред. дерева объектов
 I $E(qqchoice)=6!($E(qqchoice,1,3)'=777&($E(qqchoice)=7)) S qqchoice=qSYS.TMenuServ(qqchoice) Q "" ;меню сервиса
 I W("ZBtred"),..EndOP() Q ""
 ;
 G m1p1:$E(qqchoice,1,4)="100_",m1p2p:$E(qqchoice,1,4)="200_",m1p3:$E(qqchoice,1,4)="300_",m777:$E(qqchoice,1,4)="777_",m888:$E(qqchoice,1,4)="888_",m50:$P(qqchoice,"_")="50",@("m"_$TR(qqchoice,"_","p"))
 ;
TMenuIM S qqzM=$S(qqoM'["(":qW.GG(qqoM,"XMenuDo",qqcM),1:$G(@qqoM@(qqcM,"XMenuDo"))) S:qqzM="" qqzM=$S(qqoM="query":"D qWEB.Query(""query:"_qqcM_""")",qqoM["("&&(qqoM?1"Vs(".e1"Tabs".e):"D qARM.OnTabChange("_$E($P(qqoM,","),4,255)_"_""."_$E(qqoM,$L(qqoM)-1)_""",qqcM)",1:"") Q  ;25.02.11 возможно использование массива Vs(qqnump,"Tabs" в качестве меню действий 
 ;Вызов
m1p2p   D ..SaveView(1)
 S qqchoice=qwin(qwin,"o",1,$P(qqchoice,"_",2))
 I $E(qqchoice,4,255)'["qq" D ..OpenWindow("","","",..VerCall(qqchoice),"",qqchoice) Q ""
 D ..Wait("D qWEB.Query("""_qqchoice_""")") Q ""
m1p1 ;XML-браузер
 d ..wP("-qARM","Cursor",-11)
 D ..SaveView(1,"",$P(qview," "))
 S %1=qWEB.OpenPrint(qview,1,"","","",$P(qview," "),$J) I %1'="" D ..Message(%1) Q ""
 D qWEB.Browser($P(qqchoice,"_",2))
 Q ""
m1p3 ;печать
 S qqchoice=qwin(qwin,"o",2,$P(qqchoice,"_",2))
 I $E(qqchoice,4,255)'["qq" D ..Print(qqchoice) Q ""
 D ..Wait("D qWEB.Query("""_qqchoice_""")") Q ""
m777 ;Запросы
 I $P(qqchoice,"_",2)="" D ..MenuQ() Q "" ;@dol 11.1.04
 I $P(qqchoice,"_",2)=0 D  Q "" ;новый запрос (сохранение состояния)
 .N qqcq,qoq  S qoq=$D(Vo(qqnump,"XQuery")),(Vo(qqnump,"XQuery",37),Vo(qqnump,"XQuery",36))=Vo(qqnump)_"qq"
 .S qqcq=$P(qW.rNew("XQuery",Vo(qqnump)_"qqA")," ") K:'qoq Vo(qqnump,"XQuery")
 .D ..SaveView(,$NA(^Q(1,"XQuery",qqcq)))
 .S ^Q(1,"XQuery",qqcq,"XQName")="Запрос_"_$E(qqcq,$L(Vo(qqnump))+3,255)
 .I $G(W("Zar"))'="" S ^Q(1,"XQuery",qqcq,"XQanalView")=W("Zar")
 .S Vo("par",-1,23)="S W(""Zdomod"")=2" ;действие по входу
 .S Vo("par",-1,22)="D qARM.WrWin("""",0,"""",""qARM.MenuView(,-2)"") S qqend=1" ;действие после выхода
 .D ..OpenWindow(,,,qqcq_" XQuery 1",,"XXXXQueryc")
 ;выбор запроса
 ;D ..ResetSrt()
 D ..Wait("D qWEB.Query("""_qwin(qwin,"o",7,$P(qqchoice,"_",2))_""")") Q ""
 ;Действия
m888 D ..Value(..GetPar(21,,,$P(qqchoice,"_",2)),"X") Q ""
m034 D ..wM(qwin,"EvClose") Q ""
m035 D ..OpenDHelp("2,0") Q ""
 ;Настройки
m50     ;язык
 S qqchoice=$P(qqchoice,"_",2) Q:qqchoice="" ""
 D ..wcrm("50_"_qqlang,1,"",","_0) S qqlang=qqchoice D ..wipa(),..wcro(),..wcre(),..wcrm("50_"_qqlang,1,"",","_1) Q ""
 ; @Dol 10.10.04 OLE Drag&Drop
m51 Q "" ;@Dol 12.05.07 изяет - ест копировать/востановить в буфер ;S Vs(qqnump,99,"OLEDD")='$G(Vs(qqnump,99,"OLEDD")) D ..wcrm("P551",1,"",","_(+$G(Vs(qqnump,99,"OLEDD")))) Q "" ;,..OnOLEDragDrop(,Vs(qqnump,99,"OLEDD")*3) Q ""
 ; Кол-во_экземпляров в дереве;;;;;;
m52p1   
m52p20  
m52p40  
m52p80  
 F i=1,20,40,80 D ..wcrm("52_"_i,1,"",",0")
 S Vo(qqnump,-1,60)=$P(qqchoice,"_",$L(qqchoice,"_")) D ..wcrm(qqchoice,1,"",",1"),..wcre() Q ""
 ; Размер_шрифта;;;;;;
m53p8   
m53p10  
m53p12  
m53p14  
 S Vs(qqnump,99,"SFont")=$P(qqchoice,"_",$L(qqchoice,"_")) D ..MenuAn("S"),..wipa(),..wcro(),..wcre() Q ""
 ; Оптимальная_ширина_колонок;;;;;;
 ;  Дерево_объектов;;;;;;
m54p1   D ..wM(qwin_".T1","MakeColumnOptimal",-1) Q ""
 ;  Дерево_Экземпляров
m54p2   D ..wM(qwin_".T2","MakeColumnOptimal",-1) Q ""
 ;Внешний календарь
m56 D ..OpenWindow(,,,,,"XXXDate") Q ""
 ;Внешний калькулятор
m57 D ..wM("-qARM","WinExec","calc.exe",9) Q ""
m59 D ..OpenDHelp("2,1") Q ""
 ; поиск;;;;;;
m150 S Vs(qqnump,99,"Find")='$G(Vs(qqnump,99,"Find")) D ..MenuAn("F") Q "" ;поддерево/экземпляры
m151 S Vs(qqnump,99,"Find",1)='$G(Vs(qqnump,99,"Find",1)) D ..MenuAn("F") Q "" ;все объекты для поиска по одному понятию
m161 S Vt(qqnump,0)='$G(Vt(qqnump,0)) D  D ..MenuAn("F"),..wcre() Q "" ;учет постоянных условий
 .N qqo S qqo=-1 F  S qqo=$O(Vo(qqnump,qqo)) Q:qqo=""  I $G(Vo(qqnump,qqo,27))'=""!$G(Vo(qqnump,qqo,28)) D
 ..S %2=Vt(qqnump,0) D ..wM(qwin_".T1","M9",1,0,qqo),..wP(,"M1",$S(W("Zadm"):qqo_" ",1:"")_$TR(..wcroCell(qqo),"_"," "),"",0,$S($G(Vo(qqnump,qqo,3)):$S(%2:"F4",1:"F1"),%2:"F3",1:"F0"))
m163p1
m163p2
m163p3
m163p4
m163p5
 S Vs(qqnump,99,"Find",2)=$P("1 10 100 1000"," ",$P(qqchoice,"_",2)) D ..MenuAn("F") Q "" ;Max
m164 S Vs(qqnump,99,"Find",3)='$G(Vs(qqnump,99,"Find",3)) D ..MenuAn("F") Q "" ;запуск в фон
 ;
m101 D ..OnKeyDown(qwin,113) Q "" ;запросы из поиска
m102 S Vs(qqnump,99,"Find",5)='$G(Vs(qqnump,99,"Find",5)) D ..MenuAn("F") Q "" ;@dol 19.06.04 без учета регистра
m175 D ..OpenDHelp("2,7") Q ""
 ; Вычисление_аналитик
 ;m161  Q "" ;S Vs(qqnump,99,"Anal","qqc")='$G(Vs(qqnump,99,"Anal","qqc")) D ..MenuAn("A") Q "" ;ссылки на экземпляры объектов
m152 S Vs(qqnump,99,"Anal",0)='$G(Vs(qqnump,99,"Anal",0)) D ..MenuAn("A") Q "" ;пустые значения
m153 S Vs(qqnump,99,"Anal")='$G(Vs(qqnump,99,"Anal")) D ..MenuAn("A") Q "" ;значения/слова
m154p0
m154p1
m154p2
m154p3
m154p6
m154p11
m154p101
 S Vs(qqnump,99,"Anal",1)=$P(qqchoice,"_",2) D ..MenuAn("A") Q "" ;порог
m167 S Vs(qqnump,99,"Anal",2)='$G(Vs(qqnump,99,"Anal",2)) D ..MenuAn("A") Q "" ;полное дерево
 ;Архив
m168p0 K W("Zar") D ..MenuAr(1) Q ""
m168p1 N qoq S qoq=$D(Vo(qqnump,"XView")),(Vo(qqnump,"XView",37),Vo(qqnump,"XView",36))=Vo(qqnump)_"zz" ;@dol 12.11.03
 S W("Zar")=$P(qW.rNew("XView",Vo(qqnump)_"zzA")," ") K:'qoq Vo(qqnump,"XQuery")
 S ^Q(1,"XView",W("Zar"),"X11")="Аналитика ..." D ..OpenText("Аналитика ...","S ^Q(1,""XView"",W(""Zar""),""X11"")=Text D qARM.MenuView(,-1),qARM.MenuView(W(""Zadm"")),qARM.MenuAr(1)","Название отображения аналитики",300) Q ""
m168p2 D ..MenuAr() Q ""
m172 S Vs(qqnump,99,"Anal",3)='$G(Vs(qqnump,99,"Anal",3)) D ..MenuAn("A") Q "" ;учет условий
m173 S Vs(qqnump,99,"Anal",4)='$G(Vs(qqnump,99,"Anal",4)) D ..MenuAn("A") Q "" ;запуск в фон
m1701p1 N viewa S viewa=$S($G(W("Zar"))="":$E(qview,1,3)_"sysA"_qview,1:W("Zar")) D ..SaveView(1),..OpenWindow("","","",..VerCall(viewa),"",viewa) Q "" ;вызов окна результатов
m1701p2 N viewa S viewa=$E(qview,1,3)_"sysY"_qview D ..SaveView(1),..OpenWindow("","","",..VerCall(viewa),"",viewa) Q "" ;@Dol 13.04.11 приемник-печать
m171 D ..OpenDHelp("2,6") Q ""
 ;параметры диаграммы
 ; порог
m155  Q ""
m155p1 
m155p2 
m155p3 
m155p4 
m155p5 
m155p6 
 S Vs(qqnump,13,"P")=$P(" .1 1 2 5 10"," ",$P(qqchoice,"_",2))
 D ..MenuAn("D") Q ""
 ;масштабирование (0-100)
m156p0
m156p1
m156p2
m156p3
 S Vs(qqnump,13,"M")=$P(qqchoice,"_",2) D ..MenuAn("D") Q ""
 ;Сортировка
m157  Q ""
m157p1 
m157p2
m157p3
m157p4 
 S Vs(qqnump,13,"S")=$P(qqchoice,"_",2)-1#2_$S($P(qqchoice,"_",2)>2:"-",1:"") D ..MenuAn("D") Q ""
m159 S Vs(qqnump,13,"X")='$G(Vs(qqnump,13,"X")) D ..MenuAn("D") Q ""
 ;премник
m158p0
m158p1
m158p1p0
m158p1p3
m158p1p4
m158p2
m158p3
m158p4
m158p5
m158p6
m158p7
 S $P(Vs(qqnump,13,"R")," ")=$P(qqchoice,"_",2) I $P(qqchoice,"_",2)=1 S $P(Vs(qqnump,13,"R")," ",2)=$P(qqchoice,"_",3) ;временно для VRML
 D ..MenuAn("D") Q ""
m169p0p0
m169p0p1
m169p0p2
m169p0p3
m169p0p4
 S $P(Vs(qqnump,13,"R")," ",2)=$P(qqchoice,"_",3) D ..MenuAn("D") Q "" ;вид
m169p1
 S $P(Vs(qqnump,13,"R")," ",3)='$P($G(Vs(qqnump,13,"R"))," ",3) D ..MenuAn("D") Q "" ;3D
m169p2
 S $P(Vs(qqnump,13,"R")," ",4)='$P($G(Vs(qqnump,13,"R"))," ",4) D ..MenuAn("D") Q "" ;Панель инструментов
m169p3
 S $P(Vs(qqnump,13,"R")," ",5)='$P($G(Vs(qqnump,13,"R"))," ",5) D ..MenuAn("D") Q "" ;легенда Х
m169p4
 S $P(Vs(qqnump,13,"R")," ",6)='$P($G(Vs(qqnump,13,"R"))," ",6) D ..MenuAn("D") Q "" ;Легенда серии
m169p5p0
m169p5p1
m169p5p2
m169p5p3
 S $P(Vs(qqnump,13,"R")," ",7)=$P(qqchoice,"_",3) D ..MenuAn("D") Q "" ;размер Легенда
m169p8p0
m169p8p2
m169p8p5 S $P(Vs(qqnump,13,"R")," ",8)=$P(qqchoice,"_",3) D ..MenuAn("D") Q "" ;@Dol 30.04.09 размер № п/п
m169p9
m169p10
m169p11
m169p12
m169p13
m169p15 
 S $P(Vs(qqnump,13,"R")," ",$P(qqchoice,"_",2))='$P($G(Vs(qqnump,13,"R"))," ",$P(qqchoice,"_",2)) D ..MenuAn("D") Q "" ;Повтор значений и другие
m169p14p0
m169p14p1
m169p14p2
m169p14p3 S $P(Vs(qqnump,13,"R")," ",14)=$P(qqchoice,"_",3) D ..MenuAn("D") Q "" ;@Dol 18.05.09
m169p16p1
m169p16p2
m169p16p3 S $P(Vs(qqnump,13,"R")," ",16)=$P("???~_~-","~",$P(qqchoice,"_",3)) D ..MenuAn("D") Q "" ;@Dol 18.05.09
m160 D ..OpenDHelp("2,5") Q ""
 ;Help
m10p1 ;D ..OpenHelp(qARM("ClientPath")_"qword.chm") Q "" ;по браузеру
 D ..OpenWindow(,,",,0,2 1 20","XDocH1",,"XXXDocw",1) Q ""
m10p2 I $G(qARM("Pars",1))'="" D ..OpenHelp(qARM("ClientPath")_qARM("Pars",1)) Q ""
 D ..OpenVHelp() Q "" ;по приложению
m10p3 D ..Print("syssysV"_Vo(qqnump),1) Q "" ;по отображению
m10p4p1 D ..OpenWindow(,,",,0,2 1 20","XDocS1",,"XXXSDocw",1) Q ""
m10p4p2 D ..Print("syssysVXXXCxObj",1) Q ""
m10p4p3 D ..Print("syssysVXXXCxWoc",1) Q ""
m10p4p4 D ..Print("syssysVXXXXView",1) Q ""
m10p4p5 D ..Print("syssysVXXXXQueryc",1) Q ""
m10p4p6 D ..Print("syssysVXXXXViewStat",1) Q ""
m10p4p8 D ..OpenWindow(,,",,0,2 1 20","XDocRN1",,"XXXRNw",1) Q ""
m10p9 D ..OpenDHelp("2,12") Q ""
 ;меню состояний объекта
 ///m801 I $P(W("Zpos",1,"d")," ")="" K Vs(qqnump,3) D ..wcro(),..wcre() Q ""
 ///D ..wrot($P(W("Zpos",1,"d")," ")) S %12=$$$ObjRef($P(W("Zpos",1,"d")," ")),%11=$$$ObjRef($$$CurObj) S:%11'=$P(%12,",",1,$L(%11,",")) $$$CurObj=$P(W("Zpos",1,"d")," ") D ..wcre() Q ""
m801 D qARM.OpenText($G(Vs(qqnump,"X57",$P(W("Zpos",1,"d")," "))),"S Vs(qqnump,""X57"","""_$P(W("Zpos",1,"d")," ")_""")=Text D qARM.wcro()","Список дополнительных понятий",400) Q "" ///@dol 30.07.08
m802 ;I $P(W("Zpos",1,"d")," ")="" K Vs(qqnump,4) D ..wcro() Q ""
 ;D ..wpot($P(W("Zpos",1,"d")," ")) Q "" ;папки понятий
m802p0 D ..SRColWidth("S",,,1) Q "" ;@Dol 11.11.06 Сохранить размеры колонок
m802p1 D ..SRColWidth("R",,,1) Q ""
m802p3 D ..SRColWidth("D",,,1) Q ""
 ;зачеркивание
m803 I $P(W("Zpos",1,"d")," ")="" K Vs(qqnump,1),W("ZBtredo") D ..wipa(),..wcro(),..wcre() Q ""
 N qqo,qqw,qqoo S qqo=W("Zpos",1,"d"),qqw=$P(qqo," ",2),qqo=$P(qqo," ")
 I qqw="",'$G(Vs(qqnump,1,qqo)) D  Q:$G(qqoo)="" ""  ;@Dol 27.09.06 блокировка зачеркивания единственного незачеркнутого объекта
 .S qqoo=-1 F  S qqoo=$O(Vo(qqnump,qqoo)) Q:qqoo=""  I $D(Vo(qqnump,qqoo,0))>10,'$G(Vs(qqnump,1,qqoo)),qqo'=qqoo Q
 I qqw="" S Vs(qqnump,1,qqo)='$G(Vs(qqnump,1,qqo)) N qqsto S qqsto=+$S(W("Zadm")!$G(Vs(qqnump,"Analit")):1,1:..GetPar("X184")) D:qqsto=1 ..wP(qwin_".T1","M3",$S($G(Vs(qqnump,1,qqo)):"d",1:"")_$S($G(Vs(qqnump,4,qqo)):"p1",1:"p0"),W("Zpos",1,"y")) D:qqsto=1&&$G(qqXBz) ..wP(,"M5",$S($G(Vs(qqnump,1,qqo)):"R291",1:""),W("Zpos",1,"y"),0) D  D:qqsto'=1 ..wcro() D ..wcre(1) Q ""
 .I 'Vs(qqnump,1,qqo),$D(Vs(qqnump,1,qqo))=1 K Vs(qqnump,1,qqo)
 S Vs(qqnump,1,qqo,qqw)='$G(Vs(qqnump,1,qqo,qqw)),qqoo=0 D ..wP(qwin_".T1","M3",$S($G(Vs(qqnump,1,qqo,qqw)):"d",1:"")_"Bob",W("Zpos",1,"y")) D:$G(qqXBz) ..wP(,"M5",$S($G(Vs(qqnump,1,qqo,qqw)):"R291",1:""),W("Zpos",1,"y"),0) D  D:%1'="" m803e(qqo,+%1,$P(%1," ",2)),..wcre() Q "" ;@dol 1.09.04 wcre(1)
 .S %1=$G(Vo(qqnump,qqo,11,qqw)) Q:%1=""  K Vt(qqnump,9,qqo_" "_$P(%1," ")),Vt(qqnump,9,"-1 "_qqo_" "_$P(%1," ")) ;убрали образец вывода и образец заголовка
 .S %2=$P(%1," ",2)
 .I %2 D  I 1 ;связанная константа
 ..S %2=$O(Vo(qqnump,qqo,0,+%1,%2),-1) Q:%2=""
 ..I $E($G(Vo(qqnump,qqo,0,+%1,%2)))'=0 S %2="" Q
 .E  S %2=""
 .;D ..wM(qwin_".T2","MakeColumnOptimal",$P(%1," ",2)) ;не очень здорово, но пока пусть будет
 .I Vs(qqnump,1,qqo,qqw) S Vs(qqnump,1,qqo,+%1,$P(%1," ",2))=1 S:%2'="" Vs(qqnump,1,qqo,+%1,%2)=1 Q 
 .K Vs(qqnump,1,qqo,+%1,$P(%1," ",2)),Vs(qqnump,1,qqo,qqw) K:%2'="" Vs(qqnump,1,qqo,+%1,%2)
 .I '$G(Vs(qqnump,1,qqo)),$D(Vs(qqnump,1,qqo))<10 K Vs(qqnump,1,qqo)
 ;проверка на единственность в ряду
m803e(qqo,qy,qqx)   Q:'$D(Vs(qqnump,"ColWidth"))  N qqy,end S qqoo=-1,end=0 F  Q:end  S qqoo=$O(Vo(qqnump,qqoo)) Q:qqoo=""  S qqy="" F  S qqy=$O(Vo(qqnump,qqoo,0,qqy)) Q:qqy=""  I $D(Vo(qqnump,qqoo,0,qqy,qqx)),'$G(Vs(qqnump,1,qqoo)),'$G(Vs(qqnump,1,qqoo,qqy,qqx)),$S(qqo'=qqoo:1,1:qqy'=qy) S end=1 Q
 Q:qqoo'=""
 I $G(Vs(qqnump,1,qqo,qy,qqx)) S Vs(qqnump,"ColWidth",qqx)=0 D ..wP(qwin_".T2","ColumnWidth",0,qqx) Q
 N qk S qk=$P($G(Vo(qqnump,-1,9,qqx)),",") S:qk="" qk=15 S qk=$S(qk["px":+qk,qk["%":$J(qARM("Screen","Width")*qk/100,0,0),1:qk*$P(W("Zfont"),",",3))
 S Vs(qqnump,"ColWidth",qqx)=qk D ..wP(qwin_".T2","ColumnWidth",qk,qqx) Q
 ;зачеркнуть все
m800 N qqz I $P(W("Zpos",1,"d")," ",2)=""||($P(W("Zpos",1,"d")," ")="") D  G m800end
 .S qqz=-1 F  S qqz=$O(Vo(qqnump,qqz)) Q:qqz=""  S Vs(qqnump,1,qqz)=1
 S qqz="" F  S qqz=$O(Vo(qqnump,$P(W("Zpos",1,"d")," "),11,qqz)) Q:qqz=""  D qSYS.SetVs(1,$P(W("Zpos",1,"d")," "),qqz,1) ;@Dol 24.11.05 S Vs(qqnump,1,$P(W("Zpos",1,"d")," "),qqz)=1
m800end D ..wipa(),..wcro(),..wcre() Q ""
 ;свойства
m805 N yx,qqw S qqw=$P(W("Zpos",1,"d")," ",2),yx="" S:qqw'="" yx=Vo(qqnump,$P(W("Zpos",1,"d")," "),11,qqw)
 I $S($G(W("Zomod")):1,1:'qSYS.Redview("SavTmp")) D qSYS.CallDef(Vo(qqnump),$S('W("Zpos",1,"y"):"",1:$P(W("Zpos",1,"d")," ")),$S(qqw="":"",1:$P(yx," ",1)),$S(qqw="":"",1:$P(yx," ",2)))
 Q ""
m806 D qSYS.CallVocCor($P(W("Zpos",1,"d")," ",1),$P(W("Zpos",1,"d")," ",2),"") Q "" ;Словарь развертки
 ;таблица
m808 I $P(W("Zpos",1,"d")," ",1)="" D qSYS.ChObjView() Q "" ;переход на заданный объект
 Q:$P(W("Zpos",1,"d")," ",1)=-1 ""
 I $P(W("Zpos",1,"d")," ",2)="" S Vo("par",-1,29)=",,0" D ..OpenWindow(,,,,,"XXXsysO"_$P(W("Zpos",1,"d")," ",1)) Q ""
 I "M@XLHTF"'[$E($P(W("Zpos",1,"d")," ",2)) S Vo("par",-1,29)=",,0" D ..OpenWindow(,,,,,"XXXsysP"_$P(W("Zpos",1,"d")," ",2)) Q ""
 D ..Message("Нет таблицы значений") Q ""
 ;Help
m807 D ..OpenCHelp(1) Q ""
m809 D ..OpenDHelp("1,0,0") Q ""
 ;графы дерева объектов
 ;редактирование условия
m810 D ..StartEditT1() Q ""
 ;развертка по словарю
m811 N qqdbl s qqdbl=1 D ..StartEditT1() Q ""
 ;сброс
m812 S Vs(qqnump,8,$P(W("Zpos",1,"d")," "),$P(W("Zpos",1,"d")," ",2))=" " ;@dol 2.02.04
 ;наличие
m813 N qqbut s qqbut=2 D ..StartEditT1() Q ""
m814p0 S %1="...qW.G(""pF"")=Z" G m814end
m814p1 S %1="...qW.GG(100,""pF"",$E(qqc,1,7))=Z" G m814end
m814p2 S %1="...qW.zAge(Z)>30" G m814end
m814p3 S %1="...qW.zNum(100)>1" G m814end
m814p4 S %1="...qW.zSum(100,""pF"")>1000" G m814end
m814end S Vs(qqnump,8,$P(W("Zpos",1,"d")," "),$P(W("Zpos",1,"d")," ",2))=%1 D ..wP(qwin_".T1","List",%1,W("Zpos",1,"y"),1),..StartEditT1() Q ""
m815 ;I $D(^Q(1,$S($P(W("Zpos",1,"d")," ",2)'[":":$P(W("Zpos",1,"d")," ",2),1:$P($P(W("Zpos",1,"d")," ",2),":",2))))<10 D ..Message("Словарь значений пуст") Q ""
 I ..GetPar("X7801",,$P(W("Zpos",1,"d")," ",1),$P(W("Zpos",1,"d")," ",2))'="" N qqdbl s qqdbl=2 D ..StartEditT1() Q "" ;@Dol 15.10.08
 N qqo,qqw S qqo=$P(W("Zpos",1,"d")," ",1),qqo=$S($G(Vo(qqnump,qqo,2))>2:"",$E(qqo)'="v":qqo,1:$E(qqo,3,255))
 S qqw=$P(W("Zpos",1,"d")," ",2)
 I qqw[":" S qqo=$P(qqw,":"),qqw=$P(qqw,":",2)
 D qSYS.CallRel(qqw,qqo) Q ""
m816 X ..GetPar("X78",,$P(W("Zpos",1,"d")," "),$P(W("Zpos",1,"d")," ",2)) Q ""
m817 S %111=..GetPar("X780",,$P(W("Zpos",1,"d")," "),$P(W("Zpos",1,"d")," ",2))
 S:%111[$C(13,10) %111=$TR(%111,$C(13,10),"~") S:%111'["~" %111=%111_"~" 
 D qARM.MenuWoc("ZfI9",%111,,0,"S %1=$P(%111,""~"",$P(qqchoice,""ZfI9"",2)+1) K %111 S Vs(qqnump,8,$P(W(""Zpos"",1,""d""),"" ""),$P(W(""Zpos"",1,""d""),"" "",2))=%1 D ..wP(qwin_"".T1"",""List"",%1,W(""Zpos"",1,""y""),1),..StartEditT1()") Q ""
m819 D ..OpenDHelp("1,0,1") Q ""
 ;редактирование Выражения аналитики
m820 D ..StartEditT1() Q ""
 ;Вставка Характеристики
m821 D m821f("Хар-ка("_qW.GetWoc("CxWoc",$P(W("Zpos",1,"d")," ",2))_")","qW.G(""H"_$P(W("Zpos",1,"d")," ",2)_""")") Q ""
m821f(p1,p2) N qqo,qqw,qqbut S qqbut=2,qqo=$P(W("Zpos",1,"d")," "),qqw=$P(W("Zpos",1,"d")," ",2)
 S:p1'="" Vs(qqnump,12,qqo,qqw,1)=p1 K:p1="" Vs(qqnump,12,qqo,qqw,1)
 S:p2'="" Vs(qqnump,12,qqo,qqw,2)=p2 K:p2="" Vs(qqnump,12,qqo,qqw,2)
 D ..StartEditT1() Q
m822p0 D m821f("","$E(Z,1,4)") Q ""
m822p1 D m821f("","$E(Z,1,6)") Q ""
m822p2 D m821f("","qW.zAge(Z)") Q ""
m822p3 D m821f("","$S(Z="""":"""",1:Z\10*10)") Q ""
m822p4 D m821f("","$S(Z<10:"""",Z>100:"""",1:Z)") Q ""
m822p5 D m821f("","$S(Z="""":"""",qW.G(""pF"")="""":"""",1:Z/qW.G(""pF""))") Q ""
m822p6 D m821f("","$S(Z="""":"""",qW.GG(100,""pF"",$E(qqc,1,7))="""":"""",1:Z/qW.GG(100,""pF"",$E(qqc,1,7)))") Q ""
 ;сброс
m823 D m821f("","") Q ""
 ;Примеры
m827 S %111=..GetPar("X782",,$P(W("Zpos",1,"d")," "),$P(W("Zpos",1,"d")," ",2))
 S:%111[$C(13,10) %111=$TR(%111,$C(13,10),"~") S:%111'["~" %111=%111_"~" 
 D qARM.MenuWoc("ZfI9",%111,,0,"S %1=$P(%111,""~"",$P(qqchoice,""ZfI9"",2)+1) K %111 S Vs(qqnump,12,$P(W(""Zpos"",1,""d""),"" ""),$P(W(""Zpos"",1,""d""),"" "",2),2)=%1 D ..wP(qwin_"".T1"",""List"",%1,W(""Zpos"",1,""y""),2),..StartEditT1()") Q ""
 ;
m829 D ..OpenDHelp("1,0,2") Q ""
m830 D ..StartEditT1(0) Q ""
m831 D ..StartEditT1(1) Q ""
m839 D ..OpenDHelp("1,0,3") Q ""
m840
m841 D ..StartEditT1() Q ""
m842 D ..StartEditT1(1) Q ""
m843 D ..StartEditT1(2) Q ""
m844 D ..StartEditT1(3) Q ""
m847 D ..StartEditT1(4) Q ""
m848 D ..StartEditT1(5) Q ""
m845 D ..StartEditT1(-1) Q ""
m849 D ..OpenDHelp("1,0,4") Q ""
m850 D ..StartEditT1() Q ""
m853 D ..StartEditT1(1) Q "" ;@Dol 22.09.10
m851
m852 N qqo,qqw,j S qqo=$P(W("Zpos",1,"d")," ",1),qqw=$P(W("Zpos",1,"d")," ",2),Vs(qqnump,12,qqo,qqw)=$S(qqchoice=851:'($G(Vs(qqnump,12,qqo,qqw))=1),$G(Vs(qqnump,12,qqo,qqw))=2:0,1:2) D  Q "" ;только Num
 .F j=6:1:11 D ..wP(qwin_".T1","M1",$S($D(Vs(qqnump,13,0,qqo_" "_qqw_" "_j)):Vs(qqnump,13,0,qqo_" "_qqw_" "_j)_": ",1:"")_$G(Vs(qqnump,12,qqo,qqw,j)),W("Zpos",1,"y"),j,"",$S($G(Vs(qqnump,12,qqo,qqw))=2:16777215,'$G(Vs(qqnump,12,qqo,qqw))&(j<10):16777215,1:12632256))
m859 D ..OpenDHelp("1,0,"_W("Zpos",1,"x")) Q ""
 ;меню релевантных дерева экземпляров
m900p1 
m900p2 N qqq S qqq=$G(Vs(qqnump,99,"Find")),Vs(qqnump,99,"Find")=$P(qqchoice,"_",2)-1 D ..RecRel("+",qxecute0) S Vs(qqnump,99,"Find")=qqq Q ""
m901 D ..RecRel($S($G(Vc(qqnump,qxecute0,2)):"-",1:"+"),qxecute0) Q ""
m902 D ..RecRel(0) Q ""
m904
m905 D ..RecRel(1) Q ""
m909 D ..OpenDHelp("1,1") Q ""
 ;заголовок релевантных
m960 D ..RecRel(0) Q ""
m961 ;включить все (видимые)
 D ..RecRelAll(1) Q ""
m964
m965 D ..RecRel(1) Q ""
m969 D ..OpenDHelp("1,1") Q ""
 ;ячейки
m910p1 D ..NoSort(),..RecNew() Q "" ; Ввод
m910p2 D ..RecCor() Q "" ; Коррекция
m910p3 D ..RecDel() Q "" ; Удаление
m910p4 S %1=qW.rCor(qqo,qqc,"*") D ..wwww(%1) Q "" ; очистка
m910p6 D:$G(qqwchg)'="" ..RecRev() Q "" ;откат
 ;вставка
m910p8 I ..EndOP() Q ""
 D ..RecIns() Q ""
 ;N qqccc S qqccc=qW.rIns(qqo,qqc) Q:qqccc=""  S qqc=qqccc D ..wcre() Q ""
 ;сортировка
m910p9 I ..EndOP() Q ""
 I $G(qqw)=""||("YTZ"[$E(qqw)) D ..Message("Нельзя сортировать по Z*, T* или Y*-понятиям") Q ""
 D ..Question("Сортировать объект "_qqo_" по понятию "_qqw,,"","D qW.rSort(,qqo,qqw,,""^mtemps($J)"",1),qARM.wcre()") Q ""
 ;
m911p1 D m911d(3) Q "" ;принудительное редактирование (в режиме админстратора - вне запрета)
m911p2 D m911d(2) Q "" ;развертка
 ;репликация для релевантных
m911p3 N qqcc S W(qqw)=qW.GE(qqw) S qqcc="" F  S qqcc=$O(^Q($$$Relind_qview,qqo,qqcc)) Q:qqcc=""  D qW.rCor(qqo,qqcc,qqw,,0)
 D qARM.wcre() Q ""
m913p1 D ..SaveToClipbrd() D:0 qARM.Message("Сохранено") Q "" ;@Dol 19.09.06 сохранить в буфер
m913p2 D ..TestPaste() Q "" ;восстановить из буфера
m911d(qqbut)
 N qqdat,qqx,qqy
 ;StartEditT2 требует локальных пееменнных (надо бы переделать)
 S qqdat=W("Zpos",2,"d"),qqy=W("Zpos",2,"y"),qqx=W("Zpos",2,"x")
 D ..NextEdit() Q
m912 D ..MenuQ() Q "" ;@dol 11.1.04
m912p0
m912p1
m912p2
m912p3
m912p4
m912p5
m912p6
m912p7
m912p8
m912p9
m912p10
m912p11
m912p12 
 D ..ResetSrt(),..Wait("D qWEB.Query("""_qwin(qwin,"o",7,$P(qqchoice,"_",2))_""")") Q ""
 ;пояснения
m915p1 S %1=..GetPar(174) D ..OpenCHelp($S($P(%1," ",1)'="":"W"_$P(%1," ",1),1:"V"_Vo(qqnump))) Q ""
m915p2 S %1=..GetPar(174) D ..OpenCHelp($S($P(%1," ",2)'="":"W"_$P(%1," ",2),qqo=""!(qqo=-1):"V"_Vo(qqnump),1:"O"_qqo)) Q ""
m915p3 S %1=..GetPar(174) D ..OpenCHelp(2) Q "" ;$S($P(%1," ",3)'="":"W"_$P(%1," ",3),qqo=""!(qqo=-1):"V"_Vo(qqnump),$G(W("Zpos",2,"x"))<0:"O"_qqo,1:"WZs"_$P(W("Zpos",2,"d")," ",3)_"c"_W("Zpos",2,"x")_"_"_qqo)) Q ""
m915p4 D ..OpenWindow(,,,,,"XXX0") Q "" ;по приложению
 ;D ..Print("syssysV"_$P(qview," "),1) Q "" ;по всему отображению
 ;свойства
m916 I '$D(Vo(qqnump,$P(W("Zpos",2,"d")," ",2),0,$P(W("Zpos",2,"d")," ",3),W("Zpos",2,"x"))) D ..Message("Пустая ячейка") Q ""
 I $S($G(W("Zomod")):1,1:'qSYS.Redview("SavTmp")) D qSYS.CallDef(Vo(qqnump),$P(W("Zpos",2,"d")," ",2),$P(W("Zpos",2,"d")," ",3),W("Zpos",2,"x")) Q ""
 Q ""
m918 ;D ..wM(qwin,"EvClose") Q ""
 D qSYS.CallVocCor($P(W("Zpos",2,"d")," ",2),$P(W("Zpos",2,"d")," ",3),W("Zpos",2,"x")) Q "" ;Словарь развертки
m940 D ..AvtoFind(qqo,qqw,qqc,1) Q "" ;@Dol 09.05.09
 ;понятие-образец
 ;m940 N qtmpl S qtmpl=..GetPar("X784",,$P($G(W("Zpos",2,"d"))," ",2),$P($G(W("Zpos",2,"d"))," ",3),$G(W("Zpos",2,"x")))
 ;S:qtmpl["(" qtmpl=..Value(qtmpl) S:$E(qtmpl)="@" qtmpl=qW.GG($P($G(W("Zpos",2,"d"))," ",2),$E(qtmpl,2,255),$G(Vc(qqnump,$P($G(W("Zpos",2,"d"))," ",1))))
 ;I qtmpl="" D ..Message("Ссылка на понятие-образец пуста") Q ""
 ;S Vo("par","CxWoc",4)=0 D qARM.OpenWindow(,,,qtmpl_" CxWoc 1  CxWoc",,"XXXCxWoc") Q ""
m917 ;состояние
 N qqo,qqc,qqw,qqq,q710 S qqo=$P(W("Zpos",2,"d")," ",2) I qqo'="",qqo'=-1 S qqc=$G(Vc(qqnump,$P(W("Zpos",2,"d")," ",1))),qqq=qW.oZcordtu()_";"_qW.oZdtudel()
 I $G(Vo(qqnump,qqo,2))<3 S qqw="" F  S qqw=$O(^Q(1,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)),qqc,qqw)) Q:qqw=""  I qqw'="X",qqw'="Xc",qqw'="Xd" S q710=..GetPar("x710",,qqo,qqw),qqq=qqq_$C(13,10)_qqw_"="_qW.G(qqw)_$S(q710="":"",q710'="Ht"&($E(q710)'=8):"",1:" ["_qW.GtoExt(q710,qW.G(qqw))_"]") ;@Dol 20.08.06;27.20.07 q710
 D ..Message("qqo="_qqo_" qqc="""_$G(qqc)_""" Коррекция/Cоздание/Лог.удаление = "_$TR($G(qqq),";","/"),"Состояние") Q ""
m919 D ..OpenDHelp("1,1") Q ""
 ;F2 - запросы
m920
m921
m922
m923
m924
m925
m926
m927
m928
m929
m930
m931
m932
m933
m934
m935
m936
m937
m938
 D ..ResetSrt(),..Wait("D qWEB.Query("""_qwin(qwin,"o",7,$P(qqchoice,"_",1)-920)_""")") Q ""
 ;перемещения
m975
m974
m972
m971 K qqwold D qARM.TToolButtonOnClick(qwin_"..b"_($P(qqchoice,"_",1)-970)) Q:$Q "" Q
 ;Выбор по вопросу (QuestionM)
m980 X:$G(qxecute1)'="" ..Value(qxecute1,"X") Q:$Q "" Q  ;Да
m988 X:$G(qxecute0)'="" ..Value(qxecute0,"X") Q:$Q "" Q  ;Нет
m981 X:$G(qxecute2)'="" ..Value(qxecute2,"X") Q:$Q "" Q  ;Доп выбор
m982 X:$G(qxecute3)'="" ..Value(qxecute3,"X") Q:$Q "" Q  ;Доп выбор
m983 X:$G(qxecute4)'="" ..Value(qxecute4,"X") Q:$Q "" Q  ;Доп выбор
m984 X:$G(qxecute5)'="" ..Value(qxecute5,"X") Q:$Q "" Q  ;Доп выбор
m985 X:$G(qxecute6)'="" ..Value(qxecute6,"X") Q:$Q "" Q  ;Доп выбор
 ;Выход из окна
m990 D qARM.TFormOnClose(0,4) Q "" ;выбор
m991 D qARM.TFormOnClose(0,6) Q "" ;отказ
m9User d qUSER.onTMenuItemClick(Sender) q ""    ;пользовательская отработка
]]></Implementation>
</Method>

<Method name="TToolButtonOnClick">
<Internal/>
<FormalSpec>Sender:%String,Button:%Integer</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 I $P(Sender,".")'=("Q"_$G(qqnump))!$G(W("ZredB")),..ChgWin() Q "" ;Обработка смены окна (смена локальной среды)
 I $G(Vt(qqnump,"Znsp"))'="",$G(Vt(qqnump,"Znsp"))'=$ZU(5) ZN Vt(qqnump,"Znsp") ;смена NameSpace
 ;
 I $G(W("ZBt0")) D ..Message("Заблокировано.Редактируется отображение") Q ""
 N qqpar1,qqq S qqpar1=$E($P(Sender,".",$P(Sender,".",2)="T1"+3),2,40) ;@Pavel 27.03.06 3->40 большие номера кнопок
 I $G(Button) D ..OpenDHelp("2,"_..wbuttb(qqpar1)) Q ""
 ;D ..Message(Sender_" "_Button_" "_qqpar1)
 ;отработка выборов панели инструментов ;@dol 13.05.03 кнопки доп.панели (101 ...)
 I " 5 4 3 2 1 10 13 34 35 62 63 98 101 102 103 104 "[(" "_qqpar1_" ") S qqq=..EndOP() d:qqq&&(" 4 2 "[(" "_qqpar1_" ")) qARM.wM("-qARM","DestroyToolButTimer") Q:qqq "" I qqpar1<100,qqpar1'=3,qqpar1'=10,$G(Vs(qqnump,17)),$$$CurObj=$G(Vs(qqnump,7)) D:$G(W("Zadm")) ..Wait("D qARM.Message(""Жесткая фиксация"")") Q "" ;при жесткой фиксации двигаться некуда
 D:'$D(Vo(qqnump,-1,665)) ..GetPar("X1665") I Vo(qqnump,-1,665)'="" N qqend X Vo(qqnump,-1,665) Q:$G(qqend) 1 K qqend ;@Dol 21.07.05 преддействие 
 i qqpar1<901 G @("s130"_qqpar1)
 g s130900
 ;
s1306 ;('Объекты (Блокировка экземпляров)') ;@Dima
s1307 ;('Объекты/Экземпляры')
s1308 ;('Экземпляры')
s13099 Q "" ;кнопка меню пояснений
s13098 ;реверс
 D ..QuestionM("Выключить реверс~Включить реверс по экземплярам объектов и по сортировке~Включить реверс только по экземплярам объектов","","","D qARM.OnRevers(0)","D qARM.OnRevers(1)","D qARM.OnRevers(2)") Q "" ;@Dol 06.05.09
 ;S Vs(qqnump,99,"Revers")='$G(Vs(qqnump,99,"Revers"))
 ;D ..wP(qwin_".TBG.b98","ImageIndex",6+(''Vs(qqnump,99,"Revers"))) ;,..wP(qwin_".TBG.b98","Hint","Реверс")
 ;I $D(Vt(qqnump,111)) D s1300v
 ;D ..wcre() Q ""
s1305 D ..Move("Beg") Q "" ;начало
s1304 D ..Move("Up") Q ""  ;предыдущий
s1303 I $G(Vo(qqnump,-1,669))'="" Q:'$P(Vo(qqnump,-1,669)," ",2) ""  ;скролл перемещений блокировка фиксации
 D ..Fix($S($G(Vs(qqnump,7))'="":"",1:$$$CurObj))
 Q ""
s1302 D ..Move("Down") Q ""  ;следующий
s13034 D ..Move("PageDown",,$P($G(Vo(qqnump,-1,669))," ",4)) Q ""  ;@Dol 09.03.11 следующая страница
s13035 D ..Move("PageUp",,$P($G(Vo(qqnump,-1,669))," ",4)) Q ""  ;@Dol 09.03.11 предыдущая страница
s1301 D ..Move("End") Q ""  ;конец
s1300 D ..Move("E") Q ""
s1300v D ..Move("v") Q  ;для виртуальных объектов
 ;обновить
s1309 I W("ZBt0") D ..wcro() Q ""
 D ..ObjSort() S:$P($$$CondFind," ")'="" W($P($$$CondFind," "))=qW.GG($$$CurObj,$P($$$CondFind," "),qqc) ;@Dol 16.12.05
 Q:$S('W("ZBtred"):0,1:..EndOP()) "" I $D(Vt(qqnump,111)) D s1300v
 D ..wcre() D:$G(Vo(qqnump,-1,62)) ..wM(qwin,"qResize",$TR(Vo(qqnump,-1,62),"123","312")),..wpoe(,1) Q ""
 ;Установить заданный размер колонок (согласно описаниям)
s13017 I $D(Vs(qqnump,"ColWidth"))>1 K Vs(qqnump,"ColWidth") D ..wgre() Q 1
 Q ""  ;Пересчет на оптимальный
 ;отображение
s13022  Q ""
 ;настройки
s13020  Q "" ;раскрыть все объекты
 ;вывод картинок
s13023 I '$D(Vt(qqnump,9,"P")) D ..wP(qwin_".TBM.b23","Down",0),..Message("Нет картинок") Q ""
 S Vs(qqnump,99,"Pic")='$G(Vs(qqnump,99,"Pic")) D ..wcre() Q "" ;@dol 16.1.04 D ..wpic(Vs(qqnump,99,"Pic")) Q ""
 ;
s13021  ;разрешение/запрет редактирования
 I W("ZBtred"),..EndOP() D ..wP(qwin_".TBM.b21","Down",1) Q ""
 ;D:$G(Vo(qqnump,-1,62)) ..wM(qwin,"qResize"_$S(Vo(qqnump,-1,62)=1:"",1:"Hor")) ;@dima 19.01.07 перенесено в конец
 S W("ZBtred")='W("ZBtred") D:$G(Vt(qqnump,570)) ..wP(qwin_".T2","OnAutoEndDragging",W("ZBtred"))
 D ..ViEdit(),..wcre()
 D:$G(Vo(qqnump,-1,62)) ..wM(qwin,"qResize",$TR(Vo(qqnump,-1,62),"123","312")) Q "" ;@dima 19.01.07
 ; Ввод;;;;;;
s13010 D ..NoSort(),..RecNew() Q ""
 ; Коррекция;;;;;;
s13011 D ..RecCor() Q ""
 ; Удаление;;;;;1;
s13012 D ..RecDel() Q ""
 ; Удаление_перечня_релевантных
s13013 D ..RecDelRel() Q ""
 ;Развертка;;;;
s13014 Q "" ;D:$G(qqw)'="" ..RecRaz() Q ""
 ;;;I qqred'="" D ..EndEdit($G(qqstr),40,1),..RecRaz()
 N qqdat,qqx,qqy,qqbut
 ;StartEditT2 требует локальных пееменнных (надо бы переделать)
 S qqbut=2,qqdat=$G(W("Zpos",2,"d")),qqy=$G(W("Zpos",2,"y")),qqx=$G(W("Zpos",2,"x"))
 I qqy'="",qqx'="" D
 .S qqw=$P($G(Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx))," "),qqw=$S('$E(qqw):"",$E(qqw)=5:"Zs"_$P(qqdat," ",3)_"c"_qqx,1:$E($P(qqw," "),2,31))
 .D ..NextEdit()
 Q ""
s13015 D:$G(qqwchg)'="" ..RecRev() Q "" ;откат
s13062 ;I $G(^Q(1,"XView",Vo(qqnump),"XMenu","P7","XMenuDo"))'="" X ^("XMenuDo") Q "" ;переназначенный поиск
 I $G(W("ZfindF")) D ..FindFonEnd(1) Q "" ;снятие фонового поиска
 D ..Find() Q "" ;поиск
s13063 ;I $G(^Q(1,"XView",Vo(qqnump),"XMenu","P9","XMenuDo"))'="" X ^("XMenuDo") Q "" ;переназначенная аналитика
 D ..Anal() Q "" ;аналитика
s13064 I '$G(Vs(qqnump,13,"R")) D ..OpenCFX() Q "" ;диаграмма CFX
 I +Vs(qqnump,13,"R")=5 D ..OpenOC() Q "" ;диаграмма Objective Chart
 I +Vs(qqnump,13,"R")=7 D ..OpenCFXNEW() Q "" ;диаграмма CFX NEW @AKA 08.02.2011
 I +$G(Vs(qqnump,13,"R"))=1 S %1=qWEB.DiagVRML(,,,$P(Vs(qqnump,13,"R")," ",2)) I 1
 E  S %1=qWEB.Diag(Vs(qqnump,13,"R"))
 D:%1'="" ..Message(%1) Q ""
s13041  ;Сброс  
 D ..RecRel(0) Q ""
s13040  Q ""
s130402 ;выбор
 S $$$RelNum=$D(^Q($$$Relind_qview))>1
 I '$$$ReFind D ..wbuttb(402,1) Q ""
 D ..RecRel(1) Q ""
s130401 ;Уточнение
 S $$$RelNum=$D(^Q($$$Relind_qview))>1
 I $$$ReFind D ..wbuttb(401,1) Q ""
 I '$$$RelNum D ..wbuttb(401,0) Q ""
 D ..NoSort()  ;@dol 21.12.03
 D ..RecRel(1) Q ""
s13033 D ..OpenWindow(,,,,,"XXXX") Q ""
 ;
s130101 Q:$$s130100(0) "" Q "" ;меню отображений(умолчание)
s130102 Q:$$s130100(1) "" D ..NoSort(),..RecNew() Q "" ; Ввод (умолчание)
s130103 Q:$$s130100(2) "" D ..RecDel() Q "" ;; Удаление (умолчание)
s130104 Q:$$s130100(3) "" D ..Find() Q "" ;поиск(умолчание)
 ;
s130100(nnn)
 I $G(^Q(1,"XView",Vo(qqnump),"XMenu",nnn,"XMenuDo"))'="" D:$E(^("XMenuDo"))'="@" ..Value(^("XMenuDo"),"X") Q 1
 Q 0
s130900
 d qUSER.onToolButtonClick(Sender)
 q ""
]]></Implementation>
</Method>

<Method name="TestPaste">
<Description>
Проверка и восстановление из буфера обмена
см. ..SaveToCipbrd</Description>
<Internal/>
<FormalSpec>TextMsg:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ;$$$FEvent @dima убрал 20101220
 I '$D(TextMsg) d ..wM("-qARM","LoadFromClipbrd") K qBuFfXec Q:$Q "" Q  ;запрос на чтение буфера
 I $G(qBuFfXec)'="" Q 1  ;чтение из буфера с последующим выполнением qBuFfXec (см. ..SaveToClipbrd() )
 N qqoto,qqofrom,LineChObj S LineChObj="",qqoto=$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)),qqofrom=$S($E($P(TextMsg," ",2))'="v":$P(TextMsg," ",2),1:$E($P(TextMsg," ",2),3,255))
 I qqoto'=qqofrom  D  I LineChObj="" D ..Message(TextMsg_$C(13,10)_"текущий "_qqo_" "_..wcroCell(qqo),"НЕСОВПАДЕНИЕ!!!"_$S(W("Zadm"):"",1:$C(13,10)_"??? Попробовать в режиме Администратор")) Q:$Q "" Q  ;в режиме Администратор продолжим и без совпадения. Вдруг так очень надо?
 .I "CX"'[$E(qqoto),"CX"'[$E(qqofrom) F  S LineChObj=LineChObj_" "_qqoto S qqoto=qW.GG("CxObj","CxObj",qqoto) Q:qqoto=""  Q:qqoto=qW.GG("CxObj","CxObj",qqofrom)  I $L(qqoto," ")>1 S:'W("Zadm") LineChObj="" Q  ;проход по потомкам и выстаивание цепочки, если потомок единственный
 .S LineChObj=$E(LineChObj,2,30000) 
 ;D ..MenuWoc("DrDrop",$S(LineChObj'="":"(с заменой объектов) ",1:"")_"Добавить "_TextMsg_"~"_$S($E(qqo)="C":"",1:$S(LineChObj'="":"(с заменой объектов) ",1:"")_"Заместить текущий экземпляр"),,1,"D qSYS.FDragDrop(10,,"""_LineChObj_""","""_qqofrom_""")")
 D:LineChObj="" ..QuestionM("Добавить "_TextMsg_$S($E(qqo)="C":"",1:"~Заместить текущий экземпляр"),,"","D qSYS.FDragDrop(11,,"""_LineChObj_""","""_qqofrom_""")","D qSYS.FDragDrop(12,,"""_LineChObj_""","""_qqofrom_""")")
 D:LineChObj'="" ..QuestionM("(с заменой объектов) Заместить текущий экземпляр на "_TextMsg,,"","D qSYS.FDragDrop(12,,"""_LineChObj_""","""_qqofrom_""")")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="TextEdit">
<Internal/>
<FormalSpec>Text:%String,Xec:%String,Capt:%String,Width:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;надо убрать есть OpenText
 S qxecute1=$G(Xec)
 I '$D(qwin("MesForm")) D ..wC("TMesForm","MesForm") S qwin("MesForm")=""
 D ..wP("MesForm","Width",$G(Width,300)),..wP(,"OnClose",1)
 D ..wP(,"Caption",$G(Capt,"Строка"))
 D ..wP(,"Text",$G(Text))
 D ..wM(,"Show")
]]></Implementation>
</Method>

<Method name="ToolbarCreateButton">
<Description>
Создание кнопки на тулбаре.
D qARM.ToolbarCreateButton(имя_тулбара,параметр1,параметр2,..)
Параметры кнопки:
№   Параметр    Значение по умолчанию

1   Name        ""
2   Caption     ""
3   Visible     0
4   Enabled     0
5   OnClick     0
6   ImageIndex  default
7   Hint        ""
8   ShowHint                    0
9   Style       0 (Default)
10  Width       default
11  Wrap        0</Description>
<Internal/>
<FormalSpec>ToolBar:%Library.String,Name:%Library.String="",Caption:%Library.String="",Visible:%Library.String=0,Enabled:%Library.String=0,OnClick:%Library.String=0,ImageIndex:%Library.String=-1,Hint:%Library.String="",ShowHint:%Library.String=0,Style:%Library.String=0,Width:%Library.String="",Wrap:%Library.String=0</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 d qARM.wM(ToolBar,"CreateButtons",Name_$C(13)_Caption_$C(13)_Visible_$C(13)_Enabled_$C(13)_OnClick_$C(13)_ImageIndex_$C(13)_Hint_$C(13)_ShowHint_$C(13)_Style_$C(13)_Width_$C(13)_Wrap_$C(13))
 q ""
]]></Implementation>
</Method>

<Method name="UserClass">
<Description>
Инициализация пользовательских классов</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 X "S qUSER=##class(qUSER).%New()"
 N class,ID S ID="" F  S ID=$O(^Q(1,"XUClass",ID)) Q:ID=""  S class=$G(^(ID)) I class'="",class'="qUSER" X "S "_ID_"=##class("_class_").%New()"
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Util">
<Description>
Служебные функции
FuncN = номер функции</Description>
<Internal/>
<FormalSpec>FuncN:%Library.String,Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 $$$FEvent
 g @("UtilL"_FuncN)
 d qARM.Message("qARM.Util: функции "_FuncN_" не существует")
 q ""

UtilL0 ;вызов как выражение с возвратом Res
 ;Arg2=Xecute
 n Res
 x Arg1
 q $G(Res)
 
UtilL5 ; Создание Arg2 узлов (по 20 кб) со случайными данными для теста скорости
 n a,i,k
 k ^mtemptst
 f i=1:1:Arg1 d
 .s a=""
 .f k=1:1:2000 s a=a_$C($R(256))_$C($R(256))_$C($R(256))_$C($R(256))_$C($R(256))_$C($R(256))_$C($R(256))_$C($R(256))_$C($R(256))_$C($R(256))
 .s ^mtemptst(i)=a
 q $NA(^mtemptst) ; имя глобала
 
UtilL6 ; получить статус аудита 
 i $p($p($zv,") ",2)," ",1)'>5.2 q -1
 n refSys,bAs,myNsp s bAs=-1
 s myNsp=$zu(5) d $zu(5,"%SYS") 
 if ##class(Security.System).Exists("SYSTEM", .refSys, .sc) s bAs=refSys.AuditEnabled
 k refSys
 d $zu(5,myNsp)
 q bAs
 
UtilL7 ; Список процессов
 n a,b,p,R,old,pqo,prod
 s old=$p($p($zv,") ",2)," ",1)<5.2
 s p="",R="|   pid |            host |      localuser |              ip |   namespace |           user |  time |  clnt ver |   RAM |"_$C(13)
 s R=R_"+-------+-----------------+----------------+-----------------+-------------+----------------+-------+-----------+-------+"
 f  s p=$O(^$J(p)) q:p=""  i ($ZCVT($ZU(67,13,p),"U")="QARM.EXE")||($ZU(67,7,p)="00") d  ; отбор процессов
 .s a=$S(p=$J:$G(qARM("Start")),1:$ZU(88,2,p,"qARM(""Start"")")) ; время старта
 .s b=$S(a="":"",1:($P($H,",")-$P(a,","))*86400+($P($H,",",2)-$P(a,",",2))\60) ; время с момента старта
 .s R=R_$C(13)_"|"_$J(p,6)_$S(p=$J:"*",1:" ") ; pid
 .s R=R_"|"_$J($ZU(67,12,p),16)_" |"_$J($ZU(67,11,p),15)_" |"_$J($ZU(67,15,p),16)_" |"_$J($ZU(67,6,p),12) ; host | localuser | ip | namespace
 .s R=R_" |"_$J($S(p=$J:$G(qARM("User")),1:$ZU(88,2,p,"qARM(""User"")")),15) ; user
 .s R=R_" |"_$S(b="":"      ",1:$J(b\60,3)_":"_$TR($J(b#60,2)," ","0")) ; time
 .s prod=$S(p=$J:$G(qARM("Ver","PRODUCT")),1:$ZU(88,2,p,"qARM(""Ver"",""PRODUCT"")"))
 .i prod="" s prod=$S(p=$J:$G(qARM("Ver","qARMProj1.ocx")),1:$ZU(88,2,p,"qARM(""Ver"",""qARMProj1.ocx"")"))
 .s R=R_" |"_$J(prod,10) ; clt ver
 .s pqo="" i 'old s pqo=##CLASS(%SYS.ProcessQuery).%OpenId(p) ; есть ##CLASS(%SYS.ProcessQuery).%OpenId(p) 
 .s R=R_" |"_$J($S(pqo'="":pqo.MemoryUsed,1:""),6)_" |" ; ram
 q R

UtilL8 ; Из массива строк в массив с разбивкой по $C(13) @dima 20110329
       ;Arg1 - имя вершины исходного массива строк
       ;Arg2 - имя вершины целевого массива
 ; в буфере 1 уровня собирается 32000 символов данных для разбора
 ; буфер 2 уровня содержит остаток строки после переноса в буфер 1 уровня
 n SRCsubn,DSTsubn,i,bufL1,bufL2 ;,MaxLen s MaxLen=14000
 s (bufL1,bufL2)=""
 k @Arg2
 s SRCsubn=$O(@Arg1@(-1))
 s DSTsubn=0
 
UtilL8m1
 ; Из входного массива в буфер 2 уровня
 i SRCsubn'="",bufL2="" d  ; если входной массив не закончился и буфер 2 уровня пуст, то
 .s bufL2=@Arg1@(SRCsubn) ; берем строку в буфер 2 уровня
 .s SRCsubn=$O(@Arg1@(SRCsubn)) ; получаем имя следующего подузла исходного массива
 ; Из буфера 2 уровня в буфер 1 уровня
 s i=32000-$L(bufL1) ; сколько переносить из 2 уровня в 1-й
 s:$L(bufL2)<i i=$L(bufL2) ; но не больше, чем есть
 s bufL1=bufL1_$E(bufL2,1,i),bufL2=$E(bufL2,i+1,99999) ; перенос
 i $L(bufL1)<32000,(bufL2'="")||(SRCsubn'="") g UtilL8m1 ; осталось место в буфере 1 уровня - повторяем, если ещё есть данные в буфере 2 уровня или исходном массиве
 ; Разбор данных из буфера 1 уровня
 s i=$F(bufL1,$C(13)) ; позиция $C(13)
 s:i=0 i=$L(bufL1)+2 ; если не найдено, берём всю строку
UtilL8m2
 s @Arg2@(DSTsubn)=$E(bufL1,1,i-2),bufL1=$E(bufL1,i,99999) ; перенос в выходной массив без $C(13)
 s DSTsubn=DSTsubn+1 ; имя следующего подузла целевого массива
 s i=$F(bufL1,$C(13)) ; позиция $C(13)
 g:i>0 UtilL8m2 ; повторяем, пока не закончатся $C(13)
 
 i SRCsubn="",bufL1="",bufL2="" q  ; конец
 g UtilL8m1
]]></Implementation>
</Method>

<Method name="VLoadData">
<Description>
Modified: @dima 20110325
Вызывается клиентом после d ..wM("-qARM","FileFastSave",Identifier,filename). Вызов напрямую - невозможен.

Параметры:
Node - имя массива с данными;
Subnode - имя предыдущего (уже обработанного) подузла. Если равно "", то выход
addCRLF - добавлять ли после каждго узла $C(13,10):
=1 - да;
=2 - да, если уже не содержится в конце строки;
=3 = нет, а если уже содержится в конце строки - не сохранять в результирующую строку;
 иначе - не затрагивать.
вывод продолжается до конца массива.

Вызывается клиентом, пока не вернет 1
Возвращает содержимое для файла в параметрах out0 по ссылке.
</Description>
<Internal/>
<FormalSpec><![CDATA[Node:%Library.String,&Subnode:%Library.String,&out0:%Library.String,addCRLF:%Library.String]]></FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.Integer</ReturnType>
<Implementation><![CDATA[
    $$$FEvent
    i 'qARM.ProjVerNotOlder(3,4,8,36) g vldOld
    
    n n,MaxLen,val s MaxLen=14000
    S out0="" 
    Q:Subnode="" 1
    s:$D(VLDnewdat)=0 VLDnewdat=""
vldLoop
    g:$L(VLDnewdat)'<MaxLen vldCont ; данных ещё хватает
    s Subnode=$O(@Node@(Subnode))
    g:Subnode="" vldCont ; был последний подузел
    ; коррекция CRLF
    s val=@Node@(Subnode) ; Можно с $G(), но безопаснее для данных - без
    i ($G(addCRLF)=3)&&($E(val,$L(val)-1,99)=$C(13,10)) s VLDnewdat=VLDnewdat_$E(val,1,$L(val)-2)
    e  s VLDnewdat=VLDnewdat_val_$S($G(addCRLF)=1||(($G(addCRLF)=2)&&($E(val,$L(val)-1,99999)'=$C(13,10))):$C(13,10),1:"")
vldCont    
    s n=MaxLen-$L(out0) ; оставшееся место в выходном значении
    s out0=out0_$E(VLDnewdat,1,n) ; добавляем к значению
    s VLDnewdat=$E(VLDnewdat,n+1,1048576) ; что не влезло
    q:$L(out0)'<MaxLen -1 ; выход, если выходное значение заполнено
    i Subnode="",VLDnewdat="" q 1 ; был последний подузел и данные кончились
    g vldLoop
    
vldOld
    N i S i=$G(@Node) Q:i="" 1
    S out0="" F  S out0=out0_$G(@Node@(i)),i=$O(@Node@(i)) Q:i=""  Q:15000-$L(out0)<$L(@Node@(i))
    S @Node=i Q -1
]]></Implementation>
</Method>

<Method name="Value">
<Description>
Вычисление выражения или выполнение по Xecute (если Arg2="X")
В варианте Xecute, в переменную XQend записывается возвращаемое значение.</Description>
<Internal/>
<FormalSpec>ArgV1:%String,ArgV2:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $G(ArgV1)="" Q:$Q "" Q 
 S:$E(ArgV1)="@" ArgV1=..Value($E(ArgV1,2,32000)) Q:$G(ArgV2)'="X" @ArgV1 N XQend X ArgV1 Q:$Q $G(XQend) Q
]]></Implementation>
</Method>

<Method name="Valueer">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 ;D ..Message("Ошибка "_$TR($ZE,"<>","  ")_$C(13,10)_"в выражении:"_$C(13,10)_$G(Arg1)) S $EC="" Q  ;$ET=""
 s xxxmax=$st(-1),xxxstr="" f xxxi=5:1:xxxmax-1 S xxxstr=xxxstr_$C(13,10)_$P($st(xxxi,"place"),"ooLibrary.")_$P($st(xxxi,"place"),"ooLibrary.",2)_" "_$P($st(xxxi,"mcode")," ",2,30000) ;S:$st(xxxi,"ecode")'="" xxxstr=xxxstr_"***> "_$st(xxxi,"ecode")
 D qARM.Message(xxxstr,"Ошибка "_$E($P($ZE,">"),2,255)_" в выражении: "_$G(Arg1))
 Q ""
]]></Implementation>
</Method>

<Method name="VerCall">
<Description>
          Возвращает через пробел допустимые для вызываемого отображения qqc и объект.</Description>
<Internal/>
<FormalSpec>view:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $E(view,1,3)="XXX" Q qqc_" "_$$$CurObj
 N qqob,i,qqo S qqob=$$$ObjRef($$$CurObj)
 F i=$L(qqob,","):-1:1 S qqo=$P(qqob,",",i) Q:$D(^Q(1,"XView",view,"CxObj",qqo))
 Q $E(qqc,1,$$$ObjLqqc(qqo))_" "_qqo
]]></Implementation>
</Method>

<Method name="ViEdit">
<Description>
         Визуализация режима редактирования.</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 D  ;@Dol 11.04.08
 .I $P($G(Vo(qqnump,-1,55)),",",11,12)'="," D ..GridColor() Q 
 .D:"04"[Vo(qqnump,-1,61) ..GridColor($S(W("ZBtred"):180,1:-2147483632))
 D:'$G(W("Zsform"))||("12"'[(W("Zsform")#10)) ..wP(qwin_".TBR","Visible",W("ZBtred")),..wP(qwin_".TBM.b21","Down",W("ZBtred"))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Virt">
<Description>
Заполнение Vs(qqnump,"Virt",qqo) для текущей позиции в дереве экземпляров
Arg1=1 - по массиву Vc. qqci - если не задано - Vc(qqnump)
Arg1=0 - по объектной ссылке</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,qqci:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Arg1) D  Q:$Q "" Q  ;@dol 2.2.04
 .S:$G(qqci)="" qqci=$G(Vc(qqnump)) I qqci="" Q  ;@Dol 20.07.08
 .K Vs(qqnump,"Virt") N qc,ii,jj F ii=$L(qqci):-2:2 S qc=$E(qqci,1,ii) I $D(Vc(qqnump,qc)) S Vs(qqnump,"Virt",Vc(qqnump,qc,0))=Vc(qqnump,qc) D:$G(Vc(qqnump,qc,6))'=""
 ..F jj=1:2:$L(Vc(qqnump,qc,6),"~") S Vs(qqnump,"Virt",$P(Vc(qqnump,qc,6),"~",jj))=$P(Vc(qqnump,qc,6),"~",jj+1)
 N qqob,qqobi S qqob=$$$ObjRef($$$CurObj) F qqobi=$L(qqob,","):-1:1 I $G(Vo(qqnump,$P(qqob,",",qqobi),2)) S Vs(qqnump,"Virt",$P(qqob,",",qqobi))=$G(Vc(qqnump,$E(Vc(qqnump),1,qqobi*2)))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Wait">
<Description>
Если Arg3 не задан:
Выполнить Arg1 после завершения текущего события.
Используется для выполнения действия вне рамок текущего события 
(например, удаление/перевывод  узлов дерева экземпляров из события дерева экземпляров:
D qARM.Wait("D qARM.wcre()" )

Если Arg3 задан:
Выполнить действие _В_CACHE'_ (длительное), во время которого пользователю
демонстрируется анимационная заставка (часы). Во время работы клиентских методов
заставки не будет!
Arg3 - текст окна заставки.

Arg2 - оставлен для совместимости.</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $D(Arg3) D ..wM("-qARM","WaitExec",$G(Arg1),$G(Arg3)) Q:$Q "" Q  ;@Dol 16.09.06
 i ..ProjVerNotOlder(3,7,6,34) N actn S actn=$G(Arg1) D:actn'="" ..wM("-qARM","Wait",actn) Q:$Q "" Q  ;@Dima 29.06.07
 S qqxoevent=$G(Arg1) D ..wM("-qARM","UserEvent",1) Q:$Q "" Q  ;@Dima 24.02.05
]]></Implementation>
</Method>

<Method name="WrWin">
<Description>
вывод в окно - потомок.
Параметры:
- qqpar1 - qqnump потомка (если пусто, то потомок - определяется автоматически по переменной qqParent).
- qqpar2 - 1 - перенести фокус на потомка.
- qqpar2 - 2 -без переноса фокуса
- qqpar3 - список кодов переносимых и выводимых понятий (qqwchg корректируется). Значения должны быть в массиве W. Автоматически вызывается коррекция.
- qqpar4 - имя qWORD - метода (например, luse, wcre и т.п.), выполняемой в контексте окна-потомка.
признак модификации базы W("Zbasmod") в методе может быть проанализирован через переменную basmod.</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String,qqpar3:%String,qqpar4:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N basmod S basmod=$G(W("Zbasmod")) ;перенос признака модификации базы
 S qqpar1=$S(qqpar1'="":qqpar1,1:$P($G(Vt(qqnump,"Zparent")," x")," ",2)) ;@dol 5.02.03 было qqParent
 I '$D(WS(qqpar1)) Q "Нет родителя"
 N qqew,qqew1,qqwch S qqwch="" F qqew=1:1:$L($G(qqpar3)," ") S qqew1=$P(qqpar3," ",qqew) I qqew1'="",$E(qqew1)'="@" D
 .K WS(qqpar1,qqew1) M WS(qqpar1,qqew1)=W(qqew1) S qqwch=qqwch_" "_qqew1
 I $G(qqwch)'="" S WS(qqpar1,"Zvars","qqwchg")=$G(WS(qqpar1,"Zvars","qqwchg"))_" "_qqwch
 S qqew=qqnump D ..crst(1,qqpar1,1)
 D:$G(qqpar3)'=""
 .N qqred S qqred="" D ..wwww(qqpar3,1) D:qqwch'="" ..RecCor(,,0) ;откорректировать без изменения даты времени;@dol 18.12.03 D ..wwww(qqpar3)
 I $G(qqpar4)'="" D
 .I $P(qqpar4,".")'="",$P(qqpar4,".")'[" " D @qqpar4 Q
 .X qqpar4
 I qqpar2=2 D ..crst(1,qqew,3) Q:$Q "" Q    //@sasha 20080624
 I 'qqpar2 D ..crst(1,qqew,2) Q:$Q "" Q
 D:"PQ"'[qqnump ..wM("Q"_qqnump_".T2","SetFocus") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Xecute">
<Description><![CDATA[
Выполнение действия или получить значение выражения в %gXstr1.

Специальный формат %gXstr1:
zSet[имя переменной]   ->   S переменная=%gXstr2
zSXt[имя переменной]_" "_[действие]   ->   S переменная=%gXstr2 X действие
zSNt[имя переменной]_" "_[действие]   ->   N переменная S переменная=%gXstr2 X действие
zAct[имя переменной]_" "_[действие]   ->   N переменная(ые) X действие Q @%gXstr2 (выражение). Пример: <<Xecute('zActN,P s N=$R(10),P=N+1','N_P')>> работает как <<n N,P x "s N=$R(10),P=N+1" q N_P>>
?[выражение] - получение значения выражения, в случае ошибки текст ошибки возвращается вместо значения. @dima 20100723
|[действие] - выполнить действие, в случае ошибки текст ошибки возвращается как результат @dima 20100728
Если первый символ "\", $$$FEvent не делается @ 20110111]]></Description>
<Internal/>
<FormalSpec>%gXstr1:%String,%gXstr2:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 i $E(%gXstr1)="\" s %gXstr1=$E(%gXstr1,2,32768)
 e  $$$FEvent
 i %gXstr1="zNpr" d  Q:$Q "" Q
 .k qprotsto s qprotsto(1)=$G(%gXstr2)
 ;.n ln s ln=$G(qprotstr,32764) k qprotstr,qprotsto s qprotsto(1)=$G(%gXstr2),qprotstr=ln
 i $E(%gXstr1,1,4)="zSXt" s @$P($E(%gXstr1,5,32767)," ")=$G(%gXstr2),%gXstr1=$P(%gXstr1," ",2,32768) ;zSet+Xecute
 i $E(%gXstr1,1,4)="zSNt" n %gNvar s %gNvar=$P($E(%gXstr1,5,32768)," ") n @%gNvar s @%gNvar=$G(%gXstr2),%gXstr1=$P(%gXstr1," ",2,32768) ;New+zSet+Xecute
 i $E(%gXstr1)="=" Q @$E(%gXstr1,2,32768) ;@dol 1.09.03 ???n ret s @("ret="_$E(str,2,$L(str))) q ret
 i $E(%gXstr1,1,4)="zSet" s @$E(%gXstr1,5,32767)=$G(%gXstr2) Q:$Q "" Q  ;@DimaB запись данных из par2 в переменную
 i $E(%gXstr1,1,4)="zAct" n %gNvar s %gNvar=$P($E(%gXstr1,5,32768)," ") n @%gNvar x $P(%gXstr1," ",2,32768) q @%gXstr2 ;@DimaB 20081118
 i $E(%gXstr1)="?" n res d  q res
 .n $ET,$ES s $EC="",$ET="s res=$ZE,$EC="""" q:$Q res q"
 .s @("res="_$E(%gXstr1,2,32768))
 i $E(%gXstr1)="|" n res s res="" d  q res
 .n $ET,$ES s $EC="",$ET="s:$ES>0 res=$ZE,$EC="""" q:$Q res q"
 .x $E(%gXstr1,2,32768)
 x %gXstr1 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="crst">
<Description>
восстановить текущее состояние из WS 
qqpar1=1 - сохранить контекст текущего окна ( аналог вызова ..csav() )
qqpar2 - qqnump восстанавливаемой экранной формы
Arg1 =1 - восстановить и указатель окна - переменную qwin.
Arg1=3 аналог 2 только без "SetFocus"</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String,Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(qqnump)=qqpar2 Q:$Q "" Q
 N vars,var,i S vars="qqw,qqnump,qqwchg,qqzsav,qqred,qqtime,qqp4,qqp5,qqp6,qqlang,qql,qview,qqllang,qqRES,qqP1,qruls" ;qUSER" ;@dol 20.10.02 qqWS, - изьято
 I $G(qqpar1) K WS(qqnump) S $$$ID=$G(qqc) M WS(qqnump)=W F i=1:1:$L(vars,",") S var=$P(vars,",",i),@("WS(qqnump,""Zvars"",var)=$G("_var_")")
 S:'$D(WS(qqpar2,"Zvars","qqnump")) qqpar2=1/0  F i=1:1:$L(vars,",") S var=$P(vars,",",i),@(var_"=$G(WS(qqpar2,""Zvars"",var))")
 K WS(qqpar2,"Zvars"),W M W=WS(qqpar2) K WS(qqpar2)
 S qqc=$G($$$ID),qqo=$G($$$CurObj) ;@Dol 27.12.07 восстановление qqo
 I $G(Vt(qqnump,"Znsp"))'="",Vt(qqnump,"Znsp")'=$ZU(5) D
 .ZN Vt(qqnump,"Znsp") X "S qUSER=##class(qUSER).%New()"
 .D qSYS.BaseIni() ;смена NameSpace
 S:$G(Arg1) qwin="Q"_qqnump ;@Dol 26.06.05
 I $G(Arg1)=3,$D(qwin(qwin)) D ..wP(qwin,"Visible",1)   //@sasha 20080624
 I $G(Arg1)=2,$D(qwin(qwin)) D ..wP(qwin,"Visible",1) D:$P($G(Vo(qqnump,-1,29)),",",19)=""||($P($G(Vo(qqnump,-1,29)),",",19)="TFormTree") ..wM(qwin_".T"_($P($G(Vo(qqnump,-1,29)),",",3)'="100%"+1),"SetFocus")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="csav">
<Description>
Сохранить текущее состояние экранной формы в WS.</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N vars,var,i S vars="qqw,qqnump,qqwchg,qqzsav,qqred,qqtime,qqsdrb,qqp4,qqp5,qqp6,qqlang,qql,qview,qqllang,qqRES,qqP1,qruls" ;qUSER" ;;@dol 20.10.02 qqWS, - изьято
 K WS(qqnump) M WS(qqnump)=W F i=1:1:$L(vars,",") S var=$P(vars,",",i),@("WS(qqnump,""Zvars"",var)=$G("_var_")")
 S $$$ID=$G(qqc) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="getPrintParam">
<Description>
получение параметра печати - без записи в Vo</Description>
<Internal/>
<FormalSpec>view:%String,X130:%String,param:%String,NoWind:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 new set set set = ""
 new value
	
 if $get(NoWind), NoWind '< 10 do  quit value
 .;set set = +$get(Vo(qqnump, -1, 30))
 .set value = $get(Vo(qqnump,-1, 3, param))
 
 set X130 = $get(X130)
 if X130 '= "" do
 .if $length(X130, ":") > 1 set view = $piece(X130, ":", 1) set set = +$piece(X130, ":", 2) quit
 .set set = X130
  	
 new viewObj set viewObj = $select(view '[ $char(1): "XView", 1: $piece(view, $char(1), 1))
 new viewInst set viewInst = $select(view '[ $char(1): $S(view '= "": view, 1: Vo(qqnump)), 1: $piece(view, $char(1), 2))
 if (viewInst [ " ") set viewInst = $piece(viewInst, " ")
 
 
 if set = "" set set = +$get(^Q(1, viewObj, viewInst, "X130"))
 set value = $get(^Q(1, viewObj, viewInst, "XPrint", set, param))
  
 quit value
]]></Implementation>
</Method>

<Method name="getst">
<Description>
Возвращает состояние стека или (при vars=1, только из обработчика ошибки!) список переменных.
NB! в GT.M не возвращается +НомерКомандыВстроке (проверено в GT.M V4.4-002SPARM-06B3 Linux x86)
@Alex+Dima</Description>
<Internal/>
<FormalSpec>zgetstvars:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 i '$G(zgetstvars) g getstStc 
 i $D(%grtn)||$G(qqXBErrETN)||'$D(qARM("CntStr")) q "" ; GManager или флаг "BACK^%ETN" или не осн.поток - выходим @dima 20100917
 n zgetstres
 d getstParse($ST($ST(-1)-2,"MCODE"))
 s zgetstres=""
 n zgetsta s zgetsta="" f  s zgetsta=$O(zgetstres(zgetsta)) q:zgetsta=""  i '$ZU(62,1,"s o="_zgetsta) s zgetstres=zgetstres_$C(13,10)_zgetsta_"="_$$getstValue(zgetsta)
 q zgetstres
getstValue(zgetstref)
 n zgetstm s $ZT="getstTestEr"
 s @("zgetstm="_zgetstref)
 q $S($L(zgetstm)>512:$E(zgetstm,1,507)_"<...>",1:zgetstm)
getstTestEr
 s $ZT="",zgetstm=$P($ZE,">",1)_">" ;,$EC=""
 q zgetstm
getstParse(line)
 n curvar,i,quote,skoblevel,skip,varnow,tmpup
 s line=line_" "
 s curvar="",quote=0,skoblevel=0,skip=0,varnow=0
 f  q:(line="")!$$getstSym($E(line))!($E(line)="""")  s $E(line)=""  ; все до первого значимого символа удаляются
 f i=1:1:$L(line) d
 .i $E(line,i)="""" s quote='quote
 .d:'quote
 ..i varnow,$E(line,i)="(" s skoblevel=skoblevel+1
 ..i $E(line,i)=")",skoblevel>0 s skoblevel=skoblevel-1 i varnow,skoblevel=0 s curvar=curvar_$E(line,i)
 ..i 'varnow,$$getstSym($E(line,i)),'$$getstSym($E(line,i-1)),$E(line,i)'?1N s varnow=1 //начало перем.
 ..i varnow d
 ...i $$getstSym($E(line,i))!(skoblevel>0) s curvar=curvar_$E(line,i)
 ...;i $E(line,i)="@" d
 ...;.i curvar="@" s curvar="" 
 ...;.e  s skip=1
 ...i $E(line,i)="." d
 ....i curvar=".",$E(line,i-1)'="." s curvar="" 
 ....e  s skip=1
 ...i $E(line,i)="^",$$getstSym($E(line,i-1))!$E(line,i+1)="(" s skip=1
 ...i $E(line,i-1)="$" d
 ....i $E(line,i)="$" s skip=1
 ....s tmpup=$E(line,i),tmpup=$S($A(tmpup)>90:$C($A(tmpup)-32),1:tmpup)
 ....i '(("PEACFLSDGH"[tmpup)&'$$getstSym($E(line,i+1))) s skip=1
 ....i "GC"[tmpup,$L(curvar)<3 s skip=1
 .i quote,varnow s curvar=curvar_$E(line,i)
 .i 'quote,skoblevel=0,curvar'="",'$$getstSym($E(line,i)) d  //конец переменной
 ..i 'skip,$L(curvar)<250 s zgetstres(curvar)=""
 ..i curvar["(" d getstParse($P(curvar,"(",2,1000))
 ..s curvar="",varnow=0,skip=0
 q  
getstSym(c)
 q ($L(c)>0)&("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$%^.|"[c)
getstStc
 n zzzztemp,zzzzloop,zzzzStEnd
 s zzzztemp=$C(13,10)_"== next cmd call stack: ==",zzzzStEnd=$STACK(-1)-2
 for zzzzloop=$G(zzzzStLv,1):1:zzzzStEnd s zzzztemp=zzzztemp_$C(13,10)_":"_$STACK(zzzzloop,"PLACE")_"~"_$zstrip($STACK(zzzzloop,"MCODE"),"<W")
 q zzzztemp
]]></Implementation>
</Method>

<Method name="mImpOp">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 d qARM.Message("ok")
 q ""
]]></Implementation>
</Method>

<Method name="oneWin">
<Description><![CDATA[
Действие по входу в отображение - если данное окно открыто, то установка на него фокуса 041007 sasha & pavel]]></Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 ;Обход открытых окон
 n qw,qqnumpF s qw=""
 f  {
 s qw=$o(qwin(qw))
 q:qw=""
 s qqnumpF=$s($e(qw)="Q":$p(qw,"Q",2),1:"")
 i (qqnumpF'="")&&(qqnumpF'=qqnump)&&($g(Vo(qqnumpF))=$g(Vo(qqnump))) s qqend=1 d qARM.Wait("d qARM.wP(""Q"_qqnumpF_""",""WindowState"",0) d qARM.wM(""Q"_qqnumpF_".T2"",""SetFocus"")")
 }
 q ""
]]></Implementation>
</Method>

<Method name="qARMFont">
<Description><![CDATA[
Изменения фонта приложения ;@Dima&Dol 24.07.09]]></Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[ S:'$P(qqX155,",",2) $P(qqX155,",",2)=8 D qARM.wP("-qARM","HintFont"," "_$P(qqX155,",",2)),qARM.wP("-qARM","MenuFont"," "_$P(qqX155,",",2)) Q  ;@Dol 18.09.09 неверно "F"_(+$P(qqX155,",",1))_
]]></Implementation>
</Method>

<Method name="qqtime">
<Description><![CDATA[
@Dol 19.07.09 ||($E($G(^("X")),1,2)=$E($G(Vc(qqnump,Vc(qqnump),5)),1,2)&&($E($G(^("X")),6,255)=$E($G(Vc(qqnump,Vc(qqnump),5)),6,255))) - анализ на тот же день и того же пользователя.??может корректнее и разницу времен анализировать? $ZLA($RE($E(qqtm,3,5))_$C(0))
@ank 20101101 Новый алгоритм запаковки\распаковки дат, коррекция метода.]]></Description>
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 Q:$G($$$Tree) "" Q:$G(Vo(qqnump))="XXXX" "" ;@dol 22.10.02 для проводника сложности с вызовом и редактированием отображения
 Q:Arg1=-1||($G(qqc)="") "" Q:$G(Vo(qqnump,Arg1,2))>2 "" Q:$G(Vc(qqnump))="" "" ;Q:Arg1'?1.N ""
 I $E(Arg1)="v" Q:$G(^Q(1,$E(Arg1,3,255),qqc,"X"))=$G(Vc(qqnump,Vc(qqnump),5))||($S($E($G(^("X")),1,2)=$C(0,0):$E($G(^("X")),3,5),1:$E($G(^("X")),1,2))=$S($E($G(Vc(qqnump,Vc(qqnump),5)),1,2)=$C(0,0):$E($G(Vc(qqnump,Vc(qqnump),5)),3,5),1:$E($G(Vc(qqnump,Vc(qqnump),5)),1,2))&&($E($G(^("X")),$S($E($G(^("X")),1,2)=$C(0,0):9,1:6),255)=$E($G(Vc(qqnump,Vc(qqnump),5)),$S($E($G(Vc(qqnump,Vc(qqnump),5)),1,2)=$C(0,0):9,1:6),255))) "" I $D(Vo(qqnump,$E(Arg1,3,255))) N end S end=0 D  Q:end=2 ""  ;если объект-синоним, то найдем сам объект и проверим для него
 .N qqci S qqci="" F  S qqci=$O(Vc(qqnump,qqci)) Q:qqci=""  I Vc(qqnump,qqci,0)=$E(Arg1,3,255),Vc(qqnump,qqci)=qqc S end=$G(Vc(qqnump,qqci,5))=$G(^Q(1,$E(Arg1,3,255),qqc,"X"))||($S($E($G(^("X")),1,2)=$C(0,0):$E($G(^("X")),3,5),1:$E($G(^("X")),1,2))=$S($E($G(Vc(qqnump,Vc(qqnump),5)),1,2)=$C(0,0):$E($G(Vc(qqnump,Vc(qqnump),5)),3,5),1:$E($G(Vc(qqnump,Vc(qqnump),5)),1,2))&&($E($G(^("X")),$S($E($G(^("X")),1,2)=$C(0,0):9,1:6),255)=$E($G(Vc(qqnump,Vc(qqnump),5)),$S($E($G(Vc(qqnump,Vc(qqnump),5)),1,2)=$C(0,0):9,1:6),255)))+1
 I $E(Arg1)'="v" Q:$G(^Q(1,Arg1,qqc,"X"))=$G(Vc(qqnump,Vc(qqnump),5))||($S($E($G(^("X")),1,2)=$C(0,0):$E($G(^("X")),3,5),1:$E($G(^("X")),1,2))=$S($E($G(Vc(qqnump,Vc(qqnump),5)),1,2)=$C(0,0):$E($G(Vc(qqnump,Vc(qqnump),5)),3,5),1:$E($G(Vc(qqnump,Vc(qqnump),5)),1,2))&&($E($G(^("X")),$S($E($G(^("X")),1,2)=$C(0,0):9,1:6),255)=$E($G(Vc(qqnump,Vc(qqnump),5)),$S($E($G(Vc(qqnump,Vc(qqnump),5)),1,2)=$C(0,0):9,1:6),255))) "" ;@Dol 19.07.09 ||($E
 I $G(Vc(qqnump,Vc(qqnump),5))="",$G(W("ZBtredo"))'=$G(W("ZBtred")) Q "" ;@Dol 27.09.06 видимо было переключение режима
 D:'$D(Vo(qqnump,-1,200)) ..GetPar("X1200") I Vo(qqnump,-1,200)'="" N qqend,qqo,qqt S qqo=Arg1,qqt=2 X Vo(qqnump,-1,200) I $D(qqend),qqend'=-1 Q qqend
 S qqwchg="" D:$S(Vo(qqnump,-1,200)'="":$G(qqend)'=-1,1:1) ..Message("Корректируемая запись изменена пользователем "_$E($G(^Q(1,Arg1,qqc,"X")),$S($E($G(^Q(1,Arg1,qqc,"X")),1,2)=$C(0,0):9,1:6),255)_$S('W("Zadm"):"",1:" qqo="_Arg1_" qqc="_qqc_" qqci="_Vc(qqnump)_" "_Vo(qqnump)_" "_$E($G(^Q(1,Arg1,qqc,"X")),$S($E($G(^Q(1,Arg1,qqc,"X")),1,2)=$C(0,0):9,1:6),255)_" "_$E($G(Vc(qqnump,Vc(qqnump),5)),$S($E($G(Vc(qqnump,Vc(qqnump),5)),1,2)=$C(0,0):9,1:6),255)))
 D ..wqqotree(Vc(qqnump)) Q 1
 ;D ..wcre() Q 1
]]></Implementation>
</Method>

<Method name="s112">
<Description>
Вызов развертки.(только как функция)</Description>
<Internal/>
<FormalSpec>qqstr:%String,qqtr:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $D(qqstr) S W(qqred)=qqstr ;???
 S qqtr=$G(qqtr,2) ;дерево
 K W("Zpdrl") I qqtr=1 N qqw S qqw="ZfI9" Q:qqred="" "" Q:$G(W("Zpos",1,"x"))'=1&('W("ZBt0")) ""
 I W("Zcdrl")<0 Q "" ;qqred=""???
 I 'W("Zcdrl")!(+W("Zcdrl")=4)!(+W("Zcdrl")=5) S %2=$P(W("Zcdrl")," ",2) S:'%2 $P(W("Zcdrl")," ",2)=2 Q:+W("Zcdrl")=4 "" D  Q ""
 .S:$P(W("Zdrl")," ")["qUSER." @("$P(W(""Zdrl""),"" "")="_$P(W("Zdrl")," ")) ;@Dol 29.12.07
 .I $P(W("Zdrl")," ")["::" D  Q  ;@Dol 29.12.07
 ..N qqCCq,qqc0,qqw,qqc,qqo,Z
 ..S qqw=$P($P($P(W("Zdrl")," ",1),";",2),","),qqo=$P(qqw,":",1),qqw=$P(qqw,":",2)
 ..S qqc0=$P($P($P($P(W("Zdrl")," ",1),";"),"::",2),",")
 ..K W("Zldrl") S qqc="" F  S qqc=qW.UserOrd(1,qqo,qqc,$P(qqc0,"!")) S:qqc="" qqc0=$P(qqc0,"!",2,255) Q:qqc0=""&&(qqc="")  I qqc'="" S Z=qW.G(qqw) D:Z'=""
 ...I $P(W("Zdrl")," ",6)'="" S qqCCq=0 D  Q:'qqCCq
 ....I @$P(W("Zdrl")," ",6) S qqCCq=1
 ...S W("Zldrl")=$S($D(W("Zldrl")):W("Zldrl")_"~"_Z,1:Z)
 ..S W("Zldrl")=$G(W("Zldrl")) ;@Dol 09.03.11
 ..S:+W("Zcdrl")=5 W("Zldrl")="~"_W("Zldrl")
 .D s112Zdrl S:$P(W("Zdrl")," ")="" $P(W("Zdrl")," ")=qqw
 .K W("ZWs") I $P(W("Zcdrl")," ",2)=2 S %1=$G(W(qqw)),%2=$L(%1," ") S:%1'="" W("ZWs")=$P(%1," ",1,%2-1),W(qqw)=$P(%1," ",%2)
 .;Zndrl - вроде лишняя (только здесь???)
 .S %1=$S(+W("Zcdrl")=5:1000,1:$S(+$P(W("Zdrl")," ",9):+$P(W("Zdrl")," ",9),1:100)) D qW.qWoc(1,$P(W("Zdrl")," ")_" "_$S(+W("Zcdrl")=5:"",$G(^Q(1,"C"_$P(W("Zdrl")," ")))="":$G(W(qqw)),%1>^Q(1,"C"_$P(W("Zdrl")," ")):"",1:$G(W(qqw)))_" "_$P(W("Zdrl")," ",3,6),%1,%1,$P(W("Zdrl")," ",7),"Zldrl")
 .S:+W("Zcdrl")=5 W("Zldrl")="~"_W("Zldrl")
 .S:'W("Zcdrl") W("Zpdrl")=1
 ;I +W("Zcdrl")=1 S Vo("par",-1,29)=",,0,1,,,@,@",Vo("par",-1,62)=1 D ..OpenWindow(,,,,,$E(qview,1,3)_"sysW"_$S($P(W("Zldrl")," ")'="":$P(W("Zldrl")," "),1:qqw)) Q "" ;словарь-экран
 I +W("Zcdrl")=1 D  Q "" ;словарь-экран
 .N qqwr S qqwr=$$s112Scr() S W("Zldrl")=W("Zdrl") S:qqwr'="" Vo("par",-1,67)=qqwr ;постоянные условия
 .S qqwr=$S($P(W("Zldrl")," ")'="":$P(W("Zldrl")," "),$E(qqw,1,3)="ZZR":$E(qqw,4,30),1:qqw) S:$E(qqwr,$L(qqwr))=":" qqwr=qqwr_qqw
 .S Vo("par",-1,29)="200,200,0,"_$S($P(W("Zdrl")," ",10):11,1:10)_",,"_$S($P(W("Zdrl")," ",15)="":"1,,",1:$P($P(W("Zdrl")," ",15)_",,",",",1,3))_","_$S('$P(W("Zdrl")," ",10):"9,0,3",$P(W("Zdrl")," ",10)=2:",0,3",1:",0,3")_",0,"_$S($P(W("Zdrl")," ",13)=1:0,1:2),Vo("par",-1,62)=1 ;1:"1,0")
 .S:$P(W("Zdrl")," ",20) Vo("par",-1,55)=",,,-16777212",$P(Vo("par",-1,29),",",11)=0,$P(Vo("par",-1,29),",",13)=1 ;$P(W("Zdrl")," ",20) S:$P(W("Zdrl")," ",21)'="" $P(Vo("par",-1,29),",",13)=$P(W("Zdrl")," ",21) ;@Dol 20.07.05 обрамления
 .S Vo("par",-1,61)=5 ;S:$P(W("Zdrl")," ",13)'=1 Vo("par",-1,88)=0
 .S Vo("par",-1,88)=$S($P(W("Zdrl")," ",13)#2:1,$P(W("Zdrl")," ",20):2,1:0)  
 .S Vo("par",-1,80)=1,Vo("par",-1,65)=1
 .S Vo("par",-1,74)="@ZXXHR0 @ZXXHR0 @ZXXHR0" ;замещение пояснений
 .S:$P(W("Zcdrl")," ",2)'=1 Vs("par","CondEnd")=1 ;@Dol 2.09.05 если развертка-редактирование, то выход при несовпадении побуквенного уточнения (см. OnKeyPress метка OnKeyPE)
 .S Vo("par",-1,72)=$S(qqwr'[":":"3 C",1:$S($P(W("Zdrl")," ",12)[";":"2 ,",1:"3 ")_$P(qqwr,","))_$P(W("Zdrl")," ",12)
 .S Vo("par",-1,0,0,0)=..GetPar("X7100",,qqo,qqw) S:Vo("par",-1,0,0,0)'="" Vo("par",-1,0,0,0)=0_Vo("par",-1,0,0,0) ;имя в отображении @Dol 12.01.05 0_
 .S:$P(W("Zdrl")," ",8) Vo("par",$S(qqwr[":":$P(qqwr,":"),1:qqwr),0,0,0,2)=$P(W("Zdrl")," ",8)
 .S:$P(W("Zdrl")," ",9) Vo("par",-1,60)=+$P(W("Zdrl")," ",9)
 .S:$P(W("Zdrl")," ",10)=1 Vo("par",-1,3)=1,Vo("par",-1,60)=500 ;полный вывод
 .S:$P(W("Zdrl")," ",10)=2 Vo("par",-1,231)=1,$P(Vo("par",-1,29),",",17)=0 ;@Dol 14.08.06 склолбар перемещений;@dol 8.5.04 указатель перемещения
 .I $P(W("Zdrl")," ",11) S Vo("par",-1,0,1)=1,Vo("par",-1,0,1,0,42)=..GetPar("x742",,qqo,qqw),Vo("par",-1,0,1,0,43)=..GetPar("x743",,qqo,qqw) ;ред. знач 
 .S:$P(W("Zdrl")," ",13)&&($P(W("Zdrl")," ",13)<3) Vo("par",-1,230)=1 ;НЕ включать сортировку (обработка в qSYS.sysView sysR)
 .S:$P(W("Zdrl")," ",19) Vs("par",99,"Revers")=1 ;реверс
 .S:$G(qqXB1720) Vo("par",-1,720)=1 ;@Dol 13.02.06 кнопки выхода
 .S:$P(W("Zdrl")," ",22)'="" Vo("par",-1,720)=$P(W("Zdrl")," ",22) ;@Dol 05.04.06 параметр Кнопки выхода
 .S:$P(W("Zdrl")," ",23)'="" Vo("par",-1)=$P(W("Zdrl")," ",23) ;;@Dol 05.04.06 Заголовок окна
 .S:$P(W("Zdrl")," ",24) Vo("par",-1,"x710")=..GetPar("x710",,qqo,qqw) ;@Dol 07.05.08 наследование типа данных
 .D ..OpenWindow(,,,,,$E(qview,1,3)_"sysR"_qqwr)
 I +W("Zcdrl")=21 D  Q "" ;словарь-экран с множественным выбором ;@dol 25.02.03 $P(W("Zdrl")," ",16) - разделитель
 .N qqwr S qqwr=$$s112Scr() S W("Zldrl")=W("Zdrl") S:qqwr'="" Vo("par",-1,67)=qqwr ;постоянные условия
 .S qqwr=$S($P(W("Zldrl")," ")'="":$P(W("Zldrl")," "),$E(qqw,1,3)="ZZR":$E(qqw,4,30),1:qqw) S:$E(qqwr,$L(qqwr))=":" qqwr=qqwr_qqw
 .S Vo("par",-1,29)="200,200,0,"_$S($P(W("Zdrl")," ",10):11,1:10)_",,"_$S($P(W("Zdrl")," ",15)="":"1,,",1:$P($P(W("Zdrl")," ",15)_",,",",",1,3))_","_$S('$P(W("Zdrl")," ",10):"9,0,3",1:",0,3")_",0,2",Vo("par",-1,62)=1
 .S Vo("par",-1,61)=5,Vo("par",-1,80)=0 ;S:$P(W("Zdrl")," ",13)'=1 Vo("par",-1,88)=0 ;@dol 15.02.04 было '$P(W("Zdrl")," ",13)
 .S:$P(W("Zdrl")," ",20) Vo("par",-1,55)=",,,-16777212",$P(Vo("par",-1,29),",",11)=0,$P(Vo("par",-1,29),",",13)=1
 .S Vo("par",-1,88)=$S($P(W("Zdrl")," ",13)#2:1,$P(W("Zdrl")," ",20):2,1:0)
 .S Vo("par",-1,72)=$S(qqwr'[":":"4 C",1:"4 "_$P(qqwr,","))_$P(W("Zdrl")," ",12)_$S($P(W("Zdrl")," ",16)="":"",1:" "_$P(W("Zdrl")," ",16)),Vo("par",-1,73)=0
 .S Vo("par",-1,74)="@ZXXHR1 @ZXXHR1 @ZXXHR1" ;замещение пояснений
 .S Vo("par",-1,0,0,0)=..GetPar("X7100",,qqo,qqw) S:Vo("par",-1,0,0,0)'="" Vo("par",-1,0,0,0)=0_Vo("par",-1,0,0,0) ;имя в отображении
 .S Vo("par",-1,65)=1
 .S Vo("par",$S(qqwr[":":$P(qqwr,":"),1:qqwr),7)="ZTMPN" ;@dol 4.03.03 доп понятия, чтобы вернуть в порядке выбора
 .S:$P(W("Zdrl")," ",8) Vo("par",$S(qqwr[":":$P(qqwr,":"),1:qqwr),0,0,0,2)=$P(W("Zdrl")," ",8)
 .S:$P(W("Zdrl")," ",9) Vo("par",-1,60)=+$P(W("Zdrl")," ",9)
 .S:$P(W("Zdrl")," ",10)=1 Vo("par",-1,3)=1,Vo("par",-1,60)=500 ;полный вывод
 .S:$P(W("Zdrl")," ",10)=2 Vo("par",-1,231)=1,$P(Vo("par",-1,29),",",17)=0 ;@Dol 14.08.06 склолбар перемещений; ;@dol 8.5.04 указатель перемещения
 .I $P(W("Zdrl")," ",11) S Vo("par",-1,0,1)=1,Vo("par",-1,0,1,0,42)=..GetPar("x742",,qqo,qqw),Vo("par",-1,0,1,0,43)=..GetPar("x743",,qqo,qqw) ;ред. знач 
 .S:$P(W("Zdrl")," ",13)&&($P(W("Zdrl")," ",13)<3) Vo("par",-1,230)=1 ;НЕ включать сортировку (обработка в qSYS.sysView sysR)
 .S:$P(W("Zdrl")," ",19) Vs("par",99,"Revers")=1 ;реверс
 .S:$P(W("Zdrl")," ",21) Vo("par",-1,820)="D qARM.RecRelAll(2)" ;@Dol 3.04.06 - сброс/все по релевантным
 .N viewf,iqqw,qqwo,sep,qqz S qqwo=$S(qqw="ZZR":qqwr,$E(qqw,1,3)="ZZR":$E(qqw,4,30),1:qqw),viewf=0_$E(qview,1,3)_"sysR"_qqwr_$S($P(qview," ",2)="":"",1:" "_$P(qview," ",2))
 .S sep=$P(W("Zdrl")," ",16) S:sep="" sep=" "
 .K ^Q(viewf) I $G(W(qqwo))'="" F iqqw=1:1:$L(W(qqwo),sep) S qqz=$ZSTRIP($P(W(qqwo),sep,iqqw),"<>W") D:qqz'=""   ;составление перечня релевантых;@Dol 26.10.09 $ZSTRIP
 ..I qqwr'[":" S ^Q(viewf,qqwr,qqz)="",^(qqz,"ZTMPN")=iqqw,^Q(viewf,"ZTMPNcount",qqwr)=iqqw Q:$I(^Q(viewf,qqwr))
 ..N qqc,qqw S qqc=$S($G(Vs("par","CondF"))="":"",1:$P(Vs("par","CondF")," ")),qqw=$P($P(qqwr,":",2),",") ;,qqz=$P(W(qqwo),sep,iqqw)
 ..I qqw="C" S ^Q(viewf,$P(qqwr,":"),qqz)="",^(qqz,"ZTMPN")=iqqw,^Q(viewf,"ZTMPNcount",$P(qqwr,":"))=iqqw Q:$I(^Q(viewf,$P(qqwr,":")))
 ..S:$E(qqw)="C" qqz=$G(^Q(1,qqw,qqz),"???"),qqw=$E(qqw,2,255) F  S qqc=$O(^Q(1,qqw,qqz,$P(qqwr,":",1),qqc)) D:qqc'=""  Q:qqc=""  S ^Q(viewf,$P(qqwr,":"),qqc)="",^(qqc,"ZTMPN")=iqqw,^Q(viewf,"ZTMPNcount",$P(qqwr,":"))=iqqw I $I(^Q(viewf,$P(qqwr,":")))
 ...I $G(Vs("par","CondF"))'="" S qqc=$S($E(qqc,1,$L($P(Vs("par","CondF")," ")))=$P(Vs("par","CondF")," "):qqc,1:"") Q  ;@Dol 12.11.04 обработка ::qqc0,;
 ...Q:$G(Vs("par","Cond6"))=""  I @Vs("par","Cond6") Q
 ...S qqc=""
 .S:$G(qqXB1720) Vo("par",-1,720)=1 ;@Dol 13.02.06 кнопки выхода
 .S:$P(W("Zdrl")," ",22)'="" Vo("par",-1,720)=$P(W("Zdrl")," ",22) ;@Dol 05.04.06 параметр Кнопки выхода
 .S:$P(W("Zdrl")," ",23)'="" Vo("par",-1)=$P(W("Zdrl")," ",23) ;;@Dol 05.04.06 Заголовок окна
 .S:$P(W("Zdrl")," ",24) Vo("par",-1,"x710")=..GetPar("x710",,qqo,qqw) ;@Dol 07.05.08 наследование типа данных
 .K Vs("par","Cond6") D ..OpenWindow(,,,,,$E(qview,1,3)_"sysR"_qqwr)
 ;меню ;$P(W("Zcdrl")," ",3)=1 - тип данных PARAMS
 ;I +W("Zcdrl")=2 N qqCCq D s112Menu,..MenuWoc(qqw,$S(W("Zldrl")'["~"&($P(W("Zdrl")," ",2)=""):$P(W("Zdrl")," "),1:W("Zldrl")),$S('$P(W("Zcdrl")," ",3)&(W("Zldrl")'["~")&($P(W("Zdrl")," ",2)'=""):$P(W("Zdrl")," ",2),$E(qqw,1,3)'="ZZR":$G(W(qqw)),$E(qqw,4,100)'="":$G(W($E(qqw,4,100))),1:$G(W(qqw))),,,$S($P(W("Zdrl")," ",14)&(W("Zldrl")'["~"):"Выход",1:"-"),$S(W("Zldrl")["~"!($P(W("Zdrl")," ",2)'=""):1,$G(qqCCq)'="":qqCCq,1:$P(W("Zdrl")," ",6)),$P(W("Zdrl")," ",17),,$P(W("Zdrl")," ",18),$S($P(W("Zdrl")," ",19):-1,1:1)) Q "" ;развертка-меню
 I +W("Zcdrl")=2 D  Q "" ;развертка-меню
 .N qqCCq,Zldrl,Zldrl0 D s112Menu
 .I W("Zldrl")'["~" D ..MenuWoc(qqw,$S(W("Zldrl")'["~"&($P(W("Zdrl")," ",2)=""):$P(W("Zdrl")," "),1:W("Zldrl")),$S('$P(W("Zcdrl")," ",3)&(W("Zldrl")'["~")&($P(W("Zdrl")," ",2)'=""):$P(W("Zdrl")," ",2),$E(qqw,1,3)'="ZZR":$G(W(qqw)),$E(qqw,4,100)'="":$G(W($E(qqw,4,100))),1:$G(W(qqw))),,,$S($P(W("Zdrl")," ",14)&(W("Zldrl")'["~"):"Выход",1:"-"),$S(W("Zldrl")["~"!($P(W("Zdrl")," ",2)'=""):1,$G(qqCCq)'="":qqCCq,1:$P(W("Zdrl")," ",6)),$P(W("Zdrl")," ",17),,$P(W("Zdrl")," ",18),$S($P(W("Zdrl")," ",19):-1,1:1)) Q
 .S Zldrl=W("Zldrl") S:$E($P(Zldrl,"~",$L(Zldrl,"~")))'=" "&&($E($P(Zldrl,"~",$L(Zldrl,"~")))'="") Zldrl=$P(Zldrl,"~",1,$L(Zldrl,"~")-1)_"~"_$P($P(Zldrl,"~",$L(Zldrl,"~"))," ")_"~ "_$P($P(Zldrl,"~",$L(Zldrl,"~"))," ",2,255),W("Zldrl")=Zldrl S:Zldrl["~" Zldrl0=" "_$P($P(Zldrl,"~",$L(Zldrl,"~"))," ",2,255),Zldrl=$P(Zldrl,"~",1,$L(Zldrl,"~")-1)_"~"_$P($P(Zldrl,"~",$L(Zldrl,"~"))," ",1)
 .D ..MenuWoc(qqw,Zldrl,$S('$P(Zldrl0," ",3)&($P(Zldrl0," ",2)'=""):$P(Zldrl0," ",2),$E(qqw,1,3)'="ZZR":$G(W(qqw)),$E(qqw,4,100)'="":$G(W($E(qqw,4,100))),1:$G(W(qqw))),,,$S($P(Zldrl0," ",14):"Выход",1:"-"),$S(($P(Zldrl0," ",2)'=""):1,$G(qqCCq)'="":qqCCq,1:$P(Zldrl0," ",6)),$P(Zldrl0," ",17),,$P(Zldrl0," ",18),$S($P(Zldrl0," ",19):-1,1:1))
 ;меню - редактирование
 I +W("Zcdrl")=12 D  Q "" ;@Dol 25.09.08 множ.выб для ~
 .N qqCCq,Zldrl,Zldrl0 D s112Menu
 .I W("Zldrl")'["~" D ..MenuWoc(qqw,$S(W("Zldrl")'["~":$P(W("Zdrl")," "),1:W("Zldrl")),$S('$P(W("Zcdrl")," ",3)&(W("Zldrl")'["~")&($P(W("Zdrl")," ",2)'=""):$P(W("Zdrl")," ",2),$G(W(qqw))="":"",'$P(W("Zcdrl")," ",3):$S($E(qqw,1,3)'="ZZR":$G(W(qqw)),$E(qqw,4,100)'="":$G(W($E(qqw,4,100))),1:$G(W(qqw))),1:qW.GtoExt("P",W(qqw),qqw,qqo)),,,$S(W("Zdrl")'["~"&(W("Zdrl")'[$C(13,10)):$P(W("Zdrl")," ",11),1:""),$S(W("Zldrl")["~":1,$G(qqCCq)'="":qqCCq,1:$P(W("Zdrl")," ",6)),$P(W("Zdrl")," ",17),,$P(W("Zdrl")," ",18),$S($P(W("Zdrl")," ",19):-1,1:1)) Q
 .S Zldrl=W("Zldrl") S:$E($P(Zldrl,"~",$L(Zldrl,"~")))'=" "&&($E($P(Zldrl,"~",$L(Zldrl,"~")))'="") Zldrl=$P(Zldrl,"~",1,$L(Zldrl,"~")-1)_"~"_$P($P(Zldrl,"~",$L(Zldrl,"~"))," ")_"~ "_$P($P(Zldrl,"~",$L(Zldrl,"~"))," ",2,255),W("Zldrl")=Zldrl S:Zldrl["~" Zldrl0=" "_$P($P(Zldrl,"~",$L(Zldrl,"~"))," ",2,255),Zldrl=$P(Zldrl,"~",1,$L(Zldrl,"~")-1)_"~"_$P($P(Zldrl,"~",$L(Zldrl,"~"))," ",1)
 .D ..MenuWoc(qqw,Zldrl,$S('$P(Zldrl0," ",3)&($P(Zldrl0," ",2)'=""):$P(Zldrl0," ",2),$G(W(qqw))="":"",'$P(Zldrl0," ",3):$S($E(qqw,1,3)'="ZZR":$G(W(qqw)),$E(qqw,4,100)'="":$G(W($E(qqw,4,100))),1:$G(W(qqw))),1:qW.GtoExt("P",W(qqw),qqw,qqo)),,,$S(Zldrl0'["~"&(Zldrl0'[$C(13,10)):$P(Zldrl0," ",11),1:""),1,$P(Zldrl0," ",17),,$P(Zldrl0," ",18),$S($P(Zldrl0," ",19):-1,1:1)) Q
 I +W("Zcdrl")=3 D  Q ""
 .S %8=$G(W(qqw)) S:%8?2N1"."2N1"."2.4N %8=$S($L($P(%8,".",3))=2:"20",1:"")_$P(%8,".",3)_$P(%8,".",2)_$P(%8,".",1) ;@dol 23.08.04 хранится в формате даты
 .I %8=""!(%8'?1.N) S %8=$ZD($H,8) S:$G(W(qqw))="" W(qqw)=%8 S:"@Z"'[$E(qqw)&&(" "_qqwchg_" "'[(" "_qqw_" ")) qqwchg=qqwchg_" "_qqw D qARM.wwww(qqw) ;текущая дата по умолчанию @dol 6.09.02 была забыта запись в W(qqw)
 .S %8=$E(%8_"00000000",1,8) S:'$E(%8,5,6) $E(%8,5,6)="01" S:'$E(%8,7,8) $E(%8,7,8)="01"
 .D ..wC("TCalendar","Tcal",$ZDH(%8,8)-21548),..wM(,"RPosT@",qwin_".T2",0,0,"",+$G(W("Zpos",2,"x"))),..wM(,"Show"),..wM(,"Destroy")
 ;большой текст
 ;I +W("Zcdrl")=6 D ..OpenDoc(,,,qW.GetWoc("CxWoc",qqw)) Q ""
 ;sas 20091130
 I +W("Zcdrl")=6,$P(W("Zdrl")," ",2)="" D ..OpenDoc(,$P(W("Zdrl")," ",4), $P(W("Zdrl")," ",1), ..GetName(,$$$CurObj,qqw), $P(W("Zdrl")," ",3), $P(W("Zdrl")," ",5), $P(W("Zdrl")," ",6),,,,,$S('$G(W("ZBtred")):0,$P(W("Zdrl")," ",4)=0:0,1:1)_" 2 0% 0% 100% 100% 1 3 1 "_$P(W("Zdrl")," ",9)_" 0 1 0") Q "" ;@dol 15.03.04 $P(W("Zdrl")," ",1) ,3) - явно
 //I +W("Zcdrl")=6,$P(W("Zdrl")," ",2)=""  D ..OpenDoc(,$P(W("Zdrl")," ",4),$P(W("Zdrl")," ",1),..GetName(,$$$CurObj,qqw),$P(W("Zdrl")," ",3),$P(W("Zdrl")," ",5),$P(W("Zdrl")," ",6)) Q "" ;@dol 15.03.04 $P(W("Zdrl")," ",1) ,3) - явно
 I +W("Zcdrl")=6 S:$G(W("ZBtred"))&&($E(qqc,$L(qqc))=" ")&&($G(qqwchg)="") qqwchg="Znull" Q:..EndOP(1) "" D  D ..OpenDoc("W(qqw)",$S('$G(W("ZBtred")):0,$P(W("Zdrl")," ",4)="":1,1:$P(W("Zdrl")," ",4)),$P(W("Zdrl")," ",1),..GetName(,$$$CurObj,qqw),$P(W("Zdrl")," ",3)) Q "" ;@dol 22.09.03 ;23.07.04 "W(qqw)"
 .N qqonew,qqwlst,c1,c2 S qqwlst=$P(W("Zdrl")," ",2)
 .S qqonew=$P(qqwlst,":",1),qqwlst=$P(qqwlst,":",2,255)
 .I qqonew="*" S qqonew=qSYS.Chiqqw($$$CurObj,$P(qqwlst,",")),$P(W("Zdrl")," ",2)=qqonew_":"_qqwlst
 .K W(qqw) S c1="" F c2=0:1 S c1=$$$UserOrd(1,qqonew,c1,qqc) Q:c1=""  S W(qqw,c2)=qW.GG(qqonew,$P(qqwlst,","),c1) ;_$C(13,10) ;!!!$C(13,10) - непонятно, что с RichText
 ;Help
 I +W("Zcdrl")=11 S %1=$S($P(W("Zldrl")," ")'="":$P(W("Zldrl")," "),$E(qqw,1,3)="ZZR":$E(qqw,4,20),1:qqw) D ..OpenCHelp("W"_%1) Q "" ;,Vo("par",-1,29)="450,"_$S("XMTYZL"[$E(%1):90,1:300)_",0,11" D ..OpenWindow(,,,,,$E(qview,1,3)_"sysH"_%1) Q ""
 ;Media
 I +W("Zcdrl")=10 D ..OpenMedia(W("Zldrl")) Q ""
 ;картинка
 I +W("Zcdrl")=7 S qqred="" D  D:%1="" ..Message("Нет файла") Q:%1="" "" D ..OpenPic(%1,%2,$S(qqw'="":qW.GG(qqo,qqw,qqc),1:"")) Q "" ;рисунок
 .I $E(W("Zldrl"))="\" S %2=$E($P(W("Zldrl")," "),2,255),%1=$P(W("Zldrl")," ",2,255) Q
 .S %2="",%1=W("Zldrl")
 I +W("Zcdrl")=8 D  Q "" ;вызов отображения
 .S %1=$P(W("Zdrl")," ",2,255),%3=$P(%1,"~",2),%2=$P(%1,"~",1)
 .D:%1["~" 
 ..I %3="" S %3=qqc_" "_$$$CurObj Q
 ..S @("%3="_%3)
 ..S qqp40=$P(%3," ",1,4)_" "_$P(%3," ",5,255),%3=$P(%3," ",1,4) ;для совместимости со старым вариантом
 .S:$G(qqXB1720) Vo("par",-1,720)=1 ;@Dol 13.02.06 кнопки выхода
 .D ..OpenWindow(,,,%3,%2,$S($D(^Q(1,"XView",$P(W("Zdrl")," "))):$P(W("Zdrl")," "),1:$E(Vo(qqnump),1,3)_$P(W("Zdrl")," "))) ;@dol 26.02.04
 I +W("Zcdrl")=9  S:$G(W("ZBtred"))&&($E(qqc,$L(qqc))=" ")&&($G(qqwchg)="") qqwchg="Znull" Q:..EndOP(1) "" N qqend,qqnump122 S qqnump112=qqnump D  Q $S($G(qqend):-1,1:"") ;произвольное действие. Выход из формы, если в результате действия qqend=1; qqwold - отслеживание повторного действия;@dol 24.12.02 "Znull" - фиктивное понятие, чтобы прошла коррекция с созданием нового экземпляра
 .I $G(qqw)_" "_$G(W("Zpos",2,"y"))_" "_$G(W("Zpos",2,"x"))=$G(qqwold) S qqred="" Q
 .S qqwold=$G(qqw)_" "_$G(W("Zpos",2,"y"))_" "_$G(W("Zpos",2,"x")) ;qqwold - для отслеживания (запрета) повторного выполнения действия
 .S Z="" D ..Value(W("Zdrl"),"X") S:$G(qqend)'=0 qqred=""
 .;I $D(qqend),$E(qqend)'?1N D ..Message($S(qqend="@":"Выполнено "_$TR(qW.GetWoc("CxWoc",qqw),"_%"," "),1:qqend))
 .I $D(qqend),qqend'=-1,$E(qqend)'?1N D:qqend'="" ..Message($S(qqend="@":"Выполнено: "_$TR(..GetName(,$$$CurObj,qqw),"%"),1:qqend))
 .I $G(qqend),qqnump112=qqnump D  Q
 ..D:$G(qwin(qwin,"child"))'="" qARM.GetBqqnump(1) ;@Dol 06.05.06 переход в базовое окно
 ..S:$D(W("Zdomod")) W("Zdomod")=2+(qqend=-1) S:..GetPar("x173")'="" Vo(qqnump,-1,73)=2+(qqend=-1) ;@Dol 10.01.06 для обеспечения автоматического выбора/невыбора (qqend=1/-1) (если окно не изменилось)
 .I $G(qqend),qqnump112'=qqnump,$D(qwin("Q"_qqnump112)) S qqnump=qqnump112 D:$D(WS(qqnump,"Zvars","qqnump")) ..crst(,qqnump112) S qwin="Q"_qqnump ;@dol 29.09.03 - выход, а окно поменялось?????
 Q ""
 ;спец обработка варианта qqo:qqw в понятии развертки. Вставка неявного условия
s112Zdrl
 Q:$P(W("Zdrl")," ")'[":"
 N qqos,qqws,qq S qqos=$P(W("Zdrl")," "),qqws=$P($P(qqos,":",2),",") S:qqws="" qqws=qqw S $P(W("Zdrl")," ")=qqws,qqos=$P(qqos,":",1)
 S qq=$P(W("Zdrl")," ",6),$P(W("Zdrl")," ",6)=$S(qq'="":qq_"&",1:"")_$S($E(qqws)'="C":"$D(^Q(1,"""_qqws_""",Z,"""_qqos_"""))",1:"$D(^Q(1,"""_$E(qqws,2,255)_""",$G(^Q(1,"""_qqws_""",Z),""???""),"""_qqos_"""))")
 Q
s112Menu
 S:$P(W("Zdrl")," ")["qUSER." @("$P(W(""Zdrl""),"" "")="_$S($P(W("Zdrl")," ")'["+":$P(W("Zdrl")," "),1:qW.zChSym($P(W("Zdrl")," "),"+","_""+""_"))),W("Zldrl")=W("Zdrl") ;@Dol 23.03.10 +
 S:W("Zldrl")[$C(13,10) W("Zldrl")=$TR(W("Zldrl"),$C(13,10),"~")
 Q:W("Zldrl")["~"  Q:$P(W("Zdrl")," ",2)'=""  I $S($P(W("Zdrl")," ",1)[";":0,1:$P(W("Zdrl")," ",1)'[",") D s112Zdrl S W("Zldrl")=W("Zdrl")  Q  ;$P(W("Zdrl")," ",2)'="" - меню списка параметров
 I $P(W("Zdrl")," ",6)'="" S qqCCq="qARM.Value(""S XQend=1,Z=qW.G("""""_$P($P($P(W("Zdrl"),":",2),","),";")_""""")"",""X"")&("_$P(W("Zdrl")," ",6)_")" ;@dol 23.01.03
 Q
s112Scr()
 S:$P(W("Zdrl")," ")["qUSER." @("$P(W(""Zdrl""),"" "")="_$P(W("Zdrl")," ")),W("Zldrl")=W("Zdrl") ;@dol 26.10.04 
 N qqcond6 I $P(W("Zdrl")," ")[":"  D:$P(W("Zdrl")," ")["::"  D:$P(W("Zdrl")," ")'["," s112Zdrl
 .N qqc0 S qqc0=$P($P(W("Zdrl"),","),"::",2) ;@Dol 19.10.04 - обработка общей части кода
 .S W("Zdrl")=$P(W("Zdrl"),";",2,255) I $P(W("Zdrl")," ")'["," Q  ;пока только для развертки по экземплярам
 .I qqc0'["!" S Vs("par","CondF")=qqc0_" "_qqc0,Vs("par",7)="w" Q
 .S qqcond6=""" "_$TR(qqc0,"!"," ")_" ""[("" ""_$E(qqc,1,"_$L($P(qqc0,"!"))_")_"" "")",Vs("par","Cond6")=qqcond6
 ;;@dol 02.12.10 ПОРТИТСЯ Z !!! ;I $P(W("Zdrl")," ",6)'="" Q $S($G(qqcond6)="":"",1:qqcond6_"&&")_"qARM.Value(""S XQend=1,Z="_$S($P(W("Zdrl")," ")'[",":"qqc",1:"qW.G("""""_$P($P(W("Zdrl"),":",2),",")_""""")")_""",""X"")&("_$P(W("Zdrl")," ",6)_")" ;чтобы условие задавалось относительно Z ;@dol 24.01.03 qW.G(""""" - были забыты двойные кавычки
 I $P(W("Zdrl")," ",6)'="" Q $S($G(qqcond6)="":"",1:qqcond6_"&&")_$S($P(W("Zdrl")," ",6)["Z":"qARM.Value(""N Z S Z="_$S($P(W("Zdrl")," ")'[",":"qqc",1:"qW.G("""""_$P($P(W("Zdrl"),":",2),",")_""""")")_" I "_qSYS.dblqw($P(W("Zdrl")," ",6))_" S XQend=1"",""X"")",1:$P(W("Zdrl")," ",6)) ;чтобы условие задавалось относительно Z ;@dol 02.12.10 
 Q $G(qqcond6)
]]></Implementation>
</Method>

<Method name="wC">
<Internal/>
<FormalSpec>Cl:%String,Obj:%String,par1:%String,par2:%String,par3:%String,par4:%String,par5:%String,par6:%String,par7:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 i $G(%qDebug("STACK")) d ..wM("-qLOG",..getst())
 i $G(qARM("PROTv8")) n CC s CC=1 D ..wMet8() Q:$Q "" Q
 S qqbcod=$C(7,$G(Obj)'=""*4+48+($G(Cl)'=""*8)),qqb2n=$S($G(Cl)="":"",1:$C(46,147)_Cl_$C(147))_$S($G(Obj)="":"",1:$C(46,147)_Obj_$C(147)) D ..wMet() Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wG">
<Internal/>
<FormalSpec>Obj:%String,MC:%String,par1:%String,par2:%String,par3:%String,par4:%String,par5:%String,par6:%String,par7:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 i $G(%qDebug("STACK")) d ..wM("-qLOG",..getst())
 i $G(qARM("PROTv8")) n CC s CC=4 D ..wMet8() Q:$Q "" Q
 S qqb2n=$S($G(Obj)="":"",1:$C(46,147)_Obj_$C(147))_$S($G(MC)="":"",1:$C(46,147)_MC_$C(147)),qqbcod=$C(7,$G(Obj)'=""*4+64+($G(MC)'=""*2)) D ..wMet() Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wIRT">
<Description>
Старое. См. RuntimeAction</Description>
<Internal/>
<FormalSpec>MC:%String,par1:%String,par2:%String,par3:%String,par4:%String,par5:%String,par6:%String,par7:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
    i $E($G(qARM("CntStr")),1,3)="SSH" d ..Message("wIRT не поддерживает SSH") q ""
        
    k qruntimeprot,wMet8Old
    s runtimeact=1 ; флаг для wMet - писать протокол в qruntimeprot, а не в qprotstr
    d ..wM("-qARM","IRT_"_MC,.par1,.par2,.par3,.par4,.par5,.par6,.par7)
    s runtimeact=0  
    
    n %IRTRes
    d:$G(qruntimeprot(1))'=""
    .n i,dev s dev=$IO u $P
    .f i=1:1:qruntimeprot w "!&IR"_$S(i=qruntimeprot:"F",i=1:"I",1:"P")_..wzero(qruntimeprot(i)) ; wzero(), т.к. Write не поддерживает $C(0)
    .u dev
    .k qruntimeprot
    q $G(%IRTRes)
]]></Implementation>
</Method>

<Method name="wM">
<Internal/>
<FormalSpec>Obj:%String,MC:%String,par1:%String,par2:%String,par3:%String,par4:%String,par5:%String,par6:%String,par7:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 i $G(%qDebug("STACK")),$G(Obj)'="-qLOG" d ..wM("-qLOG",..getst())
 i $G(qARM("PROTv8")) n CC s CC=2 D ..wMet8() Q:$Q "" Q
 S qqb2n=$S($G(Obj)="":"",1:$C(46,147)_Obj_$C(147))_$S($G(MC)="":"",1:$C(46,147)_MC_$C(147)),qqbcod=$C(7,$G(Obj)'=""*4+16+($G(MC)'=""*2)) D ..wMet() Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wMByf">
<Description>
НЕ НУЖЕН</Description>
<Internal/>
<FormalSpec>x2:%String,x3:%String,par1:%String,par2:%String,qRES:%String=$G(qqRES),mas:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S a=1\0 Q:$Q "" Q  ;@Dol 21.03.08 чтобы заметен был вывод
 ;par2=0 - ^%QRes, 1 - ^QRes
 i '$G(mas),$S($G(par2):'$E(qRES,2),1:'$E(qRES,1)) d  Q:$Q "" Q
 .i $P(par1,".",$L(par1,"."))="jpg" d ..wC("TJPEGImage","AJPGz1i"),..wM(,"LoadFromFile",par1) n q s q=$L(x3,"."),$P(x3,".",q,q+1)="ZJPEG@" d ..wM(x2,x3,"AJPGz1i"),..wM("AJPGz1i","Destroy") q
 .d ..wM(x2,x3,par1) q
 n sw,envb,nm,bmp,n0 ;s par1=..wTR(par1) ;nm,
 I $G(mas) S nm=$NA(@$S($E(par1)'="^":par1,$E(par1,1,2)'="^|":par1,1:"^|"""_$ZU(5)_"""|"_$E(par1,2,10000))) I 1
 E  s nm=$NA(@$S($G(par2):"^|"""_$ZU(5)_"""|QRes",1:"^%QRes")@(par1)) I '$D(@nm) s par1=..wTR(par1) ;@dol 22.12.03
 S n0=$O(@nm@("")) I n0="" d:$L(x3,".")=1 ..wM(x2,"Clear@") Q:$Q "" Q  ;@Dol 17.03.07 n0 - было всегда 0 ;$D(@nm@(0))
 S bmp=$E(@nm@(n0),1,2)="BM"
 d ..wM("-qARM","BufferClear") s envb=1+$O(@nm@(""),-1) d ..wM(,"Buffer"_$S(envb>1:"2",1:1),nm,envb)
 d ..wC("TStringStream","ASS1777ARMz",""),..wP(,"Position",0) d  d ..wM("ASS1777ARMz","Destroy"),..wM("-qARM","BufferClear")
 .i 'bmp d ..wC("TJPEGImage","AJPGz1i"),..wM(,"LoadFromStream","ASS1777ARMz") d  q  ;@dol 10.1.04
 ..n q s q=$L(x3,"."),$P(x3,".",q,q+1)="ZJPEG@" d ..wM(x2,x3,"AJPGz1i"),..wM("AJPGz1i","Destroy") q
 .s $P(x3,".",$L(x3,"."))="LoadFromStream" d ..wM(x2,x3,"ASS1777ARMz")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wMet">
<Description>
Общая часть методов wC, wM, wP, wG</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 S qqdiv2=$C(0) I $D(par1) S qqb2n=qqb2n_$C(46,147)_par1_$C(147),qqdiv2=$C(1,128) I $D(par2) S qqb2n=qqb2n_$C(46,147)_..wdbl(par2)_$C(147),qqdiv2=$C(1,192) I $D(par3) S qqb2n=qqb2n_$C(46,147)_..wdbl(par3)_$C(147),qqdiv2=$C(1,224) I $D(par4) S qqb2n=qqb2n_$C(46,147)_..wdbl(par4)_$C(147),qqdiv2=$C(1,240) I $D(par5) S qqb2n=qqb2n_$C(46,147)_..wdbl(par5)_$C(147),qqdiv2=$C(1,248) I $D(par6) S qqb2n=qqb2n_$C(46,147)_..wdbl(par6)_$C(147),qqdiv2=$C(1,252) I $D(par7) S qqb2n=qqb2n_$C(46,147)_..wdbl(par7)_$C(147),qqdiv2=$C(1,254) ; Dima 25.06.09 parX -> wdbl(parX)
 i $G(runtimeact) g wMetRT
 S:$D(qprotstr)<10 qprotstr=1,qprotstr(1)="" S qprotstr(qprotstr)=qprotstr(qprotstr)_qqbcod_qqdiv2_qqb2n_$C(46)
 F qprotstr=qprotstr:1 Q:$L(qprotstr(qprotstr))'>length  S qprotstr(qprotstr+1)=$E(qprotstr(qprotstr),length+1,32127),qprotstr(qprotstr)=$E(qprotstr(qprotstr),1,length)
 Q:$Q "" Q
wMetRT
 S:$D(qruntimeprot)<10 qruntimeprot=1,qruntimeprot(1)="" S qruntimeprot(qruntimeprot)=qruntimeprot(qruntimeprot)_qqbcod_qqdiv2_qqb2n_$C(46)
 F qruntimeprot=qruntimeprot:1 Q:$L(qruntimeprot(qruntimeprot))'>length  S qruntimeprot(qruntimeprot+1)=$E(qruntimeprot(qruntimeprot),length+1,32127),qruntimeprot(qruntimeprot)=$E(qruntimeprot(qruntimeprot),1,length)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wMet8">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 n n,k,parcnt,difl,oq 
 i '(($G(runtimeact)||$G(%qDebug("STACK")))) d 
 .d:$D(Obj)#10
 ..i Obj=$G(wMet8Old("Obj")) k:Obj'="" Obj
 ..e  s wMet8Old("Obj")=Obj
 .d:$D(MC)#10
 ..i MC=$G(wMet8Old("MC")) k:MC'="" MC
 ..e  s wMet8Old("MC")=MC
 .d:$D(PV)#10
 ..i PV=$G(wMet8Old("PV")) k:PV'="" PV
 ..e  s wMet8Old("PV")=PV
  
 ; определение числа параметров
 s parcnt=1 f  s n="par"_parcnt q:'($D(@n)#10)  s parcnt=parcnt+1
 s parcnt=parcnt-1
 ; сохранение длин
 n r s r=$C(8,CC,$L($G(Cl))\256,$L($G(Cl))#256,$L($G(Obj))\256,$L($G(Obj))#256,$L($G(MC))\256,$L($G(MC))#256)
 ; value (нет - len=65535), число параметров
 s r=r_$S(($D(PV)#10):$C($L($G(PV))\256,$L($G(PV))#256),1:$C(255,255))_$C(parcnt)
 f n=1:1:parcnt s k=$L(@("par"_n)) s r=r_$C(k\256,k#256)
 
 ; сохр. данных
 s r=r_$G(Cl)_$G(Obj)_$G(MC)_$G(PV)_$G(par1)_$G(par2)_$G(par3)_$G(par4)_$G(par5)_$G(par6)_$G(par7)_$G(par8)_$G(par9)
 i $G(runtimeact) d wMet8AddRT(r)
 e  d wMet8Add(r)
 Q:$Q "" Q
wMet8Add(s)
 i $G(%qDebug("wMet")) d ..Log("qprotstr <- "_$TR(s,$C(0),".")) i $G(Obj)="-qLOG" Q:$Q "" Q  ; лог: при включенном дампе-Cache стек (если вкл.) не передается в протокол, а только методу qARM.Log(). @dima 20100611
 S:$D(qprotstr)<10 qprotstr=1,qprotstr(1)=""
 f n=1:1 q:s=""  s:n=1 oq=$G(qprotstr(qprotstr)) s:n>1 oq="",qprotstr=qprotstr+1 s difl=length-$L(oq),qprotstr(qprotstr)=oq_$E(s,1,difl),s=$E(s,difl+1,99999)
 Q:$Q "" Q
wMet8AddRT(s) ;qruntimeprot
 S:$D(qruntimeprot)<10 qruntimeprot=1,qruntimeprot(1)=""
 f n=1:1 q:s=""  s:n=1 oq=$G(qruntimeprot(qruntimeprot)) s:n>1 oq="",qruntimeprot=qruntimeprot+1 s difl=length-$L(oq),qruntimeprot(qruntimeprot)=oq_$E(s,1,difl),s=$E(s,difl+1,99999)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wP">
<Internal/>
<FormalSpec>Obj:%String,MC:%String,PV:%String,par1:%String,par2:%String,par3:%String,par4:%String,par5:%String,par6:%String,par7:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 i $G(%qDebug("STACK")) d ..wM("-qLOG",..getst())
 i $G(qARM("PROTv8")) n CC s CC=3 D ..wMet8() Q:$Q "" Q
 S qqb2n=$S($G(Obj)="":"",1:$C(46,147)_Obj_$C(147))_$S($G(MC)="":"",1:$C(46,147)_MC_$C(147))_$S('$D(PV):"",1:$C(46,147)_..wdbl(PV)_$C(147)),qqbcod=$C(7,$G(Obj)'=""*4+32+($G(MC)'=""*2)+$D(PV)) D ..wMet() Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wTR">
<Description>
Преобразование в верхний регистр.</Description>
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[ Q $TR(Arg1,"ЙЦУКЕНГШЩЗХФЫВАПРОЛДЖЭЯЧСМИТЬБЮЪQWERTYUIOPASDFGHJKLZXCVBNM","йцукенгшщзхфывапролджэячсмитьбюъqwertyuiopasdfghjklzxcvbnm")
]]></Implementation>
</Method>

<Method name="wbmp">
<Description>
ВРОДЕ НЕ НУЖЕН Создание и загрузка TBitMap
Arg3=1 - для загрузки картинки в окно (см. qARM.OpenPic ).
Arg4=1 - "глобальные" картинки</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%String,Arg3:%Library.String,Arg4:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$G(Arg3),$S($G(Arg4):'$D(WQ(Arg1)),1:'$D(WQ(qqnump,Arg1))) D ..wC("TBitmap",Arg1) D
 .I $G(Arg4) S WQ(Arg1)="" Q
 .S WQ(qqnump,Arg1)=""
 I $E(Arg2,1,2)="F," D ..wM(Arg1,$S($G(Arg3):"Picture.Bitmap.",1:"")_"LoadFromRsc","F,"_$S($E(Arg2,4)=":":"",1:qARM("ClientPath")_"F\")_$P(Arg2,",",2)) Q:$Q "" Q  ;..wMByf(  ,1,"00")явный файл
 I $E(Arg2,1,2)="R," D ..wM(Arg1,$S($G(Arg3):"Picture.Bitmap.",1:"")_"LoadFromRsc",Arg2) Q:$Q "" Q  ;Ресурс (qARMRes.dll)
 I $E(Arg2,1,2)="M," D:$D(@$P(Arg2,",",2,255))>1 ..wM(Arg1,$S($G(Arg3):"Picture.Bitmap.",1:"")_"LoadFromRsc","M,"_$NA(@$P(Arg2,",",2,255))) Q:$Q "" Q  ;,1,,1)
 S Arg2=$P(Arg2,","),Arg2=$NA(@("^|"""_$ZU(5)_"""|QRes")@($S($G(Arg3):Arg2,$G(qqP1)="":Arg2,1:qqP1_$P(Arg2,"\",$L(Arg2,"\")))))
 D:$D(@Arg2)>1 ..wM(Arg1,$S($G(Arg3):"Picture.Bitmap.",1:"")_"LoadFromRsc","M,"_$NA(@Arg2)) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wbut">
<Description>
установка кнопки заголовка
qqpar1 =1 - объекты, 2 - экземпляры
qqpar2 - номер ряда
qqpar3 - состояние</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String,qqpar3:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 D ..wP(qwin_".T"_qqpar1,"ColHeaderButton",-1) I '$G(qqpar3) Q:$Q "" Q
 D ..wP(qwin_".T"_qqpar1,"ColHeaderButton",qqpar2) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wbuttb">
<Description>
Управление кнопками Тулбаров.
butlst - номер кнопки (если больше нет параметров, возвращает номер пояснений)
Одно из нижеследующих (butlst - список через пробел):
down - 1/0 - нажата/отпущена
en - 1/0 - доступна/недоступга
vi - 1/0 - видима/невидима</Description>
<Internal/>
<FormalSpec>butlst:%String,down:%String,en:%String,vi:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N butl,but,buti,tb S butl=" 22 20 23 21 10 11 12 13 14 15 33 64 63 62 400 401 402 41 40 99 9 5 4 3 2 1 17 8 7 6 98 104 102 103 101 / M M M M R R R R R R E S S S N C C N N P G G G G G G V V V V G H H H H / 0 1 2 3 3,0 3,1 3,2 3,3 3,4 3,5 4 5 6 7 8 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 104 102 103 101"
 I '$D(down),'$D(en),'$D(vi) Q $P($P(butl,"/",3)," ",$L($P(butl," "_butlst_" ")," ")+1)
 I $D(vi)," "_butlst_" "[(" "_40_" ")!(" "_butlst_" "[(" "_41_" ")) S:0 butlst=butlst_" 400" ;удаление кнопки-подложки 400
 F buti=1:1:$L(butlst," ") S but=$P(butlst," ",buti) I but'="",but'=11,but'=13 D  ;@dol 2.2.03 11, 13
 .S tb=$P($P(butl,"/",2)," ",$L($P(butl," "_but_" ")," ")+1),tb=$S("NSC"'[tb:".TB"_tb,$G(W("Zsform"))<100:".TB"_tb,1:".T1.TB"_tb) ;@Dol 15.05.07
 .D ..wP(qwin_tb_".b"_but,$S($D(down):"Down",$D(en):"Enabled",1:"Visible"),+$G(down)!(+$G(en))!(+$G(vi)))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wcelldpar">
<Description>
Динамические параметры ячейки</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqso:%Library.String,qiii:%Library.String,qqci:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqz,qiiii,qqc,qqw S qqz=Vt(qqnump,9,"PPP",qqo,+qqso,qiii),qqc=$S($G(qqo,-1)=-1:"",1:$G(Vc(qqnump,$G(qqci,-1)))),qqw=$G(Vo(qqnump,qqo,0,+qqso,qiii)),qqw=$S('$E(qqw):"ZZR",$E(qqw)=5:"Zs"_(+qqso)_"c"_qiii,1:$E($P(qqw," "),2,31)) ;@Dol 1.10.06 qqw
 S:$E(qqz)="@" @("qqz="_$E(qqz,2,30000)) S:$E(qqz)="@" @("qqz="_$E(qqz,2,30000))  S qiiii=qiii D  ;@Dol 26.04.05 Q:qqz=""
 .I $E(qqz)="*" S qqz=$E(qqz,2,3000),qiiii=""  Q  ;@dol 20.06.04 - вся строка
 .I qqz[">" S qiiii=$S($P(qqz,">",1)="":qiiii,1:$P(qqz,">",1))_" "_$P(qqz,">",2),qqz=$P(qqz,">",3) ;@Dol 25.02.05 диапазон
 I $P(qqz,",",5)'="" S:$P($G(Vo(qqnump,qqo,0,qqso,qiii,2)),",",6) $P(qqz,",",6)=$P(Vo(qqnump,qqo,0,qqso,qiii,2),",",6) S:$P($G(Vo(qqnump,-1,55)),",",2)&&'$P(qqz,",",6) $P(qqz,",",6)=$P(Vo(qqnump,-1,55),",",2) S:'$P(qqz,",",6) $P(qqz,",",6)=8 ;;;D ..wP("F"_$P(qqz,",",5),"Size",$P(qqz,",",6)) ;@Dol 19.07.09 стиль для нестандартного размера
 D ..wP(qwin_".T2","M1",$C(30),"",qiiii,$S($P(qqz,",",5)="":"",1:"F"_$P(qqz,",",5)_" "_$P(qqz,",",6)),$P(qqz,",",2),$P(qqz,",",1),$P(qqz,",",4),$P(qqz,",",3)) Q  ;@Dol 21.07.09 $P(qqz,",",6)
]]></Implementation>
</Method>

<Method name="wcellpic">
<Description>
Вывод постоянных картинок</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqso:%Library.String,qiii:%Library.String,qqci:%Library.String,par:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqz,qqzA,qqzclr,qqw,qqzS,New,qqzF,qqzo S qqz=$G(Vt(qqnump,9,$G(par,"PP"),qqo,+qqso,qiii)),qqw=$G(Vo(qqnump,qqo,0,+qqso,qiii)),qqw=$S('$E(qqw):"ZZR",$E(qqw)=5:"Zs"_(+qqso)_"c"_qiii,1:$E($P(qqw," "),2,31)) ;@Dol 1.10.06 qqw
 S:$E(qqz)="-" qqz=$E(qqz,2,30000) I $E(qqz)="@" D
 .I qqo=-1,'qqso N qqo S qqo=$$$CurObj ;@Dol 28.01.06 для заголовков (перевыводится из wpoe)
 .N qqc S qqc=$S($G(qqo,-1)=-1:"",1:$G(Vc(qqnump,$G(qqci,-1)))) S qqz="qqz="_$E(qqz,2,30000),@qqz ;Q:qqz=""  ;@dol 14.01.03 - вычисляемый ресурс ;@Dol 26.04.05 qqz=""
 .S:$E(qqz)="-" qqz=$E(qqz,2,30000)
 .S:$E(qqz)="@" @("qqz="_$E(qqz,2,30000)) ;@Dol 25.03.05 двойная косвенность для оразцов
 D:qqz[" "   ;@Dol 1.09.05 динамическая обработка ресурсов через пробел
 .I $E($G(Vo(qqnump,qqo,0,+qqso,qiii)))=4 S qqz=$S(qW.GE($E(Vo(qqnump,qqo,0,+qqso,qiii),2,255)):$P(qqz," ",2),1:$P(qqz," ",1)) Q  ;флаг
 .S qqz=$S($G(Vc(qqnump,qqci,40))=1:$P(qqz," ",2),1:$P(qqz," ",1))  ;папки свертки/развертки
 ;;I $E(qqz)="R",$G(qqXBwsize),$P($G(qqX155),",",2)>8 S $P(qqz,",",5,6)=$P(qARM.wsize("0,16"),",",2)_",-1" ;25.02.11 временно для пропорционального увеличения ресурса
 ;@Dim-Pav 20081224
 I qqo=-1,'qqso d ..wP(qwin_".T2","M4",qqz,-1,qiii) Q  ;@dol 30.01.09 - картинки колонок !!! Забыл @Dima
 d ..wP(qwin_".T2","M4",qqz,"",qiii)
 q
 
 D:qqz'=""
 .S qqzA=$S($E(qqz,1,2)'="M,":$P(qqz,",",4),$E(qqz,$L(qqz))=")":"",1:$P($RE($P($RE(qqz),")")),",",3)),qqzclr=$S($E(qqz,1,2)'="M,":$P(qqz,",",3),$E(qqz,$L(qqz))=")":"",1:$P($RE($P($RE(qqz),")")),",",2))
 .S qqzS=$S($E(qqz,1,2)'="M,":$P(qqz,",",5,6),$E(qqz,$L(qqz))=")":"",1:$P($RE($P($RE(qqz),")")),",",5,6)) ;@Dima&Dol 15.03.07 желаемые размеры
 .I $E(qqz,1,2)="R," S qqz=$P(qqz,",")_$P(qqz,",",2) Q:$D(WQ(qqz))  D ..wC("TBitmap",qqz) S WQ(qqz)="" D ..wM(qqz,"LoadFromRsc","R,"_$E(qqz,2,255)) Q  ;@Dima 21.03.08 D ..wM(qqz,"LoadFromRes",$E(qqz,2,255)) Q
 .I $E(qqz,1,2)="F," S qqzF=qqz,qqz=$P(qqz,",")_$TR($P($P(qqz,",",2),"\",$L($P(qqz,",",2),"\")),".-") Q:$D(WQ(qqz))  D ..wC("TBitmap",qqz) S WQ(qqz)=""  D ..wM(qqz,"LoadFromRsc","F,"_$S($E(qqzF,4)=":":"",1:qARM("ClientPath")_"F\")_$P(qqzF,",",2))  Q  ;D ..wMByf(qqz,"LoadFromFile",$S($E(qqzF,4)=":":"",1:qARM("ClientPath")_"F\")_$P(qqzF,",",2),1,"00") Q
 .I $E(qqz,1,2)'="M," Q  ;;;;;;D ..Message("qqo="_qqo_" y="_qqso_" x="_qiii_" Неверная ссылка на ресурс: "_qqz,"qARM.wcelpic") S qqz="" Q
 .I $P(qqz,",",2)="^Q"||($P(qqz,",",2)="^Q(1)") D ..Message("qqo="_qqo_" y="_qqso_" x="_qiii_" Недопустимо. Ресурс - массив базы: "_qqz,"qARM.wcelpic") S qqz="" Q  ;@Dol 20.07.07
 .S qqzo=qqz,qqzF=$P(qqz,",",2,255),qqzF=$P(qqzF,")",1,$L(qqzF,")")-1)_")",qqz=$TR(qW.Translit($ZCVT(qqzF,"U")),"^,.\:""'`~@&$%*/[]{}!?|+-)(#") D:$D(WQ(qqz))&&($E(qqzo,$L(qqzo))'=")")&&$P($RE($P($RE(qqzo),")")),",",4)  Q:$D(WQ(qqz))  D ..wC("TBitmap",qqz) S WQ(qqz)="" D:$D(@qqzF)>1 ..wM(qqz,"LoadFromRsc","M,"_$NA(@qqzF)) Q  ;D ..wMByf(qqz,"LoadFromFile",qqzF,1,,1) Q
 ..D ..wM(qqz,"Destroy") K WQ(qqz) ;@Dol 1.11.05 перестраиваемый M
 I qqz'="",$G(qqzS)'="" D
 .I $E(qqzS)=$E(">") S qqzS=$E(qqzS,2,255) D ..wM(qqz,"Thumb",$S($P(qqzS,",",1):$P(qqzS,",",1),1:-1),$S($P(qqzS,",",2):$P(qqzS,",",2),1:-1)) Q  ;@Dima&Dol 20.03.07 вписывание в заданный размер
 .D ..wM(qqz,"ScaleBitmap",$S($P(qqzS,",",1):$P(qqzS,",",1),1:-1),$S($P(qqzS,",",2):$P(qqzS,",",2),1:-1)) ;@Dima&Dol 15.03.07 желаемые размеры
 I qqo=-1,'qqso D ..wP(qwin_".T2","ColumnPictureH@1",qqz,qiii,0) D:+$G(qqzA) ..wP(,"ColumnPictureAlign",+qqzA,qiii) Q  ;@Dol 29.03.06 выравнивание;@dol 3.08.04 - картинки колонок
 D:$G(qqzclr)="" ..wP(qwin_".T2","M4",qqz,"",qiii,0) D:$G(qqzclr)'="" ..wP(qwin_".T2","M4",qqz,"",qiii,qqzclr)
 D:+$G(qqzA) ..wP(qwin_".T2","CellPictureAlign",+qqzA,"",qiii)
 Q
]]></Implementation>
</Method>

<Method name="wcellsel">
<Internal/>
<FormalSpec>qqyold:%Library.String,qqxold:%Library.String,qqynew:%Library.String,qqxnew:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;D ..Message($G(qqxnew)_" "_+$G(W("Zpos",2,"x")))
 I $G(Vo(qqnump,-1,19))=3 D:+$G(qqxnew)>-1 ..wM(qwin_".T2","MakeColumnVisible",+$G(qqxnew)) Q:$Q "" Q  ;;@Dol 7.04.07 чистое выделение строки
 I "45"[(+$G(Vo(qqnump,-1,19))) D:$G(qqxnew)'=""&&(qqxnew>-1)  Q:$Q "" Q  ;@Dol 4.02.08 рамка
 .;;;;;;;;I $G(qqxnew)=""||(qqxnew>-1) Q  ;D ..wM(qwin_".T2","SetCellRect",-1,-1,"SB") Q
 .D:$G(Vo(qqnump,-1,19))=4 ..wM(qwin_".T2","M9",1,0,$G(W("Zpos",2,"d")),2) I $E($G(Vo(qqnump,$P($G(W("Zpos",2,"d"))," ",2),0,$P($G(W("Zpos",2,"d"))," ",3),+$G(W("Zpos",2,"x"))))) D ..wM(qwin_".T2","SetCellRect","",+$G(W("Zpos",2,"x")),-16777203) Q  ;qqxnew,"SB") Q
 .D ..wM(qwin_".T2","SetCellRect",-1,-1,"SB") Q
 I $G(Vo(qqnump,-1,19)) D:$G(qqxnew)'=""&&(qqxnew>-1) ..wM(qwin_".T2","M9",1,0,$G(W("Zpos",2,"d")),$S(Vo(qqnump,-1,19)=2:2,$E($G(Vo(qqnump,$P($G(W("Zpos",2,"d"))," ",2),0,$P($G(W("Zpos",2,"d"))," ",3),+$G(W("Zpos",2,"x"))))):3+$G(W("Zpos",2,"x")),1:2)) Q:$Q "" Q
 I +$G(Vo(qqnump,-1,59)) D ..wM(qwin_".T2","MoveCursor","",+$G(qqxnew),0) Q:$Q "" Q
 I $G(qqxold)'="",qqxold>-1,qqxold=$G(qqxnew) Q:$Q "" Q
 I $G(qqxold)'="",qqxold>-1,qqxold'>Vo(qqnump,-1,9) D ..wP(qwin_".T2","ColumnSelectBackColor",$S($P($G(Vo(qqnump,-1,55)),",",6)'="":$P(Vo(qqnump,-1,55),",",6),1:-16777203),qqxold) ;8388608),qqxold) ;8388608,qqyold,qqxold) разотметка старой ячейки
 I $G(qqxnew)'="",qqxnew>-1,qqxnew'>Vo(qqnump,-1,9) D ..wP(qwin_".T2","ColumnSelectBackColor",12615808,qqxnew),..wM(,"MakeColumnVisible",qqxnew) ;отметка новой ячейки;16711680,
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wcellttips">
<Description>
Вывод всплывающих подсказок</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqso:%Library.String,qiii:%Library.String,qqci:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqz,qqc,qqw S qqz=Vt(qqnump,9,"PPt",qqo,+qqso,qiii),qqc=$S($G(qqo,-1)=-1:"",1:$G(Vc(qqnump,$G(qqci,-1)))),qqw=$G(Vo(qqnump,qqo,0,+qqso,qiii)),qqw=$S('$E(qqw):"",$E(qqw)=5:"Zs"_(+qqso)_"c"_qiii,1:$E($P(qqw," "),2,31)) ;@Dol 1.10.06 qqw
 S:$E(qqz)="@" @("qqz="_$E(qqz,2,30000)) S:$E(qqz)="@" @("qqz="_$E(qqz,2,30000))
 ;;;S qqz="qqo="_qqo_" qqc="_qqc_$C(13,10)_qqz
 ;d ..wP(qwin_".T2","CellItemDataString",$S($E(qqz,1,2)'="&~":qqz,1:"&~"),"",qiii) Q:$Q "" Q  ;@Dol 03.09.08
 n v s v=$S($E(qqz,1,2)'="&~":qqz,1:"&~")
 s:$g(XBLocal) v=qSYS.getLocal(v,4)   ;@Pav преобразование по справочнику локализации 15.02.2010
 d ..wP(qwin_".T2","CellItemDataString",v,"",qiii) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wcre">
<Description>
Создание дерева экземпляров обектов.
После вывода, позиционирование на $$$CurObj с кодом экземпляра qqc
Arg1 - не используются
Arg2 - после перевывода обработка авторазмеров окна, если они заданы (X162)
Nopos=1 - не позиционироваться
Для текущего экземпляра объекта (и всех предков) сохраняется состояние развернутости для непервого вызова ( Vc(qqnump) существует)
Vs(qqnump,2) УНИЧТОЖАЕТСЯ ( кроме Vs(qqnump,2)=1 - раскрыть все)

Перед вызовом возможно заполнить узел Vs(qqnump,22) для позиционирования и входа в редактирование если необходимо
Vs(qqnump,22)=qqo_"~"_qqc_"~"_qqw_"~"_(1 - войти в редактирование qqw)

opobj=1 - сохранять состояние развернутости для текущего объекта (вне зависимости от экземпляра!!!)

Состояние сохраняется методом qARM.Estat.

Можно использовать свои варианты сохранения состояние. Но перед вызовом wcre необходимо выполнить Kill Vc(qqnump).
В противном случае ( при наличии Vc(qqnump) ) создается Vs(qqnump,2... относительно  состояния ТЕУЩЕГО экземпляра. Учитывается только Vs(qqnump,2)=1 - развернуть все. </Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%Library.String,Nopos:%Library.String,opobj:%Library.String,qqFwgre:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;;@Dol 30.10.07 ??;I '$G(Arg1) d ..wP("-qARM","Cursor",-11) ;D ..Wait("D qARM.wcre(1)") Q
 ;;D ..wP(qwin,"BulkUpdate",1) ;?может D:$G(qwin(qwin,"child"))=""
 D ..wP(qwin_".T2","BulkUpdate",1)
 D ..wM(qwin_".T2","Clear"),..wM(,"ClearItemPictures"),..wM(,"ClearRowHeaderPictures")
 S:$G(Vt(qqnump,9,"PPd"))'="" Vt(qqnump,9,"PPd")="" ;@Dol 03.03.08 сброс указателя картинок текущей строки
 D:$D(qwin(qwin,"FCBUT")) ..ButtonDestr()
 I $G(W("ZBtredo"))'=$G(W("ZBtred")) D ..wgre() S W("ZBtredo")=W("ZBtred") I $G(W("ZoBLeV")) D qARM.wP(qwin_".T2","GuaranteedItemLevel",$G(W("ZoBLeV"))) ;автоматический вызов переинициализации (не учетен переход/перестройка отображения)
 ;S qql=$S($$$ReFind:$$$Relind_qview,1:1) ;раньше нигде не устанавливалась
 I $G($$$CurObj)'="" S:'$D(Vo(qqnump,$$$CurObj,38)) Vo(qqnump,$$$CurObj,38)=..GetPar("X538",,$$$CurObj) I Vo(qqnump,$$$CurObj,38)'="" N qqwavto,qqavto D  Q:$G(qqavto)=999  ;обработка автосортировки
 .S qqwavto=$P(Vo(qqnump,$$$CurObj,38)," ") Q:qqwavto=""  Q:qqwavto=$P($G($$$CondFind)," ")  S qqavto=$P($G(Vo(qqnump,$$$CurObj,11,qqwavto))," ",2) Q:qqavto=""
 .;D:$D(Vc(qqnump))>1 ..wM(qwin_".T2","SetFocus") ;только если не начальный вывод окна
 .D ..wbut(2,qqavto,1)
 .D ..T2ColHButton(qqavto,qqwavto) S qqavto=999
 I $D(Vc(qqnump))>1 D ..Estat($G(opobj)) ;сохраним текущее состояние свертки-развертки экземпляров (отработает в qW.gForm )
 K W("@Znum") D qW.gForm(qql,$G($$$CurObj),$G(qqc))
 D:$G(Vs(qqnump,99,"Pic"),$E(qqRES,3)) ..wpic(1) ;@dol 2.11.02 Если картинки есть, и их вывод явно не запрещен - они выводятся
 I $D(Vc(qqnump))>10 D:$G(W("ZotSt")) ..wP(qwin_".T2","LabelPictureH@1","Red0",0,0)
 I $G(W("ZoBLeV")),$S($D(qqflg240):1,1:'$G(qqXBwids)) D ..wM(qwin_".T2","M2",-1,"",W("ZoBLeV"),"00",0) ;чтобы был отступ для бланка @dol 19.03.03 строка заданного уровня (чтобы не дергался экран)
 I $G(W("Zpos",2,"x"))'="" D ..wcellsel(,W("Zpos",2,"x"))
 ;sas 20090626
 ;K W("Zpos",2,"y")  ;;,W("Zpos",2,"x") 20061027 Sasha указатель курсора не отставался при переходе на след экземпляр или перевывод ;"d" нужно оставить, чтобы после перевывода встать на прежнюю строку объекта
 I $D(Vs(qqnump,2,-1)) D  ;есть свернутые объекты
 .N qqci,qqo S qqo="" F  S qqo=$O(Vs(qqnump,2,-1,qqo)) Q:qqo=""  S qqci="" F  S qqci=$O(Vs(qqnump,2,-1,qqo,qqci)) Q:qqci=""  D:$G(Vc(qqnump,qqci,40))'=1 ..wM(qwin_".T2","M9",1,0,qqci_" "_qqo_" 0","",0)
 K:'$G(Nopos) Vs(qqnump,2)
 I $G(Vc(qqnump))="" S Vc(qqnump)="AA" I '$D(Vc(qqnump,"AA")) N qqso0 S qqso0=$O(Vo(qqnump,-1,0,0)) I $S(qqso0="":1,1:$D(Vo(qqnump,-1,0,qqso0))<10) D ..wpoe(,,,1) G wcreend ;нет постоянных строк
 ;@Pav 29.06.2009
 ;D:'$G(Nopos) ..wpoe($S('$D(Vc(qqnump,Vc(qqnump))):-1,1:$G(Vc(qqnump),-1))_" "_$G(Vc(qqnump,Vc(qqnump),0),-1)_" "_$S($G(Vc(qqnump,Vc(qqnump),0))=$P($G(W("Zpos",2,"d"))," ",2):+$P($G(W("Zpos",2,"d"))," ",3),1:0)) ;,1) ; ,1) Beg=1 - видимость текущей строки
 ;I '$G(Nopos) {
 ;        ;Если указан экземпляр позиционирования
 ;        ;D:$d(Vs(qqnump,22)) qARM.Wait("d:$g(qqnump)="""" qARM.crst(,"_qqnump_",2) s ^AA=qqnump d:$d(Vs(qqnump,22)) qARM.wpoe(,,,,$p(Vs(qqnump,22),""~""),$p(Vs(qqnump,22),""~"",2)) d:$p(Vs(qqnump,22),""~"",3)'="""" qARM.NextEdit(""-""_$p(Vs(qqnump,22),""~"",3),$s($p(Vs(qqnump,22),""~"",4)=1:"""",1:1)) k Vs(qqnump,22)")
 ;        i $d(Vs(qqnump,22)) d qARM.wpoe(,,,,$p(Vs(qqnump,22),"~"),$p(Vs(qqnump,22),"~",2)) d:$p(Vs(qqnump,22),"~",3)'="" qARM.NextEdit("-"_$p(Vs(qqnump,22),"~",3),$s($p(Vs(qqnump,22),"~",4)=1:"",1:1)) k Vs(qqnump,22) q
 ;        ;Если не указан екземпляр позиционирования
 ;        D:'$d(Vs(qqnump,22)) ..wpoe($S('$D(Vc(qqnump,Vc(qqnump))):-1,1:$G(Vc(qqnump),-1))_" "_$G(Vc(qqnump,Vc(qqnump),0),-1)_" "_$S($G(Vc(qqnump,Vc(qqnump),0))=$P($G(W("Zpos",2,"d"))," ",2):+$P($G(W("Zpos",2,"d"))," ",3),1:0)) ;,1) ; ,1) Beg=1 - видимость текущей строки
 ;}

  ;@misuno 20101207
  I '$G(Nopos) {
  ;Если указан экземпляр позиционирования
  i $d(Vs(qqnump,22)) d qARM.wpoe(,,,,$p(Vs(qqnump,22),"~"),$p(Vs(qqnump,22),"~",2)) d:$p(Vs(qqnump,22),"~",3)'="" qARM.NextEdit("-"_$p(Vs(qqnump,22),"~",3),$s($p(Vs(qqnump,22),"~",4)=1:"",1:1)) k Vs(qqnump,22) q
  ;Если не указан экземпляр позиционирования
  D:'$d(Vs(qqnump,22)) ..wpoe($S('$D(Vc(qqnump,Vc(qqnump))):-1,1:$G(Vc(qqnump),-1))_" "_$G(Vc(qqnump,Vc(qqnump),0),-1)_" "_$S($G(Vc(qqnump,Vc(qqnump),0))=$P($G(W("Zpos",2,"d"))," ",2):+$P($G(W("Zpos",2,"d"))," ",3),1:0)) ;,1) ; ,1) Beg=1 - видимость текущей строки
  } 

 ;;I $G(W("ZBtred")) D ..NextEdit("",1) ;@dol 17.03.03 спозиционироваться на первую редактируемую ячейку
wcreend 
 D ..wwwwZXXadd() ;D:$D(Vt(qqnump,"ZXXadd")) ..wwwwZXXadd()
 I $G(Vo(qqnump,-1,999)) F j=0:1:Vo(qqnump,-1,9) I +$P($G(Vo(qqnump,-1,9,j)),",")=-1 D ..wM(qwin_".T2","MakeColumnOptimal",j) ;@Dol 25.03.05 $G(Vo(qqnump,-1,999)) -
 ;D ..wM(qwin_".T2","RecalcHorizontalExtent") ;@Dol 25.03.05 делается у Димы по "BulkUpdate",0)
 D:$D(Vt(qqnump,9,"FCBUT")) ..wwwwFCBUT()
 D:$D(Vt(qqnump,9,"PPDL")) qARM.wM("-qARM","UpdateDataLinks") ; tdv 18.03.2008 Получение значений всех ячеек отображения с пересчитываемыми выражениями
 I $G(Arg2),$G(Vo(qqnump,-1,62)) D ..wM(qwin_".T2","RecalcHorizontalExtent"),..wM(qwin,"qResize",$TR(Vo(qqnump,-1,62),"123","312"))
 D ..wP(qwin_".T2","BulkUpdate",0)
 S:$D(qqflg240) qqflg240=1 ;флаг используется для анализа выполнения при загрузке отображения (LoadView)
 D:'$D(qqflg240)
 .I $G(Vo(qqnump,-1,663))'="",'$P(Vo(qqnump,-1,663),",",2) D ..wM(qwin_".T2","MakeSplitterOptimal")  ;@dol 29.11.06 - если идет открытие, будет в ..OpenWindow в конце (после того, как окно стало видимым)
 .I '$G(qqXBwids),$G(W("ZoBLeV")) D ..wM(qwin_".T2","M9",1,0,"00"),..wM(,"M6","",1) ;@dol 6.12.04 - убрать лишнюю строку
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wcrm">
<Description>
Создание пункта меню
qqpar1 - номера пунктов (разделитель уровней _ )
qqpar2 = -1 - удаление, 0 или пусто - создание
1 - установка заданных параметров
qqpar3 - название
qqpar4 - активность, помеченность, .BMP-файл, разделитель ;, Hint
mbBreak
qqpar5 - возможность событий
qqpar6 - картинка

Для изменения из действия по меню - qqpar1=0</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String,qqpar3:%String,qqpar4:%String,qqpar5:%String,qqpar6:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 G:$P($G(qARM("Ver","qARMProj1.ocx")),".",4)="" wcrmold ;@Dol 24.05.07 временно на переходный период
 I qqpar1=0 S qqpar1=$P(Sender,".M",2,255) ;@dol 23.06.04 в обработке действий по выбору пункта меню
 s:$g(XBLocal) qqpar3=qSYS.getLocal($g(qqpar3),3)  ;@Pav 12.02.2010 значение из справочника локализации
 D ..wM("-qARM","wcrm",$G(qwin),$G(qqpar1),$G(qqpar2),..wdbl($g(qqpar3)),$G(qqpar4),$G(qqpar5),$G(qqchi)) ;@Dol 08.05.09 ..wdbl(
 N qqwc,mnm S qqwc=$G(qqpar6) D:qqwc'=""
 .S mnm=qqpar1 N qqpar1 S qqpar1=mnm D:$E(qqpar1)'?1N
 ..I qqpar1'["_" S qqpar1=$E(qqpar1,3,6) Q
 ..S qqpar1=$P(qqpar1,"_",2)
 .i $E(qqpar1,1,2)="8u" s mnm="XU8.M"_qqpar1 ;"XU"_qqchi_".
 .e  s mnm="M"_qqpar1
 .I $E(qqwc)="@" S qqwc=..Value($E(qqwc,2,30000))
 .D ..wbmp("PIM"_qqpar1,qqwc,,1) d ..wP(qwin_"."_mnm,"Bitmap","PIM"_qqpar1)
 ;D ..wM("-qARM","wcrm",$G(qwin),$G(qqpar1),$G(qqpar2),$G(qqpar3),$G(qqpar4),$G(qqpar5),$G(qqchi))
 Q:$Q "" Q
 ;************@Dima 23.05.07 перенесено в объект
wcrmold I qqpar1=0 S qqpar1=$P(Sender,".M",2,255) ;@dol 23.06.04 в обработке действий по выбору пункта меню
 N qqwc,qqPOP,mnm S qqPOP="" I $E(qqpar1)'?1N D
 .I qqpar1'["_" S qqPOP=$E(qqpar1,1,2),qqpar1=$E(qqpar1,3,6) Q  ;имя PopUp меню - два символа; (было 5)
 .S qqPOP=$P(qqpar1,"_"),qqpar1=$P(qqpar1,"_",2)
 i $E(qqpar1,1,2)="8u" s mnm="XU8.M"_qqpar1 ;"XU"_qqchi_".
 e  s mnm="M"_qqpar1
 I '$G(qqpar2) D ..wC("TMenuItem",qwin_"."_mnm)
 I $G(qqpar3)'="" d ..wP(qwin_"."_mnm,"Caption",qqpar3)
 I $P($G(qqpar4),",",2)'="" d ..wP(qwin_"."_mnm,"Checked",$P(qqpar4,",",2))
 I $G(qqpar5)'=""!('$G(qqpar2)) d ..wP(qwin_"."_mnm,"OnClick",$S($G(qqpar5)=1:1,$G(qqpar5)=0:0,1:1))
 I $P($G(qqpar4),",")'="" d ..wP(qwin_"."_mnm,"Enabled",+qqpar4)
 I $G(qqpar2)<0 d ..wM(qwin_"."_mnm,"Destroy") Q:$Q "" Q
 S qqwc=$G(qqpar6) D:qqwc'=""
 .I $E(qqwc)="@" S qqwc=..Value($E(qqwc,2,30000))
 .D ..wbmp("PIM"_qqpar1,qqwc,,1) d ..wP(qwin_"."_mnm,"Bitmap","PIM"_qqpar1)
 S qqwc=$P($G(qqpar4),",",4)  I qqwc'="" d ..wP(qwin_"."_mnm,"Break",qqwc)
 ;S qqwc=$P($G(qqpar4),",",5,255) I qqwc'="" d ..wP(qwin_".M"_qqpar1,"Hint",qqwc),..wP(qwin_".M"_qqpar1,"HintShow",1)
 I $G(qqpar2) Q:$Q "" Q
 I $L(qqpar1,"_")=1,qqPOP="" Q:$Q "" Q  ;d ....wM(qwin_".AM","Items.Add","M"_qqpar1) Q "" ;выбоы горизонтального меню
 I $L(qqpar1,"_")=1 d ..wM(qwin_"."_qqPOP,"Items.Add",mnm) Q:$Q "" Q  ;вершина всплывающего меню
 i $E(qqpar1,1,2)="8u" d ..wM(qwin_".XU"_qqchi_".M"_$P(qqpar1,"_",1,$L(qqpar1,"_")-1),"Add",mnm) I 1
 e  d ..wM(qwin_".M"_$P(qqpar1,"_",1,$L(qqpar1,"_")-1),"Add",mnm)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wcro">
<Description>
Создание дерева объектов.
qqpar1 - создание таблиц понятий:
Vo(qqnump,qqo,11,qqw)=qqso_" "_qqx
Vo(qqnump,qqo,10,num)=qqw    num=1...N - порядковый номер
и параметров колонок (Vo(qqnump,-1,9,col)
wrt=1 - выводить, даже если запрет вывода (признак запрета сбрасывается) ;@Dol 30.12.10</Description>
<Internal/>
<FormalSpec>qqpar1,wrt</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$D(Vo(qqnump,-1,84)) D ..GetPar("X184") S:$P(Vo(qqnump,-1,84),",")="" $P(Vo(qqnump,-1,84),",")=$S($G(W("Zsform"))=11&0:-1,$E(Vo(qqnump),1,3)="XXX":1,1:2) ;@Dol 30.12.10 ? если нет тулбаров, запрет вывода ? пока блокировано (&0)
 I '$G(W("ZBt0")),$P(Vo(qqnump,-1,84),",")=-1 Q:'$G(wrt)  S $P(Vo(qqnump,-1,84),",")=1 ;@Dol 30.12.10 -1 - запрет вывода
 N j,qi,qiii,qqso,qk,qkk,qqw,qqsto
 S qqsto=$S(W("Zadm"):1,1:Vo(qqnump,-1,84)) ;стиль дерева объектов
 S:$G(Vs(qqnump,"Analit")) $P(qqsto,",")=1
 D ..wP(qwin_".T1","BulkUpdate",1)
 D ..wM(,"Clear"),..wM(,"ClearItemPictures"),..wM(,"ClearCellPictures")
 D ..wP(qwin_".T1","Scrollbars",3)
 S qqsto=+qqsto
 D ..wP(,"GridStyle",''qqsto*3),..wP(,"ItemLines",$S(''qqsto:4,1:1)) ;@Dol 23.09.10 четыре строки в режиме Адм/Аналит ;было ''qqsto+1
 S qi=$S(W("ZBt0"):$G(Vo(qqnump,-1,9),1)+2,1:''qqsto*11+1) D ..wP(,"Columns",qi) ;10-12
 S qkk=$P($G(Vo(qqnump,-1,70))," ") F j=0:1:qi-1 D  ;qkk - список умолчаний
 .D ..wP(,"ColumnText",$S('j:"Объекты"_$S(W("ZBt0"):"",1:"/Понятия"),$G(W("ZBt0")):(j-1),1:$P("Условие Аналитика A D Num Sum Min Max Mid Dmid"," ",j)),j)
 .I W("ZBt0") D ..wP(,"ToolTipColumnE",$S('j:"Завершение редактирования",1:"Графа "_j_" дерева экземпляров"),j)
 .I 'W("ZBt0") D ..wP(,"ToolTipColumnE",$S('j:$S(W("Zadm"):"Редактирование дерева объектов",1:"Раскрыть все объекты"),j=1:"Условия поискового образа",j=2:"Выражения аналитик",j=3:"Аналитические срезы",j=4:"Вычисляемые значения",j=5:"Количество в выборке",j=6:"Сумма всех значений",j=7:"Минимальное значение",j=8:"Максимальное значение",1:"Среднее значение"),j)
 .D
 ..I $G(W("ZBt0")) D  Q  ;@dol 15.03.03 - реальный размер колонок
 ...I 'j S qk="15,0,1" Q
 ...S qk=$P($G(Vo(qqnump,-1,0,0,j-1,2)),",") S:qk="" qk=$P($G(Vo(qqnump,-1,9,j-1)),",") S qk=$S(qk="":10,qk=-1:10,1:qk) S qk=qk*$G(W("Zoom"),1)_$S(qk["px":"px",1:"")_",0,1" Q
 ..S qk=$S($G(W("ZBt0")):"15,0,1",'j:"17,0,5",j<3:"15,0,5",j<5:4,1:"7,2,1"),qiii=$P(qkk,",",j+1) S:qiii $P(qk,",")=qiii
 .D ..wP(,"ColumnWidth",$S(qk["px":+qk,qk["%":$J(qARM("Screen","Width")*qk/100,0,0),1:qk*$P(W("Zfont"),",",3)),j) I 'W("ZBt0"),j D ..wP(,"ColumnForeColor",8388608,j) ;если в размере в конце стоит pc - то пиксели, иначе - условные символы)
 .D ..wP(,"ColumnStyle",$P(qk,",",2)+($P(qk,",",3)*4+8+$S(W("ZBt0"):0,1:0)),j)
 D:$G(qqXBz)  ;@dol 19.11.05 колонка зачеркивания
 .D ..wP(,"RowHeaderAppearance",'$G(W("ZBt0"))) Q:$G(W("ZBt0"))
 .D ..wP(,"RowHeaderWidth",16) I '$D(WQ("R291"))  D qARM.wC("TBitmap","R291") S WQ("R291")="" D qARM.wM("R291","LoadFromRes",291)
 .D ..wP(qwin_".T1","OnMouseMove",1),..wP(,"ToolTipRowE","Сброс/установка зачеркивания всех объектов",-1),..wP(,"RowColPictureH@1","R291",0)
 I W("ZBt0") D wcrot(-1,1,"") G wcroend
 ;
 D:qqsto ..wwde()
 ;заголовок отображения
 D ..wM(,"M2",-1,"",0,"",0)
 D ..wP(,"M1",$S($G(Vs(qqnump,"Analit"))||$G(W("Zadm")):Vo(qqnump)_" ",1:"")_Vo(qqnump,-1),0,0,$S($G(Vo(qqnump,-1,67))="":"F1",1:"F4"))
 D ..wP(,"M1",$G(Vs(qqnump,120,2)),0,2) ;@Dol 26.05/06 заголовок аналитики
 D:qqsto
 .S qiii=$G(Vo(qqnump,-1,26)) I qiii'="" S @("qiii="_qiii) I qiii'="" D  Q  ;замещающая картинка
 ..D ..wbmp("po",qiii),..wP(qwin_".T1","M3","po",0)
 .D ..wP(,"M3",$S($G($$$Tree):"Ot",1:"Bow"),0)
 ;
 S qqso=""
 F  S qqso=$O(Vo(qqnump,-1,0,qqso)) Q:qqso=""  S %1=$P($G(Vo(qqnump,-1,0,qqso))," ") I %1'="" Q:$G(Vs(qqnump,1,%1))=-1  D wcrot(%1,1,%1)
 D ..wpot(),..wrot(),..wfot(-1)
wcroend ;D ..wM(qwin_".T1","RecalcHorizontalExtent") ;@Dol 27.05.07 есть в BulkUpdate
 D ..wP(qwin_".T1","BulkUpdate",0) Q:$Q "" Q
wcrot(qqo,qqlev,qqob) ; служебная подпрограмма
 I '($D(Vo(qqnump,qqo))#10) D ..Message("Ссылка на несуществующий объект "_qqo) Q
 N qqso S qqso=""
 I $G(W("ZBt0")),$D(Vo(qqnump,qqo,0,0))<10 S ^Q(1,"XView",Vo(qqnump),"CxObj",qqo,"Xy",0,"Xx",0,"x70")=0,^("X71")="...",Vo(qqnump,qqo,0,0,0)="0..." ;@dol 17.12.12 порождение строки 0
 F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""  S %1=$G(Vo(qqnump,qqo,0,qqso)) D  I W("ZBt0"),$G(Vo(qqnump,qqo,889))'="" Q
 .I %1="",'W("ZBt0") D:'qqso  Q  ;строка объекта (исполнение)
 ..I +qqsto'=1,$G(Vs(qqnump,1,qqo)) S qqlev=qqlev-1 K Vs(qqnump,4,qqo) Q
 ..D ..wM(,"M2",-1," ",qqlev,qqo,0,"",$S('$G(qqXBz):"",$G(Vs(qqnump,1,qqo)):"R291",1:""))
 ..S %2=$S(qqsto'=1:0,1:$G(Vo(qqnump,qqo,27))'=""!$G(Vo(qqnump,qqo,28))),%3=$TR(..wcroCell(qqo),"_"," ") D ..wP(,"M1",$S($G(Vs(qqnump,"Analit"))||$G(W("Zadm")):qqo_" ",1:"")_$S(qqsto'=1:%3,'$D(Vt(qqnump,111)):%3,$D(Vt(qqnump,111,0,qqo)):%3,$D(Vt(qqnump,111,1,qqo)):"<<"_%3_">>",1:"<"_%3_">"),"",0,$S(qqsto'=1:"",..GetPar(53,,qqo):$S(%2:"F4",1:"F1"),%2:"F3",1:""))
 ..S qiii=$G(Vo(qqnump,qqo,26)) I qiii'=""  D  Q  ;замещающая картинка объекта
 ...D  Q:qiii=""  ;@dol 7.10.04
 ....I $E(qiii)="@" S @("qiii="_$E(qiii,2,30000)) Q
 ....I "M,R,F,"'[$E(qiii,1,2) S @("qiii="_qiii)
 ...D ..wbmp("po"_qqo,qiii)
 ...D:$D(Vt(qqnump,9,qqo_" 0")) ..wP(qwin_".T3","M3","po"_qqo,Vt(qqnump,9,qqo_" 0")) ;подправим образец экземпляров
 ...D ..wP(qwin_".T1","M3","po"_qqo,"")
 ..Q:'qqsto
 ..D ..wP(,"M3",$S($G(Vs(qqnump,1,qqo)):"d",1:"")_$S($G(Vs(qqnump,4,qqo)):"p1",1:"p0"),"") ;раскрытые папки
 ..I $D(Vs(qqnump,8,qqo)) D ..wP(,"M4","Bor","",1) ;для объекта есть условие
 ..I $G(Vs(qqnump,12,qqo)) D ..wP(,"M4","Bor","",4) ;ссылка на экземпляр в аналитике
 .I %1="",W("ZBt0") D  Q  ;строка объекта (редактирование)
 ..S qiii=$S(qqso:"",1:$S(qqo<0:Vo(qqnump),1:qqo_" ")_..wcroCell(qqo)) F qi=0:1:$S($G(Vo(qqnump,qqo,889))'="":0,1:$O(Vo(qqnump,qqo,0,qqso,""),-1)) D
 ...;I $G(Vo(qqnump,qqo,0,qqso,qi))=0,$O(^Q(1,"XView",Vo(qqnump),"CxObj",qqo,"Xy",qqso,"Xx",qi,""))="x70",$S(qqso:1,1:qi) K ^Q(1,"XView",Vo(qqnump),"CxObj",qqo,"Xy",qqso,"Xx",qi),Vo(qqnump,qqo,0,qqso,qi)  ;@dol 17.03.03 удаление пустых констант
 ...S qiii=qiii_$C(31)_$S($G(Vo(qqnump,qqo,0,qqso,qi))="":"",1:..wcroCell(qqo,qqso,qi))
 ..D ..wM(,"M2",-1,qiii,qqlev-('qqso),qqo_" "_qqso,0)
 ..D:'qqso ..wP(,"M3",$S(qqo<0:"Bow",1:"p0"),"",0)
 .I qqo=-1,$O(Vo(qqnump,-1,0,qqso),-1)="" D ..wM(,"M2",-1,Vo(qqnump)_$G(Vo(qqnump,-1)),0,"-1 0",0),..wP(,"M3","Bow","")
 .D:$G(Vs(qqnump,1,$P(%1," ")))'=-1 wcrot($P(%1," "),qqlev+1,qqob_","_$P(%1," ")) Q  ;ссылка на объект; @Dol 8.10.04 -1 - блокировка вывода 
 Q
]]></Implementation>
</Method>

<Method name="wcroCell">
<Description>
                Содержимое ячейки дерева объектов</Description>
<Internal/>
<FormalSpec>qObj:%String,y:%String,x:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qiiii,qiiiiadd
 I $G(y)="" S qiiii=$G(Vo(qqnump,qObj)) S:$E(qiiii)="@"!(qiiii="") qiiii=qW.GetWoc("CxObj",qObj) Q qiiii_$S('$G(W("ZBt0")):"",$G(Vo(qqnump,qObj,889))'="":$C(13,10)_"Ссылка на описание в "_Vo(qqnump,qObj,889),1:$C(13,10)_"Lqqc="_$G(Vo(qqnump,qObj,0))_$S('$G(Vo(qqnump,qObj,2)):"",1:" "_qW.GetWoc("Cx52",+$G(Vo(qqnump,qObj,2)))))
 
 //S qiiii=$S($G(Vo(qqnump,qObj,0,y,x)) D:qiiii'=""  закомментирована sasha 20080717
 S qiiii=$S($G(Vo(qqnump,qObj,0,y,x))'="":Vo(qqnump,qObj,0,y,x),1:qARM.GetPar("x70",,qObj,y,x)_qARM.GetPar("x71",,qObj,y,x)) D:qiiii'=""
 .I $E(qiiii)=0 Q:$E(qiiii,2)'="@"  S qiiii=0_$TR($S($L(qiiii)=2:..GetName(,qObj),1:..GetName(,qObj,$E(qiiii,3,20))),"%") Q
 .I "234"[$E(qiiii) S qiiii=qiiii_" "_$S(..GetPar("X7100",,qObj,y,x)'=""&(W("ZBt0")=1):..GetPar("X7100",,qObj,y,x)_" <"_qW.GetWoc("CxWoc",$E(qiiii,2,200))_">",1:qW.GetWoc("CxWoc",$E(qiiii,2,200)))
 S qiiiiadd=$C(13,10)_..GetPar(72,,qObj,y,x)_$C(13,10)_..GetPar(76,,qObj,y,x) ;..GetPar(730,,qObj,y,x)_" "_..GetPar(731,,qObj,y,x)_" "_..GetPar(73,,qObj,y,x)_$C(13,10)_..GetPar(740,,qObj,y,x)_" "_..GetPar(74,,qObj,y,x)_$C(13,10)_..GetPar(75,,qObj,y,x)_$C(13,10)_..GetPar(76,,qObj,y,x)
 S:$TR(qiiiiadd,$C(13,10,32))="" qiiiiadd=""
 Q qiiii_qiiiiadd
]]></Implementation>
</Method>

<Method name="wdbl">
<Description>
Дублирование в строке "верхних" двойных кавычек ($C(147)). Необходим при передаче данных через 
протокол. (В нем они значимы).</Description>
<Internal/>
<FormalSpec>str:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N char S char=1 F  S char=$F(str,$C(147),char) Q:'char  S $E(str,char-1)=$C(147,147),char=char+1
 Q str
]]></Implementation>
</Method>

<Method name="wfoc">
<Description>
вход в редактирование дерево (qqpar1), позицию (y -qqpar2, x - qqpar3)
qqpar4 - поиск по индексу </Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String,qqpar3:%String,qqpar4:%String,selpos:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqtr S qqtr=qqpar1,qqpar1=qwin_".T"_qqpar1,qqpar2=$G(qqpar2) K qqCEKey
 I qqpar2="",$G(qqpar4)'="" D ..wM(qqpar1,"M9",1,0,qqpar4)
 G:$P($G(qARM("Ver","qARMProj1.ocx")),".",2)>4 wfocnew ;@Dima -новое дерево
 D  Q:$Q "" Q
 .I $P(W("Zdrl")," ",8)'="",'W("Zcdrl")!(+W("Zcdrl")=4)!(+W("Zcdrl")=5) D ..wP(qqpar1,"ColumnWidth",$S($P(W("Zdrl")," ",8)["px":+$P(W("Zdrl")," ",8),1:$P(W("Zdrl")," ",8)*$P(W("Zfont"),",",3)),qqpar3)
 .;qqred теряется по развертке поискового образа (Home несколько раз)
 .I $G(qqred)'="" N q743 S q743=$S(qqred="ZfI9"&(qqtr=1):$S($G(W("Zpos",1,"x"))=2:2,1:0),1:..GetPar(743,,qqo,qqred)) I q743 D ..wM("-qARM","ChangeLanguage",$S(q743=1&(qqlang=1)!(q743=3):"00000419",1:"00000409")) ;рус англ OOOOO409
 .I $E(qqw,1,3)="ZZR" D ..wP(qqpar1,"M1",$P(W("Zldrl"),"~"),qqpar2,qqpar3) S qqCEKey=0
 .I qqtr=2,$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,10))?1(1"1",1"10") D  Q  ;дата ; @tdv 05.08.05 - дабавлен тип 10 DATEYY
 ..I $P(W("Zcdrl")," ",2)=2 D wfoc1 Q
 ..;I '$D(qwin(qwin,"DTP")) D ..wC("TqDateTimePicker",qwin_".DTP",qqpar1,0,0,$S(qqpar2="":-1,1:qqpar2),qqpar3) S qwin(qwin,"DTP")="" D:0 ..wP(,"OnKeyUp",1) D ..wP(,"OnKeyDown",1) D ..wP(,"OnExit",1) I 1
 ..;E  D ..wM(qwin_".DTP","CellNew",qqpar1,0,0,$S(qqpar2="":-1,1:qqpar2),qqpar3),..wP(,"Visible",1)  ;RPosT@ 2,2
 ..D:$D(qwin(qwin,"DTP")) ..wM(qwin_".DTP","Destroy") D ..wC("TqDateTimePicker",qwin_".DTP",qqpar1,0,0,$S(qqpar2="":-1,1:qqpar2),qqpar3) S qwin(qwin,"DTP")="" D ..wP(,"OnKeyDown",1) D ..wP(,"OnExit",1) ;@dol 31.07.03 модернизированная дата
 ..D ..wM(,"SetFocus"),..wP(,"AutoShift",'$G(qqXBDate)) ;автоперескок
 ..S %8=$G(W(qqw)) S:%8?2N1"."2N1"."2.4N %8=$S($L($P(%8,".",3))=2:"20",1:"")_$P(%8,".",3)_$P(%8,".",2)_$P(%8,".",1) ;@dol 23.08.04 хранится в формате даты
 ..I %8=""!(%8'?1.N) S %8=$ZD($H,8) S:$G(W(qqw))="" W(qqw)=%8 S:"@Z"'[$E(qqw)&&(" "_qqwchg_" "'[(" "_qqw_" ")) qqwchg=qqwchg_" "_qqw D qARM.wwww(qqw) ;текущая дата по умолчанию @dol 6.09.02 была забыта запись в W(qqw)
 ..S %8=$E(%8_"00000000",1,8) S:'$E(%8,5,6) $E(%8,5,6)="01" S:'$E(%8,7,8) $E(%8,7,8)="01"
 ..D ..wP(qwin_".DTP","Date",$ZDH(%8,8)-21548)
 .I qqtr=2,$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,10))?1(1"Ht",1"T") D  Q  ;Время ($H), tdv 20100326 - T
 ..I $P(W("Zcdrl")," ",2)=2 D wfoc1 Q
 ..D:$D(qwin(qwin,"DTP")) ..wM(qwin_".DTP","Destroy") D ..wC("TqDateTimePicker",qwin_".DTP",qqpar1,0,0,$S(qqpar2="":-1,1:qqpar2),qqpar3) S qwin(qwin,"DTP")="" D ..wP(,"OnKeyDown",1) D ..wP(,"OnExit",1) ;@dol 31.07.03 модернизированная дата
 ..D ..wP(,"Format","HH:mm") ;@Dol 28.06.06 время без секунд
 ..D ..wP(,"Kind",1),..wM(,"SetFocus"),..wP(,"AutoShift",0) ;- время
 ..S %8=$G(W(qqw)) I %8=""!(%8'?1.N) S %8=$P($H,",",2) S:$G(W(qqw))="" W(qqw)=%8 S:"@Z"'[$E(qqw)&&(" "_qqwchg_" "'[(" "_qqw_" ")) qqwchg=qqwchg_" "_qqw D qARM.wwww(qqw) ;текущая дата по умолчанию @dol 6.09.02 была забыта запись в W(qqw)
 ..D ..wP(qwin_".DTP","Date",%8/(24*3600))
 .I qqtr=2,$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,10))=6 D  Q  ;ГГГГММ
 ..I $P(W("Zcdrl")," ",2)=2 D wfoc1 Q
 ..D:$D(qwin(qwin,"MOY")) ..wM(qwin_".MOY","Destroy") D ..wC("TqMonthEdit",qwin_".MOY",qqpar1,0,0,$S(qqpar2="":-1,1:qqpar2),qqpar3) S qwin(qwin,"MOY")="" D ..wP(,"OnKeyDown",1) D ..wP(,"OnExit",1) ;@dol 1.12.03 ГГГГММ
 ..D ..wM(,"SetFocus")
 ..S %8=$G(W(qqw)) S:%8?2N1"."2.4N %8=$S($L($P(%8,".",3))=2:"20",1:"")_$P(%8,".",3)_$P(%8,".",2)_"00" ;@dol 23.08.04 хранится в формате даты
 ..I %8=""!(%8'?1.N) S %8=$E($ZD($H,8),1,6) S:$G(W(qqw))="" W(qqw)=%8 S:"@Z"'[$E(qqw)&&(" "_qqwchg_" "'[(" "_qqw_" ")) qqwchg=qqwchg_" "_qqw D qARM.wwww(qqw)
 ..D ..wM(qwin_".MOY","SetMonth",+$E(%8,5,6),+$E(%8,1,4))
 .I qqtr=2,$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,10))=7 D  ; ; @tdv 05.08.05 ГГГГММДДччммсс
 ..D ..wP(qqpar1,"M1",$G(W(qqw)),qqpar2,qqpar3)
 .I qqtr=2,$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,44))'="" D  Q  ;маска
 ..I $P(W("Zcdrl")," ",2)=2 D wfoc1 Q
 ..I '$D(qwin(qwin,"MSE")) D ..wC("TqAdvMaskEdit",qwin_".MSE",qqpar1,0,0,$S(qqpar2="":-1,1:qqpar2),qqpar3) S qwin(qwin,"MSE")="" D ..wP(,"ReturnIsTab",0) D ..wP(,"OnKeyDown",1) D ..wP(,"OnExit",1) I 1
 ..E  D ..wM(qwin_".MSE","CellNew",qqpar1,0,0,$S(qqpar2="":-1,1:qqpar2),qqpar3),..wP(,"Visible",1) D ..wP(,"OnKeyDown",1) D ..wP(,"OnExit",1)
 ..D ..wM(,"SetFocus") ;,..wP(,"EditType",6)
 ..D ..wP(,"EditMask",Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,44)),..wP(,"Text",$G(W(qqw)))
 .I qqtr=2,$E($G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,10)))="M" D  Q  ;Деньги
 ..I $P(W("Zcdrl")," ",2)=2 D wfoc1 Q
 ..I '$D(qwin(qwin,"MONY")) D ..wC("TqMoneyEdit",qwin_".MONY",qqpar1,$S(qqpar2="":-1,1:qqpar2),qqpar3) S qwin(qwin,"MONY")="" I 1
 ..E  D ..wM(qwin_".MONY","CellNew",qqpar1,$S(qqpar2="":-1,1:qqpar2),qqpar3),..wP(,"Visible",1)
 ..D ..wM(,"SetFocus")
 ..D ..wP(,"MaxRubLen",+$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,45)))
 ..S:'$D(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,87)) Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,87)=..GetPar("X787",,$$$CurObj,$P(W("Zpos",2,"d")," ",3),qqpar3) S qqtr=$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,87)) S:$E(qqtr)="@" @("qqtr="_$E(qqtr,2,3000)) D ..wP(,"ForceSign",+qqtr) ;@Dima 15.11.06 ForceSign
 ..D ..wP(,"KopDigits",$E(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,10)_2,2))
 ..D ..wP(,"Value",$G(W(qqw)))
 .D ..wP(qqpar1,"OnCEKeyDown",1) ;,..wM(,"SetCellEditSelection",0,0)
 .I $P(W("Zcdrl")," ",2)=2,"045"[(+W("Zcdrl")) D ..wM(qqpar1,"StartComboEdit",qqpar2,qqpar3,..wdbl(W("Zldrl")),"~") Q  ;+W("Zcdrl")'=3 - старый вариант даты
 .I $P(W("Zcdrl")," ",2)=1,"045"[(+W("Zcdrl")) D ..wM(qqpar1,"StartCombo",qqpar2,qqpar3,..wdbl(W("Zldrl")),"~") Q
 .D ..wP(qqpar1,"OnCEKeyDownT",1) ;,..wP(qqpar1,"EndEditOnEnter","YT"'[$E(qqw)) ;@Dol 10.11.05 Для текста - Enter - новая строка
 .I qqtr=2,$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,10))="N" D ..wP(qqpar1,"EditNum",1) ;@Dima@Dol 26/07/06 число
 .I qqtr=2,$S($E(qqw)'="T":$G(W(qqw))="",1:$G(W(qqw,0))=""),"Y"'[$E(qqw),$G(Vo(qqnump,-1,65))=2,qqw'?1"Zs"1.n1"c"1.n D ..wP(qqpar1,"BulkUpdate",1),..wP(qqpar1,"M1","",qqpar2,qqpar3),..wM(,"StartEdit",qqpar2,qqpar3),..wP(qqpar1,"M1"," ",qqpar2,qqpar3),..wP(,"BulkUpdate",0,1) Q  ;@dol 26.02.03 уберем ненужный пробел при выводе пустых значений;@dol 5.3.03 и сразу вставим, чтобы ячейка не исчезла по выходу ESC (@* ???);@dol 17.07.03 qqtr=2 - иначе проблемы с выр.аналитик;@dol 17.06 - Zs;@Dol 27.06.06 "TY"'[$E(qqw) - убрано
 .I '$D(selpos) N selpos S selpos=$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,46)) S:$E(selpos)="@" @("selpos="_$E(selpos,2,1000)) ;@Dol 13.10.05 зона выделения
 .D ..wM(qqpar1,"StartEdit",qqpar2,qqpar3),..wM(,"SetCellEditSelection",$S($P($G(selpos),",")="":-1,1:$P(selpos,",")),$S($P($G(selpos),",",2)="":-1,1:$P(selpos,",",2)))  ;на конец без выделения
 .D:qqtr=2 ..wP(,"CellEditLimit",+$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,45)))
 .D:$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,42))=1 ..wP(,"EditUpperCase",1) ;@Dima@Dol 24/03/06 БОЛЬШИЕ БУКВЫ
 ;непосредственная развертка для даты и маски
wfoc1 S qqCEKey=0 D ..wP(qqpar1,"OnCEClick",1),..wP(,"OnCEKeyDown",1),..wP(,"OnCEKeyDownT",0),..wM(qqpar1,"StartCombo",qqpar2,qqpar3,..wdbl(W("Zldrl")),"~") Q
 ;для нового дерева
wfocnew N q743,q710,q744,q747,zzz N qqtrdecp,KopDigits,ForceSign,MaxRubLen,SelKop,KopBack 
 ;????I $P(W("Zdrl")," ",8)'="",'W("Zcdrl")!(+W("Zcdrl")=4)!(+W("Zcdrl")=5) D ..wP(qqpar1,"ColumnWidth",$S($P(W("Zdrl")," ",8)["px":+$P(W("Zdrl")," ",8),1:$P(W("Zdrl")," ",8)*$P(W("Zfont"),",",3)),qqpar3) ;Изменение размеров колонки на момент редактирования (??Может убрать)
 I $G(qqred)'="" S q743=$S(qqred="ZfI9"&(qqtr=1):$S($G(W("Zpos",1,"x"))=2:2,1:0),1:..GetPar(743,,qqo,qqred)) I q743 D ..wM("-qARM","ChangeLanguage",$S(q743=1&(qqlang=1)!(q743=3):"00000419",1:"00000409")) ;рус англ OOOOO409
 ;???I $E(qqw,1,3)="ZZR" D ..wP(qqpar1,"M1",$P(W("Zldrl"),"~"),qqpar2,qqpar3) S qqCEKey=0 ;старый вариант развертки по константе на предыдущей ячейке (?? вроде не нужен)
 I qqtr=2 S q710=$S($E($G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3)))=3:2,1:$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,10))) I q710'="",q710'=0,q710'="N",q710'=3,q710'="P" D  Q:$Q "" Q  ;обработка типов данных ;;sasha 020807 была пропущена проверка на существование переменной Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3)
 .I q710?1(1"1",1"10") D  Q  ;дата ; @tdv 05.08.05 - дабавлен тип 10 DATEYY
 ..S %8=$G(W(qqw)) S:%8?2N1"."2N1"."2.4N %8=$S($L($P(%8,".",3))=2:"20",1:"")_$P(%8,".",3)_$P(%8,".",2)_$P(%8,".",1) ;@dol 23.08.04 хранится в формате даты
 ..I %8'=" ",%8=""!(%8'?1.N)!($E(%8)=0) S %8=$ZD($H,8) S:$G(W(qqw))="" W(qqw)=%8 ;;;@Dol 23.07.07 S:"@Z"'[$E(qqw)&&(" "_qqwchg_" "'[(" "_qqw_" ")) qqwchg=qqwchg_" "_qqw D qARM.wwww(qqw) ;текущая дата по умолчанию @dol 6.09.02 была забыта запись в W(qqw)
 ..I %8'=" " S %8=$E(%8_"00000000",1,8) S:'$E(%8,5,6) $E(%8,5,6)="01" S:'$E(%8,7,8) $E(%8,7,8)="01" ;@Dol 12.03.08 %8=" " - пустая дата
 ..//sas 20090113
 ..D ..wM(qqpar1,"ExtEdit",5_" "_$G(qqXBnoFK),qqpar2_" "_qqpar3,$S(%8=" ":0,1:$ZDH(%8,8)-21548),$S(q710=10:1,1:0)) ;,"",0_" "_'$G(qqXBDate)) ;Format??? par4
 .I q710="DEC" D  Q  ;DECIMAL sas 20081128
 ..S:'$D(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,87)) Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,87)=..GetPar("X787",,$$$CurObj,$P(W("Zpos",2,"d")," ",3),qqpar3) S ForceSign=$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,87)) S:$E(ForceSign)="@" @("ForceSign="_$E(ForceSign,2,3000)) ;@Dima 15.11.06 ForceSign
 ..S:'$D(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,88)) Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,88)=..GetPar("X788",,$$$CurObj,$P(W("Zpos",2,"d")," ",3),qqpar3) S KopDigits=$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,88)) S:$E(KopDigits)="@" @("KopDigits="_$E(KopDigits,2,3000)) ;@sas 20081128 KopDigits
 ..S:'$D(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,89)) Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,89)=..GetPar("X789",,$$$CurObj,$P(W("Zpos",2,"d")," ",3),qqpar3) S qqtrdecp=$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,89)) S:$E(qqtrdecp)="@" @("qqtrdecp="_$E(qqtrdecp,2,3000)) ;@sas 20081203 вариант вывода дробной части
 ..S:'$D(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,811)) Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,811)=..GetPar("X7811",,$$$CurObj,$P(W("Zpos",2,"d")," ",3),qqpar3) S SelKop=$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,811)) S:$E(SelKop)="@" @("SelKop="_$E(SelKop,2,3000)) ;@sas 20101118 SelKop
 ..S:'$D(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,812)) Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,812)=..GetPar("X7812",,$$$CurObj,$P(W("Zpos",2,"d")," ",3),qqpar3) S KopBack=$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,812)) S:$E(KopBack)="@" @("KopBack="_$E(KopBack,2,3000)) ;@sas 20101118 KopBack
 ..S MaxRubLen=$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,45))
 ..//sas 20081203 sas 20090113 $S(+qqtrdec=0:11,+qqtrdecp=0:11,1:6)если количество после запятой = "" или 0 то 11 тип, иначе по флагу, по умолчанию 11
 ..D ..wM(qqpar1,"ExtEdit",$S(+KopDigits=0:11,+qqtrdecp=0:11,1:6)_" "_$G(qqXBnoFK),qqpar2_" "_qqpar3,$G(W(qqw)),+KopDigits,+ForceSign,+MaxRubLen,+SelKop_" "_+KopBack)   //;@sas 20101118 добавлен ввод справа на лево дробной части
 .I $E(q710)="M" D  Q  ;Деньги
 ..S:'$D(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,87)) Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,87)=..GetPar("X787",,$$$CurObj,$P(W("Zpos",2,"d")," ",3),qqpar3) S qqtr=$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,87)) S:$E(qqtr)="@" @("qqtr="_$E(qqtr,2,3000)) ;@Dima 15.11.06 ForceSign
 ..D ..wM(qqpar1,"ExtEdit",6_" "_$G(qqXBnoFK),qqpar2_" "_qqpar3,$G(W(qqw)),$E(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,10)_2,2),+qqtr,+$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,45)))
 .I q710?1(1"Ht",1"T") D  Q  ;Время ($H), tdv 20100326 - T
 ..S %8=$G(W(qqw)) I %8[":",%8?2N1":"2N S %8=$P($ZDTH("20071111 "_%8,8),",",2) ;@Dol 02.11.07 хранится в виде времени
 ..I %8=""!(%8'?1.N) S %8=$P($H,",",2) S:$G(W(qqw))="" W(qqw)=%8 ;;;@Dol 23.07.07 S:"@Z"'[$E(qqw)&&(" "_qqwchg_" "'[(" "_qqw_" ")) qqwchg=qqwchg_" "_qqw D qARM.wwww(qqw) ;текущая дата по умолчанию @dol 6.09.02 была забыта запись в W(qqw)
 ..D ..wM(qqpar1,"ExtEdit",9_" "_$G(qqXBnoFK),qqpar2_" "_qqpar3,$E(%8\3600+100,2,3)_":"_$E(%8#3600\60+100,2,3),"00[0-23]:00[0-59]") ;@Dol 17.07.07 маска
 .I q710=6 D  Q  ;ГГГГММ
 ..S %8=$G(W(qqw)) S:%8?2N1"."2.4N %8=$S($L($P(%8,".",3))=2:"20",1:"")_$P(%8,".",3)_$P(%8,".",2)_"00" ;@dol 23.08.04 хранится в формате даты
 ..I %8'=" ",%8=""!(%8'?1.N) S %8=$E($ZD($H,8),1,6) S:$G(W(qqw))="" W(qqw)=%8 ;;@Dol 23.07.07 S:"@Z"'[$E(qqw)&&(" "_qqwchg_" "'[(" "_qqw_" ")) qqwchg=qqwchg_" "_qqw D qARM.wwww(qqw)
 ..D ..wM(qqpar1,"ExtEdit",9_" "_$G(qqXBnoFK),qqpar2_" "_qqpar3,$S(%8=" ":"",1:$E(%8,5,6)_"."_(+$E(%8,1,4))),"00[1-12].0000[Y]") ;@Dol 17.07.07 маска
 .I $E(q710)=7 D  Q  ; @tdv 05.08.05 ГГГГММДДччммсс ;;@Dol 05.06.07 маска и умолчания;q710=70 - без секунд
 ..S %8=$G(W(qqw)) I %8[".",%8?2N1"."2N1"."4N1" "2N1":"2N.E S %8=$P($P(%8," "),".",3)_$P(%8,".",2)_$P(%8,".",1)_$P($P(%8," ",2),":",1)_$P($P(%8," ",2),":",2)_$P($P(%8," ",2),":",3) ;@Dol 02.11.07 хранится в формате
 ..I %8=""!(%8'?1.N) S %8=$TR($ZDT($H,8)," :") S:$G(W(qqw))="" W(qqw)=%8 ;;;@Dol 23.07.07 S:"@Z"'[$E(qqw)&&(" "_qqwchg_" "'[(" "_qqw_" ")) qqwchg=qqwchg_" "_qqw D qARM.wwww(qqw)
 ..S %8=$E(%8_"00000000000000",1,14) S:'$E(%8,5,6) $E(%8,5,6)="01" S:'$E(%8,7,8) $E(%8,7,8)="01"
 ..D ..wM(qqpar1,"ExtEdit",9_" "_$G(qqXBnoFK),qqpar2_" "_qqpar3,$E(%8,7,8)_"."_$E(%8,5,6)_"."_$E(%8,1,4)_" "_$E(%8,9,10)_":"_$E(%8,11,12)_$S(q710=7:":"_$E(%8,13,14),1:""),"00[1-31].00[1-12].0000[Y] 00[0-23]:00[0-59]"_$S(q710=7:":00[0-59]",1:""))
 .I $E(q710)=8 D  Q  ;@Dol 27.10.07 интервал;q710=80 - без секунд
 ..S %8=$G(W(qqw)) ;??? а если хранится во внешнем представлении
 ..I %8=""!(%8'?1.N) S %8=$E($TR($ZDT($H,8)," :"),1,q710=8*2+12) S:$G(W(qqw))="" W(qqw)=qW.GtoExt("I",%8_">>"_$E(%8,1,8))
 ..D ..wM(qqpar1,"ExtEdit",9_" "_$G(qqXBnoFK),qqpar2_" "_qqpar3,qW.GtoExt(q710,W(qqw)),"00[1-31].00[1-12].0000[Y] 00[0-23]:00[0-59]"_$S(q710=8:":00[0-59]",1:"")_$S(q710=81:"<<",1:">>")_"00[1-31].00[1-12].0000[Y] 00[0-23]:00[0-59]"_$S(q710=8:":00[0-59]",1:""))
 .I q710=2 D  Q  ;Список
 ..//sas 20090113 @Dol 08.05.09 ..wdbl(
 ..D ..wM(qqpar1,"ExtEdit",2_" "_$G(qqXBnoFK),qqpar2_" "_qqpar3,..wdbl(qW.zReplace($G(W(qqw))," ",$C(13,10))),($G(q710)="N")_" "_$S(qqtr:$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,42))=1,1:0)_" "_0,+$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,45))_" -1 -1") ;_0 - Ctrl+Enter - перевод строки
 ..//D ..wM(qqpar1,"ExtEdit",2,qqpar2_" "_qqpar3,qW.zReplace($G(W(qqw))," ",$C(13,10)),($G(q710)="N")_" "_$S(qqtr:$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,42))=1,1:0)_" "_0,+$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,45))_" -1 -1") ;_0 - Ctrl+Enter - перевод строки
 .;I $E(q710)="T" D  Q  ;@Dol 27.01.09 НУЖНО ВВЕСТИ ТИП Текст (RTF) в словарь x710
 .;.D ..wM(qqpar1,"ExtEdit",10_" "_$G(qqXBnoFK),qqpar2_" "_qqpar3,$S($E(qqw)'="T":$G(W(qqw)),1:""),$S($E(qqw)="T":"W(qqw)",1:""),1_" W(qqw)",q710="TRTF"_" 1 1","1 3 1") ;q710="TRTF"
 I qqtr=1||($G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",qqtr,"d")," ",3),qqpar3,10))=3)||$P($G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",qqtr,"d")," ",3),qqpar3,2)),",",3)||($E(qqw)="T") D  Q  ;многострочный текст
 .I $E(qqw)="T" D  I 1
 ..S zzz="",q744="" F  S q744=$O(W(qqw,q744)) Q:q744=""  S zzz=zzz_$C(13,10)_$G(W(qqw,q744))
 ..S zzz=$E(zzz,3,32000)
 .E  S zzz=$G(W(qqw))
 .//sas 20090113 @Dol 08.05.09 ..wdbl(
 .D ..wM(qqpar1,"ExtEdit",2_" "_$G(qqXBnoFK),qqpar2_" "_qqpar3,..wdbl(zzz),$S(qqtr=2:q710="N",1:0)_" "_$S(qqtr=2:$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,42))=1,1:0)_" "_0,+$S(qqtr=2:$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,45)),1:0)_" -1 -1") ;_0 - Ctrl+Enter - перевод строки
 .//D ..wM(qqpar1,"ExtEdit",2,qqpar2_" "_qqpar3,zzz,$S(qqtr=2:q710="N",1:0)_" "_$S(qqtr=2:$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,42))=1,1:0)_" "_0,+$S(qqtr=2:$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,45)),1:0)_" -1 -1") ;_0 - Ctrl+Enter - перевод строки
 ;;;I '$D(selpos) N selpos S selpos=$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,46)) S:$E(selpos)="@" @("selpos="_$E(selpos,2,1000)) ;@Dol 13.10.05 зона выделения
 //sas 20090113
 I $P(W("Zcdrl")," ",2)=2,"045"[(+W("Zcdrl")) D ..wM(qqpar1,"ExtEdit",3_" "_$G(qqXBnoFK),qqpar2_" "_qqpar3,$G(W(qqw)),..wdbl(W("Zldrl")),"~  20",($G(q710)="N")_" "_$S(qqtr:$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,42))=1,1:0)_" "_(''$P(W("Zdrl")," ",18)),+$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,45))) Q:$Q "" Q  ;_" "_$S($P($G(selpos),",")="":-1,1:$P(selpos,","))_" "_$S($P($G(selpos),",",2)="":-1,1:$P(selpos,",",2))) Q:$Q "" Q  ;редактирование+список
 //sas 20090113
 I $P(W("Zcdrl")," ",2)=1,"045"[(+W("Zcdrl")) D ..wM(qqpar1,"ExtEdit",4_" "_$G(qqXBnoFK),qqpar2_" "_qqpar3,$S($G(W(qqw))="":0,1:$L($P("~"_W("Zldrl")_"~","~"_W(qqw)_"~"),"~")-1),..wdbl(W("Zldrl")),"~  20") Q:$Q "" Q  ;выпадающий список
 ;обычное редактирование
 D:'$D(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,47)) ..GetPar("X747",,$$$CurObj,$P(W("Zpos",2,"d")," ",3),qqpar3) S q747=$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,47)) S:$E(q747)="@" @("q747="_$E(q747,2,30000)) ;универсальная маска
 S:q747="" q744=$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,44)) ;маска
 ;;;????.I qqtr=2,$S($E(qqw)'="T":$G(W(qqw))="",1:$G(W(qqw,0))=""),"Y"'[$E(qqw),$G(Vo(qqnump,-1,65))=2,qqw'?1"Zs"1.n1"c"1.n D ..wP(qqpar1,"BulkUpdate",1),..wP(qqpar1,"M1","",qqpar2,qqpar3),..wM(,"StartEdit",qqpar2,qqpar3),..wP(qqpar1,"M1"," ",qqpar2,qqpar3),..wP(,"BulkUpdate",0,1) Q  ;@dol 26.02.03 уберем ненужный пробел при выводе пустых значений;@dol 5.3.03 и сразу вставим, чтобы ячейка не исчезла по выходу ESC (@* ???);@dol 17.07.03 qqtr=2 - иначе проблемы с выр.аналитик;@dol 17.06 - Zs;@Dol 27.06.06 "TY"'[$E(qqw) - убрано
 //sas 20090113 @Dol 08.05.09 ..wdbl(
 I q747'="" D ..wM(qqpar1,"ExtEdit",9_" "_$G(qqXBnoFK),qqpar2_" "_qqpar3,..wdbl($G(W(qqw))),q747) Q:$Q "" Q  ;@Dima 05.06.07 Универсальная маска
 //I q747'="" D ..wM(qqpar1,"ExtEdit",9,qqpar2_" "_qqpar3,$G(W(qqw)),q747) Q:$Q "" Q  ;@Dima 05.06.07 Универсальная маска
 I '$D(selpos) N selpos S selpos=$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,46)) S:$E(selpos)="@" @("selpos="_$E(selpos,2,1000)) ;@Dol 13.10.05 зона выделения
 //sas 20090113 @Dol 08.05.09 ..wdbl(
 D ..wM(qqpar1,"ExtEdit",1_" "_$G(qqXBnoFK),qqpar2_" "_qqpar3,..wdbl($G(W(qqw))),($G(q710)="N")_" "_$S(qqtr:$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,42))=1,1:0)_" "_(q744="%PASSW"),+$G(Vo(qqnump,$$$CurObj,0,$P(W("Zpos",2,"d")," ",3),qqpar3,45))_" "_$S($P($G(selpos),",")="":-1,1:$P(selpos,","))_" "_$S($P($G(selpos),",",2)="":-1,1:$P(selpos,",",2)),$S(q744="%PASSW":"",1:q744))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wfot">
<Description>
Сделать неактивными все объекты кроме поддерева объекта qqpar1
qqpar1 не задан - все активны
qqpar1=-1 - неактивны все объекты из Vs(qqnump,7)
qqpar1=-2 - все объекты, не входящие в поисковый образ
qqpar1=-3 - восстановить все объекты, не входящие в поисковый образ
Arg2=1- только переформирование Vs(qqnump,7)</Description>
<Internal/>
<FormalSpec>qqpar1:%String,Arg2:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqo S qqpar1=$G(qqpar1),Arg2='$G(Arg2)
 I $G(qqpar1)="" K Vs(qqnump,7) D:Arg2 ..wP(qwin_".T1","M10",1,0,1000) Q:$Q "" Q
 S qqo=-1 F  S qqo=$O(Vo(qqnump,qqo)) Q:qqo=""  D:$G($$$ObjRef(qqo))'=""  ;чтобы отсеч висячие или отсутствующие объекты
 .I qqpar1=-2 Q:$D(^Q($$$Relind_qview,qqo))  D:'$D(Vs(qqnump,7,qqo)) wfoto(0) S Vs(qqnump,7,qqo)=''$G(Vs(qqnump,7,qqo))_" 1" Q
 .I qqpar1=-3 Q:$D(^Q($$$Relind_qview,qqo))  D  Q
 ..I '$G(Vs(qqnump,7,qqo)) D wfoto(1) K Vs(qqnump,7,qqo) Q
 ..S Vs(qqnump,7,qqo)=1
 .I qqpar1=-1 D:$D(Vs(qqnump,7,qqo)) wfoto(0) Q
 .I ","_$$$ObjRef(qqo)_","'[(","_qqpar1_",") D:'$D(Vs(qqnump,7,qqo)) wfoto(0) S $P(Vs(qqnump,7,qqo)," ")=1
 Q:$Q "" Q
wfoto(q) ;неактивность объекта qqo
 D:Arg2 ..wM(qwin_".T1","M9",1,0,qqo),..wP(,"M10",q,"",$S($G(Vs(qqnump,4,qqo)):+$G(Vo(qqnump,qqo,10)),1:0)) Q
]]></Implementation>
</Method>

<Method name="wgre">
<Description>
Переинициализация граф дерева экземпляров.</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 D:'$D(Arg1) ..wP(qwin_".T2","Columns",Vo(qqnump,-1,9)+1)
 ;@Dol 23.11.05 цвета и фонт
 N qqsty,k,q1,q2,qk,qn,j,nres,i1,x S qqsty=$G(Vo(qqnump,-1,0,0,0,2)) I $G(Vo(qqnump,-1,55))'="" S:$P(qqsty,",",4)="" $P(qqsty,",",4)=$P(Vo(qqnump,-1,55),",",1) S:$P(qqsty,",",6)="" $P(qqsty,",",6)=$P(Vo(qqnump,-1,55),",",2) ;@Dol 05.03.08
 I qqsty'="" D:$TR($P(qqsty,",",5,9),",")'=""   d:$P(qqsty,",",16) qARM.wP(qwin_".T2","MinColHeadersHeight",+$P(qqsty,",",16),"") ;@Dol 02.07.10 MinColH
 .I $P(qqsty,",",6)'="" S $P(qqsty,",",5)=+$P(qqsty,",",5) ;D ..wP("F"_$P(qqsty,",",5),"Size",$P(qqsty,",",6))
 .D ..wP(qwin_".T2","M1",$C(30),-1,0,$S($P(qqsty,",",5)="":"",1:"F"_$P(qqsty,",",5)_" "_$P(qqsty,",",6)),$P(qqsty,",",9),$P(qqsty,",",8)) ;;@Dol 21.07.09 $P(qqsty,",",6)
 ;параметры граф 
 S nres=0
 I $S(+Vo(qqnump,-1,61)=1||(+Vo(qqnump,-1,61)=2):..GetPar("X1197")'=0,1:..GetPar("X1197")) S nres=256 ;@dol 9.07.04 ,$G(Vo(qqnump,-1,88))=0 ;;запрет изменения размеров колонок для бланка и пояснений
 K Vo(qqnump,-1,999),Vt(qqnump,999) F j=0:1:Vo(qqnump,-1,9) S q2=$S($G(Vo(qqnump,-1,9,j))="":"15,0",1:Vo(qqnump,-1,9,j)) F k=1:1:3 D
 .S qqsty=$G(Vo(qqnump,-1,0,0,j,2)) I qqsty'="",$P(qqsty,",",2)'=""||($P(qqsty,",",7)'="") D ..wP(qwin_".T2","ColumnTextStyle",$P(qqsty,",",2)+(16*$P(qqsty,",",7)),j)
 .S qk=$P(q2,",",k)
 .I k=1 D  Q
 ..I qk=-1 S Vo(qqnump,-1,999)=1,qk=15 ; Q  ;7.04.08 - сложности иначе с авторазмерами ;@Dol 25.03.05 Флаг будет проверятся в wcre ( в конце)
 ..S:qk="" qk=15 D ..wP(qwin_".T2","ColumnWidth",$S(qk["px":+qk,qk["%":$J(qARM("Screen","Width")*qk/100,0,0),1:qk*$P(W("Zfont"),",",3)),j) D:qk["." ..wM(,"FixColWidth",j) ;@Dol 24.12.10 фиксированая ширина конки
 .I k=2 S %1=qk Q
 .D ..wP(qwin_".T2","ColumnStyle",%1+(qk*4+($G(Vo(qqnump,-1,61))'=2*8)+nres+$S($G(Arg1):0,$G(Vo(qqnump,-1,65))=2:1024+2048,'W("ZBtred")&('$G(Vo(qqnump,-1,65))):1024+2048,1:0))+$S('$P(q2,",",7):0,$P(q2,",",7)=1:4096,1:16384),j)  ;ширина,выравнивание,тип(1/мноного строк 8192*верт.выравн пока ошибка в описании),8 -ToolTips для формы типа Пояснения не выводить
 .D:'$D(Arg1)  ;@dol 3.08.04  ;постоянные заголовки и картинки
 ..S (x,i1)=j,qn=$E($G(Vo(qqnump,-1,0,0,j)),2,255) S:$E($G(Vo(qqnump,-1,0,0,j)))=5&&($TR(qn," ")'="") @("qn="_qn) I qn'="" D:$P(qn,"~",1)'="" ..wP(,"ColumnText",$P(qn,"~",1),j) D:qn["~" ..wP(,"ToolTipColumnE",$P(qn,"~",2),j) ;@Dol 30.11.10 выражение для постоянных заголовков
 ..S qn=$G(Vo(qqnump,-1,0,0,j,6)) I qn'="" S Vt(qqnump,9,"PP",-1,0,j)=qn D qARM.wcellpic(-1,0,j) S:$E(qn)="@" Vt(qqnump,999,"PP",-1,0,j)=qn ;@Dol 28.01.06 Дин.ресурс
 S k=..GetPar("X1663") I k'="" D  ;@Dol 26.06.05 сплиттер
 .D ..wP(qwin_".T2","OpenEnded",'$G(qqXBwids)),..wP(,"OpenEnded2",'$G(qqXBwids)) ;последняя колонка левой и правой части расширяется;@Dol 16.12.09 так лучше?
 .;;D:'$G(qqXBwids) ..wP(qwin_".T2","OpenEnded",1),..wP(,"OpenEnded2",1) ;@Dol 04.05.08 '$G(qqXBwids)
 .D ..wP(qwin_".T2","BulkUpdate",0),..wP(,"SplitterBar",1),..wP(,"SplitColumn",+k) D:$P(k,",",3) ..wP(,"SplitterWidth",$P(k,",",3))
 .D ..wP(,"BulkUpdate",1)
 ; tdv 7.6.2006 - динамическое получение размеров колонок
 N var S var=1 D
 .; если не выводить
 .I ..GetPar("X188")=1 S var=0 Q
 .; если фиксированные размеры
 .I ..GetPar("X1197")=1 S var=0 Q
 .; если бланк,пояснения
 .I ..GetPar("x161")?1(1"1",1"2") D
 ..; если не выводить
 ..I $S(..GetPar("X188")="":1,1:..GetPar("X188")) S var=0 Q
 ..; если выводить и фиксированные размеры
 ..I ..GetPar("X1197")'=0 S var=0

 D qARM.wP(qwin_".T2","SaveColSizes",var) I var=0 K Vs(qqnump,"ColWidth")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wipa">
<Description>
Инициализация дерева образцов (T3). ;@Dol 01.06.10 прверка qqnump</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 I $D(qqnump),qqnump'="P",qqnump'="Q",qqnump'="",qqnump=$E($P(qwin,"."),2,4) K Vt(qqnump,9) M Vt(qqnump,9)=Vt(qqnump,999) S Vt(qqnump,9)=-1 D ..wM(qwin_".T3","Clear"),..wP(,"Columns",Vo(qqnump,-1,9)+1)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wpic">
<Description>
Вывод/удаление картинок (qqpar1=1/0) в дереве экземпляров.
qqty0 - только одна картинка ;@Dol 22.04.08</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqty0:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$D(Vt(qqnump,9,"P")) D:0 ..Message("Нет картинок") Q:$Q "" Q
 I '$G(qqpar1) D ..wM(qwin_".T2","ClearCellPictures") Q:$Q "" Q  ;не очень хорошо для режима редактирования (исчезнут указатели развертки)
 ;qql - ?????
 N qqobim,qqpic,qqc,qqci,qqo,qqw,qqzS,qclr,qal,qqty
 I '$$$Tree N qql S qql=1
 E  N qqRef,qqref S qqRef=$G($$$GloRef)
 S qqobim=1,qqty=$S($G(qqty0)="":"",1:$O(Vt(qqnump,9,"P",qqty0),-1)) F  S qqty=$O(Vt(qqnump,9,"P",qqty)) Q:$S(qqty="":1,$G(qqty0)="":0,1:qqty0'=qqty)   S qqci="" D:$P(qqty," ")=-1  I $P(qqty," ")'=-1 F  S qqci=$O(Vc(qqnump,qqci)) Q:qqci=""   I Vc(qqnump,qqci,0)=$P(qqty," ") D
 .I $P(qqty," ",1)'=-1,$P(qqty," ",2),$G(Vc(qqnump,qqci,40))=-1 Q  ;@dol 5.5.04 объект свернут
 .S qqo=$P(qqty," ",1),qqpic=Vo(qqnump,qqo,0,$P(qqty," ",2),$P(qqty," ",3),6) S:$E(qqpic)="-" qqpic=$E(qqpic,2,30000)
 .S qqw=$E(Vo(qqnump,qqo,0,$P(qqty," ",2),$P(qqty," ",3)),2,255)
 .I $G($$$Tree),qqci'="" D qW.qRef(qqci)
 .S qqc=$S(qqci="":"",1:Vc(qqnump,qqci)) I "M,F,R,"'[$E(qqpic,1,2) S:$G(Vo(qqnump,qqo,41)) qqc=$P(qqc,"~",$E(qqw,1,2)),qqw=$E(qqw,3,30000) S qqpic=..Value($S($E(qqpic)'="@":qqpic,1:$E(qqpic,2,30000))) ;@dol 26.02.04
 .Q:qqpic=""  D  ;@dol 16.104 прозрачность (0/1) и выравнивание
 ..I "M,F,R,"'[$E(qqpic,1,2) S qclr=$P(qqpic,",",2),qal=$P(qqpic,",",3),qqzS=$P(qqpic,",",4,5) S:qclr="" qclr=1 Q  ;непрозрачен по умолчанию
 ..I "M,"'[$E(qqpic,1,2) S qclr=$P(qqpic,",",3),qal=$P(qqpic,",",4),qqzS=$P(qqpic,",",5,6) S:qclr="" qclr=0 Q  ;прозрачен по умолчанию
 ..I $E(qqpic,$L(qqpic))=")" S qclr=1,qal=0 Q  ;M, непрозрачен по умолчанию
 ..S qclr=$RE($P($RE(qqpic),")")),qal=$P(qclr,",",3),qqzS=$P(qclr,",",5,6),qclr=$P(qclr,",",2) S:qclr="" qclr=1 S qqpic=$P(qqpic,")",1,$L(qqpic,")")-1)_")"
 .D ..wbmp("pe"_qqnump_qqobim,qqpic)
 .D ..wM(qwin_".T2","M9",1,0,$S(qqci="":"-1",1:qqci)_" "_$P(qqty," ",1,2))
 .D:$G(qqzS)'=""
 ..I $E(qqzS)=$E(">") S qqzS=$E(qqzS,2,255) D ..wM("pe"_qqnump_qqobim,"Thumb",$S($P(qqzS,",",1):$P(qqzS,",",1),1:-1),$S($P(qqzS,",",2):$P(qqzS,",",2),1:-1)) Q  ;@Dima&Dol 14.04.07 вписывание в заданный размер
 ..D ..wM("pe"_qqnump_qqobim,"ScaleBitmap",$S($P(qqzS,",",1):$P(qqzS,",",1),1:-1),$S($P(qqzS,",",2):$P(qqzS,",",2),1:-1)) ;@Dima&Dol 15.03.07 желаемые размеры
 .D ..wP(qwin_".T2","M4","pe"_qqnump_qqobim,"",$P(qqty," ",3),qclr)
 .D:qal ..wP(,"CellPictureAlign",qal,"",$P(qqty," ",3))
 .S qqobim=qqobim+1
 I $$$Tree S $$$GloRef=qqRef
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wpoe">
<Description>
Позиционирование(отметка) и Вывод заголовка дерева Экземпляров
Beg=1 - выставить текущую строку в начало экрана
NoSelCel - не переустанавливать отметку текущей ячейки
Capt=1 - вывести заголовки граф и окна (используется, если нет экземпляров)

curobj, curqqc - позиционирование на заданный объект с заданным кодом экземпляра (curqqc="" - первый)
curqqw - позиционирование на понятие</Description>
<Internal/>
<FormalSpec>qqpar1:%String,Beg:%Library.String,NoSelCel:%Library.String,Capt:%Library.String,curobj:%Library.String,curqqc:%Library.String,curqqw</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $G(Capt) S:$G(qqpar1)="" qqpar1=" "_$S($G($$$CurObj)'=""&&$D(Vo(qqnump,$$$CurObj)):$$$CurObj,1:$O($$$MObjRef("")))_" 0" Q:$P(qqpar1," ",2)=""  S $$$CurObj=$P(qqpar1," ",2),($$$ID,qqc)="" G wpoeCapt
 I $G(curobj)'="" D  I $G(qqpar1)="" Q:$Q "" Q  ;@dol 15.02.07 !!!было D:$G(curobj)'=""
 .N qqci S qqci="" F  S qqci=$O(Vc(qqnump,qqci))  Q:qqci=""  I Vc(qqnump,qqci,0)=curobj,$S($G(curqqc)="":1,1:Vc(qqnump,qqci)=curqqc) Q
 .I qqci'="" S qqpar1=qqci_" "_curobj_" 0" Q
 .I $G(Vc(qqnump))'="",$G(Vc(qqnump,Vc(qqnump),0))'="" S qqpar1=Vc(qqnump)_" "_Vc(qqnump,Vc(qqnump),0)_" 0" ;@Dol 26.08.05
 S:$G(qqpar1)="" qqpar1=$G(W("Zpos",2,"d"))
 S W("Zpos",2,"d")=qqpar1 ;qqpar1=qqci qqo qqso
 S:$P(qqpar1," ")'="" Vc(qqnump)=$P(qqpar1," ") ;********@dol 19.07.04 раньше не НЕ БЫЛО. ???Неприятности с принудительным позиционированием????
 S $$$CurObj=$P(qqpar1," ",2),($$$ID,qqc)=$S($P(qqpar1," ")="":"",1:$G(Vc(qqnump,$P(qqpar1," "))))
 ;S qqo=$$$CurObj ;@Dol 11.10.106 ?нельзя
 I $D(Vt(qqnump,111)),$P(qqpar1," ",2)'=-1 D ..Virt(1)
 D:'$G(NoObj)
 .I $G(W("Zsform"))#10'=1,$$$CurObj'="" D  ;счетчики
 ..I $G(Vo(qqnump,$$$CurObj,2))<3 S %3=$S($E($$$CurObj)'="v":$$$CurObj,1:$E($$$CurObj,3,255)),%2=$G(Vo(qqnump,%3,247)) S:%2'="" %2=$S('$D(Vo(qqnump,$P(%2," "))):"",1:$P(%2," ")) S %2=$J($S(%2="":+$G(^Q(1,%3)),1:"*"_+$G(^Q(1,%2,$E(qqc,1,$$$ObjLget(%2)),"McO"_%3))),7) ;@Dol 9.10.07 для счетчиков поддеревьев
 ..D ..wP(qwin_$S($G(W("Zsform"))<100:".TBN",1:".T1.TBN")_".b41","Caption",$J(+$G(^Q($$$Relind_qview,$$$CurObj)),7))
 ..D ..wP(qwin_$S($G(W("Zsform"))<100:".TBN",1:".T1.TBN")_".b40","Caption",$S($G(Vo(qqnump,$$$CurObj,2))<3:%2,Vo(qqnump,$$$CurObj,2)=4:$J($P($G(@("^"_$$$CurObj))," ",2),7),Vo(qqnump,$$$CurObj,2)=6:$S($E($G(Vo(qqnump,$$$CurObj,33),"@"))="@":"",1:$J($G(@(Vo(qqnump,$$$CurObj,33))),7)),1:"")) ;@Dol 14.08.06 для массивов (6);%2=$J($G(^Q(1,$S($E($$$CurObj)'="v":$$$CurObj,1:$E($$$CurObj,3,255)))),7)
 .D ..wP(qwin_".T1","MultiSelect",0)
 .D ..wM(qwin_".T1","M9",1,0,$P(qqpar1," ",2),1) ;отметка объекта
 I $G(Beg),$S($$$CurObj="":0,$G(Vo(qqnump,-1,61))'=1!1:1,$G(Vo(qqnump,$$$CurObj,4)):$P($G(Vt(qqnump,"Expand"))," ")'=$P(qqpar1," ")!(Beg=2),1:1) D  ;,Vo(qqnump,-1,61)'=3 D  ;попытка установить видимость всего поддерева
 .S %2=$O(Vc(qqnump,$P(qqpar1," ")_"яя"))
 .I %2="" S %2=$O(Vc(qqnump,""),-1) Q:%2=$P(qqpar1," ")  Q:%2=""
 .S %3=0 F %4=$L(%2)-2:-2:2 I $G(Vo(qqnump,Vc(qqnump,$E(%2,1,%4),0),4)) S %3=$S("15"[(+$G(Vo(qqnump,-1,61))):$P($G(Vt(qqnump,"Expand"))," ")'=$P(qqpar1," "),1:1) Q:%3  ;@dol 19.12.02 - лишняя развертка последнего свернутого
 .Q:%3  D ..wM(qwin_".T2","M9",1,0,%2_" "_$G(Vc(qqnump,%2,0))_" 0",1)
 I $$$CurObj'="",$D(Vo(qqnump,$$$CurObj,11,"@ZXXPntr")),qqpar1'="" D ..wM(qwin_".T2","M8",$P(Vo(qqnump,$$$CurObj,11,"@ZXXPntr")," ",2)),..wwww("@ZXXPntr") ;@Dol 24.08.05 вывод указателя;@Dol 20.04.07 переставлена строка
 D:qqpar1'=""
 .D:$G(Vt(qqnump,9,"PPd"))'=""  ;@Dol 03.03.08 удаление картинок в старой текущей строке
 ..D ..wM(qwin_".T2","M9",1,0,Vt(qqnump,9,"PPd")) S %2=$P(Vt(qqnump,9,"PPd")," ",1),%3=$P(Vt(qqnump,9,"PPd")," ",2),%4=$P(Vt(qqnump,9,"PPd")," ",3),%5="" F  S %5=$O(Vt(qqnump,9,"PPd",%3,%4,%5)) Q:%5=""  D ..wP(,"M4","","",%5,0)
 ..S Vt(qqnump,9,"PPd")=""
 .I $P(qqpar1," ")="AA" Q:'$D(Vc(qqnump,"AA"))  ;@Dol 17.12.07 
 .D ..wM(qwin_".T2","M9",1,0,qqpar1,$S($G(Vo(qqnump,$$$CurObj,19))'="":$S("035"[(+$G(Vo(qqnump,$$$CurObj,19))):1,1:$S(Vo(qqnump,$$$CurObj,19)=2||(Vo(qqnump,$$$CurObj,19)=4):2,$G(W("Zpos",2,"x"))="":2,$E($G(Vo(qqnump,$P($G(W("Zpos",2,"d"))," ",2),0,$P($G(W("Zpos",2,"d"))," ",3),+$G(W("Zpos",2,"x"))))):3+$G(W("Zpos",2,"x")),1:2)),"035"[(+$G(Vo(qqnump,-1,19))):1,1:$S(Vo(qqnump,-1,19)=2||(Vo(qqnump,-1,19)=4):2,$G(W("Zpos",2,"x"))="":2,$E($G(Vo(qqnump,$P($G(W("Zpos",2,"d"))," ",2),0,$P($G(W("Zpos",2,"d"))," ",3),+$G(W("Zpos",2,"x"))))):3+$G(W("Zpos",2,"x")),1:2))) ;отметка экземпляра @dol 12.08.03 отметка ячейки;@Dol 27.10.06 $G(Vo(qqnump,$$$CurObj,19))- для объекта
 .D:$G(curqqw)'="" 
 ..I $G(Vo(qqnump,$P($G(W("Zpos",2,"d"))," ",2),11,curqqw))'="" S W("Zpos",2,"x")=$P(Vo(qqnump,$P($G(W("Zpos",2,"d"))," ",2),11,curqqw)," ",2),qqw=curqqw Q  ;@Dol 25.10.08 переход на заданное понятие;21.10.09 qqw=
 ..I curqqw?1"Zs"1.n1"c"1.n S W("Zpos",2,"x")=$P(curqqw,"c",2),qqw=curqqw Q  ;@Dol 12.02.10 для выражений
 .I $S($G(Vo(qqnump,$$$CurObj,19))'="":"45"[Vo(qqnump,$$$CurObj,19),1:45[(+$G(Vo(qqnump,-1,19)))) D    ;@Dol 4.02.08 рамка на ячейке
 ..I $G(W("Zpos",2,"x"))=""||'$E($G(Vo(qqnump,$P($G(W("Zpos",2,"d"))," ",2),0,$P($G(W("Zpos",2,"d"))," ",3),+$G(W("Zpos",2,"x"))))) D ..wM(qwin_".T2","SetCellRect",-1,-1,"SB") Q
 ..D ..wM(qwin_".T2","SetCellRect","",+$G(W("Zpos",2,"x")),-16777203) ;"SB")
 .I $S($G(Vo(qqnump,$$$CurObj,19))'="":"67"[Vo(qqnump,$$$CurObj,19),1:"67"[(+$G(Vo(qqnump,-1,19)))) D ..wM(qwin_".T2","SetRowRect","",-16777203)    ;@Dol 16.06.10 рамка на строке
 .I '$G(Vo(qqnump,-1,19)),+$G(Vo(qqnump,-1,59)) D ..wM(qwin_".T2","MoveCursor","",+$G(W("Zpos",2,"x")),0)
 .I $D(Vt(qqnump,9,"PPd",$P(qqpar1," ",2),$P(qqpar1," ",3))) S Vt(qqnump,9,"PPd")=qqpar1,%5="" F  S %5=$O(Vt(qqnump,9,"PPd",$P(qqpar1," ",2),$P(qqpar1," ",3),%5)) Q:%5=""  D ..wcellpic($P(qqpar1," ",2),$P(qqpar1," ",3),%5,$P(qqpar1," ",1),"PPd") ;@Dol 03.03.08 картинки текущей строки
 I $D(qwin(qwin,"SBM")),$D(Vt(qqnump,669)),$S($P(Vo(qqnump,-1,669)," ",3):1,1:$G(Vt(qqnump,669)," ")'=" ") D ..OnScroll(,) ;указатель перемещений
wpoeCapt I '$G(qARMwpoe),$G(Vo(qqnump,-1,64))'="" D  ;обобщение заголовка
 .N qqo S qqo=$$$CurObj ;@Dol 11.10.06
 .I $E(Vo(qqnump,-1,64),1,3)="@@@" X $E(Vo(qqnump,-1,64),4,300000) Q  ;D ..Value($E(Vo(qqnump,-1,64),4,300000),"X") Q  ;просто действие
 .S %2=$G(W($S($E(Vo(qqnump,-1,64),1,2)="@@":"@@",1:Vo(qqnump,-1,64)))) I %2'="",$E(qqc,1,$L(%2))=%2 Q  ;@dol 31.07.03 иначе SUBSCR при размере вражения >255 
 .D
 ..I $E(Vo(qqnump,-1,64),1,2)="@@" S %2=..Value($E(Vo(qqnump,-1,64),3,300000)) Q  ;@("%2="_$E(Vo(qqnump,-1,64),3,300000)) Q
 ..S %2=qW.GG($$$CurObj,Vo(qqnump,-1,64),qqc)
 .D ..wP(qwin,"Caption",$TR($S($E(%2)="-":$E(%2,2,30000),1:"qWORD-XML. "_%2),"_",$S($G(Vo(qqnump,-1,66)):" ",1:"_"))) ;@Dol 29.07.09 "_"
 N qARMwpoe,i1,x S qARMwpoe=1 ;флаг для блокировки обработки обобщения заголовка (из него может вызываться wpoe !!!)
 S %2=$P(qqpar1," ",2,3) Q:%2="" ""
 I $S("12"[(+$G(Vo(qqnump,-1,61))):$G(Vo(qqnump,-1,88))=1,1:$G(Vo(qqnump,-1,88))=1) D  Q:$Q "" Q  ;бланк,пояснения
 .I $G(W("Zosrt"))'="",$D(Vo(qqnump,-1,11,"Znew")) S W("Znew")=$P($$$CondFind," ",5)_$P($$$CondFind," ",6) D ..wwww("Znew",,,-1,"") ;@Dol 16.12.04
 I $G(W("Zosrt"))="",$G(Vt(qqnump,"wpoe"))=%2||($G(Vo(qqnump,-1,88))=1),'$G(Vt(qqnump,"wpoe",1)),'$D(Vt(qqnump,9,"PP",-1,0)),$G(Vo(qqnump,-1,0,0,0,20))="" Q:$Q "" Q  ;@Dol 12.02.10 Можно не перевыводить;15.02.10 $G(W("Zosrt"))="",
 I '$D(Vt(qqnump,9,"-1 "_%2)),$S($$$CurObj'=-1:1,1:$G(Vo(qqnump,-1,88))#3'=2) D  ;формирование образца ;@Dol 7.10.08 88#3'=2 - только постоянные
 .S %9=..GetPar(176) I %9 N jj K Vs(qqnump,176) S jj=0 ;горячие клавиши заголовка ;;@dol 5.5.04 для сетки
 .S %6="",%7="" F j=0:1:Vo(qqnump,-1,9) D
 ..S %8=$E($G(Vo(qqnump,-1,0,0,j)),2,255) I $TR(%8," ")'="",$E($G(Vo(qqnump,-1,0,0,j)))=5 S (x,i1)=j,@("%8="_%8) ;@Dol 30.11.10 выражение для постоянных заголовков
 ..I $G(Vo(qqnump,-1,88))#3=2 S $P(%7,$C(31),j+1)=%8 Q  ;$P(%8,"~") Q  ;постоянный заголовок
 ..S %3=$G(Vo(qqnump,$P(%2," ",1),0,$P(%2," ",2),j)) Q:%3=""  ;@Dol 13.10.08 %3=""
 ..S %10=..GetPar("X7103",,$P(%2," ",1),$P(%2," ",2),j) ;@Dol 8.01.08 имя заголовка 
 ..;S %3=$G(Vo(qqnump,$P(%2," ",1),0,$P(%2," ",2),j))
 ..S %4=$S('$E(%3)||("567"[$E(%3)):"",1:$E($P(%3," "),2,255)) I %8="",%4="" S %8=$S(%10'="":%10,1:..GetPar("X7100",,$P(%2," ",1),$P(%2," ",2),j)) ;@dol 21.07.03 имя в отображении для выражений, констант
 ..S $P(%6,",",j+1)=%4
 ..I '$G(Vs(qqnump,1,$$$CurObj,$P(%2," ",2),j)) S:%9&&(%4'=""!(%8'="")) jj=jj+1,Vs(qqnump,176,jj)=j S $P(%7,$C(31),j+1)=$S(%9&&(%4'=""!(%8'="")):$E("123456789QWERTYUIOPASDFGHJKLZXCVBNM",jj)_".",1:"")_$S(%8'="":$TR($S($E(%8)'="@":%8,1:qW.GetWoc("CxWoc",$E(%8,2,32))),"_"," "),%4="":"",%10'="":%10,1:..GetName(,$$$CurObj,%4)) ;$TR(qW.GetWoc("CxWoc",%4),"_"," "))
 ..s:$g(XBLocal) $P(%7,$C(31),j+1)=qSYS.getLocal($P(%7,$C(31),j+1),6) ;@pav подключение словаря локализации 22.03.2010
 .D ..wM(qwin_".T3","M2",+Vt(qqnump,9),%7,0,0,0) S Vt(qqnump,9)=Vt(qqnump,9)+1 S Vt(qqnump,9,-1_" "_%2)=Vt(qqnump,9)_" "_%6
 D:$D(Vt(qqnump,9,"PP",-1,0))   ;@Dol 28.01.01 динамический ресурс заголовков
 .S j="" F  S j=$O(Vt(qqnump,9,"PP",-1,0,j)) Q:j=""  D:$E($G(Vt(qqnump,9,"PP",-1,0,j)))="@" ..wcellpic(-1,0,j,Vc(qqnump)) S pP($I(pP))=j
 D:$G(Vo(qqnump,-1,0,0,0,20))'=""  ;@Dol 28.01.06 динамические параметры заголовков
 .N qqo,qqci,qqz S qqo=$$$CurObj,qqci=Vc(qqnump),qqz=Vo(qqnump,-1,0,0,0,20) S:$E(qqz)="@" @("qqz="_$E(qqz,2,3000))
 .D ..wP(qwin_".T2","M1",$C(30),-1,0,$S($P(qqz,",",5)="":"",1:"F"_$P(qqz,",",5)),$P(qqz,",",2),$P(qqz,",",1),$P(qqz,",",4),$P(qqz,",",3))
 I $S($$$CurObj'=-1:1,1:$G(Vo(qqnump,-1,88))#3'=2) S %6=Vt(qqnump,9,-1_" "_%2),(%7,Vs(qqnump,10))=$P(%6," ",2,255) D ..wP(qwin_".T2","BulkUpdate",1) D ..wM(qwin_".T2","M7",qwin_".T3",-1,+%6,0) D ..wP(qwin_".T2","BulkUpdate",0,1) ;@Dol 7.10.08 88#3'=2 - только постоянные
 ;
 I $D(Vt(qqnump,"Zsc"))>1,$G(Vt(qqnump,"Zsc"))'=0  S %6="" F  S %6=$O(Vt(qqnump,"Zsc",%6)) Q:%6=""  D ..wP(qwin_".T2","ColumnText",$P($G(W("Zsc"_%6)),"~"),%6) D ..wP(,"ToolTipColumnE",$P($G(W("Zsc"_%6)),"~",2),%6) ;@dol 8.01.08 Zsc* понятия зголовков, ToolTip
 K Vt(qqnump,"wpoe") S Vt(qqnump,"wpoe")=%2 ;@Dol 12.02.10
 I $P($$$CondFind," ")=""||($G(W("Zosrt"))="") Q:$Q "" Q  ;нет упорядоченности
 S Vt(qqnump,"wpoe",1)=1 ;@Dol 12.02.10
 I $G(W("Zosrt","x"))="" S %6=$P($G(Vo(qqnump,W("Zosrt"),11,$P($$$CondFind," ")))," ",2) D:%6=""  I %6="" Q:$Q "" Q
 .S %6="ZBs" F  S %6=$O(W(%6)) S:$E(%6,1,3)'="ZBs" %6="" Q:%6=""  Q:$G(W(%6))  ;@dol 10.1.04 по колонке, а не по понятию сортировки
 .Q:%6=""  S %6=$P(%6,"ZBs",2)-1
 I $G(W("Zosrt","x"))'="" S %6=W("Zosrt","x")
 S %8=$E($G(Vo(qqnump,-1,0,0,%6)),2,255) S %10=$S(%8'="":"",1:$P(..GetPar("X7103",,W("Zosrt"),$P($$$CondFind," ")),"~")) ;@Dol 04.12.08 имя заголовка 
 S %7=$S(%8'=""||($G(Vo(qqnump,-1,88))#3=2):$TR($S($E(%8)'="@":$P(%8,"~"),1:qW.GetWoc("CxWoc",$E(%8,2,32))),"_"," "),%10'="":%10,1:..GetName(,W("Zosrt"),$P($$$CondFind," "))) ;@Dol 04.12.08
 s:$g(XBLocal) %7=qSYS.getLocal(%7,6) ;@pav подключение словаря локализации 22.03.2010
 I $D(Vo(qqnump,-1,11,"Znew")) S W("Znew")=$P($$$CondFind," ",5)_$P($$$CondFind," ",6) D ..wwww("Znew",,,-1,"") Q:$Q "" Q  ;@dol 26.02.04 для развертки с редактированием (qSYS.sysView (sysR) )
 D ..wP(,"ColumnText",$TR(%7,"_"," ")_$S($P($$$CondFind," ",5)'=""||($P($$$CondFind," ",6)'=""):$S($TR(%7,"_ ")="":"",1:$C(13,10))_$P($$$CondFind," ",5)_$P($$$CondFind," ",6),1:""),%6)
 D ..wM(,"MakeColumnVisible",%6) ;@Dol 10.12.06
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wpot">
<Description>
Раскрытие/закрытие (qqpar2=1\0) папки понятий объекта qqpar1
если не задан qqpar2, то переключение
если qqpar1="", то все узлы (qqpar2="" - начальная установка</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$S(W("Zadm")!$G(Vs(qqnump,"Analit")):1,1:..GetPar("X184")) Q:$Q "" Q  ;стиль дерева объектов
 N qqk,qqso,qqw,qi,qqlev S qqpar1=$G(qqpar1),qqpar2=$G(qqpar2)
 D:qqpar1'="" ..wP(qwin_".T1","BulkUpdate",1)
 I qqpar2="",qqpar1'="" S qqpar2='$G(Vs(qqnump,4,qqpar1))
 ;
 D:qqpar1'=""  I qqpar1="" F  S qqpar1=$O(Vo(qqnump,qqpar1)) Q:qqpar1=""  I qqpar1'=-1,$D(Vo(qqnump,qqpar1,0))>1 D
 .D  ;Обработка дополнительного понятия для режима Аналитик (пока C - код экземпляра)
 ..I $G(Vs(qqnump,"Analit")) Q:$D(Vo(qqnump,qqpar1,11,"C"))  S Vo(qqnump,qqpar1,11,"C")="",qi=$I(Vo(qqnump,qqpar1,10)),Vo(qqnump,qqpar1,10,qi)="C" Q  ;добавим C
 ..Q:'$D(Vo(qqnump,qqpar1,11,"C"))  Q:$G(Vo(qqnump,qqpar1,11,"C"))'=""  S qi=$I(Vo(qqnump,qqpar1,10),-1) K Vo(qqnump,qqpar1,11,"C"),Vo(qqnump,qqpar1,10,qi+1)  ;удалим
 .I qqpar2'="" Q:qqpar2=''$G(Vs(qqnump,4,qqpar1))  S Vs(qqnump,4,qqpar1)=qqpar2  ;нет смены состояния ?
 .I qqpar2="",'$G(Vs(qqnump,4,qqpar1)) Q
 .;S qqlev=$L($$$ObjRef(qqpar1),",")+1
 .D ..wM(,"M9",1,0,qqpar1) I qqpar2'="",'$D(WQ(qqnump,"po"_qqpar1)) D ..wP(,"M3",$S($G(Vs(qqnump,1,qqpar1)):"d",1:"")_$S(qqpar2:"p1",1:"p0"),"")
 .I qqpar2=0 Q:'$G(Vo(qqnump,qqpar1,10))  D  Q  ;@ZX* - псевдо-кнопки. Не нужно показывать
 ..S qqk=0 F qi=1:1:$G(Vo(qqnump,qqpar1,10)) S qqw=Vo(qqnump,qqpar1,10,qi) I $E(qqw,1,3)'="@ZX"," "_$G(Vo(qqnump,qqpar1,7))_" "'[(" -"_qqw_" ") D:'qqk ..wM(,"M9",1,0,qqpar1_" "_Vo(qqnump,qqpar1,10,qi)) I $I(qqk) ;@Dol 18.05.09 -qqw
 ..I $G(Vs(qqnump,"X57",qqpar1))'="" S qqk=qqk+$L($G(Vs(qqnump,"X57",qqpar1))," ") ;@Dol 06.05.09
 ..D:qqk ..wM(,"M6","",qqk-1) Q  ;-1???
 .S qqlev=$L($G($$$ObjRef(qqpar1)),",")+1
 .F qi=1:1:$G(Vo(qqnump,qqpar1,10)) S qqw=Vo(qqnump,qqpar1,10,qi) I $E(qqw,1,3)'="@ZX"," "_$G(Vo(qqnump,qqpar1,7))_" "'[(" -"_qqw_" ") D wpotw ;@Dol 18.05.09 -qqw
 .F qi=1:1:$L($G(Vs(qqnump,"X57",qqpar1))," ") S qqw=$P($G(Vs(qqnump,"X57",qqpar1))," ",qi) I qqw'="",'$D(Vo(qqnump,qqpar1,11,qqw)) D wpotw  ;@Dol 30.07.08 динамические дополнительные параметры
 D:qqpar1'="" ..wP(,"BulkUpdate",0)
 I qqpar1'="",qqpar2,$G(Vs(qqnump,3,qqpar1)) D ..wrot(qqpar1)  ;c240???
 Q:$Q "" Q
wpotw  
 D ..wM(,"M2",""," ",qqlev,qqpar1_" "_qqw,0,"",$S('$G(qqXBz):"",$G(Vs(qqnump,1,qqpar1,qqw)):"R291",1:""))
 S qqk=$S(W("Zadm")!$G(Vs(qqnump,"Analit")):qqw_" ",1:"")_..GetName(,qqpar1,qqw) ;$TR(qW.GetWoc("CxWoc",qqw),"_"," ")
 D ..wP(,"M1",qqk,"",0,$S($E(qqw)'="@"&&(qqw'[":"):"",1:"F1"),"",8388608)
 D ..wP(,"M3",$S($G(Vs(qqnump,1,qqpar1,qqw)):"d",1:"")_"Bob","") ;картинка для понятий
 S %1=$G(Vs(qqnump,8,qqpar1,qqw)) D ..wP(,"M1",%1,"",1,"",16777215) ;поисковый образ
 D
 .D ..wP(,"M1",$G(Vs(qqnump,12,qqpar1,qqw,2))_$S($G(Vs(qqnump,12,qqpar1,qqw,1))=""&&($G(Vs(qqnump,12,qqpar1,qqw,17))="")&&($G(Vs(qqnump,12,qqpar1,qqw,18))=""):"",1:$C(13,10)_$G(Vs(qqnump,12,qqpar1,qqw,1))_$C(13,10)_$G(Vs(qqnump,12,qqpar1,qqw,17))_$C(13,10)_$G(Vs(qqnump,12,qqpar1,qqw,18))),"",2,"",16777215) ;выражения аналитик ;@Dol 23.09.10 18
 .S %1=$G(Vs(qqnump,12,qqpar1,qqw,3)) D:%1'="" ..wP(,"M4","CA","",3,0) D ..wP(,"M1",$E(%1,2,3)_$S($G(Vs(qqnump,12,qqpar1,qqw,3,1)):"*",1:""),"",3,"",16777215) ;@Dol 23.03.08 суммы
 .S %1=$G(Vs(qqnump,12,qqpar1,qqw,4)) D:%1'="" ..wP(,"M4","CD","",4,0) D ..wP(,"M1",$E(%1,2,3)_$S($G(Vs(qqnump,12,qqpar1,qqw,4,1))=1:"*",$G(Vs(qqnump,12,qqpar1,qqw,4,1))=2:"u",$G(Vs(qqnump,12,qqpar1,qqw,4,1))=3:"l",$G(Vs(qqnump,12,qqpar1,qqw,4,1))=4:"-",$G(Vs(qqnump,12,qqpar1,qqw,4,1))=5:"n",1:""),"",4,"",16777215) ;@Dol 20.01.10
 .N j F j=5:1:11 D ..wP(,"M1",$S($D(Vs(qqnump,13,0,qqpar1_" "_qqw_" "_j)):Vs(qqnump,13,0,qqpar1_" "_qqw_" "_j)_$S('$D(Vs(qqnump,13,0,qqpar1_" "_qqw_" "_j,1)):":",1:"-")_" ",1:"")_$G(Vs(qqnump,12,qqpar1,qqw,j)),"",j,"",$S(j=5:16777215,$G(Vs(qqnump,12,qqpar1,qqw))=2:16777215,'$G(Vs(qqnump,12,qqpar1,qqw))&(j<10):16777215,1:12632256)) D:$D(Vs(qqnump,13,0,qqpar1_" "_qqw_" "_j)) ..wP(,"M4","CY","",j,0)  ;9-11 ;@Dol 22.09.10 Y- Без итогов
 Q
]]></Implementation>
</Method>

<Method name="wqqotree">
<Description>
Перевывод/замещение поддерева на экране
qOref - указатель в Vc, не задан - текущая позиция на экране

Может быть вариант:
qOref - код объекта
qqcold - код экземпляра (обязан быть задан, хотя бы пустым). Пуст - первый экземпляр объекта на экране

!!!Если qqcold="*" - ДОБАВЛЕНИЕ в конец объекта qOref НОВОГО экземпляра qqcnew.

qqcnew - новый кодэкземпляраю Не задан - просто перевывод
qX54=1 - объект выводится как развернутый (важно в варианте X54=2)

Arg1=1 - не позиционироваться
По умолчанию позиционирование на первую первыводиую строку (если не указан qqop)
qqop - объект позиционирования в рамках перевыводимого дерева. qqcp - код его экземляра (не указан - первый)

Nobut=1 - не пересоздавать кнопки</Description>
<Internal/>
<FormalSpec>qOref:%Library.String,qqcold:%Library.String,qqcnew:%Library.String,qX54:%Library.String,Arg1:%Library.String,qqop:%Library.String,qqcp:%Library.String,Nobut:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qOref1,qObj,q6,qL
 ;D:$D(qwin(qwin,"FCBUT")) ..ButtonDestr()
 ;;;;;;;;;D ..wP(qwin,"BulkUpdate",1)
 I $D(qqcold) D  S qOref=qOref1 I qOref1="" Q:$Q "" Q
 .I qqcold="*" D  Q  ;@Dol 01.03.06 вставка в конец (для объекта qOref)
 ..I $G(qOref)=""||($G(qqcnew)="") D ..Message("*** qARM.wqqotree Отсутствует qOref или qqcnew") S qOref1="" Q
 ..S qOref1="" F  S qOref1=$O(Vc(qqnump,qOref1),-1) Q:qOref1=""  I Vc(qqnump,qOref1,0)=qOref Q
 ..I qOref1="" D ..Message("*** qARM.wqqotree Нет ни одной строки экземпляров") Q
 ..I Vc(qqnump,qOref1)[" " S qqcold=Vc(qqnump,qOref1) Q
 ..;вставка Oref нового объекта 
 ..N qqci2 S qqci2=$A(qOref1,$L(qOref1))+1 D  S Vc(qqnump,qOref1)="",Vc(qqnump,qOref1,0)=qOref 
 ...I qqci2<126 S $E(qOref1,$L(qOref1))=$C(qqci2) Q
 ...S $E(qOref1,$L(qOref1)-1,$L(qOref1))=$C($A(qOref1,$L(qOref1)-1)+1,65)
 .S qOref1="" F  S qOref1=$O(Vc(qqnump,qOref1)) Q:qOref1=""  I Vc(qqnump,qOref1,0)=qOref,$S(qqcold="":1,1:Vc(qqnump,qOref1)=qqcold) Q
 S:$G(qOref)="" qOref=Vc(qqnump) I $D(qwin(qwin,"FCBUT")),'$G(Nobut) D ..ButtonDestr(qOref)
 I $G(qqcnew)'="",$G(Vs(qqnump,7))=Vc(qqnump,qOref,0) S $P($$$CondFind," ",10,11)=qqcnew_" "_qqcnew ;@Dol 29.07.05
 S:'$D(qqcnew) qqcnew=Vc(qqnump,qOref)
 S qObj=Vc(qqnump,qOref,0),qOref1=qOref D
 .I $G(qqcold)'="*" S q6=$G(Vc(qqnump,qOref,6)) Q
 .S q6=$O(Vc(qqnump,qOref),-1) Q:q6=""  S q6=$G(Vc(qqnump,$E(q6,1,$L(qOref)),6)) ;@Dol 03.06.10 для вставки узел 6 (список зачеркнутых объектов и кодов их экземпляров)
 I $G(qX54)||$S($G(Vo(qqnump,qObj,4))>1:$G(Vc(qqnump,qOref,40))=1,1:0) S qX54=$G(Vo(qqnump,qObj,4)) K Vo(qqnump,qObj,4) ;вывод свернутого развернутым
 F  K Vc(qqnump,qOref1) S qOref1=$O(Vc(qqnump,qOref1)) Q:$E(qOref1,1,$L(qOref))'=qOref
 D ..wP(qwin_".T2","BulkUpdate",1)
 I $G(qqcold)'="*" D ..wM(qwin_".T2","M9",1,0,qOref_" "_qObj_" 0"),..wM(,"DeleteDependents","") ;удалить поддерево
 I $G(Vs(qqnump,7))=qObj S $P($$$CondFind," ",10,11)=qqcnew_" "_qqcnew
 S qL=$O(Vc(qqnump,qOref_"яя"))="" S:$G(qqXBwids) qL=0 ;@Dol 07.09.05 нужна обработка max. уровня
 I $G(qqcold)="*" D qW.gForm(qql,qObj,qqcnew,,qOref,,,,q6) I 1  ;@Dol 03.06.10 q6
 E  D qW.gForm(qql,qObj,qqcnew,,qOref,,,1,q6) ;@dol 29.07.04 было всего 100 экз!!!;;вставка нового содержимого 
 I qL,$G(W("ZoBLeV")) D ..wM(qwin_".T2","M2",-1,"",W("ZoBLeV"),"00",0) ;@Dol 07.09.05
 S:$G(Vs(qqnump,"Virt",qObj))'="" Vs(qqnump,"Virt",qObj)=qqcnew ;@dol 21.1.04
 ;;;S:q6'="" Vc(qqnump,qOref,6)=q6 ;@dol 2.2.04
 I $D(qX54) S Vo(qqnump,qObj,4)=qX54 I qX54'=""||($G(Vo(qqnump,qObj,400))'="")  S Vc(qqnump,qOref,40)=1 I qX54,"15"[(+$G(Vo(qqnump,-1,61))) D ..wM(qwin_".T2","M9",1,0,qOref_" "_qObj_" 0") D ..wcellpic(qObj,0,0,qOref) ;,..wP(,"M4","p1","",0,0) ;@dol 24.04.03 вывод папки
 I $D(Vs(qqnump,2,-1)) D  K Vs(qqnump,2,-1) ;@Dol 22.07.07 есть свернутые объекты
 .N qqci,qqo S qqo="" F  S qqo=$O(Vs(qqnump,2,-1,qqo)) Q:qqo=""  S qqci="" F  S qqci=$O(Vs(qqnump,2,-1,qqo,qqci)) Q:qqci=""  D:$G(Vc(qqnump,qqci,40))'=1 ..wM(qwin_".T2","M9",1,0,qqci_" "_qqo_" 0","",0)
 D ..wwwwZXXadd(qObj) ;@Dol 21.05.08 qObj
 I $D(Vt(qqnump,9,"FCBUT")),'$G(Nobut) D ..wwwwFCBUT(,qOref),..wM(qwin,"Vol_ArrayElementPaint")
 I '$G(Arg1) S qqc=qqcnew D   ;@dol 10.03.05
 .I $G(qqop)="" D ..wpoe(qOref_" "_qObj_" 0") Q
 .S qOref1=qOref F  S qOref1=$O(Vc(qqnump,qOref1))  S:$E(qOref1,1,$L(qOref))'=qOref qOref1="" Q:qOref1=""   I Vc(qqnump,qOref1,0)=qqop,$S($G(qqcp)="":1,1:Vc(qqnump,qOref1)=qqcp) Q
 .S:qOref1="" qOref1=qOref D ..wpoe(qOref1_" "_qqop_" 0")
 D ..wP(qwin_".T2","BulkUpdate",0,1) ;@dol 6.05.05 1 - не делать RecalGorExt
 I qL,$G(W("ZoBLeV")) D ..wM(qwin_".T2","M9",1,0,"00"),..wM(,"M6","",1) ;макс. уровень, если перевывод всего дерева@Dol 07.09.05
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wrot">
<Description>
свернуть/развернуть (qqpar2=1\0) узел объекта qqpar1
если не задан qqpar2, то переключение
если qqpar1="", то все объекты (qqpar2="" - начальная установка</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S qqpar1=$G(qqpar1),qqpar2=$G(qqpar2)
 I qqpar2="",qqpar1'="" S qqpar2='$G(Vs(qqnump,3,qqpar1))
 I qqpar1'="",qqpar2=''$G(Vs(qqnump,3,qqpar1)) Q:$Q "" Q  ;0 ;нет смены состояния
 I qqpar1'="" S Vs(qqnump,3,qqpar1)=qqpar2 D ..wM(qwin_".T1","M9",1,0,qqpar1,"",'qqpar2) ;Q:'qqpar2 1
 N qqot1,qqot2,qqot3 S (qqot2,qqot1)=$S(qqpar1="":"",1:$$$ObjRef(qqpar1)_",") F  S qqot1=$O($$$MObjRef(qqot1)) Q:$S(qqot1="":1,qqot2="":0,1:$E(qqot1,1,$L(qqot2))'=qqot2)  S qqot3=$P(qqot1,",",$L(qqot1,",")) D
 .;Q:qqpar1'="" ????
 .I qqpar2=0,qqot2'="" Q:$L(qqot1,",")'=$L(qqot2,",")  Q:'$G(Vs(qqnump,4,qqot3))  D ..wM(qwin_".T1","M9",1,0,qqot3,"",1) K Vs(qqnump,3,qqot3) Q  ;при раскрытии просмотр следующего уровня на предмет раскрытых папок
 .S:qqpar2'="" Vs(qqnump,3,qqot3)=qqpar2
 .I qqpar2="",'$G(Vs(qqnump,3,qqot3)) Q
 .I qqpar2=1,$L(qqot1,",")>1,$G(Vs(qqnump,3,$P(qqot1,",",$L(qqot1,",")-1))) Q
 .D ..wM(qwin_".T1","M9",1,0,qqot3,"",'$G(Vs(qqnump,3,qqot3)))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wsize">
<Description>
Пересчет размеров окна относительно текущего фонта. Текущие размеры - относительно фонта 8
Поправки (15 и 40) зависят от того, как задаются размеры окна (qqXBFws) - надо доделать</Description>
<Internal/>
<FormalSpec>wsize:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N wsizeX,wsizeY S wsizeX=$P(wsize,",",1),wsizeY=$P(wsize,",",2)
 S wsize=$P($G(qqX155),",",2)/8 S wsizeX=$J(wsizeX*wsize,0,0) S:wsizeX+15>qARM("Screen","Width") wsizeX=qARM("Screen","Width")-15
 S wsize=$P($G(qqX155),",",2)-8/2+8/8,wsizeY=$J(wsizeY*wsize,0,0) S:wsizeY+40>qARM("Screen","Height") wsizeY=qARM("Screen","Height")-40
 Q wsizeX_","_wsizeY
]]></Implementation>
</Method>

<Method name="wwde">
<Description>
Вывод признака наличия поискового образа и аналитик.</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 D ..wP(qwin_".T1","ColumnPictureH@1",$S($D(Vs(qqnump,8))>1&('W("ZBt0")):"Del",1:"Red0"),1,0),..wP(,,$S($D(Vs(qqnump,12))>1&('W("ZBt0")):"Del",1:"Red0"),2,0)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wwrefr">
<Description>
Перевывод (обновление).
Не изменяется свернутость/зачеркнутость. Перевыводятся все видимые на экране строки заданных экземпляров объектов (и их картинок).

Если заданы qqo и qqc - конкретный экземпляр или все экземпляры (qqc="") ; в противном случае обновляется весь экран.
Только строки вершины - qqo=-1

rel=1 - перевывести ТОЛЬКО отметку релевантных
rel=-1 - НЕ перевыводить (и не пересчитывать по релевантным) отметку релевантных

Отметка релевантных ПЕРЕСЧИТЫВАЕТСЯ по состоянию перечня релевантных.
если задан par, то это список пересчитываемых параметров (p - картинки, d - динамические параметры, t - всплывающие подсказки). Текст ячеек НЕ перевыводится ;@Dol 03.08.09

Возвращает 1, если что-либо перевыведено.
Метод ЗАВЕРШАЕТ операцию коррекции НО не завершает текущее РЕДАКТИРОВАНИЕ.
В правиле проверки ячейки использовать осторожно (ТЕКУЩЕЕ редактирование в этом случае НЕ завершено - пропадет текущее значение). </Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqc:%Library.String,rel:%Library.String,par</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqci,qstr,qiii,qqz,qqff,qiiii,end,qqso
 I ..EndOP(1) Q:$Q 0 Q
 ;;;;;;;D ..wP(qwin,"BulkUpdate",1)
 D ..wP(qwin_".T2","BulkUpdate",1)
 I $G(rel)'=1 D:$D(qwin(qwin,"FCBUT")) ..ButtonDestr()
 S qqo=$G(qqo) D:qqo=-1||(qqo="")   ;перевывод вершины
 .N qqo,qqc S qqci=-1,qqo=-1,qqc="",qqso=0 F  S qqso=$O(Vo(qqnump,-1,0,qqso)) Q:qqso=""  I $P($G(Vo(qqnump,-1,0,qqso))," ")="",$G(Vs(qqnump,1,-1,qqso))'=2 D wwwrefrS
 I qqo'=-1 S qqci="" F  S qqci=$O(Vc(qqnump,qqci)) Q:qqci=""  D  Q:qqci=""
 .I $G(qqo)="" D wwwrefrW(qqci,Vc(qqnump,qqci,0),Vc(qqnump,qqci)) Q
 .Q:qqo'=Vc(qqnump,qqci,0)  I $G(qqc)="" D wwwrefrW(qqci,qqo,Vc(qqnump,qqci)) Q
 .I qqc=Vc(qqnump,qqci) D wwwrefrW(qqci,qqo,qqc) S qqci=""
 I $G(rel)'=1 D ..wwwwZXXadd(-1) ;@Dol 21.05.08 -1
 D ..wP(qwin_".T2","BulkUpdate",0,1)
 I $G(end),$G(Vs(qqnump,99,"Pic"),$E(qqRES,3)) D ..wpic(1) ;с картинками пока криво - перевыводятся ВСЕ
 I $G(rel)'=1 D:$D(Vt(qqnump,9,"FCBUT")) ..wwwwFCBUT()
 I $G(rel)'=-1,$G(Vo(qqnump,-1,88))'=1,'$G(Vo(qqnump,-1,80)),$G(Vo(qqnump,-1,194))'="" D ..wP(qwin_".T2","RowColPictureH@1",$P(Vo(qqnump,-1,194)," ",''$$$RelNum+1),0) ;@Dol 14.07.08 заголовок колонки релевантных
 ;;;;;;D ..wP(qwin,"BulkUpdate",0)
 Q:$Q +$G(end) Q
wwwrefrW(qqci,qqo,qqc)
 S qqo=Vc(qqnump,qqci,0),qqc=Vc(qqnump,qqci)
 I $G(Vo(qqnump,qqo,2))<3,qqc'[" " S Vc(qqnump,qqci,5)=$G(^Q(1,$S($E(qqo)="v":$E(qqo,3,255),1:qqo),qqc,"X")) ;@Dol 13.03.06 qqtime
 S qqso="" F  S qqso=$O(Vc(qqnump,qqci,11,qqso)) Q:qqso=""  D wwwrefrS
 Q
wwwrefrS
 D ..wM(qwin_".T2","M9",1,0,qqci_" "_qqo_" "_qqso)
 I $G(rel)'=-1,qqo'=-1,'qqso,'$G(Vo(qqnump,qqo,244)) D  ;пересчет отметки релевантных
 .S Vc(qqnump,qqci,2)=''$D(^Q($$$Relind_qview,qqo,qqc))  ;А ссылочные ?????
 .D:$G(Vo(qqnump,-1,194))'="" ..wP(,"M5",$S($G(Vo(qqnump,-1,821))'="":$P(Vo(qqnump,-1,194)," ",''qW.GG(qqo,Vo(qqnump,-1,821),qqc)+1),1:$P(Vo(qqnump,-1,194)," ",''$G(Vc(qqnump,qqci,2))+1)),"",0) ;@Dol 21.08.08 821
 .;$S(qqso:"",$G(Vo(qqnump,qqo,244)):"",'$G(Vc(qqnump,qqciobj,1),1):"",$G(Vo(qqnump,-1,194))="":"",'$G(Vc(qqnump,qqciobj,2)):$P(Vo(qqnump,-1,194)," ",1),1:$P(Vo(qqnump,-1,194)," ",2))
 I $G(rel)=1 Q:'$D(Vo(qqnump,qqo,11,"ZTMPN"))  D qARM.wwww("ZTMPN",,,qqo,qqc) Q  ;@Dol 14.07.08
 I '$D(Vt(qqnump,9,qqo_" "_qqso)),'$D(Vt(qqnump,9,qqo_" "_qqso_" ")) Q  ;откуда-то берутся лишние строки?
 G:$G(par)'="" wwrefpar S qstr=qW.GetLine(qqc,qqo,qqso),end=1 ;,Qss=qqo_" "_qqso
 ;D ..wM(qwin_".T2","M9",1,0,qqci_" "_qqo_" "_qqso)
 ;dima & sas 20090701 был забыт qwin_".T2"
 D ..wP(qwin_".T2","M1",qstr,"")
 I '$D(Vt(qqnump,9,qqo_" "_qqso)) S qqz=qqso N qqso S qqso=qqz_" "  ;строка неактивна
 I $D(Vt(qqnump,9,qqo_" "_qqso)),Vt(qqnump,9,qqo_" "_qqso)'<0 D ..wM(,"M7",qwin_".T3","",Vt(qqnump,9,qqo_" "_qqso),W("ZBtred"))
wwrefpar
 I $D(Vt(qqnump,9,"PP",qqo,+qqso)),$S($G(par)="":1,1:par["p") S qiii="" F  S qiii=$O(Vt(qqnump,9,"PP",qqo,+qqso,qiii)) Q:qiii=""  D:'$G(Vs(qqnump,1,qqo,+qqso,qiii)) qARM.wcellpic(qqo,+qqso,qiii,qqci)
 I $D(Vt(qqnump,9,"PPP",qqo,+qqso)),$S($G(par)="":1,1:par["d") S qiii="" F  S qiii=$O(Vt(qqnump,9,"PPP",qqo,+qqso,qiii)) Q:qiii=""  D:'$G(Vs(qqnump,1,qqo,+qqso,qiii)) qARM.wcelldpar(qqo,+qqso,qiii,qqci) ;@dol 20.01.03 Вычисляемые параметры ячейки (пока - только цвет)
 I $D(Vt(qqnump,9,"PPt",qqo,+qqso)),$S($G(par)="":1,1:par["t") S qiii="" F  S qiii=$O(Vt(qqnump,9,"PPt",qqo,+qqso,qiii)) Q:qiii=""  D:'$G(Vs(qqnump,1,qqo,+qqso,qiii)) qARM.wcellttips(qqo,+qqso,qiii,qqci) ;@dol 11.04.06
 I $G(qqff)'="" F qiii=2:1:$L(qqff," ") S qiiii=$P(qqff," ",qiii) D ..wP(,"M4","Flg"_(''$E(qiiii)),"",$E(qiiii,2,5),0) ;флаги (нужно переделать на постоянные картинки)
 Q
]]></Implementation>
</Method>

<Method name="wwww">
<Description>
Вывод в дерево экземпляров значений понятий текущего объекта.
qqpar1 - список кодов понятий через пробел).
* - вывести все обобщения и выражения
Для вывода выражения (или константы) в строке S колонке K дерева экземпляров
текущего объекта используется псевдопонятие ZsScK. Например, Zs0c0.
Arg1=1 - не выдавать сообщение об отсутствии выводимого понятия в отображении. 
p31=1 - всегда перевыводить картинки и встроенные элементы. Нужно, если они были зачеркнуты;@Dol 22.04.08 ;;;(раньше было но не использовалось-Если задан p31 - тип ввода с заменой варианта редактирования (x531).Цвета символа и фона на заданный в описании отображения (X152, X177 должны быть цвета). 
curobj - код объекта, если вывод во внетекущий, qqc - код его экземпляра. Если объект выше - код необязателен, если ниже, и qqc не указан - первый встреченный.
Для вывода в другое окно (ПОКА ТОЛЬКО ОБОБЩЕНИЙ):
qqnumpo - номер окна. curobj и qqc д.б. заданы.

!!!New Обработка зачеркнутости (Работает и для констант, учтены картинки и навесные элементы). Например:
S Vs(qqnump,1,qqo,qqw)=1 D qARM.wwww(qqw) ;удаляет с экрана
S Vs(qqnump,1,qqo,qqw)=0 D qARM.wwww(qqw) ;восанавливает на  экране (=0 обязательно!!!)
K Vs(qqnump,1,qqo,qqw) D qARM.wwww(qqw,,1) ;восанавливает на  экране
S Vs(qqnump,1,qqo,0,1)=1 D qARM.wwww("Zs0c1") ;удаляет с экрана константу в строке 0 колонке 1
S Vs(qqnump,1,qqo,0,1)=0 D qARM.wwww("Zs0c1") ;восстанавливает константу
K Vs(qqnump,1,qqo,0,1) D qARM.wwww("Zs0c1",,1) ;восстанавливает константу</Description>
<Internal/>
<FormalSpec>qqpar1:%String,Arg1:%String,p31:%Library.String,curobj:%Library.String,qqc:%Library.String,qqnumpo:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(qqnumpo)'="" Q:'$D(qwin("Q"_qqnumpo))  N qqnumpT S qqnumpT=qqnump,qqnump=qqnumpo,qwin="Q"_qqnump  ;@Dol 24.07.09 !!! N qqnumpT 
 I qqpar1="" Q:$Q "" Q  ;S $ET="S ^Err=$ZE"
 N %1 N qqilst,qqw,q,i,qqci,qqc0,curobjD,qflag S:$G(qqc)'="" qqc0=qqc S curobjD=$D(curobj)
 I $G(curobj)="",$G(qqc)="" S curobj=$G($$$CurObj),qqci=$S(curobj=-1:"-1",1:$G(Vc(qqnump))),qqc=$S(qqci="":"",1:$G(Vc(qqnump,qqci)))
 S:curobj="" curobj=-1 S:curobj=-1 qqci=-1
 I curobj'=$$$CurObj!($G(qqc0)'=""),curobj'=-1 S qqci=Vc(qqnump) D  S:qqci'="" qqc=Vc(qqnump,qqci) I $G(qqci)="",curobjD Q:$Q "" Q  ;@Dol 24.02.10 если задан объект и он не найден, ничего не надо выводить
 .I $G(qqc)="" S %3=$$$ObjRef($$$CurObj) I ","_%3[(","_curobj_",") D  Q:qqci'=""  ;@dol 29.5.04 было _%3_","
 ..F  S qqci=$E(qqci,1,$L(qqci)-2) Q:qqci=""  Q:Vc(qqnump,qqci,0)=curobj
 .S qqci="" F  S qqci=$O(Vc(qqnump,qqci))  Q:qqci=""  I Vc(qqnump,qqci,0)=curobj,$S($G(qqc)="":1,1:Vc(qqnump,qqci)=qqc) Q
 S:$G(qqci)="" qqci=Vc(qqnump)
 N qqo S qqo=curobj ;@oleg 9.01.03
 I qqpar1["*" D  ;@dol 6.03.03 формирование списка всех выводимых выражений и обобщений
 .N x,y,z S y="",z="" F  S y=$O(Vo(qqnump,qqo,0,y)) Q:y=""  S x="" F  S x=$O(Vo(qqnump,qqo,0,y,x)) Q:x=""  D
 ..S qqw=Vo(qqnump,qqo,0,y,x) Q:'qqw  ;Q:$E(qqw)>5
 ..I +qqw=5 S z=z_" Zs"_y_"c"_x Q
 ..I $E(qqw,2)="@" S z=z_" "_$E(qqw,2,255)
 .S qqpar1=$P(qqpar1,"*")_z_$P(qqpar1,"*",2,255)
 ;D:$G(p31) ..wM("-qARM","ClearCache") ;@Dol 23.01.09 очистка кэша картинок (будут пересоздаваться все графические объекты) ; @dima 20091020 не используется
 F qqilst=1:1:$L(qqpar1," ") S qqw=$P(qqpar1," ",qqilst) D:qqw'=""
 .I qqw?1.N D:'$G(Arg1) ..Message("wwww="_qqw) Q
 .I $E(qqw,1,2)="Zs",$S(qqw?1"Zsc"1.3n:1,qqw?1"Zs"1.3n1"c"1.3n:1,1:0)  D  Q  ;@Dol 4.10.06 контроль Zsc* Zs*c*
 ..I $E(qqw,1,3)="Zsc" S Vt(qqnump,"Zsc",+$P(qqw,"c",2))=1 D ..wP(qwin_".T2","ColumnText",$P($G(W(qqw)),"~"),+$P(qqw,"c",2)) D ..wP(,"ToolTipColumnE",$P($G(W(qqw)),"~",2),+$P(qqw,"c",2)) Q  ;@dol 4.02.03 Z-понятия заголовков;30.10.09 Подсказки
 ..S %3=$G(Vo(qqnump,curobj,0,+$P($E(qqw,3,5),"c"),+$P(qqw,"c",2))) Q:%3=""  I $G(Vc(qqnump,qqci,40))=-1,$P($E(qqw,3,5),"c") Q  ;@dol 19.11.03 свернут но не выведен
 ..Q:"05"'[$E(%3)  I $G(Vs(qqnump,1,curobj)) Q  ;не выводить зачеркнутые объекты
 ..I $G(Vs(qqnump,1,curobj,+$P($E(qqw,3,5),"c"),+$P(qqw,"c",2))) S %3=+$P($E(qqw,3,5),"c")_" "_(+$P(qqw,"c",2)) D wwwwDel Q  ;@Dol 22.04.08 удаление зачеркнутых
 ..I $E(%3)=5 S %3=..Value($E(%3,2,30000)) D  I 1
 ...I $G(Vo(qqnump,curobj,0,+$P($E(qqw,3,5),"c"),+$P(qqw,"c",2),10))=1,%3?8N S %3=qW.GtoExt(1,%3) Q  ;@dol 23.08.03 выражение-дата
 ...S:$G(Vo(qqnump,-1,66)) %3=$TR(%3,"_"," ")  ;@dol 27.05.04
 ..E  S %3=$E(%3,2,30000),%3=$S(%3="@":..GetName("",curobj),$E(%3)="@":..GetName("",curobj,$E(%3,2,30)),1:%3)
 ..I $G(Vo(qqnump,-1,65))=2,$TR(%3,"~")="" S %3=$S(%3="":" ",%3="~":"",1:%3)  ;@dol 16.1.04
 ..D ..wM(qwin_".T2","M9",1,0,qqci_" "_curobj_" "_(+$P($E(qqw,3,6),"c")))
 ..D wwwwDP(+$P($E(qqw,3,6),"c")_" "_(+$P(qqw,"c",2))) ;@dol 23.03.04 динамические параметры выражений
 ..I $G(p31)=""||($G(p31)?1N) D ..wP(qwin_".T2","M1",%3,"",$P(qqw,"c",2)) D  Q
 ...I $D(Vt(qqnump,9,"FCBUT",curobj,+$P($E(qqw,3,6),"c"),+$P(qqw,"c",2))),$S($G(p31)=1:1,$E(Vt(qqnump,9,"FCBUT",curobj,+$P($E(qqw,3,6),"c"),+$P(qqw,"c",2)))="@"||($P(Vt(qqnump,9,"FCBUT",curobj,+$P($E(qqw,3,6),"c"),+$P(qqw,"c",2))," ")="FT"):1,1:$G(Vs(qqnump,1,curobj,+$P($E(qqw,3,6),"c"),+$P(qqw,"c",2)))=0) D ..wwwwFCBUT(,qqci,curobj,+$P($E(qqw,3,6),"c"),+$P(qqw,"c",2))  ;@Dol 9.11.05 перевывод кнопки панели инструментов
 ..D wwww1(+$P($E(qqw,3,6),"c"),+$P(qqw,"c",2),%3)
 .I qqw="Ztitle" D  Q
 ..;I $G(W("Ztitle"))'="" D ..wP(qwin,"Caption",W("Ztitle")) Q  ;@Dol 20.09.04
 ..D ..wP(qwin,"Caption",$TR($S($E($G(Vo(qqnump,-1)))="-":$E(Vo(qqnump,-1),2,3000),1:$S($G(qqXBpre):$S($G(^Q(1,"XBase",0,"XBName"))="":"",1:$TR($E(^("XBName")),"-")_$E(^("XBName"),2,255))_".",1:"qWORD-XML.")_$S(W("Zadm"):"(Администратор "_$P($P(qARM("CntStr"),":",2),"[")_":"_$P(qARM("CntStr"),":",3)_") ",$G(Vs(qqnump,"Analit")):"(Аналитик) ",1:"")_$G(Vo(qqnump,-1))),"_",$S($G(Vo(qqnump,-1,66)):" ",1:"_"))) Q  ;@Dol 29.07.09 "_"
 .I qqw="@Zdrel"!($E(qqw,1,3)="ZZR")  Q  ;D:'$G(Arg1) ..Message("wwww "_qqw) Q  ;@dol 3.11.03
 .I $G(Vs(qqnump,1,curobj)) Q  ;не выводить зачеркнутые объекты
 .S %3=$G(Vo(qqnump,curobj,11,qqw)) I %3="" D:'$G(Arg1)&&(qqw'="ZfI9") ..Message("qARM.wwww. Понятия "_qqw_" нет в объекте "_curobj) Q  ;@Dol 01.03.05 &&(qqw'="ZfI9") - поисковый образ
 .I $S($G(Vs(qqnump,1,curobj,qqw)):1,1:$G(Vs(qqnump,1,curobj,$P(%3," "),$P(%3," ",2)))) D wwwwDel Q  ;@Dol 22.04.08 выводить зачеркнутые
 .I $G(qqci)'="",$G(Vc(qqnump,qqci,40))=-1,$P(%3," ") Q  ;@dol 19.11.03 свернут но не выведен
 .I $G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),84))'="" N qqend D  I $G(qqend) S q=$E(qqend,2,30000) Q:q=""  G wwwwEnd  ;@Dol 3.02.06 Образец
 ..N qqo S qqo=curobj D qARM.GetPar("x710",,qqo,$P(%3," "),$P(%3," ",2))
 .S q=$S(curobjD||($E(qqw)="@")||(qqw="ZTMPN")||($E(qqw,1,4)="ZMAS")||(qqw[":"):qW.GG(curobj,qqw,$G(qqc,"??")),1:$G(W(qqw)))
 .I q="",qqred'=qqw,$S('$G(Vo(qqnump,curobj,870)):0,Vo(qqnump,curobj,870)=1:qqc[" ",1:1) S q=$G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),5)) I q'="" D:$E(q)="@"  S qflag=q I q'="" S:Vo(qqnump,curobj,870)=2 q="["_q_"]" ;@Dol 1.12.07 вывод значений по умолчанию (X5870);@Dol 06.11.09 для флага qflag
 ..N qqo S qqo=curobj,@("q="_$E(q,2,30000))
 .I $E(qqw)'="T",$E(qqw,1,2)'="HT" D  I 1
 ..I q="NULL" S q=$S($G(W("Zadm"))||$G(qFindDO)||$G(qAnalDO)||$G(qrCopy)||$G(qStreem):q,1:"") ;@Dol 26.02.05 
 ..I $G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),10)),"1678"[$E(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),10)) S q=qW.GtoExt(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),10),q) Q  ; @tdv 05.08.05 добавлены типы 7,10 - DATETIME,DATEYY
 ..I $G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),10))="Ht" S q=qW.GtoExt("Ht",q) Q
 ..I $E($G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),10)))="M" S q=qW.GtoExt(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),10),q) Q
 ..I $G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),10))="P",qqred="" S q=qW.GtoExt("P",q,qqw,curobj) Q
 ..I $G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),10))="DEC" S q=qW.GtoExt(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),10),q,,,,$G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),810))) Q   ; sas 20100714 для DEC включение групп разрядов
 ..I $E($G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2))))=3 D  Q  ;@dol 17.01.03 список с обработкой режима одного слова
 ...I q[" " S i=1 F  S i=$F(q," ",i) Q:'i  S $E(q,i-1)=$C(13,10)
 ...I qqw'=qqred,$G(Vo(qqnump,-1,66)),'$G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),62)) S q=$TR(q,"_"," ") ;@dol 20.12.05 X762
 ..I qqw'=qqred,$G(Vo(qqnump,-1,66)),'$G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),62)) S q=$TR(q,"_"," ") ;@dol 20.12.05 X762 если не вывод текущего понятия в режиме редактирования
 .E  D
 ..I $E(qqw,1,2)="TB",$G(Vo(qqnump,curobj,2))'=6 S q=qW.GT(curobj,qqw,qqc,2) Q
 ..S q="" F i=0:1:$S($E(qqw,1,2)="TB":5,1:$O(W(qqw,""),-1)) Q:$L(q)+$L($G(W(qqw,i)))>25000  S q=$S(i=0:"",1:q_$C(13,10))_$G(W(qqw,i)) ;@Dol 05.05.05 >30000
 ..I i'=+$O(W(qqw,""),-1) S q=q_$C(13,10)_"................." ;все равно не увидеть
 .I $G(Vo(qqnump,-1,65))=2,$E(qqw,1,3)'="@ZX" S q=$S(q="":" ",q="~":"",1:q) ;@dol 16.1.04 "~" = "";;@Dol 10.03.05 ,$TR(q,"~")=""
wwwwEnd .i $G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),104)) s:$g(XBLocal) q=qSYS.getLocal(q,2)  ;@pav если элемент интерфейса то переводим по словарю локализации
 .D ..wM(qwin_".T2","M9",1,0,qqci_" "_curobj_" "_$P(%3," "))
 .D wwwwDP(%3)
 .;;;I $E($G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2))))=4 D:$E($G(Vt(qqnump,9,"PP",curobj,+$P(%3," "),$P(%3," ",2))))="" ..wP(,"M4","Flg"_(''q),"",$P(%3," ",2),0) S q=qW.GtoExt("F",q,qqw,curobj) Q:q=""
 .I $E($G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2))))=4 D:$E($G(Vt(qqnump,9,"PP",curobj,+$P(%3," "),$P(%3," ",2))))="" ..wP(,"M4","Flg"_$S($D(qflag):''qflag,1:''q),"",$P(%3," ",2),0) S q=$S('$D(qflag):qW.GtoExt("F",q,qqw,curobj),1:"["_$S(qW.GtoExt("F",''qflag,qqw,curobj)="":$P("нет да"," ",qflag+1),1:qW.GtoExt("F",''qflag,qqw,curobj))_"]") ; Q:q=""  ;@Dol 06.11.09 вывод умолчаний
 .I $G(p31)=""||($G(p31)?1N) N type,type1 S type=$G(Vt(qqnump,9,"FCBUT",curobj,+$P(%3," "),$P(%3," ",2))) S:type'="" type1=$S(type="@":..GetPar("x760",,curobj,+$P(%3," "),$P(%3," ",2)),1:type) D  Q  ;@Dol 23.03.09 перевывод навесных элементов;@Dol 29.04.09 clock pb
 ..I $P($G(type1)," ")="PB" D ..wP(,"M1",q,"",$P(%3," ",2)) Q  ;@Dol 12.05.09 для прогрессбара просто перевывод содержимого связанной ячейки
 ..I $P($G(type1)," ")="CLOK" N qqwr D  Q:qqwr
 ...S qqwr="" F  S qqwr=$O(qwin(qwin,"FCBUT",qqwr)) Q:qqwr=""  Q:$G(qwin(qwin,"FCBUT",qqwr))=(qqci_" "_curobj_" "_(+$P(%3," "))_" "_$P(%3," ",2))
 ...Q:'qqwr  I q=-1 D ..wP(qwin_".FCBUT"_qqwr,"Stopped",1) Q  ;остановка
 ...I $TR(q," ")=""||(q'?1.N) D ..wM(qwin_".FCBUT"_qqwr,"Destroy") K qwin(qwin,"FCBUT",qqwr) D ..wP(qwin_".T2","M1",q,"",$P(%3," ",2)) Q  ;удаление
 ...D ..wP(qwin_".FCBUT"_qqwr,"Seconds",q),..wP(,"Stopped",0) ;запуск
 ..I $P($G(type1)," ")="RE" S:$G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),10))="RX" q=$S($A(q)=1:q,qqw'=qqred:qW.CRTF(q),1:qW.zChSym(qW.CRTF(q),$C(13,10),"\par")) I qqw=qqred D ..wM(Sender,"InsertText",q) Q  ;перевывод внутри редактирования RE; @Dol 28.06.10 $A(q)=1 - уже RTF
 ..D ..wP(,"M1",q,"",$P(%3," ",2)) 
 ..I type'="",$S($G(p31)=1:1,$E(type)="@"||($E($P(type," ",2))="@")||($P(type," ")="FT"):1,$G(Vs(qqnump,1,curobj,qqw))=0:1,1:$G(Vs(qqnump,1,curobj,$P(%3," "),$P(%3," ",2)))=0) D ..wwwwFCBUT(,qqci,curobj,+$P(%3," "),$P(%3," ",2)) ;@Dol 06.09.09 было ($P(type," ")="FT")
 .D wwww1($P(%3," "),$P(%3," ",2),q) I $P(%3," ",2) S q=$G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2)-1)) I $E(q)=0 S q=$E(q,2,30000) D wwww1($P(%3," "),$P(%3," ",2)-1,$S(q="@":..GetName("",curobj),$E(q)="@":..GetName("",curobj,$E(q,2,30)),1:q))
 S:$D(qqnumpo) qqnump=qqnumpT,qwin="Q"_qqnump Q:$Q "" Q
wwww1(y,x,q)    S (%4,Vo(qqnump,curobj,0,y,x,31))=p31,%5=$E(Vo(qqnump,curobj,0,y,x)) D ..wP(,"M1",q,"",x,"",$S(p31<0&(%5=0):"",1:$$wwwwcolor(9)),$$wwwwcolor(8)) Q
wwwwcolor(n)    Q $P(Vo(qqnump,-1,$S(p31<0:77,%5=0:50,%5=5:51,1:52)),",",n)
wwwwDP(%3)  I $D(Vt(qqnump,9,"PP",curobj,+$P(%3," "),$P(%3," ",2))),$S($G(p31)=1:1,$E($G(Vt(qqnump,9,"PP",curobj,+$P(%3," "),$P(%3," ",2))))="@"||($G(Vt(qqnump,9,"PP",curobj,+$P(%3," "),$P(%3," ",2)))[" ")||(qqw="@ZXXPntr"):1,$G(Vs(qqnump,1,curobj,qqw))=0:1,1:$G(Vs(qqnump,1,curobj,$P(%3," "),$P(%3," ",2)))=0) D  ;есть динамические постоянные картинки;@Dol 24.08.05 @ZXXPntr
 .D ..wcellpic(curobj,+$P(%3," "),$P(%3," ",2),qqci)
 I $D(Vt(qqnump,9,"P",curobj_" "_(+$P(%3," "))_" "_$P(%3," ",2))),$S($G(p31)=1:1,$G(Vs(qqnump,1,curobj,qqw))=0:1,1:$G(Vs(qqnump,1,curobj,$P(%3," "),$P(%3," ",2)))=0) D  ;@Dol 22.04.08 постоянные картинки
 .D ..wpic(1,curobj_" "_(+$P(%3," "))_" "_$P(%3," ",2))
 D:$D(Vt(qqnump,9,"PPP",curobj,+$P(%3," "),$P(%3," ",2))) ..wcelldpar(curobj,+$P(%3," "),$P(%3," ",2),qqci)  ;@dol 20.01.03 Вычисляемые параметры ячейки (пока - только цвет)
 D:$D(Vt(qqnump,9,"PPt",curobj,+$P(%3," "),$P(%3," ",2))) ..wcellttips(curobj,+$P(%3," "),$P(%3," ",2),qqci) ;@dol 11/04/06 Всплывающая подсказка
 Q
 ;@Dol 22.04.08 удаление зачеркнутых
wwwwDel D ..wM(qwin_".T2","M9",1,0,qqci_" "_curobj_" "_$P(%3," ")),..wP(,"M1","","",$P(%3," ",2)) D  Q
 .I $G(Vo(qqnump,curobj,0,$P(%3," "),$P(%3," ",2),6))'="" D ..wP(,"M4","","",$P(%3," ",2)) ;сотрем картинку
 .Q:'$D(Vt(qqnump,9,"FCBUT",curobj,+$P(%3," "),$P(%3," ",2)))  ;удаление встроенных элементов
 .N qqwr S qqwr="" F  S qqwr=$O(qwin(qwin,"FCBUT",qqwr)) Q:qqwr=""  Q:$G(qwin(qwin,"FCBUT",qqwr))=(qqci_" "_curobj_" "_$P(%3," ")_" "_$P(%3," ",2))
 .I qqwr D ..wM(qwin_".FCBUT"_qqwr,"Destroy") K qwin(qwin,"FCBUT",qqwr)
]]></Implementation>
</Method>

<Method name="wwwwFCBUT">
<Description>
Разрисовка встроенных элементов
Если задан qqo - перерисовка конкретного элемента (нужна для перевывода кнопок панели инструментов в qARM.wwww )</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,qqci0:%Library.String,qqo:%Library.String,qqso:%Library.String,qiii:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqci,qqz,qqc,qqzz,qtyp,qqwr,one I $G(qqo)'="" S qqci=qqci0,qqc=$G(Vc(qqnump,qqci)),one=1 D:0 ..wP(qwin,"BulkUpdate",1) D  D wwwwFCBUTd  D:0 ..wP(qwin,"BulkUpdate",0)  Q:$Q qqwr Q  ;перевывод встроенного элемента
 .S qqwr="" F  S qqwr=$O(qwin(qwin,"FCBUT",qqwr)) Q:qqwr=""  Q:$G(qwin(qwin,"FCBUT",qqwr))=(qqci_" "_qqo_" "_qqso_" "_qiii)
 .I qqwr D ..wM(qwin_".FCBUT"_qqwr,"Destroy") K qwin(qwin,"FCBUT",qqwr)
 D:$G(Arg1) ..ButtonDestr($G(qqci0))
 ;рамки 
 S qqo=-1 F  S qqo=$O(Vt(qqnump,9,"FR",qqo)) Q:qqo=""  S qqci=$S($G(qqci0)="":"",1:$E(qqci0,1,$L(qqci0)-1)_$C($A(qqci0,$L(qqci0))-1)) F  S qqci=$O(Vt(qqnump,9,"FR",qqo,qqci)) Q:$S($G(qqci0)="":qqci="",1:$E(qqci,1,$L(qqci0))'=qqci0)  D  ;разрисовка рамок
 .S qiii=Vt(qqnump,9,"FR",qqo,qqci) S:$E(qiii)="@" qqc=$S(qqo=-1:"",1:$G(Vc(qqnump,qqci))),@("qiii="_$E(qiii,2,30000)) I qiii'="" S qqz=$O(qwin(qwin,"FCBUT",""),-1)+1,qwin(qwin,"FCBUT",qqz)=qqci D ..wC("TTreeFrame",qwin_".FCBUT"_qqz,qwin_".T2",qqci,+$P(qiii," ",1),1,+$P(qiii," ",2),''$P(qiii," ",3)) D:$P(qiii," ",4)'="" ..wP(,"Color",$P(qiii," ",4))
 ;заголовки
 S qqo=-1 F  S qqo=$O(Vt(qqnump,9,"FH",qqo)) Q:qqo=""  S qqci=$S($G(qqci0)="":"",1:$E(qqci0,1,$L(qqci0)-1)_$C($A(qqci0,$L(qqci0))-1)) F  S qqci=$O(Vt(qqnump,9,"FH",qqo,qqci)) Q:$S($G(qqci0)="":qqci="",1:$E(qqci,1,$L(qqci0))'=qqci0)  D
 .I '$D(Vc(qqnump,qqci)) K Vt(qqnump,9,"FH",qqo,qqci) Q
 .S qiii=Vt(qqnump,9,"FH",qqo,qqci) S:$E(qiii)="@" qqc=$S(qqo=-1:"",1:$G(Vc(qqnump,qqci))),@("qiii="_$E(qiii,2,30000))
 .Q:qiii=""  S qqz=$O(qwin(qwin,"FCBUT",""),-1)+1,qwin(qwin,"FCBUT",qqz)=qqci_" "_qqo_" "_(+$P(qiii," ",1)) D ..wC("THeader",qwin_".FCBUT"_qqz,qwin_".T2",qqci_" "_qqo_" "_(+$P(qiii," ",1)),+$P(qiii," ",2),$P(qiii," ",3))
 .D:$P(qiii," ",4)'="" ..wP(,"Style",$P(qiii," ",4)) D:$P(qiii," ",5)'="" ..wP(,"HotTrack",$P(qiii," ",5)) I $P(qiii," ",6)'=""&&('$P(qiii," ",4)) D ..wP(,"OnClick",1)
 S qqo=-1,qqci=-1 D:$D(Vt(qqnump,9,"FCBUT",qqo))  I $O(Vt(qqnump,9,"FCBUT",qqo))'="" S qqci=$S($G(qqci0)="":"",1:$E(qqci0,1,$L(qqci0)-1)_$C($A(qqci0,$L(qqci0))-1)) F  S qqci=$O(Vc(qqnump,qqci)) Q:$S($G(qqci0)="":qqci="",1:$E(qqci,1,$L(qqci0))'=qqci0)  S qqo=Vc(qqnump,qqci,0) I $D(Vt(qqnump,9,"FCBUT",qqo)) S qqc=Vc(qqnump,qqci) D
 .S qqso="" F  S qqso=$O(Vt(qqnump,9,"FCBUT",qqo,qqso)) Q:qqso=""  D:$S(qqci=-1:1,1:$D(Vc(qqnump,qqci,11,qqso)))
 ..S qiii="" F  S qiii=$O(Vt(qqnump,9,"FCBUT",qqo,qqso,qiii)) Q:qiii=""  D wwwwFCBUTd
 Q:$Q "" Q
wwwwFCBUTd S qqzz=$G(Vt(qqnump,9,"FCBUT",qqo,qqso,qiii)) S qtyp=$P(qqzz," "),qqzz=$P(qqzz," ",2,500)
 I qtyp="@" S qtyp=..GetPar("x760",,qqo,qqso,qiii) Q:qtyp=""  S qqzz=..GetPar("X761",,qqo,qqso,qiii) ;@Dol 13.07.08 для образцов (см. qW.gForm метка wtwe )
 S:$E(qqzz)="@" @("qqzz="_$E(qqzz,2,30000)) I $TR(qqzz," ")="-1" Q:qtyp'="FT"  Q:$G(one)&($G(qqwr)="")  D ..wM(qwin_".T2","M9",1,0,qqci_" "_qqo_" "_qqso),..wP(,"M1","","",qiii),..wP(,"M4","","",qiii,0) D:$G(one) ..wM(qwin,"Vol_ArrayElementPaint") Q  ;@Dol 2.11.06 удаление кнопки панели
 S qqz=$S('$G(qqwr):$O(qwin(qwin,"FCBUT",""),-1)+1,1:qqwr) S qwin(qwin,"FCBUT",qqz)=qqci_" "_qqo_" "_qqso_" "_qiii ;S Vt(qqnump,9,qtyp,qqo,qqso,qiii)=qqz
 I qtyp="FCBUT" D ..wC("TCellButton",qwin_".FCBUT"_qqz,qwin_".T2",qqci_" "_qqo_" "_qqso,qiii) D:$P(qqzz," ",1)'=0 ..wP(,"OnClick",1) D:$P(qqzz," ",2) ..wP(,"Enabled",0) Q  ;D:$P(qqzz," ",2)'=0 ..wP(,"Focused",1) Q
 I qtyp="FT" D ..wC("TCellToolButton",qwin_".FCBUT"_qqz,qwin_".T2",qqci_" "_qqo_" "_qqso,$S($P(qqzz," ",6)'="":$P(qqzz," ",6),1:qiii)) D:$P(qqzz," ",1)'=0 ..wP(,"OnClick",1) D:$P(qqzz," ",2)'="" ..wP(,"Enabled",$P(qqzz," ",2)) D:$P(qqzz," ",4)'="" ..wP(,"Down",$P(qqzz," ",4)) D:$P(qqzz," ",5)'="" ..wP(,"Back",$P(qqzz," ",5)) D:$P(qqzz," ",7) ..wP(,"Dead",1) D:$P(qqzz," ",3)  Q  ;tdv 8.5.08 добавлена обработка $P(qqzz," ",2)
 .D ..wP(,"Style",1) N qqzzz,qqw,qqzz6 S qqzzz=..GetPar("X73",,qqo,qqso,qiii) Q:qqzzz=""  S qqzz6=$P(qqzzz," ",6),qqzzz=$P(qqzzz," ") ;25.02.11 было $P(..GetPar("X73",,qqo,qqso,qiii)," ") - не обрабатывалось условие вывода
 .D wwwwFCBUTqqw ;код понятия
 .S:(qqzzz["("&&($E(qqzzz)'=":"))||($E(qqzzz)="@") @("qqzzz="_$S($E(qqzzz)="@":$E(qqzzz,2,500),1:qqzzz))
 .I '$D(qwin(qwin,"XU"_$TR(qqw,"@_","o"))) d ..wC("TPopupMenu",qwin_".XU"_$TR(qqw,"@_","o")) S qwin(qwin,"XU"_$TR(qqw,"@_","o"))=""
 .D ..MenuWoc("XU"_qqw,$P(qqzzz," "),,,,,qqzz6,1,-1),..wP(qwin_".FCBUT"_qqz,"Menu",qwin_".XU"_$TR(qqw,"@_","o")) ;@Dol 25.02.11
 I qtyp="FH" D ..wC("THeader",qwin_".FCBUT"_qqz,qwin_".T2",qqci_" "_qqo_" "_qqso,$S($P(qqzz," ",3)'="":$P(qqzz," ",3),1:qiii),$S('$P(qqzz," ",4):0,1:$P(qqzz," ",4)-1)) D:$P(qqzz," ",2)'="" ..wP(,"Style",$P(qqzz," ",2)) D:$P(qqzz," ")'=0 ..wP(,"OnClick",1),..wP(,"HotTrack",1) Q  ;D:$P(qiii," ",3)'="" ..wP(,"HotTrack",$P(qqzz," ",3)) Q
 I qtyp="FR" D ..wC("TTreeFrame",qwin_".FCBUT"_qqz,qwin_".T2",$S($P(qqzz," ",8)="":qqci_" "_qqo_" "_qqso,1:$P(qqzz," ",8)),$P(qqzz," ",5),$S($P(qqzz," ",3)'="":$P(qqzz," ",3),1:qiii),$S('$P(qqzz," ",4):0,$P(qqzz," ",4)["%":$P(qqzz," ",4),1:$P(qqzz," ",4)-1),0) D:$P(qqzz," ",6)'="" ..wP(,"Color",$P(qqzz," ",6)) D:$P(qqzz," ",2)'="" ..wP(,"Style",$P(qqzz," ",2)) D:$P(qqzz," ",7)'="" ..wP(,"Line",$P(qqzz," ",7)) D qARM.wM(,"Paint") Q  ;qqso_$S($P(qqzz," ",5)="":"",1:$C(13)_$P(qqzz," ",5)),
 I qtyp="WIN" D  Q  ;@Dol 13.07.08 встроенное окно
 .D wwwwFCBUTqqw ;код понятия
 .I $P(qqzz," ",1)="X" X $P(qqzz," ",2,30000) Q  ;задано действие по открытию
 .S qqz=$P(qqzz," ",6) S:qqz="" qqz="?" ;код отображения окна
 .;OlgaS 12.11.2008
 .n viewcd,qqct s viewcd=qqz, qqct=$s($g(qqc)="":-1,1:qqc)
 .I $G(Vs(qqnump,"WIN",qqz,qqct))'="",$D(qwin("Q"_Vs(qqnump,"WIN",qqz,qqct))) Q:$G(Vs(qqnump,"WIN",qqz,qqct,1))=""  D  Q  ;окно открыто
 ..N qqnumpT S qqzz=Vs(qqnump,"WIN",qqz,qqct,1),qqnumpT=qqnump D ..crst(1,Vs(qqnump,"WIN",qqz,qqct),1)
 ..I qqzz=1 X Vo(qqnump,-1,23) ;действие по открытию
 ..I qqzz=2 D ..wcre() ;перевывод
 ..D ..crst(1,qqnumpT,2)
 .S qtyp=$P(qqzz," ",9,100) S:$E(qtyp)="@" @("qtyp="_$E(qtyp,2,3000)) S:$TR(qtyp," ")="" qtyp="" ;qqpar4
 .S Vs(qqnump,"WIN",qqz,qqct)=..OpenWindow(,,$P(qqzz," ",7),qtyp,$P(qqzz," ",8),qqz,1,,qqo_","_qqso_"~"_$g(qqci)_","_$S($P(qqzz," ",3)'="":$P(qqzz," ",3),1:qiii)_","_$P(qqzz," ",4)_","_$P(qqzz," ",5)) ;открытие окна
 .S:$P(qqzz," ",1) Vs(qqnump,"WIN",viewcd,qqct,1)=$P(qqzz," ",2) ;действия по перевыводу
 I qtyp="RE" D  Q  ;@Dol 25.07.08 редактор текстов
 .D ..wC("TTreeRichEdit",qwin_".FCBUT"_qqz,qwin_".T2",$S($P(qqzz," ",3)="":qqci_" "_qqo_" "_qqso,1:$P(qqzz," ",3)),$P(qqzz," ",6),$S($P(qqzz," ",4)'="":$P(qqzz," ",4),1:qiii),$S('$P(qqzz," ",5):$P(qqzz," ",5),$P(qqzz," ",5)["%":$P(qqzz," ",5),1:$P(qqzz," ",5)-1),0) 
 .; OlgaS 22.01.09 - для нового RichEdit @Dol 27.01.09
 .D ..wP(,"RichFmt",1),..wP(,"M1SaveRich",''$P(qqzz," ",10)) D:$P(qqzz," ",2) ..wM(,"CellBind",qqci_" "_qqo_" "_qqso,qiii,$P(qqzz," ",2)\2) D:$P(qqzz," ",8)'="" ..wP(,"ScrollBars",$P(qqzz," ",8))
 .D ..wP(,"EditorBorder",''($P(qqzz," ",7)#4)) D ..wP(,"Flat",$P(qqzz," ",7)#4>1) D ..wP(,"BorderStyle",$P(qqzz," ",7)>3)
 .D:$P(qqzz," ",9)'="" ..wP(,"WordWrap",$P(qqzz," ",9)) D:$P(qqzz," ",11)'="" ..wP(,"Optimal",$P(qqzz," ",11))
 .D:$P(qqzz," ",12)'="" ..wP(,"ShowToolBar",$P(qqzz," ",12)=1) D:$P(qqzz," ",13)'="" ..wP(,"DiskOp",$P(qqzz," ",13))
 .D ..wP(,"Mode",$P(qqzz," ",1))
 .D wwwwFCBUTqqw d ..wP(,"M1SaveNode","MasTxT") d ..wP(,"CanPaint",1) Q  ;@dima 20090727 "CanPaint" ;$NA(W(qqw))) Q 
 I qtyp="CLOK" D  Q  ;@Dol 29.04.09 часы
 .D ..wC("TClock",qwin_".FCBUT"_qqz,qwin_".T2",qqci_" "_qqo_" "_qqso,qiii) D:$P(qqzz," ",1) ..wP(,"Days",1) D:$P(qqzz," ",2)="" ..wP(,"Stopped",1) D:$P(qqzz," ",2)'="" ..wP(,"Seconds",$P(qqzz," ",2))
 I qtyp="PB" D  Q  ;@Dol 29.04.09 прогрессбар
 .D ..wC("TProgressBar",qwin_".FCBUT"_qqz,qwin_".T2",qqci_" "_qqo_" "_qqso,$S($P(qqzz," ",3)'="":$P(qqzz," ",3),1:qiii),$S('$P(qqzz," ",4):0,1:$P(qqzz," ",4)-1))
 .D:$P(qqzz," ",1)'="" ..wP(,"Enabled",1)
wwwwFCBUTqqw ;код понятия
 I $G(Vt(qqnump,9,"FCBUT",qqo,qqso,qiii))'="@" S qqw=$P($G(Vo(qqnump,qqo,0,qqso,qiii))," "),qqw=$S('$E(qqw):"ZZR",$E(qqw)=5:"Zs"_qqso_"c"_qiii,1:$E($P(qqw," "),2,31)) Q
 S qqw=..GetPar("X7tmpl",,qqo,qqso,qiii) S:qqw="" qqw="Zs"_qqso_"c"_qiii Q
]]></Implementation>
</Method>

<Method name="wwwwZXXadd">
<Description>
Arg1 - код объекта для блокировки перевывода скролбара</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Vo(qqnump,-1,669))'="",'$D(Vt(qqnump,669))!1 D  ;@Dol 26.08.06 обработка скролбара перемещений
 .I $D(Vt(qqnump,"SBM")) D qARM.wP(qwin_".SBM","Visible",Vt(qqnump,"SBM")) Q:'Vt(qqnump,"SBM")  ;@Dol 29.04.08 блокировка скролбара
 .I $G(Arg1)'="",$P(Vo(qqnump,-1,669)," ")=Arg1||(Arg1=-1) Q  ;@Dol 21.05.08 перевывод одного экземпляра
 .N qqoo,qqci,qqci1 S qqoo=$P(Vo(qqnump,-1,669)," "),qqci=$O(Vt(qqnump,"ZXXmove",qqoo,"")),qqci1=$S(qqci="":"",1:$O(Vt(qqnump,"ZXXmove",qqoo,""),-1))
 .S Vt(qqnump,669)=$S(qqci="":"",$D(Vt(qqnump,"ZXXmove",qqoo,qqci,1)):qqci,1:"")_" "_$S(qqci1="":"",$D(Vt(qqnump,"ZXXmove",qqoo,qqci1,2)):qqci1,1:"") ;qqci начала и конца, если первая видимая не первая в базе и последняя видимая не последняя в базе
 .K Vt(qqnump,"ZXXmove",qqoo)
 .I '$P(Vo(qqnump,-1,669)," ",3) D qARM.wP(qwin_".SBM","Visible",Vt(qqnump,669)'=" ") Q:Vt(qqnump,669)=" "  ;автоматическое управление появлением
 .D ..OnScroll(,)
 I '$D(Vt(qqnump,"ZXXadd")),'$D(Vt(qqnump,"ZXXmove")) Q:$Q "" Q
 N qqoo,qqci0,qqci1,qqci,qqo0 S qqci0=$G(Vc(qqnump)),qqo0=$$$CurObj
 I $G(Vo(qqnump,-1,669))="",$D(Vt(qqnump,"ZXXmove")) S qqoo="" F  S qqoo=$O(Vt(qqnump,"ZXXmove",qqoo)) Q:qqoo=""  D
 .S qqci="" F  S qqci=$O(Vt(qqnump,"ZXXmove",qqoo,qqci)) Q:qqci=""  D  K Vt(qqnump,"ZXXmove",qqoo,qqci)
 ..Q:'$D(Vc(qqnump,qqci))  S Vc(qqnump)=qqci,$$$CurObj=qqoo,Vc(qqnump,qqci,"@ZXXmove")=$D(Vt(qqnump,"ZXXmove",qqoo,qqci,2))+1 D ..wwww("@ZXXmove")
 S qqoo="" F  S qqoo=$O(Vt(qqnump,"ZXXadd",qqoo)) Q:qqoo=""  D
 .S qqci="" F  S qqci=$O(Vt(qqnump,"ZXXadd",qqoo,qqci)) Q:qqci=""  D
 ..I '$D(Vc(qqnump,qqci)) K Vt(qqnump,"ZXXadd",qqoo,qqci) Q
 ..S qqci1=$O(Vt(qqnump,"ZXXadd",qqoo,qqci))
 ..I qqci1'="",$E(qqci,1,$L(qqci)-2)=$E(qqci1,1,$L(qqci)-2),$D(Vc(qqnump,qqci1)) D  Q
 ...I Vt(qqnump,"ZXXadd",qqoo,qqci) K Vt(qqnump,"ZXXadd",qqoo,qqci) S Vc(qqnump)=qqci,$$$CurObj=qqoo D ..wwww("@ZXXadd") Q
 ...K Vt(qqnump,"ZXXadd",qqoo,qqci)
 ..I Vc(qqnump,qqci)[" " K Vt(qqnump,"ZXXadd",qqoo,qqci) S Vc(qqnump)=qqci,$$$CurObj=qqoo D ..wwww("@ZXXadd") Q
 ..I 'Vt(qqnump,"ZXXadd",qqoo,qqci) S Vc(qqnump)=qqci,Vt(qqnump,"ZXXadd",qqoo,qqci)=1,$$$CurObj=qqoo D ..wwww("@ZXXadd")
 S Vc(qqnump)=qqci0,$$$CurObj=qqo0 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="wwwwZnum">
<Description>
Перевывод счетчика строк объекта qqoz (обобщение @Znum) для текущего состояния экрана
Beg=1 отсчет от 1 (по умолчанию), -1 - отсчет от первого значения на экране, иначе от значения Beg </Description>
<Internal/>
<FormalSpec>qqoz:%Library.String,Beg:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqci,qqcz,qqozz S:$G(Beg)="" Beg=1 S qqci="" F  S qqci=$O(Vc(qqnump,qqci)) Q:qqci=""  Q:Vc(qqnump,qqci,0)=qqoz
 I qqci="" Q:$Q "" Q
 S qqozz=$S($E(qqoz)="v":$E(qqoz,3,255),1:qqoz)
 I Beg=-1 S Beg=$G(W("@Znum",qqozz,Vc(qqnump,qqci))) S:'Beg Beg=1
 K W("@Znum",qqozz) S W("@Znum",qqozz)=Beg-1 F  D:Vc(qqnump,qqci,0)=qqoz ..wwww("@Znum",1,,qqoz,Vc(qqnump,qqci)) S qqci=$O(Vc(qqnump,qqci)) Q:qqci=""
 Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="wzero">
<Description><![CDATA[
0->127,1; 127->127,127]]></Description>
<Internal/>
<FormalSpec>str:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N char 
 S char=1 F  S char=$F(str,$C(127),char) Q:'char  S $E(str,char-1)=$C(127,127),char=char+1
 S char=1 F  S char=$F(str,$C(0),char) Q:'char  S $E(str,char-1)=$C(127,1),char=char+1
 Q str
]]></Implementation>
</Method>

<Method name="zSet">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[ Q:$Q "" Q
]]></Implementation>
</Method>
</Class>


<Class name="%Library.qARM">
<IncludeCode>%qWORD</IncludeCode>
<Modified>0</Modified>
<ProcedureBlock>0</ProcedureBlock>
<Super>%Library.RegisteredObject</Super>
<TimeCreated>66787,41897.083401</TimeCreated>
</Class>


<Class name="%Library.qPrint">
<Modified>0</Modified>
<ProcedureBlock>0</ProcedureBlock>
<Super>%Library.RegisteredObject</Super>
<TimeCreated>66787,41897.106616</TimeCreated>

<Method name="CallPrint">
<Description>
Открыть окно настройки параметров печати</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 I '$D(^Q(1,"XView",Vs(qqnump,"Virt","XView"),"XPrint")) D qARM.Question("Создать Набор печати ",1,,"S ^Q(1,""XView"","""_qqc_""",""XPrint"","_0_")="""" D qPrint.CallPrint()") Q
 S Vs("par","Virt","XPrint")=0
 S Vo("par",-1,87)=1,Vo("par",-1,65)=2
 S Vo("par",-1,29)=",,0,10,,,,,,,,,2,,3,,5"
 S Vs("par",5)="XPrint"
 S Vo("par","XPrint",33)="^Q(1,""XView"","""_qqc_""",""XPrint"")"
 ;s Vs("par","Virt","XView")=qqc
 ;D qARM.OpenWindow(,,,0_" XPrint 1  XPrint","","XXXXNView")
 D qARM.OpenWindow(,,,0_" XPrint 1  XPrint","","XXXXNPrint")
 Q
]]></Implementation>
</Method>

<Method name="GetXMLglob">
<Description>
Получение XML файла из глобала:
первый индекс - идентификатор процесса либо  число (например $j) или код пользователя quser
следующие индексы: "код_объекта","код_экземпляра_объекта","код_понятия"="значение понятия"

например ^aaa($j,"код_объекта","код_экземпляра_объекта","код_понятия")="значение понятия"


Результат в ^qXMLi("идентификатор") b и в файле qwordG.xml
NoTrSp=1 - не преобразовывать "_" в пробел</Description>
<Internal/>
<FormalSpec>Glob:%Library.String,NoTrSp</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n f,glub
 n GlobStart
 n ii,PavXML,id
 
 s PavXML=$na(^mtempXMLg)
 k @PavXML@($j)
 
 s f=qWEB.ClientPath()_"qwordG.xml"
 s Glob=$na(@Glob)

 s ii=-1
 s @PavXML@($j,$i(ii))="<?xml version='1.0' encoding='windows-1251'?>"_$c(13,10)
 s @PavXML@($j,$i(ii))="<!--?xml-stylesheet type='text/xsl' href='qword.xsl'?-->"_$C(13,10)
 s @PavXML@($j,$i(ii))="<baseO>"_$c(13,10)

 s glub=0
 d ups(Glob)

 s @PavXML@($j,$i(ii))="</baseO>"_$c(13,10)

 s id=$tr($p($p(Glob,"(",2),")"),"""""","")
 k ^qXMLi(id) m ^qXMLi(id)=@PavXML@($j)
 ;Запись в файл
 d qARM.OpenIE("^qXMLi("""_id_""")",f,0)

 q

ups(GlobStart)
 n index,Globb,ind,GlobOld,Obj,aaa
 ;уроень вложенности узла
 s glub=$i(glub)

 ;определение текущего объекта для кодов
 s:'(glub#2) Obj=$tr($p($p(GlobStart,")"),",",$l($p(GlobStart,")"),",")),"""","")

 s index=""
 f  {
 s Globb=$p(GlobStart,")"),GlobOld=Globb,Globb=Globb_","""_index_""")"
 s ind="index=$o("_Globb_")"
 s @ind
 q:index=""

 s aaa=GlobOld_","""_index_""")"

 ;если объект или понятие
 i glub#2
 {
 ;если нет потомков то это - понятие и записываем значение
 s:($l($d(@aaa))=1) @PavXML@($j,$i(ii))="<"_index_">"_qW.CXML($s($g(NoTrSp)=1:$g(@aaa),1:$tr($g(@aaa),"_"," ")))_"</"_index_">"_$c(13,10)
 }
 ;если код экземпляра
 i '(glub#2)
 {
 ;открыть тег объектов
 s @PavXML@($j,$i(ii))="<"_Obj_">"_$c(13,10)
 ;код экземпляра данного объекта
 s @PavXML@($j,$i(ii))="<C>"_$tr(index,"_"," ")_"</C>"_$c(13,10)
 }	     

 ;если есть потомки то обходим потомков   
 d:($l($d(@aaa))=2) ups(aaa)
 ;закрыть тег объекта
 s:'(glub#2) @PavXML@($j,$i(ii))="</"_Obj_">"_$c(13,10)
 }
 s glub=glub-1

 q
]]></Implementation>
</Method>

<Method name="Print">
<Description>
Вызов печати по параметрам печати nump отображения viewpr</Description>
<Internal/>
<FormalSpec>viewpr:%String,nump:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
	s:$g(viewpr)="" viewpr=$p(qview," ")
	s:$g(nump)="" nump=1
	
	n userPath s userPath=qWEB.ClientPath()

	;q
	;Параметры печати
	i '$d(^Q(1,"XView",viewpr,"XPrint",nump)) d qARM.Message("Нет параметров печати "_nump) q
	
	;Формат файла
	n xp1
	s xp1=$g(^Q(1,"XView",viewpr,"XPrint",nump,"xp1"))
	i xp1="" d qARM.Message("Не указан формат файла!") q
	
	;Приемник печатной формы
	n xp2
	s xp2=$g(^Q(1,"XView",viewpr,"XPrint",nump,"xp2"))
	;i xp2="" d qARM.Message("Не указан приемник печатной формы!") q
	;Имя файла (глобала) результата
	n Xp3
	s Xp3=$g(^Q(1,"XView",viewpr,"XPrint",nump,"p3"))
	i Xp3="" d qARM.Message("Не указано имя файла!") q
	
	n nameFile s nameFile=Xp3
	s:$e(nameFile)="@" @("nameFile="_$e(nameFile,2,$l(nameFile)))
	D qARM.wM("-qARM","DelClientFile",userPath_nameFile)

	n userPathTemp
	n indf,xpODF,xp8,xp7,nameODF,Xp4,Xp11
	n tXML,tXSL
	n xp9,Xp5,Xp12
	n xp10,Xp6,Xp13
	n xpHTML,nameHTML,xmlPath,xslPath
	;формат ODF
	i xp1=1 {
		s userPathTemp=(userPath_"TempODF")
		D qARM.wM("-qARM","ForceDir",userPathTemp,"","")
		D qARM.wM("-qARM","DeleteFiles","*.*",userPathTemp)
		
		D qARM.wM("-qARM","ForceDir",userPathTemp_"\Configurations2","","")
		D qARM.wM("-qARM","ForceDir",userPathTemp_"\META-INF","","")
		
		;Обходим указанные файлы
		s indf=""
		f  {
			s indf=$o(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf))
			q:indf=""
			;Имя файла
			s xpODF=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"xpODF"))
			s nameODF=$g(^Q(1,"CxpODF",xpODF))
			;s:$e(nameODF)="@" @("nameODF="_$e(nameODF,2,$l(nameODF)))
			;Вариант файла
			s xp8=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"xp8"))
			;Тип источника
			s xp7=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"xp7"))
			;Тип источника XML файла
			s xp9=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"xp9"))
			;Тип источника XSL файла
			s xp10=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"xp10"))
			;Готовый файл
			i xp8=1 {
				;Если текст
				i xp7=1 {
					D:nameODF'="manifest.xml" qARM.wM("-qARM","FileFastSave",$na(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"TBxp1")),userPathTemp_"\"_nameODF)
					D:nameODF="manifest.xml" qARM.wM("-qARM","FileFastSave",$na(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"TBxp1")),userPathTemp_"\META-INF\"_nameODF)
				}
				;Если ссылка на файл
				i xp7=2 {
					;путь к файлу
					s Xp4=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"p4"))
					s:$e(Xp4)="@" @("Xp4="_$e(Xp4,2,$l(Xp4)))
					D:nameODF'="manifest.xml" qARM.wM("-qARM","CopyFile",Xp4,userPathTemp_"\"_nameODF)
					D:nameODF="manifest.xml" qARM.wM("-qARM","CopyFile",Xp4,userPathTemp_"\META-INF\"_nameODF)
				}
				;Если ссылка на текст
				i xp7=3 {
					;ссылка на глобал
					s Xp11=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"p11"))
					s:$e(Xp11)="@" @("Xp11="_$e(Xp11,2,$l(Xp11)))
					D:nameODF'="manifest.xml" qARM.wM("-qARM","CopyFile",Xp11,userPathTemp_"\"_nameODF)
					D:nameODF="manifest.xml" qARM.wM("-qARM","CopyFile",Xp11,userPathTemp_"\META-INF\"_nameODF)
				}	
			}
			;Если формируется из xml и xsl
			i xp8=2 {
				;ФАЙЛ XML
				;Если текст
				i xp9=1 {
					s xmlPath=$na(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"TBxp2"))
					s tXML="n"
					;D qARM.wM("-qARM","FileFastSave",$na(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"TBxp2")),userPathTemp_"\"_nameODF)
				}
				;Если ссылка на файл
				i xp9=2 {
					;путь к файлу
					s Xp5=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"p5"))
					s:$e(Xp5)="@" @("Xp5="_$e(Xp5,2,$l(Xp5)))
					s xmlPath=Xp5
					s tXML="f"
					;D qARM.wM("-qARM","CopyFile",Xp5,userPathTemp_"\"_nameODF)
				}
				;Если ссылка на текст
				i xp9=3 {
					;ссылка на глобал
					s Xp12=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"p12"))
					s:$e(Xp12)="@" @("Xp12="_$e(Xp12,2,$l(Xp12)))
					s xmlPath=$na(@Xp12)
					s tXML="n"
					;D qARM.wM("-qARM","CopyFile",Xp13,userPathTemp_"\"_nameODF)
				}
				
				;ФАЙЛ XSL
				;Если текст
				i xp10=1 {
					s xslPath=$na(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"TBxp3"))
					s tXSL="n"
				}
				;Если ссылка на файл
				i xp10=2 {
					;путь к файлу
					s Xp6=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"p6"))
					s:$e(Xp6)="@" @("Xp6="_$e(Xp6,2,$l(Xp6)))
					s xslPath=Xp6
					s tXSL="f"
				}
				;Если ссылка на текст
				i xp10=3 {
					;ссылка на глобал
					s Xp13=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileODF",indf,"p13"))
					s:$e(Xp13)="@" @("Xp13="_$e(Xp13,2,$l(Xp13)))
					s xslPath=$na(Xp13)
					s tXSL="n"
				}
				
				;Преобразование XSLT
				d ..Transform(,userPathTemp,nameODF,xmlPath,xslPath,tXML,tXSL)
			}
		}
		;Запаковываем
		;s ^A=""""_qARM("ClientPath")_"7za"" a -tzip """_userPath_xp3_""" -mx=9 """_userPathTemp_"\*"""
		D qARM.wM("-qARM","ModalExec",""""_qARM("ClientPath")_"7za"" a -tzip """_userPath_nameFile_""" -mx=9 """_userPathTemp_"\*""",1)
		
		;D qARM.wM("-qARM","ShellExecute",0,"open",userPath_nameFile,"swriter.exe","",1)
		;D qARM.wM("-qARM","ShellExecute",0,"open",userPath_nameFile,"","",1)
	}
	
	;формат HTML
	i xp1=2 {
		s userPathTemp=(userPath_"TempHTML")
		D qARM.wM("-qARM","ForceDir",userPathTemp,"","")
		D qARM.wM("-qARM","DeleteFiles","*.*",userPathTemp)
		
		;Обходим указанные файлы
		s indf=""
		f  {
			s indf=$o(^Q(1,"XView",viewpr,"XPrint",nump,"fileHTML",indf))
			q:indf=""
			;Имя файла
			s xpHTML=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileHTML",indf,"xpHTML"))
			s nameHTML=$g(^Q(1,"CxpHTML",xpHTML))
			;s:$e(nameODF)="@" @("nameODF="_$e(nameODF,2,$l(nameODF)))
			;Вариант файла
			s xp8=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileHTML",indf,"xp8"))
			;Тип источника
			s xp7=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileHTML",indf,"xp7"))
			;Готовый файл
			i xp8=1 {
				;Если текст
				i xp7=1 {
					d qARM.wM("-qARM","FileFastSave",$na(^Q(1,"XView",viewpr,"XPrint",nump,"fileHTML",indf,"TBxp1")),userPathTemp_"\"_nameHTML)
					s:nameHTML["xml" xmlPath=userPathTemp_"\"_nameHTML
					s:nameHTML["xsl" xslPath=userPathTemp_"\"_nameHTML
				}
				;Если ссылка на файл
				i xp7=2 {
					;путь к файлу
					s Xp4=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileHTML",indf,"p4"))
					s:$e(Xp4)="@" @("Xp4="_$e(Xp4,2,$l(Xp4)))
					D qARM.wM("-qARM","CopyFile",Xp4,userPathTemp_"\"_nameHTML)
					s:nameHTML["xml" xmlPath=userPathTemp_"\"_nameHTML
					s:nameHTML["xsl" xslPath=userPathTemp_"\"_nameHTML
				}
				;Если ссылка на текст
				i xp7=3 {
					;ссылка на глобал
					s Xp11=$g(^Q(1,"XView",viewpr,"XPrint",nump,"fileHTML",indf,"p11"))
					s:$e(Xp11)="@" @("Xp11="_$e(Xp11,2,$l(Xp11)))
					D qARM.wM("-qARM","CopyFile",Xp11,userPathTemp_"\"_nameHTML)
					s:nameHTML["xml" xmlPath=userPathTemp_"\"_nameHTML
					s:nameHTML["xsl" xslPath=userPathTemp_"\"_nameHTML
				}
			}
			;Если формируется из xml и xsl
			i xp8=2 {
				
			}
		}
		;Преобразование XSLT
		d ..Transform(,userPath,nameFile,xmlPath,xslPath)
	}
	
	
	;Открыть файл если пишем не в глобал и не файл
	;D:(xp2'=6)&(xp2'=7) qARM.wM("-qARM","ShellExecute",0,"open",userPath_nameFile,"","",1)
	
	;Если не указан приемник
	i xp2="" d qARM.wM("-qARM","ShellExecute",0,"open",userPath_nameFile,"","",1) q
	
	;xp2
	;1 - OpenOffice.org
	;2 - 
	;3 - Word
	;4 - Excel
	;5 - IE
	;6 - Global
	;7 - File
	
	;TOpenDocument
	;0 - MSIE 
    ;1 - MSWord 
    ;2 - MSExcel 
    ;3 - OpenOffice
    
    ;qARM("IsInstalled","MSExcel")
	;qARM("IsInstalled","MSWord")
	;qARM("IsInstalled","OpenOffice")
	
	i (xp2=3)&('$g(qARM("IsInstalled","MSWord"))) s xp2=1
	i (xp2=4)&('$g(qARM("IsInstalled","MSExcel"))) s xp2=1
	i (xp2=1)&('$g(qARM("IsInstalled","OpenOffice"))) {
		i nameFile[".odt" s xp2=3
		i nameFile[".ods" s xp2=4
	}
	
	;Не файл и не глобал
	D:(xp2'=6)&(xp2'=7) qARM.wM("OpenFile","Free"),qARM.wC("TOpenDocument","OpenFile",userPath_nameFile,"",$s(xp2=1:3,xp2=3:1,xp2=4:2,xp2=5:0,1:"")),qARM.wP("OpenFile","ReadOnly",0)
	
	;D:(xp2'=6)&(xp2'=7) qARM.wM("OpenFile","Free"),qARM.wC("TOpenDocument","OpenFile",userPath_nameFile,"",0)


	
	q
]]></Implementation>
</Method>

<Method name="Transform">
<Description>
Вызов XSLT преобразования
tXML,tXSL = "f" - файл
tXML,tXSL = "n" - узел</Description>
<Internal/>
<FormalSpec>ObjName,DirName,CurrentFilename,nameXML,nameXSL,tXML,tXSL</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
	s:$g(ObjName)="" ObjName="Transform"
	i '$d(qARM("TXMLProcessor",ObjName)) s qARM("TXMLProcessor",ObjName)="" D qARM.wC("TXMLProcessor",ObjName)
	D qARM.wM(ObjName,"Initialize",0,DirName) ; DirName - каталог, где формируются файлы
	
	D qARM.wM(ObjName,"New",CurrentFilename) ; создание нового документа, имя файла - CurrentFilename
	;d qARM.Log(DirName_"~"_CurrentFilename_"!!"_tXML_" "_nameXML_"---"_tXSL_" "_nameXSL)
	;s ^A($i(^A))=(DirName_"~"_CurrentFilename_"!!"_tXML_" "_nameXML_"---"_tXSL_" "_nameXSL)
	D qARM.wM(ObjName,$s($g(tXML)="f":"LoadXML",1:"GetXML"),nameXML,1)
	D qARM.wM(ObjName,$s($g(tXSL)="f":"LoadXSL",1:"GetXSL"),nameXSL,1)
	D qARM.wM(ObjName,"TransformNode")
	
	;D qARM.wM(,"GetXML",имя_узла) или D qARM.wM(,"LoadXML",имя_файла)
	;D qARM.wM(,"GetXSL",имя_узла) или D qARM.wM(,"LoadXSL",имя_файла)
	;D qARM.wM(,"TransformNodeToObject") или D qARM.wM(,"TransformNode")
	;D qARM.wM(,"AddFiles",узел)        ; выгрузка картинок
	q
]]></Implementation>
</Method>
</Class>


<Class name="%Library.qSYS">
<IncludeCode>%qWORD</IncludeCode>
<Modified>0</Modified>
<ProcedureBlock>0</ProcedureBlock>
<Super>%Library.RegisteredObject</Super>
<TimeCreated>66787,41897.141771</TimeCreated>

<Method name="AAVerObj">
<Internal/>
<ClassMethod>1</ClassMethod>
<FormalSpec>Job:%String,Arg1:%String,Arg2:%String,Arg3:%String,Arg4:%String,Arg5:%String,Arg6:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - (1) явное имя ^CacheTemp заменено на макрос $$$tmpGl
                       - (2) явная ссылка на ^CacheTemp("Error") и ^CacheTemp("Error",Job) заменена на refErr и refErrJob
    */
    s $ET="S "_$na($$$tmpGl)_"(""Error"",Job,$I("_$na($$$tmpGl)_"(""Error"",Job)))=$ZE Q:$Q """" Q  " ;15.12.2008 Kokarev (1), было: S $ET="S ^CacheTemp(""Error"",Job,$I(^CacheTemp(""Error"",Job)))=...
    ;;исправил sasha 20080514
    i $G(length)="" s qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qARM=##class(%TqARM).%New() d qSYS.BaseIni()
    n refErr,refErrJob s refErr=$na($$$tmpGl("Error")),refErrJob=$na(@refErr@(Job)) ;15.12.2008 Kokarev (2)
    s @refErr=Job,@refErrJob@($i(@refErrJob))="*** Запуск проверки "_$s($d(Arg4):"Объектов",1:"Понятий")_" *** "_$zdt($h,3) ;15.12.2008 Kokarev (2)
    i $d(Arg4) d qSYS.VerObj($g(Arg1),+$g(Arg2),+$g(Arg3),+$g(Arg4),+$g(Arg5),+$g(Arg6),$g(Job)) i 1
    e  d qSYS.VerWoc($g(Arg1),+$g(Arg2),+$g(Arg3),+$g(Job))
    s @refErrJob@($i(@refErrJob))="*** Проверка "_$s($d(Arg4):"Объектов",1:"Понятий")_" завершена *** "_$zdt($h,3) ;15.12.2008 Kokarev (2)
    s @refErr=Job_" "_$h ;15.12.2008 Kokarev (2)
    q
]]></Implementation>
</Method>

<Method name="APOPfon">
<Description>
Получение по почте файла журнала qjfon.xml (записывается в каталог базы Cache) и его 
восстановление в базу.
^QJErr - информация о состоянии процесса</Description>
<Internal/>
<FormalSpec>server:%Library.String,username:%Library.String,password:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    150802
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 k ^QJErr("ProgERRPOP")
 s $et="s ^QJErr(""ProgERRPOP"")=$ze"
 LOCK APOPfon:2 e  q
 #include %occOptions
 #include %occStatus
 ;s ^QJErr("StopReceive")=0
 n qvnumb,k,sender,mnum,getmail,getnum,execute,count
 new mailserver,status,from,to,date,subject,messagesize,hdrs,key,mailMsg,qerr,nummail,f,num,byt,period,qWEB,qSYS,qW,qARM
 n timereceive
 S qWEB=##class(%qWEB).%New()
 S qSYS=##class(%qSYS).%New()
 S qW=##class(%qWORD).%New()
 S qARM=##class(%TqARM).%New()
 s period=10               //// Период опроса почтового сервера
 ;k ^QJErr("Receive")
start1 
 i $g(^Q(1,"XBase",0,"XFResivJrn"))=0 s ^QJErr("Receive")="ОСТАНОВЛЕН процесс приема писем. Для запуска процесса установите флаг"  h 5 g start1

 s ^QJErr("Receive")="ЗАПУЩЕН процесс приема писем. Для остановки процесса снимите флаг"

 ;I $G(server)="" S server=$G(^Q(1,"XBase",0,"Xsmtppopadr")) S:server="" server=$G(^Q(1,"XBase",0,"Xsmtpadr"),"132.32.32.240")
 ;I $G(username)="" s username=$P($G(^Q(1,"XBase",0,"Xsmtpuser"),"dol dol")," ")
 ;I $G(password)="" s password=$P($G(^Q(1,"XBase",0,"Xsmtpuser"),"dol dol")," ",2)
 ;D qARM.Message(server_" "_domadr_" "_password)
 ;s server="132.32.32.123"
 ; s domadr="PavelPF@sparm.com"
 ;s password="****"
 //////////////////////////

 ; display mail but don't delete from mailbox
 s f=0
 ;s qWEB=##class(%qWEB).%New()
 ;s qWORD=##class(%qWORD).%New()

 set mailserver=##class(%Net.POP3).%New()
 set mailserver.AttachDir=$zu(168)
 set mailserver.Debug=0
 set mailserver.StoreAttachToFile=1

 ;;;write !,"Calling Connect"
 set status=mailserver.Connect(server,username,password)
 if $$$ISERR(status) do DecomposeStatus^%occSystem(status,.err) s ^QJErr("Receive","journal")=$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1)_" Ошибка соединения "_err(err) h 10 g start1
 ;write !,"Calling FetchMessage"
 d mailserver.GetMailBoxStatus(.num,.byt)
 S qerr="писем - "_num_" объем -"_byt

 ;Если нет сообщений
 s:$g(^QJErr("Receive","journal"))="" ^QJErr("Receive","journal")="Время последнего восстановления: "
 i num=0  {
 s timereceive=$s($g(timereceive)="":$p(^QJErr("Receive","journal"),"Время последнего восстановления: ",2),1:timereceive)
 D mailserver.%Close() s ^QJErr("Receive","journal")="Нет писем "_$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1)_" Время последнего восстановления: "_$g(timereceive)  h 10 g start1 
 }

 ;Прием и обработка XML если в теме письма есть строка "qWJrnXML"
 f nummail=1:1:num  
 {               
 set status=mailserver.FetchMessage(nummail,.from,.to,.date,.subject,.messagesize,.hdrs,.mailMsg,0)
 if $$$ISERR(status) do DecomposeStatus^%occSystem(status,.err) s ^QJErr("Receive","journal")=$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1)_" Ошибка приема"_i_"-го письма "_err(err) D mailserver.%Close() h 10 g start1
 ;write !,"from="_from
 ;write !,"to="_to
 ;write !,"date="_date
 ;write !,"subject="_subject
 ;write !,"messagesize="_messagesize

 ;s ^QJErr("journal",nummail)=num
 ;w nummail_" "_subject,"vvv:"_subject["qWJrnXML",!
 i $P(subject,"|")="qWJrnXML"
 {
 s f=f+1
 k $$$tmpGl($j,"1") ;15.12.2008 Kokarev
 ;i $P(subject,"|",3)=0  k ^getmail($P(subject,"|",2))   ;если первое письмо, то убить закодированное поддерево для данного сендера
 i $P(subject,"|",3)=0 k ^QJHistory("Receive",$P(subject,"|",2)),^Security("Receive",$P(subject,"|",2))

 ;s qin=$Na(^getmail($P(subject,"|",2),$P(subject,"|",3)))
 ;d FileLoadf($zu(168)_"qjfon.xml",qin)        ;запись из файла в массив ^getmail(имя отправителя,номер письма)

 s qin=$Na(^QJHistory("Receive",$P(subject,"|",2),$P(subject,"|",3),"xmlEncr"))
 
 d qSYS.FileLoad($zu(168)_"qjfon.xml",qin)        ;запись из файла в массив ^QJHistory("Receive",имя отправителя,номер письма,"xmlEncr")

 D mailserver.DeleteMessage(nummail) ;удалить письмо(пометить)
 }
 D mailMsg.%Close()
 }

 D mailserver.QuitAndCommit()  ;удалить помеченные
 D mailserver.%Close()



 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;Восстановление журнала из массива

 s sender="",execute=""  f  {
 s sender=$O(^QJHistory("Receive",sender)) q:sender=""

 ;выявление полученных, отсечение недошедших писем (если пришли не по порядку)
 s mnum="",getmail=""
 f  {
 s mnum=$O(^QJHistory("Receive",sender,mnum))
 q:mnum=""
 i (mnum=(+$O(^QJHistory("Receive",sender,mnum),-1)+1))!(mnum=0) {s getmail=mnum }
 else {s ^QJErr("Receive","journal",sender,"status")="!!! Жду "_(+$O(^QJHistory("Receive",sender,mnum),-1)+1)_"-ое письмо" q}
 ;d qARM.Message(mnum_"="_(+$O(^getmail(sender,mnum),-1)+1))
 }

 ;d qARM.Message(getmail) 

 ;определение последнего восстановленного письма
 s getnum=$O(^Security("Receive",sender,""),-1)
 i getnum="" s getnum=0
 ;s ^pav("getnum")=getnum,^pav("getmail")=getmail
 ;восстановление от последнего восстановленного до последнего вовремя полученного
 s count=0  f mnum=getnum:1:getmail            {
 s count=count+1
 s qin=$Na(^QJHistory("Receive",sender,mnum,"xmlEncr"))         
 s qrefSec=$Na(^Security("Receive",sender,mnum))
 i mnum=0  {
 s @qrefSec@("key")="70D1BC8E ED1F7773 0A7BEF8F E945CC09 69E1B707 9B40B226 EA29A1C0 515244F2"
 s @qrefSec@("sbox")="9F32A807 1C546DEB C3DB1475 09A62EF8 E81536C2 9BA740FD 29C36B87 1A0FED54 816CD9BA 452E3F07 CEB0A89F 2745D361 2A83B09D 46C17F5E 78631D4F E0B2AC95"
 }

 k ^qout
 s k=qSYS.SECUEncrLet(qin,"^qout",@qrefSec@("key"),@qrefSec@("sbox"),.vout)

 i k<0 {s ^QJErr("Receive","err",sender)="НЕОБХОДИМА ПОВТОРНАЯ ОТПРАВКА!! Невозможно расшифровать k="_k_" Письмо "_mnum_" Время "_$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1)
 k ^Security("Receive",sender,(mnum+1),"key"),^Security("Receive",sender,(mnum+1),"sbox")
 s mnum=getmail+1 ;выйти из цикла, далее не восстанавливать письма, ждать повторного получения
 }
 else   {
 k ^QJErr("Receive","err",sender)       
 s qrefSec=$Na(^Security("Receive",sender,(mnum+1)))
 
 ;misuno 20080806
 ;s @qrefSec@("key")=vout("key"),@qrefSec@("sbox")=vout("sbox")
 s @qrefSec@("key")=qSYS.SECxInsSpace(vout("key"),8),@qrefSec@("sbox")=qSYS.SECxInsSpace(vout("sbox"),8)
 
 n refTmpGl s refTmpGl=$na($$$tmpGl($j,"1")) k @refTmpGl ;15.12.2008 Kokarev: refTmpGl - ссылка на временный массив; было: ^CacheTemp($j,"1")
 s ^QJErr("Receive","journal",sender,"status")="Запись ^qout в "_refTmpGl d qWEB.LoadJrnXML(0,"^qout",refTmpGl)
 ;;misuno 20080806 k ^CacheTemp($j,"1") s ^QJErr("Receive","journal",sender,"status")="Запись ^qout в ^CacheTemp..." d qWEB.LoadJrnXML(0,"^qout","^CacheTemp("_$j_",""1"")")
 s ^QJErr("Receive","journal",sender,"status")="Восстановление журнала из "_refTmpGl_" в базу... Письмо "_mnum d qW.rJrn($na(@refTmpGl@("XJrn")),1) s ^QJErr("Receive","journal",sender,"status")="Восстановление журнала успешно завершено! Письмо: "_mnum_" Время "_$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1)
 ;;;misuno 20080806 s ^QJErr("Receive","journal",sender,"status")="Восстановление журнала из ^CacheTemp в базу... Письмо "_mnum d qW.rJrn("^CacheTemp("_$j_",""1"",""XJrn"")",1) s ^QJErr("Receive","journal",sender,"status")="Восстановление журнала успешно завершено! Письмо: "_mnum_" Время "_$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1)
 }
 }  ;закрытие цикла от последнего восстановл до последн вовремя получ
 s execute=+(execute)+count             ;количество обработанных писем


 }       ;закрывает сендера
 s:$d(k) timereceive=$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1)
 s timereceive1=$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1)

 s ^QJErr("Receive","journal","lastconnect")=$S(f'=0:"Получено "_f_" Обработано "_execute_" "_timereceive1,1:"Нет писем с журналом "_timereceive1) h period g start1

 q
]]></Implementation>
</Method>

<Method name="ASMTPfon">
<Description>
Отправка по почте файла журнала qjfon.xml (записывается в каталог базы Cache).
Слой журнала из ^Q(1,"XBase",0,"Xsmtplast") - Последний ID журнала


^QJErr - информация о состоянии процесса
Для включения журналирования: установить флаг в Проводник/База "Включить журналирование"
^Security - история ключей кодирования
^QJHistory("Send",от,номер письма,"xml"),^QJHistory("Send",от,номер письма,"xmlEncr") - 
история отправленных писем: xml-журнал и закодированный xml.
Удаление ^Security приведет к обнулению счетчика № письма и  потере данных в ^QJHistory("Send",от)</Description>
<Internal/>
<FormalSpec>smtpserver:%Library.String,from:%Library.String,to:%Library.String,label:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 //110702
 k ^QJErr("ProgERRSMTP")
 s $et="s ^QJErr(""ProgERRSMTP"")=$ze"
 LOCK ASMTPfon:2 e  q
 #include %occOptions
 #include %occStatus
 ;s ^QJErr("StopSend")=0
 N subj,s,m,status,period,qWEB,qSYS,qW,qARM
 n k,sb,tmp,qvovka,qvnumb,qin,qrefSec,qout,tmp
 S qWEB=##class(%qWEB).%New()
 S qSYS=##class(%qSYS).%New()
 S qW=##class(%qWORD).%New()
 S qARM=##class(%TqARM).%New()
 s period=$G(^Q(1,"XBase",0,"Xperiodsmtp"),10)     ///  Период опроса почтового сервера
 ;k ^QJErr("Send")
start 

 i $g(^Q(1,"XBase",0,"XFSendJrn"))=0 s ^QJErr("Send")="ОСТАНОВЛЕН процесс отправки писем. Для запуска процесса установите флаг"  h 2 g start 

 s ^QJErr("Send")="ЗАПУЩЕН процесс отправки писем. Для остановки процесса установите снимите флаг"

 ;I $g(smtpserver)="" s smtpserver=$G(^Q(1,"XBase",0,"Xsmtpadr"),"132.32.32.240")
 ;I $g(from)="" s from=$G(^Q(1,"XBase",0,"Xsmtpfrom"),"pavelpf@sparm.com")
 ;I $g(to)="" s to=$G(^Q(1,"XBase",0,"Xsmtpto"),"pavelpf@sparm.com")
 ;s from="olgaas@sparm.com"
 ;s to="pavelpf@sparm.com"

 s subj="qWJrnXML|"_from_"|"
 ;s subj="ooo"
 i '$d(^QJ) s ^QJErr("Send","journal")="Нет журнала "_$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1),^Q(1,"XBase",0,"Xsmtplast")="" h 10 g start 
 s beg=$G(^Q(1,"XBase",0,"Xsmtplast")) S:beg="" beg=($O(^QJ(1,"XJrn",""))-1)
 S end=$O(^QJ(1,"XJrn",""),-1)
 I beg=end||(end<beg)||('$D(^QJ(1,"XJrn",beg))&&beg'=0) s ^QJErr("Send","journal")="Нет записей журнала "_$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1) h 10 g start 

 //s beg=$G(^Q(1,"XBase",0,"Xsmtplast"))  I beg=""||('$D(^QJ(1,"XJrn",beg))) S beg=($O(^QJ(1,"XJrn",""))-1)
 //S end=$O(^QJ(1,"XJrn",""),-1)
 //I beg=""||(end<beg) s ^QJErr("Send","journal")="Нет записей журнала"_$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1) h @period g start 

 set s=##class(%Net.SMTP).%New()
 ;S s.Debug=1
 /* было до 20080806
 set s.smtpserver=smtpserver
 ;set s.timezone="-0400"   
 set m=##class(%Net.MailMessage).%New()
 set m.From=from
 do m.To.Insert(to)
 */
 
 //misuno 20080806
 set auth=##class(%Net.Authenticator).%New() ;use default authentication list
 set login=$P($G(^Q(1,"XBase",0,"Xpopuser"))," ")
 set password=$P($G(^Q(1,"XBase",0,"Xpopuser"))," ",2)
 set auth.UserName=login
 set auth.Password=password
 set auth.MechanismList="LOGIN"
 set s.authenticator=auth
 set s.smtpserver=smtpserver
 ;set s.timezone="-0400"   
 set m=##class(%Net.MailMessage).%New()
 set m.From=from
 f i=1:1 s toi=$p(to,",",i) q:toi=""  do m.To.Insert(toi)
 ;do m.To.Insert(to)
 
 ;write !,"s.port="_s.port
 ;write !,"s.localhost="_s.localhost

 set m.Subject=subj

 ///////////////////////////////////////////////////////////
 ;Кодирование
 s qin="qvovka",qout="out" k @qin,@qout
 d qWEB.GetJrnXML(0,qin,beg,end) ;k ^vol m ^vol=@qin

 s qvnumb=+$O(^Security("send",from,""),-1),qrefSec=$Na(^Security("send",from,qvnumb)) ;номер письма и ссылка на массив где хранятся ключи
 ;если письмо первое задаем начальные ключи
 i qvnumb=0  d
 .s @qrefSec@("key")="70D1BC8E ED1F7773 0A7BEF8F E945CC09 69E1B707 9B40B226 EA29A1C0 515244F2"
 .s @qrefSec@("sbox")="9F32A807 1C546DEB C3DB1475 09A62EF8 E81536C2 9BA740FD 29C36B87 1A0FED54 816CD9BA 452E3F07 CEB0A89F 2745D361 2A83B09D 46C17F5E 78631D4F E0B2AC95"
 set m.Subject=subj_qvnumb                          ;добавление номера письма к теме


 ///История
 i qvnumb=0 k ^QJHistory("Send",from)
 m ^QJHistory("Send",from,qvnumb,"xml")=@qin
 //


 ;кодирование @qin и результат в @qout
 d EncrLet(qin,qout,@qrefSec@("key"),@qrefSec@("sbox"),m.Subject,qvnumb,.tmp)
 m ^QJHistory("Send",from,qvnumb,"xmlEncr")=@qout               ///История
 d FileSave("qjfon.xml",qout)  ;запись в файл
 /////////////////////////////////////////////////////////////

 ;d qWEB.GetJrnXML(2,qARM("ClientPath")_"qj.xml",beg,end)    /////Запись текста в файл
 ;s status=m.AttachFile(qARM("ClientPath"),"qj.xml")
 ;d qWEB.GetJrnXML(2,$zu(168)_"qjfon.xml",beg,end)    /////Запись текста в файл


 s status=m.AttachFile($zu(168),"qjfon.xml")


 ;w !,"Соединение с сервером и отправка сообщений..." 
 s ^QJErr("Send","journal")="Соединение с сервером и отправка сообщений..."_$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1)
 set status=s.Send(m)
 if $$$ISERR(status) do DecomposeStatus^%occSystem(status,.err) do m.%Close() do s.%Close() s ^QJErr("Send","journal")=$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1)_" Ошибка отправки "_err(err) h 10 g start
 S ^Q(1,"XBase",0,"Xsmtplast")=end
 do m.%Close()
 do s.%Close()
 ;Сохранение ключей
 s qvnumb=qvnumb+1,qrefSec=$Na(^Security("send",from,qvnumb)),@qrefSec@("key")=tmp("key"),@qrefSec@("sbox")=tmp("sbox")

 s ^QJErr("Send","journal","last")="Последнее отправленное письмо "_$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1)_" № "_(qvnumb-1)
 s ^QJErr("Send","journal")="Журнал успешно отправлен "_$ZDATE($HOROLOG,2)_" "_$ZTIME($PIECE($HOROLOG,",",2),1)  h period g start

 q

ZJ(e)
 if $L(e<4) s e=$Tr($J("",4-$L(e))," ",0)_e
 q e     
shiftL(e,n)
 n t,i
 for i=1:1:n s t=$Zboolean(e,$Zhex("80000000"),1),e=$Zboolean(e,$Zhex("7FFFFFFF"),1),e=e*2 i t>0 s e=e+1
 q e
s32bToInt(e)
 q ((256**3)*$A($E(e,1)))+((256**2)*$A($E(e,2)))+((256)*$A($E(e,3)))+$A($E(e,4))
IntTo32b(d)
 n t,i,e s d=$TR($J($Zhex(d),8)," ",0),e=""
 f i=1:2:8 s e=e_$C($Zhex($E(d,i,i+1)))
 q e
GetKey(d)   
 n k,e,i,t,b,o,dz s k=qSYS.Encrypt(d) 
 f i=1:1:12 s k=k_$C($R(256))
 s k=$$BsToHs(k),k=$$InsSpace(k,8)
 s dz(0)="" f i=1:1:32 s dz(0)=dz(0)_$C($R(256)) //$Tr($J($Zhex($A($R(256))),2)," ",0)
 s b=..SECGetSbox() 
 d ..SECg28147("dz","o",k,b,1)
 s k=$$BsToHs(o(0)),k=$$InsSpace(k,8)
 q k
padd(e)
 s:$L(e)<8 e=$Tr($J(e,8)," ",0) q e
FileSave(file,e)
 n i o file:"nw" u file for i=0:1:$O(@e@(""),-1) w @e@(i)
 c file q
FileLoad(file,e)
 n t o file:("RF":32000):0
 u file f i=0:1  r t q:$zeof<0  s @e@(i)=t
 c file q        
ResRand(k,n)
 n t
 for i=0:1:(k-1) s d(i)=0
 for n=1:1:n s t=$R(k),d(t)=d(t)+1
 q
BsToHs(d)
 n i,e s e="" f i=1:1:$L(d) s e=e_$Tr($J($Zhex($A($E(d,i))),2)," ",0)
 q e
InsSpace(d,k)
 n i,n,e s n=$L(d),e="" f i=1:k:n s e=e_$E(d,i,i+k-1) i i<(n-k) s e=e_" "
 q e
Signr(d,f,t,n)
 //d -data; f -from; t- time; n -nuber of letter;
 s @d@(0)=$P($H,",")_":"_$P($H,",",1)_f_":"_$TR($J("",20)," ",0)_":"
EncrLet(dt,do,key,sbox,f,z,o);
 //dt -inp data; do - outp data; f -from; z -number; o - new keys
 n t,i,n,s,p s n=0,t=do k @do s do=t
 s s=$$GetKey(dt),p=..SECGetSbox()
 s t=1+$O(@dt@(""),-1),@dt@(t)="::"_$Zhex(+$P($H,","))_":"_$Zhex(+$P($H,",",2))_":"_f_":"_$Tr(s_":"_p_":"," ","")_z_":"
 f i=0:1:t s n=n+$L(@dt@(i))
 s i=n\8*8-n i i<0 s @dt@(t)=@dt@(t)_$J("",0-i)
 s n=qSYS.Encrypt(dt),n=$$BsToHs(n),$P(@dt@(t),":",2)=n
 d ..SECg28147(dt,do,key,sbox,1) s o("key")=s,o("sbox")=p
 q
UEncrLet(dt,do,key,sbox,o)
 n t,x,y,n,k
 d ..SECg28147(dt,do,key,sbox,-1)
 s n=$O(@do@(""),-1) i n="" q -2
 s t=$Re(@do@(n)) i $L(t,":")<8 q -3
 s k=$L($Re($P(t,":")))+2
 s x=$Re($P(t,":",8)),$P(t,":",8)="" s @do@(n)=$Re(t)
 s y=$$BsToHs(qSYS.Encrypt(do))
 s t=$Re($P(t,":",2,8)),@do@(n)=$E(@do@(n),1,$L(@do@(n))-$L(t)-k)
 s o("number")=$P(t,":",7),o("from")=$P(t,":",4),o("key")=$P(t,":",5),o("sbox")=$P(t,":",6),n=$Zhex($P(t,":",2))_","_$Zhex($P(t,":",3)),o("data")=$Zd(n),o("time")=$Zt(n)
 q:x=y 0 q -1
 q 1
]]></Implementation>
</Method>

<Method name="Au">
<Description>
Проверяет Arg1 (не задан - quser) на авторов qWORD</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ Q $C(32,100,114,111,119,113,32,102,100,106,99,109,57,55,32)[(" "_$G(Arg1,$G(quser))_" ")
]]></Implementation>
</Method>

<Method name="BaseIni">
<Description>
           Инициализация параметров базы.</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    ВНИМАНИЕ: при вызове методов TqARM: wM(),wP(), wC() необходимо выполнять анализ переменной length: i $D(length) d ...
              метод используется для инициализации  в фоновом процессе, в котором length - не определена
    22.01.2009 Kokarev - добавлен анализ переменной length при вызове D qARM.wM("-qARM","ForceDir",qARM("WorkPath"),"","")
    */
 S qqllang=$G(^Q(1,"XBase",0,"xLang")) ;список поддерживаемых языков (через пробел) qqlang
 S qqXBaseX5280=$G(^Q(1,"XBase",0,"XBaseX5280")) ;глобальное условие темпоральности
 S qqXBaseX527=$G(^Q(1,"XBase",0,"XBaseX527")) ; глобальное условие вывода
 S qqXBTempor=$G(^Q(1,"XBase",0,"XBTempor")) ; Описание темпоральности
 S qqXBColor=$G(^Q(1,"XBase",0,"XBColor"),-2147483633) ;Win14606046) ;цвет фона по умолчанию
 
 S qqXBREnew=+$G(^Q(1,"XBase",0,"XBREnew")) ; Использование навесного RichEdit как редактора текста. @sas 20091006
 
 s:$e(qqXBColor)="@" @("qqXBColor="_$e(qqXBColor,2,$l(qqXBColor)))  ;@Pav 23.03.2009
 S qqXBOpenDoc=$G(^Q(1,"XBase",0,"XBOpenDoc"),0) ; редактор текста sas 20090623
 
 ;@pav
 ;Включить словарь локализации
 s XBLocal=$g(^Q(1,"XBase",0,"XBLocal"))
 ;Включить режим заполнения словаря локализации
 s XBfLocal=$g(^Q(1,"XBase",0,"XBfLocal"))
 ;Язык локализации
 s XLocal=$g(^Q(1,"XBase",0,"XLocal"))
 ;
 
 ;;;K qqXBDate S:+$G(^Q(1,"XBase",0,"XBDate")) qqXBDate=1 ;@Dima 01.04.08 - не используется
 K qqXBprwr S:+$G(^Q(1,"XBase",0,"XBprwr")) qqXBprwr=1
 K qqXBWStyle S:+$G(^Q(1,"XBase",0,"XBWStyle")) qqXBWStyle=1
 ;;;;;K qqXBNoXP S:+$G(^Q(1,"XBase",0,"XBNoXP")) qqXBNoXP=1
 K qqWinDos S:+$G(^Q(1,"XBase",0,"XFVDos")) qqWinDos=1
 
 K qqXFJUser S:+$G(^Q(1,"XBase",0,"XFJUser")) qqXFJUser=1
 ;misuno 20080806
 K qqXFJRUser S:+$G(^Q(1,"XBase",0,"XFJRUser")) qqXFJRUser=1
 
 K qqLastWin S:$G(^Q(1,"XBase",0,"XBLastWin")) qqLastWin=1
 
 K qqXBpre S:+$G(^Q(1,"XBase",0,"XBpre")) qqXBpre=1
 K qTRAN S:+$G(^Q(1,"XBase",0,"XBTRAN")) qTRAN=1 ;@Vol&Sasha
 K qqXBNHelp S:+$G(^Q(1,"XBase",0,"XBNHelp")) qqXBNHelp=1
 ;s qqXBPrttoOOW=+$G(^Q(1,"XBase",0,"XBPrttoOOW")) ;sas 20090630
 s qqXBPrttoOOW=+$S($D(qARM("UseOpenOfficeDefault")):$G(qARM("UseOpenOfficeDefault")),1:$G(^Q(1,"XBase",0,"XBPrttoOOW"))) ;sas 20090630 ;dima 20090720
 
 N qqp F qqp="X155","X150","X151","X152","X177","X1664","X1194","XBp","XBf","XBadd","XBdel","XBNfon","XBz","XB1720","XB2help","XBRDop","XB186","XB159","XBMesTime","XBFws","XBwids","XBupdate","xBrefrExprMode","XBrefrExpr","XBAllDlgUpd","XBErrVar","XBErrETN","XBErrMet","XBnoFK","XB11990","XBOpenDoc","XBwsize","XB11992","XBPrtReadOnly","XBPrtUniqFile","XBPrtDelFiles","XBPrtKeepDays" K @("qq"_qqp) S:$TR($G(^Q(1,"XBase",0,qqp)),", ")'="" @("qq"_qqp_"=^Q(1,""XBase"",0,qqp)")
 
 ; dima 20090112
 ;i $G(qARM("Password"))'="" D ..UpdFiles() q:$G(updfExitFlag)
 i $G(qARM("Password"))'="" s qARM("FUpdLog",$I(qARM("FUpdLog")))="Логин не пустой: да" D ..UpdFiles() q:$G(updfExitFlag)
 e  s qARM("FUpdLog",$I(qARM("FUpdLog")))="Пустой логин - нет обновления"
 
 i qARM.ProjVerNotOlder(4,10,5,15) s qARM("PROTv8")=1 ; @dima 20100630 8 версия протокола - постоянно
 
 ; Создание рабочего каталога и переменной qARM("WorkPath") с его именем  @dima 20081029
 S qARM("WorkPath")=$S($G(^Q(1,"XBase",0,"XFuprof")):$G(qARM("SysVars","USERPROFILE"))_"\qWORD-XML\",1:$G(qARM("ClientPath"))_$G(qARM("ComputerName"))_"\")
 i $d(length) D qARM.wM("-qARM","ForceDir",qARM("WorkPath"),"","") ; 22.01.2009 Kokarev

 I $D(length),$G(qqXBMesTime) D qARM.wP("-qARM","EditMsgTime",qqXBMesTime*1000)
 I $D(length),$G(^Q(1,"XBase",0,"xBGrSt"))'="" D qARM.wP("-qARM","GradientStyle",^Q(1,"XBase",0,"xBGrSt")) ;@Dima@Dol 21.07.10
 
 ; tdv 23.07.2008 - Режим обновления пересчитываемых выражений
 i $get(qqxBrefrExprMode)="" s qqxBrefrExprMode=1
 D:$D(length) qARM.wP("-qARM","DataLinkMode",qqxBrefrExprMode)  
 ; tdv 18.03.2008 - Период обновления пересчитываемых выражений
 i $s($g(qqXBrefrExpr)="":1,qqXBrefrExpr<0:1,1:0) s qqXBrefrExpr=-1
 D:$D(length) qARM.wP("-qARM","DataLinkUpdatePeriod",qqXBrefrExpr)
 
 I $G(qqXBRDop)'="",$D(length) D  ;ресурсы кнопок дополнительной панели
 .I '$D(qwin("TBHImages")) S qwin("TBHImages")=1 D qARM.wC("TCustomImageList","TBHImages"),qARM.wP(,"Width",16),qARM.wP(,"Height",16)
 .F qqp=1:1:9 S:$P(qqXBRDop," ",qqp)="" $P(qqXBRDop," ",qqp)="R,367"
 .D qARM.wM("TBHImages","Fill",$TR(qqXBRDop," ",$C(13)))
 D:$D(length) qARM.wP("-qARM","Use3DToolbars",'$G(^Q(1,"XBase",0,"XBNoRlf"))) ;@dima градиент на тулбарах
 I $D(length),$G(qqXBFws) D qARM.wP("-qARM","UseClientSize",1) ;@Dol 25.01.08 -надо бы всегда, но для старых версий qARMProj
 S qqlang=$S(qqllang="":1,1:$P(qqllang," ")) ;основной язык (Q(qqlang, ссылка на словари)
 S qqRES=1_(+$G(^Q(1,"XBase",0,"xPict"),0))_(+$G(^Q(1,"XBase",0,"XFPict"),0))_(+$G(^Q(1,"XBase",0,"XFPbut9"),0)) ;????XFPbut9 брать ресурсы из файлов или массивов (0,1). Байт 1 - qqP0, 2 - qqP1
 S qqP1=$G(^Q(1,"XBase",0,"XPas")) ;ссылка на директорию картинок ячеек дерева экземпляров
 S qqWEB=+$G(^Q(1,"XBase",0,"XWeb")) ;работа через WebLink
 D:$G(qWEB)'="" qWEB.Print2SetGlb()  ; установка глобальных параметров печати
 Q:$Q "" Q
 ;;;??? $D(length) - индикация инициалзации протокола
]]></Implementation>
</Method>

<Method name="BasePar">
<Description>
Наследование параметров вывода из описания базы 
par - параметр "X155","X150","X151","X152","X177","X1664"
value - текущее его значение в описании отображения
если задан par0, то наследование от его</Description>
<Internal/>
<FormalSpec>par:%Library.String,value:%Library.String,par0:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S par=$S($D(par0):par0,1:$G(@("qq"_par))) Q:$TR(par,", ")="" $TR(value,"*")
 N pari,parz F pari=1:1:$L(par,",") S parz=$P(par,",",pari) I parz'="",$P(value,",",pari)="" S $P(value,",",pari)=parz
 Q $TR(value,"*") ;@Dol 18.10.05 * - оставить умолчание
]]></Implementation>
</Method>

<Method name="BrCall">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$D(qqbut) N qqbut S qqbut=1+$G(Arg1)
 I $$$CurObj="XView" D  Q:$Q "" Q
 .I qqbut=2 D  Q
 ..I '$G(Arg1),$G(W("Zadm")) D qARM.QuestionM("Описание окна "_qqc_"~Дизайнирование окна "_qqc,,,"D qSYS.BrCall(1)","D qARM.OpenWindow(1,,,,,"""_qqc_""")") Q  ;@Dol 11.09.07 
 ..I '$G(^Q(1,"XBase",0,"XBNDes")) D qARM.OpenWindow(,,,qqc_" XView  ^Q(1)",,"XXXXView") Q
 ..S Vs("par",3,"XPrint")=1,Vs("par",1,"XPrint")=1,Vs("par",3,"XMenu")=1,Vs("par",1,"XMenu")=1,Vs("par",1,"XQuest")=1,Vs("par",3,"XTabs")=1,Vs("par",1,"XTabs")=1
 ..S Vs("par",3,"CxObj")=1,Vs("par",1,"CxObj")=1,Vs("par",3,"Xo364")=1,Vs("par",1,"Xo364")=1
 ..S Vo("par",-1,29)=",,0,10,,,,,,,,,2,,3,,5" ;,,01,0
 ..D qARM.OpenWindow(,,,qqc_" XView",,"XXXXNView")
 .S Vo("par",-1,73)="",Vo("par",-1,89)=0 ;@dol 19.11.03 блокировка выхода с выбором и наследования релевантных
 .D qARM.OpenWindow(,,,,,qqc) Q
 I $$$CurObj="CxObj" D  Q:$Q "" Q
 .;???I $G(^Q(1,"XBase",0,"XBNDes"))=1 S Vs("par",5)="CxObj"
 .I qqbut=2 D qARM.OpenWindow(,,,qqc_" CxObj",,"XXXCxObj") Q
 .D qARM.OpenWindow(,,,,,"XXXsysO"_qqc)
 I $$$CurObj="XQuery" D  Q:$Q "" Q
 .;????I $G(^Q(1,"XBase",0,"XBNDes"))=1 S Vs("par",5)="XQuery"
 .I qqbut=2 D qARM.OpenWindow(,,,qqc_" XQuery",,"XXXXQueryc") Q
 .I $G(^Q(1,"XQuery",qqc,"XQView"))="",'$G(^("XQprint")),'$G(^("XQdiag")) D qARM.Message("Запрос может быть выполнен только из отображения "_$P(qqc,"qq")) Q
 .D qWEB.Query(qqc,,,,,,1)
 I $$$CurObj="CxWoc" D  Q:$Q "" Q
 .;????I $G(^Q(1,"XBase",0,"XBNDes"))=1 S Vs("par",5)="CxWoc"
 .I qqbut=2 D qARM.OpenWindow(,,,qqc_" CxWoc",,"XXXCxWoc") Q
 .I "XT@ML"[$E(qqc) D qARM.Message("Не бывает словаря значений") Q
 .S Vo("par",-1,29)=",,0"
 .D qARM.OpenWindow(,,,,,"XXXsysP"_qqc)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="BrCall235">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
  
 ;;описание отображения qqview,хранящегося под организацией, копируем в ^Q(1,"XView",qqview)
 ;; создаем и редактируем как обычное проводниковое отображение
 ;; закрывая окно отображения, копируем его описание в объект хранения под организацией
 
 ;; проверить блокировку
 
 n qqview S qqview="XXX"_qqc
 
 n refTmpGl s refTmpGl=$na($$$tmpGl("qview",$ZU(5),qqview)) ; 15.12.2008 Kokarev
 N stat S stat=$G(@refTmpGl)
 
 ;;I stat'="",$P(stat," ")'=$j D  I stat'="" D qARM.Question("Отображение блокировано (?редактируется) "_$TR($ZDT($P(stat," ",2),4),"/",".")_" """_$P(stat," ",3)_""". Разблокировать",0,"","K "_refTmpGl) D qARM.wbut(1) Q:$Q 1 Q   ;@Dol 07.05.08 Разблокировка
 ;;.I $H>$P(stat," ",2)!($G(qARM("ComputerName"))=$P(stat," ",3)) K @refTmpGl S stat=""
 
 i stat'="",$d(^Q(1,"XView",qqview))  D  I $d(^Q(1,"XView",qqview))  D qARM.Message("Отображение блокировано (?редактируется) "_$TR($ZDT($P(stat," ",2),4),"/",".")_" """_$P(stat," ",3)) Q:$Q 1 Q
 .I $P(stat," ")'=$j,$H>$P(stat," ",2) k ^Q(1,"XView",qqview) K @refTmpGl S stat=""
  
 i '$G(Arg1)  k ^Q(1,"XView",qqview) m ^Q(1,"XView",qqview)=^Q(1,qqo,qqc)
 
 I '$D(qqbut) N qqbut S qqbut=1+$G(Arg1)
 
 I qqbut=2 D  Q
 .I '$G(Arg1),$G(W("Zadm")) D qARM.QuestionM("Описание окна "_qqview_"~Дизайнирование окна "_qqview,,,"D qSYS.BrCall235(1)","D qARM.OpenWindow(1,,,,,"""_qqview_""")") Q  ;@Dol 11.09.07 
 .S Vs("par",3,"XPrint")=1,Vs("par",1,"XPrint")=1,Vs("par",3,"XMenu")=1,Vs("par",1,"XMenu")=1,Vs("par",1,"XQuest")=1,Vs("par",3,"XTabs")=1,Vs("par",1,"XTabs")=1
 .S Vs("par",3,"CxObj")=1,Vs("par",1,"CxObj")=1,Vs("par",3,"Xo364")=1,Vs("par",1,"Xo364")=1
 .S Vo("par",-1,29)=",,0,10,,,,,,,,,2,,3,,5" ;,,01,0
 .D qARM.OpenWindow(,,,qqview_" XView",,"XXXXNView")
 
 S Vo("par",-1,73)="",Vo("par",-1,89)=0 ;@dol 19.11.03 блокировка выхода с выбором и наследования релевантных
 D qARM.OpenWindow(1,,,,,qqview) Q
 
  
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="BrCall235Ex">
<Internal/>
<FormalSpec>qqcMy</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
  
 
 i ($g(qqcMy)'="")&&($d(^Q(1,"XView","XXX"_qqcMy))) n Dview s Dview=$g(^Q(1,"View",qqcMy,"Dview")) k ^Q(1,"View",qqcMy) m ^Q(1,"View",qqcMy)=^Q(1,"XView","XXX"_qqcMy) s ^Q(1,"View",qqcMy,"Dview")=$g(Dview) k ^Q(1,"XView","XXX"_qqcMy) d:$g(Vs(qqnump,"qqnump"))'="" qARM.WrWin(Vs(qqnump,"qqnump") ,"","","d qARM.wcre()")
 
 q 1
]]></Implementation>
</Method>

<Method name="CallDCpar">
<Description>
Вызов окна редактирования динамического образца (XDCpar)</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String,Arg4:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;формирование ссылки
 N qqref,qqcref,i,qqoref
 F i=4:-1:1 D:$G(@("Arg"_i))'=""  Q:$G(@("Arg"_i))'=""
 .S qqcref=@("Arg"_i)
 .S qqoref=$P("XView CxObj Xy Xx"," ",i)
 .S:$G(Arg1)'="" Vs("par","Virt","XView")=Arg1 S:$G(Arg2)'="" Vs("par","Virt","CxObj")=Arg2 S:$G(Arg3)'="" Vs("par","Virt","Xy")=Arg3 S:$G(Arg4)'="" Vs("par","Virt","Xx")=Arg4
 .I i=2 S Vo("par","CxObj",33)="^Q(1,""XView"","""_Arg1_""",""CxObj"")" S Vo("par","Xy",33)="^Q(1,""XView"","""_Arg1_""",""CxObj"",Vs(qqnump,""Virt"",""CxObj""),""Xy"")" S Vo("par","Xx",33)="^Q(1,""XView"","""_Arg1_""",""CxObj"",Vs(qqnump,""Virt"",""CxObj""),""Xy"",Vs(qqnump,""Virt"",""Xy""),""Xx"")" Q
 .I i=3 S Vo("par","Xy",33)="^Q(1,""XView"","""_Arg1_""",""CxObj"","""_Arg2_""",""Xy"")" S Vo("par","Xx",33)="^Q(1,""XView"","""_Arg1_""",""CxObj"","""_Arg2_""",""Xy"",Vs(qqnump,""Virt"",""Xy""),""Xx"")" Q
 .I i=4 S Vo("par","Xx",33)="^Q(1,""XView"","""_Arg1_""",""CxObj"","""_Arg2_""",""Xy"","""_Arg3_""",""Xx"")" Q
 S Vs("par",1)="",Vs("par",2)="",Vs("par",3)="",Vs("par",4)="" ;чтобы не влияло сохраненное состояние
 S Vo("par",-1,29)=$S(i<3:",,0,10",i<5:",,0,11",1:",,0,10")_",,,,,,,,,2,,3,,5",Vo("par",-1)="Редактирование Хранимых параметров ячейки"
 S Vo("par",$S(i=4:"Xx",i=2:"CxObj",1:"XView"),3)=1
 S Vo("par",-1,23)="S W(""Zdomod"")=2" ;действие по входу
 ;S Vo("par",-1,22)="D qARM.WrWin("""",0,"""",""qSYS.Redview("_$S(i<4:11,1:10)_")"") S qqend=1" ;действие после выхода  
 I $G(Arg4)'="",$G(^Q(1,"XView",Arg1,"CxObj",Arg2,"Xy",Arg3,"Xx",Arg4,"X71"))="" D  ;$G(Vo(qqnump,Arg2,0,Arg3,Arg4))="" D  ;если ячейка не существует, то ее нужно создать
 .S Vo(qqnump,Arg2,0,Arg3,Arg4)=0
 .S ^Q(1,"XView",Arg1,"CxObj",Arg2,"Xy",Arg3,"Xx",Arg4,"x70")=0,^("X71")=""
 S Vs("par",5)=qqoref D qARM.OpenWindow(,,,qqcref_" "_qqoref_" 1  "_qqoref,"","XXXXNView")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CallDef">
<Description>
Вызвать отображение редактирования параметров отображения (SYSview).
Arg1 - код отображения
Arg2 - код объекта
Arg3 - строка
Arg4 -ячейка

Ref=1 - разрешить редактировать, если в текущем отображении ссылка на описание в другом.</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%String,Arg3:%String,Arg4:%String,Ref:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Arg2)'="",$G(Vo(qqnump,Arg2,889))'="",'$G(Ref),'$G(W("ZBt0")) D qARM.Question("Ссылка на описание в отображении "_$P(Vo(qqnump,Arg2,889)," ")_$C(13,10)_"Продолжить",0,"","D qSYS.CallDef("""_$P(Vo(qqnump,Arg2,889)," ")_""","""_$S($P(Vo(qqnump,Arg2,889)," ",2)="":$G(Arg2),1:$P(Vo(qqnump,Arg2,889)," ",2))_""","""_$G(Arg3)_""","""_$G(Arg4)_""",1)") Q:$Q "" Q
 I '$D(^Q(1,"XView",Arg1)) D qARM.Message("Описание отображения "_Arg1_" сгенерировано "_$S(Arg1["sys":" методом qSYS.sysView",1:"")) Q:$Q "" Q
 I $G(Arg2)'="",'$D(^Q(1,"XView",Arg1,"CxObj",Arg2)) D qARM.Message("Описание объекта "_Arg2_" сгенерировано.") Q:$Q "" Q
 ;формирование ссылки
 N qqref,qqcref,i,qqoref,qXBNDes S qXBNDes=$G(^Q(1,"XBase",0,"XBNDes")) 
 I qXBNDes F i=4:-1:1 D:$G(@("Arg"_i))'=""  Q:$G(@("Arg"_i))'=""
 .S qqcref=@("Arg"_i)
 .S qqoref=$P("XView CxObj Xy Xx"," ",i)
 .S:$G(Arg1)'="" Vs("par","Virt","XView")=Arg1 S:$G(Arg2)'="" Vs("par","Virt","CxObj")=Arg2 S:$G(Arg3)'="" Vs("par","Virt","Xy")=Arg3 S:$G(Arg4)'="" Vs("par","Virt","Xx")=Arg4
 .;S:i=1 Vs("par","Virt","XView")=Arg1 S:i=2 Vs("par","Virt","CxObj")=Arg2 S:i=3 Vs("par","Virt","Xy")=Arg3 S:i=4 Vs("par","Virt","Xx")=Arg4
 .S:0 Vo("par","XView",33)="^Q(1,""XView"","""_Arg1_""")" 
 .I i=2 S Vo("par","CxObj",33)="^Q(1,""XView"","""_Arg1_""",""CxObj"")" S Vo("par","Xy",33)="^Q(1,""XView"","""_Arg1_""",""CxObj"",Vs(qqnump,""Virt"",""CxObj""),""Xy"")" S Vo("par","Xx",33)="^Q(1,""XView"","""_Arg1_""",""CxObj"",Vs(qqnump,""Virt"",""CxObj""),""Xy"",Vs(qqnump,""Virt"",""Xy""),""Xx"")" Q
 .I i=3 S Vo("par","Xy",33)="^Q(1,""XView"","""_Arg1_""",""CxObj"","""_Arg2_""",""Xy"")" S Vo("par","Xx",33)="^Q(1,""XView"","""_Arg1_""",""CxObj"","""_Arg2_""",""Xy"",Vs(qqnump,""Virt"",""Xy""),""Xx"")" Q
 .I i=4 S Vo("par","Xx",33)="^Q(1,""XView"","""_Arg1_""",""CxObj"","""_Arg2_""",""Xy"","""_Arg3_""",""Xx"")" Q
 I 'qXBNDes F i=1:1:5 Q:$G(@("Arg"_i))=""  D
 .S qqcref=@("Arg"_i)
 .S qqoref=$P("XView CxObj Xy Xx"," ",i)
 .S qqref=$S(i=1:$NA(^Q(1)),i=2:$NA(@qqref@("XView",Arg1)),i=3:$NA(@qqref@("CxObj",Arg2)),i=4:$NA(@qqref@("Xy",Arg3)))
 S Vs("par",1)="",Vs("par",2)="",Vs("par",3)="",Vs("par",4)="" ;чтобы не влияло сохраненное состояние
 I 'qXBNDes D:i<5  ;свернутые в дереве объектов
 .S Vs("par",3,"Xx")=1
 .S:i<4 Vs("par",3,"Xy")=1
 .S:i<3 Vs("par",3,"CxObj")=1,Vs("par",1,"CxObj")=1
 I qXBNDes D:i<4
 .S Vs("par",1,"XPrint")=1,Vs("par",3,"XMenu")=1,Vs("par",1,"XMenu")=1,Vs("par",1,"XQuest")=1,Vs("par",3,"XTabs")=1,Vs("par",1,"XTabs")=1 ;всегда свернуты (по объектам) и зачеркнуты
 .I i=3 S Vo("par","Xx",4)=3 Q  ;если выводятся стрроки, то ячейки свернуты (по экземплярам) и не выведены
 .I i=2 S Vo("par","Xy",4)=3,Vo("par","Xx",4)=3 Q  ;если объект - то свернуты его строки и ячейки
 .I i=1 S Vs("par",3,"CxObj")=1,Vs("par",1,"CxObj")=1 Q  ;если отображение - объекты не выводятся (сворачиваются и зачеркиваются)
 ;S Vo("par",-1,29)=$S(i<3:"520,450,100,1",i<5:"520,450,0,1",1:"520,350,0,11")
 I qXBNDes S Vo("par",-1,29)=$S(i<3:",,0,10",i<5:",,0,11",1:",,0,10")_",,,,,,,,,2,,3,,5",Vo("par",-1)="Отображение"_" "_$G(Arg1)_$S($G(Arg2)'="":" Объект "_$G(Arg2),1:"")_$S($G(Arg3)'="":" Строка "_$G(Arg3),1:"")_$S($G(Arg4)'="":" Ячейка "_$G(Arg4),1:"") ;5
 ;I 'qXBNDes S Vo("par",-1,29)=$S(i<3:",,100,",i<5:",,0,1",1:",,0,11") ;5
 I 'qXBNDes S Vo("par",-1,29)=$S(i<3:"520,450,,1",i<5:"520,450,0,1",1:"520,350,0,11")
 I qXBNDes S Vo("par",$S(i=4:"Xx",i=2:"CxObj",1:"XView"),3)=1
 I 'qXBNDes S Vo("par","CxObj",4)=(i=2) ;свернуты объекты в дереве экземпляров
 I 'qXBNDes  S Vo("par","Xx",4)=(i=4) ;свернуты ячейки
 S Vo("par",-1,23)="S W(""Zdomod"")=2" ;действие по входу
 S Vo("par",-1,22)="D qARM.WrWin("""",0,"""",""qSYS.Redview("_$S(i<(5-qXBNDes):11,1:10)_")"") S qqend=1" ;действие после выхода 
 I $G(Arg4)'="",$G(^Q(1,"XView",Arg1,"CxObj",Arg2,"Xy",Arg3,"Xx",Arg4,"X71"))="" D  ;$G(Vo(qqnump,Arg2,0,Arg3,Arg4))="" D  ;если ячейка не существует, то ее нужно создать
 .S Vo(qqnump,Arg2,0,Arg3,Arg4)=0
 .S ^Q(1,"XView",Arg1,"CxObj",Arg2,"Xy",Arg3,"Xx",Arg4,"x70")=0,^("X71")=""
 I qXBNDes S Vs("par",5)=qqoref D qARM.OpenWindow(,,,qqcref_" "_qqoref_" 1  "_qqoref,"","XXXXNView") Q:$Q "" Q
 D qARM.OpenWindow(,,,qqcref_" "_qqoref_" 1 "_qqref_" "_qqoref,"","XXXXView") ;,1)
 Q:$Q "" Q
 ;;;;;;;;;;
 I $G(Arg2)'="",$G(Vo(qqnump,Arg2,889))'="",'$G(Ref),'$G(W("ZBt0")) D qARM.Question("Ссылка на описание в отображении "_$P(Vo(qqnump,Arg2,889)," ")_$C(13,10)_"Продолжить",0,"","D qSYS.CallDef("""_$P(Vo(qqnump,Arg2,889)," ")_""","""_$S($P(Vo(qqnump,Arg2,889)," ",2)="":$G(Arg2),1:$P(Vo(qqnump,Arg2,889)," ",2))_""","""_$G(Arg3)_""","""_$G(Arg4)_""",1)") Q:$Q "" Q
 I '$D(^Q(1,"XView",Arg1)) D qARM.Message("Описание отображения "_Arg1_" сгенерировано "_$S(Arg1["sys":" методом qSYS.sysView",1:"")) Q:$Q "" Q
 I $G(Arg2)'="",'$D(^Q(1,"XView",Arg1,"CxObj",Arg2)) D qARM.Message("Описание объекта "_Arg2_" сгенерировано.") Q:$Q "" Q
 ;формирование ссылки
 N qqref,qqcref,i,qqoref F i=1:1:5 Q:$G(@("Arg"_i))=""  D
 .S qqcref=@("Arg"_i)
 .S qqoref=$P("XView CxObj Xy Xx"," ",i)
 .S qqref=$S(i=1:$NA(^Q(1)),i=2:$NA(@qqref@("XView",Arg1)),i=3:$NA(@qqref@("CxObj",Arg2)),i=4:$NA(@qqref@("Xy",Arg3)))
 S Vs("par",1)="",Vs("par",2)="",Vs("par",3)="",Vs("par",4)="" ;чтобы не влияло сохраненное состояние
 D:i<5  ;свернутые в дереве объектов
 .S Vs("par",3,"Xx")=1
 .S:i<4 Vs("par",3,"Xy")=1
 .S:i<3 Vs("par",3,"CxObj")=1,Vs("par",1,"CxObj")=1
 ;S Vo("par",-1,29)=$S(i<3:"520,450,100,1",i<5:"520,450,0,1",1:"520,350,0,11")
 S Vo("par",-1,29)=$S(i<3:",,100,",i<5:",,0,1",1:",,0,11") ;5
 S Vo("par","CxObj",4)=(i=2) ;свернуты объекты в дереве экземпляров
 S Vo("par","Xx",4)=(i=4) ;свернуты ячейки
 S Vo("par",-1,23)="S W(""Zdomod"")=2" ;действие по входу
 S Vo("par",-1,22)="D qARM.WrWin("""",0,"""",""qSYS.Redview("_$S(i<5:11,1:10)_")"") S qqend=1" ;действие после выхода   
 I $G(Arg4)'="",$G(^Q(1,"XView",Arg1,"CxObj",Arg2,"Xy",Arg3,"Xx",Arg4,"X71"))="" D  ;$G(Vo(qqnump,Arg2,0,Arg3,Arg4))="" D  ;если ячейка не существует, то ее нужно создать
 .S Vo(qqnump,Arg2,0,Arg3,Arg4)=0
 .S ^Q(1,"XView",Arg1,"CxObj",Arg2,"Xy",Arg3,"Xx",Arg4,"x70")=0,^("X71")=""
 D qARM.OpenWindow(,,,qqcref_" "_qqoref_" 1 "_qqref_" "_qqoref,"","XXXXView") ;,1)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CallEx">
<Description>
Вызов отображения экземпляров объектов по ссылкам из текущего слова словаря.</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqob,qqobl,qqz,qqrel S qqob="",qqobl="",qqz=qW.G("CC") I qqz'="" F  S qqob=$O(^Q(1,$S($E(qqo)'="D":$E(qqo,2,1000),1:qqo),qqz,qqob)) Q:qqob=""  S qqobl=$S(qqobl="":"",1:qqobl_",")_qqob
 I qqobl="" D qARM.Message("Нет ссылок для текущего значения") Q:$Q "" Q
 S qqrel=0_$E(qview,1,3)_"sysI"_qqobl_$S(qview[" ":" "_$P(qview," ",2),1:"")
 K ^Q(qqrel) M ^Q(qqrel)=^Q(1,$S($E(qqo)'="D":$E(qqo,2,1000),1:qqo),qqz)
 S Vs("par","Relind")=0
 D qARM.OpenWindow(,,,,0,$E(qview,1,3)_"sysI"_qqobl)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CallGM">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 G @Arg1
m61p7p1 D qSYS.QUser(1,,1) S ^DoXbf="K ^QUser" S ^DoXaf="D qSYS.QUser(,1,1)"
 s %GMVirt="d qW.GMFileExp("""_$$$CurObj_":"_qqc_""","""",0,"""","""","""","""","""")"  s %GMInit="s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()" d qARM.wM("-qARM","ClipboardSet")
 ;s %GMVirt="d qW.GMFileExp("""_$$$CurObj_":"_qqc_""",,0,,,""^DoXbf ^QUser ^DoXaf ^Q"")"  s %GMInit="s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()" d qARM.wM("-qARM","ClipboardSet")
 D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -F"_$TR(qARM("qpars",0)," ","*")_" -C -S -H -M -D")
 q ""
 ;
m61p7p2 s %GMVirt="d qW.GMFileExp("""_$$$CurObj_":"_qqc_""","""",1,"""","""","""","""","""")"  s %GMInit="s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()" d qARM.wM("-qARM","ClipboardSet")
 D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -F"_$TR(qARM("qpars",0)," ","*")_" -C -S -H -M -D")
 q ""           
m61p7p3 s %GMVirt="d qW.GMFileExp("""_$$$CurObj_""","""_qqc_""","""",0,,"""","""","""","""","""")"  s %GMInit="s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()" d qARM.wM("-qARM","ClipboardSet")
 D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -F"_$TR(qARM("qpars",0)," ","*")_" -C -S -H -M -D")
 q ""   
m61p7p4 S classL="User.qUSER"
 N qclass S qclass="" F  S qclass=$O(^Q(1,"XUClass",qclass)) Q:qclass=""  D:qclass'="qUSER"
 .S:'$D(^QUser("User."_qclass)) classL=$g(classL)_$s($g(classL)'="":",",1:"")_$G(^Q(1,"XUClass",qclass))
 ;;sas 20090409
 s %GMVirt="d qW.GMFileExp(153,""B1AAAAA"",,,""%ClVirt %ClVirtInc ^Q"")"  s %GMInit="S ^swvv=1 D getClss^%GMan00x7(classL,.%ClVirt,.%ClVirtInc) m ^swvv=% s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()" d qARM.wM("-qARM","ClipboardSet")
 ;s %GMVirt="d qW.GMFileExp(153,""B1AAAAA"",,,""%ClVirt %ClVirtInc ^Q"")"  s %GMInit="S ^swvv=1 D getClss^%GMan00x6(classL,.%ClVirt,.%ClVirtInc) m ^swvv=% s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()" d qARM.wM("-qARM","ClipboardSet")
 D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -F"_$TR(qARM("qpars",0)," ","*")_" -C -S -H -M -D")
 q ""       
 ;      
m61p8 ; восстановление
 N qclass S qclass="" F  S qclass=$O(^Q(1,"XUClass",qclass)) Q:qclass=""  D
 .S classL=$g(classL)_","_qclass_"=##class("_$G(^Q(1,"XUClass",qclass))_").%New()"
 s %GMVirt="S:0 BB=$I(BB),^BB(BB)=%gNd_%gVl d qW.GMFileImp()"  s %GMInit="s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()"_classL d qARM.wM("-qARM","ClipboardSet")
 D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -F"_$TR(qARM("qpars",0)," ","*")_" -C -R -H -M")
 q ""
 ;
m61p9 ; восстановление
 s %GMVirt="S BB=$I(BB),^BB(BB)=%gNd_%gVl d qW.GMFileImp()"  s:0 %GMInit="s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()" d qARM.wM("-qARM","ClipboardSet")
 D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -F"_$TR(qARM("qpars",0)," ","*")_" -C -R -H -M")
 q ""



 ;  G @Arg1
 ;m61p7p1   s %GMVirt="d qW.GMFileExp("""_$$$CurObj_""","""_qqc_""",0)"  s %GMInit="s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()" d qARM.wM("-qARM","ClipboardSet")
 ;  D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -F"_$TR(qARM("qpars",0)," ","*")_" -C -S -H -M -D")
 ;  q ""
 ;
 ;m61p7p2   s %GMVirt="d qW.GMFileExp("""_$$$CurObj_""","""_qqc_""",1)"  s %GMInit="s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()" d qARM.wM("-qARM","ClipboardSet")
 ;  D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -F"_$TR(qARM("qpars",0)," ","*")_" -C -S -H -M -D")
 ;  q ""            
 ;m61p7p3   s %GMVirt="d qW.GMFileExp("""_$$$CurObj_""","""_qqc_""",0)"  s %GMInit="s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()" d qARM.wM("-qARM","ClipboardSet")
 ;  D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -F"_$TR(qARM("qpars",0)," ","*")_" -C -S -H -M -D")
 ;  q ""    
 ;      
 ;m61p8 ; восстановление
 ;  s %GMVirt="S:0 BB=$I(BB),^BB(BB)=%gNd_%gVl d qW.GMFileImp()"  s %GMInit="s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()" d qARM.wM("-qARM","ClipboardSet")
 ;  D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -F"_$TR(qARM("qpars",0)," ","*")_" -C -R -H -M")
 ;  q ""
]]></Implementation>
</Method>

<Method name="CallMenu">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 I $G(Arg1)="" D qARM.Message("Неопределенный вызов меню") Q
 I '$D(^Q(1,"XView",qqc,"XMenu",Arg1)) D qARM.Question("Создать меню",1,,"S ^Q(1,""XView"","""_qqc_""",""XMenu"","_Arg1_")="""" D qSYS.CallMenu("_Arg1_")") Q
 S Vs("par","Virt","XMenu")=Arg1
 S Vo("par",-1,87)=1 ;,Vo("par",-1,65)=1
 S Vo("par",-1,29)=",,0,10,,,,,,,,,2,,3,,5"
 S Vs("par",5)="XMenu" S Vo("par","XMenu",33)="^Q(1,""XView"","""_qqc_""",""XMenu"")" S Vo("par","XMenu1",33)="^Q(1,""XView"","""_qqc_""",""XMenu"","_Arg1_",""XMenu1"")",Vo("par","XMenu2",33)="^Q(1,""XView"","""_qqc_""",""XMenu"","_Arg1_",""XMenu1"",Vs(qqnump,""Virt"",""XMenu1""),""XMenu2"")",Vo("par","XMenu3",33)="^Q(1,""XView"","""_qqc_""",""XMenu"","_Arg1_",""XMenu1"",Vs(qqnump,""Virt"",""XMenu1""),""XMenu2"",Vs(qqnump,""Virt"",""XMenu2""),""XMenu3"")" 
 D qARM.OpenWindow(,,,Arg1_" XMenu 1  XMenu 1","","XXXXNView")
 Q
]]></Implementation>
</Method>

<Method name="CallObj">
<Description>
Вызов редактирования свойств текущего объекта для отображения
редактирования отображений ( XXXXView).</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Arg1)'="" N qqc S qqc=Arg1
 S Vo("par","CxObj",4)=0 ;убрать свертку экземпляров
 S Vo("par",-1,23)="S W(""Zdomod"")=2"
 S Vo("par",-1,22)="D qARM.WrWin("""",0,"""",""qARM.wcre()"") S qqend=1"
 D qARM.OpenWindow(,,,qqc_" CxObj 1  CxObj",,"XXXCxObj")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CallObjN">
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 S Vo("par",-1,29)=",,0,10,,,,,,,,,2,,3,,5",Vs("par",5)="CxObj"
 S Vo("par",-1)="Отображение "_Vs(qqnump,"Virt","XView")_" Объекты "
 S Vo("par","CxObj",33)="^Q(1,""XView"","""_Vs(qqnump,"Virt","XView")_""",""CxObj"")",Vo("par","Xy",33)="^Q(1,""XView"","""_Vs(qqnump,"Virt","XView")_""",""CxObj"",Vs(qqnump,""Virt"",""CxObj""),""Xy"")",Vo("par","Xx",33)="^Q(1,""XView"","""_Vs(qqnump,"Virt","XView")_""",""CxObj"",Vs(qqnump,""Virt"",""CxObj""),""Xy"",Vs(qqnump,""Virt"",""Xy""),""Xx"")"
 S Vo("par","Xy",4)=2
 D qARM.OpenWindow(,,," CxObj","","XXXXNView")
 Q
]]></Implementation>
</Method>

<Method name="CallPrint">
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 I '$D(^Q(1,"XView",Vs(qqnump,"Virt","XView"),"XPrint")) D qARM.Question("Создать Набор печати ",1,,"S ^Q(1,""XView"","""_qqc_""",""XPrint"","_0_")="""" D qSYS.CallPrint()") Q
 S Vs("par","Virt","XPrint")=0
 S Vo("par",-1,87)=1,Vo("par",-1,65)=1
 S Vo("par",-1,29)=",,0,10,,,,,,,,,2,,3,,5"
 S Vs("par",5)="XPrint" S Vo("par","XPrint",33)="^Q(1,""XView"","""_qqc_""",""XPrint"")" ;S Vo("par","XMenu1",33)="^Q(1,""XView"","""_qqc_""",""XMenu"","_Arg1_",""XMenu1"")",Vo("par","XMenu2",33)="^Q(1,""XView"","""_qqc_""",""XMenu"","_Arg1_",""XMenu1"",Vs(qqnump,""Virt"",""XMenu1""),""XMenu2"")",Vo("par","XMenu3",33)="^Q(1,""XView"","""_qqc_""",""XMenu"","_Arg1_",""XMenu1"",Vs(qqnump,""Virt"",""XMenu1""),""XMenu2"",Vs(qqnump,""Virt"",""XMenu2""),""XMenu3"")" 
 D qARM.OpenWindow(,,,0_" XPrint 1  XPrint","","XXXXNView")
 Q
]]></Implementation>
</Method>

<Method name="CallQStat">
<Description>
Вызов экранной формы для показа/изменения состояния отображения запроса.</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 ;@Dol 19.03.08 переделан под произвольный объект хранения запроса 
 N qv,qq K Vs("par")
 S qq=qW.G("XQuery") S:qq="" qq=qqc ;запрос, где хранится состояние 
 S qv=qW.G("XQView") S:qv="" qv=$P(qqc,"qq") ;отображение запроса
 M Vs("par")=^Q(1,qqo,qq,"XObjStat") ;qqo>"XQuery"
 S Vo("par",-1,73)=1,Vo("par",-1,72)=""
 S Vo("par",-1,23)="" ;20.03.08 блокировка действия по входу
 S Vo("par",-1,22)="D qARM.SaveView(,""^Q(1,"""""_qqo_""""","""""_qq_""""")"") S qqend=1" ;действие по выходу qqo>"XQuery"
 S Vo("par",-1,720)=1
 S Vo("par",-1,663)="",Vo("par",-1,669)="" ;@Dol 20.03.08 Сплитер и скролбар перемещений удаляются
 D qARM.OpenWindow(,,",,100%,2",,,qv) K qqwold
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CallQuest">
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 I '$D(^Q(1,"XView",qqc,"XQuest")) D qARM.Question("Создать Действие Пользователя",1,,"S ^Q(1,""XView"","""_qqc_""",""XQuest"","_0_")="""" D qSYS.CallQuest()") Q
 S Vs("par","Virt","XQuest")=0
 S Vo("par",-1,87)=1,Vo("par",-1,65)=1
 S Vo("par",-1,29)=",,0,10,,,,,,,,,2,,3,,5"
 S Vs("par",5)="XQuest" S Vo("par","XQuest",33)="^Q(1,""XView"","""_qqc_""",""XQuest"")" ;S Vo("par","XMenu1",33)="^Q(1,""XView"","""_qqc_""",""XMenu"","_Arg1_",""XMenu1"")",Vo("par","XMenu2",33)="^Q(1,""XView"","""_qqc_""",""XMenu"","_Arg1_",""XMenu1"",Vs(qqnump,""Virt"",""XMenu1""),""XMenu2"")",Vo("par","XMenu3",33)="^Q(1,""XView"","""_qqc_""",""XMenu"","_Arg1_",""XMenu1"",Vs(qqnump,""Virt"",""XMenu1""),""XMenu2"",Vs(qqnump,""Virt"",""XMenu2""),""XMenu3"")" 
 D qARM.OpenWindow(,,,0_" XQuest 1  ","","XXXXNView")
 Q
]]></Implementation>
</Method>

<Method name="CallRel">
<Internal/>
<FormalSpec>qqw:%String,OBJ:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S Vo("par",-1,29)=",,0,11",Vo("par",-1,62)=1 ;",,0,10,,,@,@"
 S Vo("par",-1,669)=qqw ;@Dol 1.09.06 
 ;S Vo("par",-1,23)="D qARM.wbuttb(22,,,0),qARM.wbuttb(20,,,0),qARM.wbuttb(23,,,0),qARM.wbuttb(21,,,0) D:0 qARM.wbuttb(64,,,0),qARM.wbuttb(63,,,0) S W(""Zdomod"")=2" ;действие по входу
 S Vo("par",-1,23)="S W(""Zdomod"")=2" ;действие по входу
 S Vo("par",-1,22)="D qSYS.CallRel1() S qqend=1" ;действие после выхода
 S Vo("par",-1,65)=1
 D qARM.OpenWindow(,,,,,$E(qview,1,3)_"sysW"_qqw)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CallRel1">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqpar1,qqew,list,qlist S qlist="" I $$$CurObj'="" F  S qlist=$O(^Q($$$Relind_qview,$$$CurObj,qlist)) Q:qlist=""  S list=$S('$D(list):"",1:list_"!!")_qlist ;@Dol 15.10.08 I $$$CurObj'=""
 I $G(list)="" Q:$Q "" Q
 S qqpar1=$P(qqParent," ",2)
 S qqew=qqnump D qARM.csav(),qARM.crst("",qqpar1) S qwin="Q"_qqnump
 S Vs(qqnump,8,$P(W("Zpos",1,"d")," "),$P(W("Zpos",1,"d")," ",2))=$G(list)
 D qARM.wP(qwin_".T1","List",$G(list),W("Zpos",1,"y"),1),qARM.wM(,"M9",1,0,$P(W("Zpos",1,"d")," ")),qARM.wP(,"M4",$S($D(Vs(qqnump,8,$P(W("Zpos",1,"d")," "))):"Bor",1:"Red0"),"",1)
 D qARM.csav(),qARM.crst("",qqew) S qwin="Q"_qqnump Q
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CallRelView">
<Internal/>
<FormalSpec>view:%Library.String,qqo:%Library.String,qqw:%Library.String,Nsp:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S Vo("par",-1,29)=",,0,,,,,",Vo("par",-1,62)=1 ;,@,@
 S Vo("par",-1,23)="D qARM.wbuttb(22,,,0),qARM.wbuttb(20,,,0),qARM.wbuttb(23,,,0),qARM.wbuttb(21,,,0) D:0 qARM.wbuttb(64,,,0),qARM.wbuttb(63,,,0) S W(""Zdomod"")=2" ;действие по входу
 S Vo("par",-1,22)="D qSYS.CallRelView1("""_$G(qqo)_""","""_$G(qqw)_""") S qqend=1" ;действие после выхода
 D qARM.OpenWindow(,,,,,view,,$G(Nsp))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CallRelView1">
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(Arg1)="" Arg1=$$$CurObj
 N qqpar1,qqew,list,qlist S qlist="" F  S qlist=$O(^Q($$$Relind_qview,Arg1,qlist)) Q:qlist=""  S list=$S('$D(list):"",1:list_"!!")_$S($G(Arg2)="":qlist,1:qW.GG(Arg1,Arg2,qlist))
 I $G(list)="" Q:$Q "" Q
 S qqpar1=$P(qqParent," ",2)
 S qqew=qqnump D qARM.csav(),qARM.crst("",qqpar1) S qwin="Q"_qqnump
 S Vs(qqnump,8,$P(W("Zpos",1,"d")," "),$P(W("Zpos",1,"d")," ",2))=$G(list)
 D qARM.wP(qwin_".T1","List",$G(list),W("Zpos",1,"y"),1),qARM.wM(,"M9",1,0,$P(W("Zpos",1,"d")," ")),qARM.wP(,"M4",$S($D(Vs(qqnump,8,$P(W("Zpos",1,"d")," "))):"Bor",1:"Red0"),"",1)
 D qARM.csav(),qARM.crst("",qqew) S qwin="Q"_qqnump Q
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CallSaveGM">
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 S %GMInit="" ;;; ??????
 X qW.G("XRef2") S ^DoXbf=qW.G("XUDoBeg"),^DoXaf=qW.G("XUDoEnd")
 ;D qSYS.QUser(1,,1) S ^DoXbf="K ^QUser" S ^DoXaf="D qSYS.QUser(,1,1)" ; !!!!!!
 N classL
 I qW.G("Xsys") S classL="%Library.qARM,%Library.qSYS,%Library.qWEB,%Library.qWORD,%Library.TqARM" ; !!!!!!!
 D:qW.G("Xusr")                 ; !!!!!!!!!!!
 .S classL=$G(classL)_$s($g(classL)'="":",",1:"")_"User.qUSER"
 .N qclass S qclass="" F  S qclass=$O(^Q(1,"XUClass",qclass)) Q:qclass=""  D:qclass'="qUSER"
 ..S:'$D(^QUser("User."_qclass)) classL=$g(classL)_$s($g(classL)'="":",",1:"")_$G(^Q(1,"XUClass",qclass))
 ;;sas 20090409
 s:$G(classL)'="" %GMInit="D getClss^%GMan00x7("""_classL_""",.%ClVirt,.%ClVirtInc) "
 ;s:$G(classL)'="" %GMInit="D getClss^%GMan00x6("""_classL_""",.%ClVirt,.%ClVirtInc) "
 N XListMas S XListMas=$S(qW.G("Xsys")=1:"^%QView",1:"")_" "_$S($G(classL)'="":"%ClVirt %ClVirtInc",1:"")_" "_$S(qW.G("XUDoBeg")'="":"^DoXbf",1:"")_" "_$S(qW.G("Xusr")=1:"^QUser",1:"")_" "_$S(qW.G("XUDoEnd")'="":"^DoXaf",1:"")_" "_qW.G("XListMas")    ;;;_" "_$S(qW.G("XListTop")'=""!(qW.G("XRef1")'="")!(qW.G("XRef3")'=""):"^Q",1:"") ; ???
 S XListMas=qW.zReplace($G(XListMas)," "," ",1,1) I $G(XListMas)'="" S XListMas=XListMas_" ^Q"  ;; временно
 D qARM.Message("///"_$G(XListMas)_"///")
 s %GMVirt="d qW.GMFileExp("""_qW.G("XListTop")_""","""_qW.G("XRef1")_""","_qW.G("XRef3")_",,"_qW.G("XRef4")_","""_$G(XListMas)_""","""_qW.G("XRef5")_""","""_qW.G("XCondSave")_""")"  s %GMInit=$G(%GMInit)_"s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()" d qARM.wM("-qARM","ClipboardSet")
 D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -F"_$TR(qW.G("XRes")," ","*")_" -C -S -H -M -D","","","",1)
 q ""
]]></Implementation>
</Method>

<Method name="CallTB">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 D qARM.OpenWindow(,,,,,"XXXToolBar") Q   ;@Pavel - а где описания 
 I '$D(^Q(1,"XView",qqc,"XTB")) D qARM.Question("Создать Пользовательскую панель инструментов",1,,"S ^Q(1,""XView"","""_qqc_""",""XTB"","_0_")="""" D qSYS.CallTB()") Q
 S Vs("par","Virt","XTB")=0
 S Vo("par",-1,87)=1,Vo("par",-1,65)=1
 S Vo("par",-1,29)=",,0,10,,,,,,,,,2,,3,,5"
 S Vs("par",5)="XTB" S Vo("par","XTB",33)="^Q(1,""XView"","""_qqc_""",""XTB"")"
 D qARM.OpenWindow(,,,0_" XTB 1  XTB","","XXXXNView")
 Q
]]></Implementation>
</Method>

<Method name="CallTabs">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$D(^Q(1,"XView",qqc,"XTabs")) D qARM.Question("Создать Закладки",1,,"S ^Q(1,""XView"","""_qqc_""",""XTabs"","_0_")="""" D qSYS.CallTabs()") Q
 S Vs("par","Virt","XTabs")=0
 S Vo("par",-1,87)=1,Vo("par",-1,65)=1
 S Vo("par",-1,29)=",,0,10,,,,,,,,,2,,3,,5"
 S Vs("par",5)="XTabs" S Vo("par","XTabs",33)="^Q(1,""XView"","""_qqc_""",""XTabs"")"
 D qARM.OpenWindow(,,,0_" XTabs 1  XTabs","","XXXXNView")
 Q
]]></Implementation>
</Method>

<Method name="CallVocCor">
<Description>
Коррекция словарей развертки. Отображкение коррекции определяется по параметрам развертки.
Если развертка по ww*-объекту, то предполагается, что существует отображение adm_Voc с описанием всех ww* словарей.
В X783 может содержаться или конкретное специальное отображение или варант adm_Voc*.</Description>
<Internal/>
<FormalSpec>Obj:%Library.String,y:%Library.String,x:%Library.String,test:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N q73,q730,q,qqz,qqo,qviewV S qqo=Obj,qviewV="adm_Voc" ;qviewV - отображение словарей
 S q730=qARM.GetPar("x730",,$G(Obj),$G(y),$G(x))
 S q=",0,1,2,5,12,21,8,9,"[(","_q730_",") Q:$G(test) q I 'q D qARM.Message("Нет развертки по словарю") Q:$Q "" Q
 S q73=qARM.GetPar("X783",,$G(Obj),$G(y),$G(x)) I q73'="" S:$E(q73)="@" q73=qARM.Value($E(q73,2,32000)) S qviewV=q73 I qviewV'["adm_Voc" D qARM.OpenWindow(,,,,,qviewV) Q:$Q "" Q  ;@dol 24.08.03 явно задано @dol 15.02.03 @
 S qqz=qARM.GetPar("X73",,$G(Obj),$G(y),$G(x)) S:$E(qqz)="@" @("qqz="_$E(qqz,2,30000))
 I q730=8 D  Q:$Q "" Q  ;развертка-отображение
 .S q73="spr_"_$P(qqz," ") I '$D(^Q(1,"XView",q73)) D qARM.Message("Нет отображения редактирования словаря ( "_q73_" )") Q
 .D qARM.OpenWindow(,,,,,q73)
 I q730=9 D  Q:$Q "" Q  ;развертка - действие
 .I qqz'["OpenWindow" D qARM.Message("Нет явного вызова отображения ( OpenWindow )") Q
 .S qqz=$P(qqz,"OpenWindow(",2),q73=..PSYN(qqz," ",1) S:$E(q73,$L(q73))=")" $E(q73,$L(q73))=""
 .S q73=..PSYN(q73,",",..PSYN(q73,",")) ;??? исправить ..PSYN для ()
 .S @("q73="_q73) S q73="spr_"_$E(q73,4,255)
 .I '$D(^Q(1,"XView",q73)) D qARM.Message("Нет отображения редактирования словаря ( "_q73_" )") Q
 .D qARM.OpenWindow(,,,,,q73)
 S q73=$P(qqz," ") S:q73="" q73=qARM.GetPar("X71",,$G(Obj),$G(y),$G(x))
 I q73'[":" S Vo("par",-1,29)=",,0" D qARM.OpenWindow(,,",,0 1",,,"XXXsysP"_q73) Q:$Q 1 Q
 I $E(q73,1,2)="ww" D   Q:$Q 1 Q
 .N qqoo S qqoo=$E($P(q73,":"),2,255) ;объект словаря
 .I '$D(^Q(1,"XView",qviewV,"CxObj",qqoo)) D qARM.Message("В отображении "_qviewV_" нет объекта-словаря "_qqoo) Q  ;@dol 21.11.03
 .S Vs("par",5)="100,"_qqoo,Vs("par",1,qqoo)=1,Vs("par",1,100)=1 D qARM.OpenWindow(,,",,0 1",,,qviewV)
 I q73'[";" D qARM.OpenWindow(,,,",,0 1",,"XXXsysO"_$P(q73,":")) Q:$Q 1 Q
 N qi,qq S q="" F qi=1:1:$L(q73,";") S qq=$P($P(q73,";",qi),":") Q:qq=""  S $P(q,",",qi)=qq
 S Vs("par",5)=q D qARM.OpenWindow(,,",,0 1",,,"###sysT"_$P(q,",")) Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="CallWoc">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqw,qqt,qXBN S qXBN=$G(^Q(1,"XBase",0,"XBNDes"))=1||($E(Vo(qqnump),1,6)="XXXXNV") 
 S qqt=$S('qXBN:$G(@$$$GloRef@("Xx",qqc,"x70")),1:$G(@Vo(qqnump,qqo,33)@(qqc,"x70")))
 I qqt="" Q:$Q "" Q
 I "234"'[qqt Q:$Q "" Q
 S qqw=qW.GG("Xx","X71",qqc) I qqw="" Q:$Q "" Q
 S:qqw[":" qqw=$P($P(qqw,":",2),"{")
 S Vo("par","CxWoc",4)=0 ;убрать свертку экземпляров
 S Vo("par",-1,23)="S W(""Zdomod"")=2"
 S Vo("par",-1,22)="D qARM.WrWin("""",0,"""",""qARM.wcre()"") S qqend=1"
 S Vs("par",2,qqo)=1
 D qARM.OpenWindow(,,,qqw_" CxWoc 1  CxWoc",,"XXXCxWoc")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="ChCode">
<Description>
Сменить код объека в описании (пока только понятия)
Arg1 - "CxWoc"
Arg2 - старый код
Arg3 - новый код</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N err,qqo,qqw,view,qqz,y,x
 I $D(^Q(1,Arg1,Arg3)) Q "Недопустимо. Имеется код "_Arg1_" "_Arg3
 I Arg1="CxWoc" Q:$D(^Q(1,Arg2))>1 "Недопустимо. Имеются значения "_Arg1_" "_Arg3 Q:$E(Arg2)="C"!($E(Arg3)="C") "Недопустимо для С-понятий" D  Q $G(err)
 .M ^Q(1,"CxWoc",Arg3)=^Q(1,"CxWoc",Arg2)
 .S qqz=^Q(1,"CxWoc",Arg2),^Q(1,"xWoc",qqz)=Arg3 K ^Q(1,"CxWoc",Arg2)
 .;поиск в отображениях
 .S view="" F  S view=$O(^Q(1,"XView",view)) Q:view=""  I $E(view,1,3)'="XXX" D
 ..S qqo=-1 F  S qqo=$O(^Q(1,"XView",view,"CxObj",qqo)) Q:qqo=""  D  ;I " "_$G(^Q(1,"XView",view,"CxObj",qqo))_" "[(" "_Arg2_" ") D
 ...S y="" F  S y=$O(^Q(1,"XView",view,"CxObj",qqo,"Xy",y)) Q:y=""  S x="" F  S x=$O(^Q(1,"XView",view,"CxObj",qqo,"Xy",y,"Xx",x)) Q:x=""  I $G(^(x,"X71"))=Arg2 S ^("X71")=Arg3
 Q ""
]]></Implementation>
</Method>

<Method name="ChObjView">
<Description>
Выбор объекта отображения</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 S Vo("par",-1,67)="$D(^Q(1,""XView"","""_Vo(qqnump)_""",""CxObj"",qqc))" ;постоянные условия
 S Vo("par",-1,29)="200,200,0,11,,,@,@",Vo("par",-1,62)=1
 S Vo("par",-1,80)=1,Vo("par",-1,65)=1
 S Vo("par",-1,74)="@ZXXHR0 @ZXXHR0 @ZXXHR0" ;замещение пояснений 
 S Vo("par",-1,72)="1  S Vs(qqnump,""CurObj"")=qqc,qqc="""" D qARM.wrot("""",0),qARM.wcre()" ;$S(qqwr'[":":"3 C",1:"3 "_$P(qqwr,","))_$P(W("Zdrl")," ",12)
 ;.S:$P(W("Zdrl")," ",8) Vo("par",qqwr,0,0,0,2)=$P(W("Zdrl")," ",8)
 ;.S:$P(W("Zdrl")," ",9) Vo("par",-1,60)=+$P(W("Zdrl")," ",9)
 S Vo("par",-1,3)=1 ;полный вывод
 S Vo("par",-1,73)=0 ;выход с выбором
 ;.S:$P(W("Zdrl")," ",11) Vo("par",-1,86)="S:qc=115 W(""ZBtred"")=1" ;включение редактирования по F4
 D qARM.OpenWindow(,,,,,$E(qview,1,3)_"sysRCxObj")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="ChViewPar">
<Internal/>
<FormalSpec>Par:%Library.String,old:%Library.String,new:%Library.String,view:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(view)="" view=Vo(qqnump)
 I $G(Par)'?1(1"x",1"X")1.4N Q "??? Par="_$G(Par)
 N qqt,num S qqt=$E(Par,2)
 I qqt=1 D:$S('$D(old):1,1:$G(^Q(1,"XView",view,Par))=old)  Q ""
 .I $I(num),$G(new)="" K ^Q(1,"XView",view,Par) Q
 .S ^Q(1,"XView",view,Par)=new
 N qqo,y,x S qqo="" F  S qqo=$O(^Q(1,"XView",view,"CxObj",qqo)) Q:qqo=""  D
 .I qqt=5 D:$S('$D(old):1,1:$G(^Q(1,"XView",view,"CxObj",qqo,Par))=old)  Q
 ..I $I(num),$G(new)="" K ^Q(1,"XView",view,"CxObj",qqo,Par) Q
 ..S ^Q(1,"XView",view,"CxObj",qqo,Par)=new
 .I qqt=7 S y="" F  S y=$O(^Q(1,"XView",view,"CxObj",qqo,"Xy",y)) Q:y=""  S x="" F  S x=$O(^Q(1,"XView",view,"CxObj",qqo,"Xy",y,"Xx",x)) Q:x=""  D:$S('$D(old):1,1:$G(^Q(1,"XView",view,"CxObj",qqo,"Xy",y,"Xx",x,Par))=old)
 ..I $I(num),$G(new)="" K ^Q(1,"XView",view,"CxObj",qqo,"Xy",y,"Xx",x,Par) Q
 ..S ^Q(1,"XView",view,"CxObj",qqo,"Xy",y,"Xx",x,Par)=new
 Q +$G(num)
]]></Implementation>
</Method>

<Method name="Chiqqw">
<Description>
Для объекта Arg1 возвращает объект-потомок с понятием Arg2</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N Arg S (Arg,Arg1)=$G($$$ObjRef(Arg1))_"," Q:Arg="," ""
 F   S Arg=$O($$$MObjRef(Arg)) Q:$E(Arg,1,$L(Arg1))'=Arg1  I $D(Vo(qqnump,$P(Arg,",",$L(Arg1,",")),11,Arg2)) S Arg2="" Q
 Q:Arg2'="" "" Q $P(Arg,",",$L(Arg1,","))
]]></Implementation>
</Method>

<Method name="Chqqwqqo">
<Description>
Замена понятия qqwold на qqw для списка объектов qqolst (через пробел) во всех отображениях.
z=1 замена и в экземплярах объектов тоже
z=2 - замена на одно слово
z=3 - замена на одно слово+первая буква большая, остальные - маленькие (если все буквы большие)
z=4 - замена на одно слово, если нет подчерка
ev - выражение преобразование (z - безразлично). Z - значение понятия qqwold
X166=1 - поставить для преобразованных выражений признак НЕ выводить подчерк.</Description>
<Internal/>
<FormalSpec>qqw:%Library.String,qqwold:%Library.String,qqolst:%Library.String,z:%Library.String,ev:%Library.String,X166:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqo,qqc,view,qqz,y,x,ii,iii,err,Z
 I $E(qqw)="T"||($E(qqwold)="T"),$E(qqwold)'=$E(qqw) D qARM.Message("Нессответствие типов понятия") Q:$Q "" Q
 ;поиск в отображениях
 S view="" F  S view=$O(^Q(1,"XView",view)) Q:view=""  I $E(view,1,3)'="XXX" S ii=0 D  I ii S ^Q(1,"XView",view,"X166")=1,^Q(1,"XView",view,"X")=qW.zCnv(1,$H,quser) S err=$G(err)_" "_view
 .S qqo=-1 F  S qqo=$O(^Q(1,"XView",view,"CxObj",qqo)) Q:qqo=""  S x=$S($E(qqo)="v":$E(qqo,3,255),1:qqo) I " "_qqolst_" "[(" "_x_" ") D
 ..S y="" F  S y=$O(^Q(1,"XView",view,"CxObj",qqo,"Xy",y)) Q:y=""  S x="" F  S x=$O(^Q(1,"XView",view,"CxObj",qqo,"Xy",y,"Xx",x)) Q:x=""  I $G(^(x,"X71"))=qqwold S ^("X71")=qqw,ii=1
 D qARM.Message($G(err),"Преобразованы отображения")
 I '$G(z) Q:$Q "" Q
 S err="" F x=1:1:$L(qqolst," ") S qqo=$P(qqolst," ",x) D
 .S qqc="",ii=0,iii=0 F  S qqc=$O(^Q(1,qqo,qqc)) Q:qqc=""  I $D(^Q(1,qqo,qqc,qqwold)),$I(ii) D
 ..I $E(qqw)="T" M ^Q(1,qqo,qqc,qqw)=^Q(1,qqo,qqc,qqwold) K ^Q(1,qqo,qqc,qqwold) Q
 ..I $G(ev)'="" S Z=qW.G(qqwold),@("W(qqw)="_ev) I 1
 ..E  S W(qqw)=qW.G(qqwold) D
 ...I z=4 Q:W(qqw)["_"  S W(qqw)=$TR(W(qqw)," ","_") Q
 ...S:z>1 W(qqw)=$TR(W(qqw)," ","_") I z=3,W(qqw)=$ZCVT(W(qqw),"U") S W(qqw)=$E(W(qqw))_$ZCVT($E(W(qqw),2,3000),"L")
 ..I $L(W(qqw))>200,$I(iii) D
 ...I W(qqw)[";_" S W(qqw)=qW.zReplace(W(qqw),";_","; ") Q
 ...I W(qqw)["._" S W(qqw)=qW.zReplace(W(qqw),"._",". ") Q
 ...I W(qqw)[",_" S W(qqw)=qW.zReplace(W(qqw),",_",", ") Q
 ...S y=$L(W(qqw),"_")\2,W(qqw)=$P(W(qqw),"_",y)_" "_$P(W(qqw),"_",y+1,10000)
 ..S W(qqwold)="" D qW.rCor(qqo,qqc,qqw_" "_qqwold,,,0)
 .S $P(err,$C(13,10),x)=qqo_" - "_ii_$S('iii:"",1:" разбито слов "_iii)
 D qARM.Message($G(err),"Преобразовано экземпляров") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="ColColp">
<Description>
Диалоговое определение цвета для параметров ячеек</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqw S qqw=$O(Vo(qqnump,$P(W("Zpos",2,"d")," ",2),0,$P(W("Zpos",2,"d")," ",3),W("Zpos",2,"x"))) Q:qqw=""
 F  Q:$E(Vo(qqnump,$P(W("Zpos",2,"d")," ",2),0,$P(W("Zpos",2,"d")," ",3),qqw))=2  S qqw=$O(Vo(qqnump,$P(W("Zpos",2,"d")," ",2),0,$P(W("Zpos",2,"d")," ",3),qqw)) Q:qqw=""
 Q:qqw=""  S qqw=$E(Vo(qqnump,$P(W("Zpos",2,"d")," ",2),0,$P(W("Zpos",2,"d")," ",3),qqw),2,255) Q:qqw=""  ;код понятия соседней ячейки
 D qARM.OpenWinColorDialog("S W("""_qqw_""")=qARM(""qpars"",""color""),qqwchg=$G(qqwchg)_"" "_qqw_""" I qARM.EndOP()||1 D qARM.wwww("""_qqw_""")",+qW.G(qqw))
 K qqwold Q
]]></Implementation>
</Method>

<Method name="ColRel">
<Description>
Динамическое удаление/появление (ColRel=0/1) колонки релевантных. !!! В описании отображения/Релевантные она должна быть объявлена ;@Dol 19.03.09
ColHead=0/1 - заголовки колонок</Description>
<Internal/>
<FormalSpec>ColRel,ColHead</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ D:$G(ColHead)'="" qARM.wP(qwin_".T2","ColHeaderAppearance",ColHead) D:$G(ColRel)'="" qARM.wP(qwin_".T2","RowHeaderAppearance",ColRel),qARM.wP(,"RowHeaderWidth",ColRel*16) Q
]]></Implementation>
</Method>

<Method name="ColWidth">
<Description>
Изменение размера колонок №№ (от Nbeg до Nend)
Возвращает текущую ширину экрана в пикселях ( qARM("Screen","Width") )
Можно использовать в действии по входу в отображение
Если динамически, то необходимо после изменения вызвать D qARM.wgre(1)</Description>
<Internal/>
<FormalSpec>Nbeg:%Library.String,Nend:%Library.String,Size:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 F Nbeg=Nbeg:1:$G(Nend,Nbeg) S $P(Vo(qqnump,-1,9,Nbeg),",")=Size ;S $P(Vo(qqnump,-1,0,0,Nbeg,2),",")=Size
 S W("ZBtredo")="" Q:$Q qARM("Screen","Width") Q
]]></Implementation>
</Method>

<Method name="Compress">
<Description>
Сжатие методом LZ77.
src,dest - имена узлов источника и приемника, в подузлах которых находятся данные (в dest пишется по 32 кб).
decomp=1 - разжатие
ksrc=1 - удаление узла-источника после обработки

Перед обработкой узел-приемник удаляется!

Максимальная степень сжатия: в 8.5 раз
Максимальное увеличение размера данных при невозможности сжатия: 6.25%

(Примечание: во всех подузлах src, кроме последнего, должна содержаться строка не короче 20 символов.)</Description>
<Internal/>
<FormalSpec>src:%Library.String,dest:%Library.String,decomp:%Library.String,ksrc:%Library.String=0</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 k @dest
 g:$G(decomp) CpDec
 n srcn,destn,srcbuf,tar,tart,cnt,i,pos,rpos,poso,H,L,win,wino,out,succ,buf,rd,beg,a,b
 s srcn=$O(@src@("")),destn=1 
 i srcn="" k:ksrc @src q ""
 s tar="",wino="",srcbuf=@src@(srcn),buf=$E(srcbuf,1,17),rd=$L(buf),cnt=0,tart=""
CpLp
 s win=wino_buf,beg=1,pos=0,poso=0
 f i=3:1:$L(buf) s poso=pos,pos=$F($E(win,beg,$L(wino)-1+i),$E(buf,1,i)) q:'pos  s pos=beg-1+pos,beg=pos-i
 s succ=1
 i pos s rpos=pos-i
 e  s:poso i=i-1,rpos=poso-i s:'poso succ=0
 i succ s rpos=$L(wino)-rpos
 i (succ&(tart'=""))||(cnt=16) s tar=tar_$C(cnt-1)_tart,cnt=0,tart=""
 i 'succ s cnt=cnt+1,tart=tart_$E(buf,1,1),i=1 
 e  s L=rpos#256,H=((i-2)*16)+(rpos\256),tar=tar_$C(H,L)
 i $L(tar)>31999 s @dest@(destn)=tar,tar="",destn=destn+1
 s buf=buf_$$CpGetS(i),wino=wino_$E(buf,1,i)
 s buf=$E(buf,i+1,10000)
 i buf="" s:tart'="" tar=tar_$C(cnt-1)_tart s:tar'="" @dest@(destn)=tar k:ksrc @src q ""
 s:$L(wino)>4096 wino=$E(wino,$L(wino)-4095,10000)
 g CpLp
CpGetS(c)
 q:srcn="" ""
 s a=$E(srcbuf,rd+1,rd+c),rd=rd+c
 s b=c-$L(a)
 i b>0 s srcn=$O(@src@(srcn)) i srcn'="" s srcbuf=@src@(srcn),a=a_$E(srcbuf,1,b),rd=b
 q a

CpDec
 n srcn,prevs,destn,srcbuf,tar,wino,d,i,k,len,offs,so,a,b s tar="",wino="" s i=0
 s srcn=$O(@src@("")) 
 i srcn="" k:ksrc @src q ""
 s destn=1,srcbuf=@src@(srcn),prevs=""
DcLp1
 s c=$A($$DcGetS(1)),len=c\16
 i len s offs=(c#16)*256+$A($$DcGetS(1)) f k=1:1:len+2 s so=$L(tar)-offs s:so>0 tar=tar_$E(tar,so) s:so<1 tar=tar_$E(prevs,$L(prevs)+so)
 e  s tar=tar_$$DcGetS(c+1)
 i $L(tar)>31999 s @dest@(destn)=tar,prevs=$E(tar,$L(tar)-4150,50000),tar="",destn=destn+1
 i (i+1>$L(srcbuf))&(srcn="") s:tar'="" @dest@(destn)=tar k:ksrc @src q ""
 g DcLp1
DcGetS(d)
 q:srcn="" ""
 s a=$E(srcbuf,i+1,i+d),i=i+d
 s b=d-$L(a)
 i b>0 s srcn=$O(@src@(srcn)) i srcn'="" s srcbuf=@src@(srcn),a=a_$E(srcbuf,1,b),i=b
 q a
]]></Implementation>
</Method>

<Method name="CreAr">
<Description>
Создание отображения Аналитики
Arg1 = "" - виртуальное, иначе - код отображения архива</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;N qqpar2 
 I '$D(Arg1) S qqpar2="A"_qqpar2_$S(quser="#":"",quser="U":" "_$J,1:" "_quser)
 I $D(Arg1) N qqpar2,qqParent S qqpar2=Arg1,qqParent=" "_qqnump N qqnump S qqnump="Ar" K Vo(qqnump),Vs(qqnump),^Q(1,"XView",Arg1) ;временное псевдо-экран K ^Q(1,"XView",Arg1)
 ;K Vs(qqnump,13) M Vs(qqnump,13)=Vs($P(qqParent," ",2),13)
 ;K Vs(qqnump,12) M Vs(qqnump,12)=Vs($P(qqParent," ",2),12)
 N qqcref 
 ;K Vs(qqnump,14) M Vs(qqnump,14)=Vs($P(qqParent," ",2),14)
 S qqcref=''$D(Vs($P(qqParent," ",2),14))
 N qqo,qqwA,qi,qqso,qqref ;@dol 21.01.03 ,qqref !!!!!!
 K ZP,ZA ;массивы понятий аналитик и значений
 K qqref S qqref="^Q(qql)" F ZP=1:1:$O(Vs($P(qqParent," ",2),13,3,""),-1) S ZP(ZP)="A"_$P(Vs($P(qqParent," ",2),13,3,ZP)," ",2),(qqref,qqref(ZP))=$E(qqref,1,$L(qqref)-1)_",ZP("_ZP_"),ZA("_ZP_"))"
 S Vo(qqnump,-1)=$S('$D(Arg1):"Аналитика...",1:$G(^Q(1,"XView",Arg1,"X11"),"Аналитика...")) D:$D(Arg1) CreArV(,,,"X11",Vo(qqnump,-1))
 N qAnew S qAnew=qW.GG("XBase","XFNewAn",0) G:qAnew CreArNew
 ;
 S Vo(qqnump,-1,23)="S qql="""_qqpar2_""",Vs(qqnump,""GloRef"")=$NA(^Qa(qql))"
 D:$D(Arg1) CreArV(,,,"X123",Vo(qqnump,-1,23))
 S Vo(qqnump,-1,27)="-",Vo(qqnump,-1,28)="-" D:$D(Arg1) CreArV(,,,"X127",Vo(qqnump,-1,27)),CreArV(,,,"X128",Vo(qqnump,-1,28))
 S Vo(qqnump,-1,3,25)="S Vs(qqnump,""GloRef"")=""^Qa(qql)"",qql="""_qqpar2_""",Vs(qqnump,""GloRef"")=$NA(^Qa(qql))"
 S:$D(Arg1) ^Q(1,"XView",Arg1,"XPrint",0,"X325")=Vo(qqnump,-1,3,25)
 S $$$Tree=1 D:$D(Arg1) CreArV(,,,"x121",1)
 S Vo(qqnump,-1,0,0,0)="0Аналитика/Агрегат" D:$D(Arg1) CreArV(-1,0,0,"x710",0),CreArV(-1,0,0,"X71",Vo(qqnump,-1,0,0,0))
 ;
 S Vo(qqnump,-1,0,1,0)="5$ZDT(qW.zCnv(0,qW.G(""Xc"")),4)_"" ""_$E(qW.G(""Xc""),$S($E(qW.G(""Xc""),1,2)=$C(0,0):9,1:6),255)" ;@ank 20101101 Изменено в соответсвтии с новым алгоритмом запаковки\распаковки дат ;информация о создании
 D:$D(Arg1) CreArV(-1,1,0,"x70",5),CreArV(-1,1,0,"X71",$E(Vo(qqnump,-1,0,1,0),2,3000))
 G:$D(ZP)=1 CreArend ;только общие агрегаты
 ;
 F qi=1:1:ZP D   ;коды объектов аналитик - "A"_qqw - что очень плохо, если одинаковые понятия
 .I qi=1 S Vo(qqnump,-1,0,2)=ZP(1) D:$D(Arg1) CreArV(-1,2,,"X60",ZP(1)) S Vs(qqnump,12)=ZP(1)_" C" I 1
 .E  S Vo(qqnump,ZP(qi-1),0,1)=ZP(qi) D:$D(Arg1) CreArV(ZP(qi-1),1,,"X60",ZP(qi))
 .S Vo(qqnump,ZP(qi))=qW.GetWoc("CxWoc",$E(ZP(qi),2,255))
 .I $D(Arg1) D CreArV(ZP(qi),,,"X51",Vo(qqnump,ZP(qi)))
 .S Vs(qqnump,4,ZP(qi))=1,Vs(qqnump,12,ZP(qi),"C",3)="A"_qi,Vs(qqnump,13,2,ZP(qi)_" C")=qi,Vs(qqnump,13,3,qi)=ZP(qi)_" C"
 .S $$$ObjLqqc(ZP(qi))=255 ;????
 .S Vo(qqnump,ZP(qi),0,0,0)="2C" D:$D(Arg1) CreArV(ZP(qi),0,0,"x70",2),CreArV(ZP(qi),0,0,"X71","C")
 ;учитывается фиксация
 N ZPmax S ZPmax=ZP F ZP=$S($G(Vs($P(qqParent," ",2),99,"Anal",2)):1,1:ZP):1:ZPmax D
 .S qqo="",qs=$O(Vo(qqnump,ZP(ZP),0,""),-1)+qqcref F  S qqo=$O(Vs($P(qqParent," ",2),12,qqo)) Q:qqo=""  I $S($G(Vs($P(qqParent," ",2),7))="":1,1:'$G(Vs($P(qqParent," ",2),7,qqo))) D  ;qs=qqcref
 ..S qqw="" F  S qqw=$O(Vs($P(qqParent," ",2),12,qqo,qqw)) Q:qqw=""  D:$D(Vs($P(qqParent," ",2),12,qqo,qqw,4))
 ...S qs=qs+1,Vo(qqnump,ZP(ZP),0,qs,0)="0Итого: "_qW.GetWoc("CxWoc",qqw) D:$D(Arg1) CreArV(ZP(ZP),qs,0,"x70",0),CreArV(ZP(ZP),qs,0,"X71",$E(Vo(qqnump,ZP(ZP),0,qs,0),2,3000))
 ...S Vo(qqnump,ZP(ZP),0,qs,1)="3LA"_qqw D:$D(Arg1) CreArV(ZP(ZP),qs,1,"x70",3),CreArV(ZP(ZP),qs,1,"X71","LA"_qqw)
 ...I ZP=ZPmax S Vs(qqnump,12,ZP(ZP),"LA"_qqw,4)="D" F qi=5:1:9 S Vs(qqnump,12,ZP(ZP),"LA"_qqw,qi)=$G(Vs($P(qqParent," ",2),12,qqo,qqw,qi))
 I qqcref D  ;ссылочные объекты (не учтен вариант нескольких вершин)
 .S qqo=$O(Vs($P(qqParent," ",2),14,"")),Vo(qqnump,ZP(ZP),0,1)=qqo M Vs(qqnump,1,qqo)=Vs($P(qqParent," ",2),1,qqo) D:$D(Arg1) CreArV(ZP(ZP),1,,"X60",qqo) D CreArR(qqo,$NA(Vs($P(qqParent," ",2),14))) ;с переносом зачеркнутых
 G CreArend
CreArNew
 I qqnump="P",$G(Vo($P(qqParent," ",2)))["sysA" M Vo(qqnump)=Vo($P(qqParent," ",2)),Vt(qqnump)=Vt($P(qqParent," ",2)) M:0 Vs(qqnump,1)=Vs($P(qqParent," ",2),1) Q "" ;,Vs(qqnump)=Vs($P(qqParent," ",2)) Q "" ;печать из отображения аналитики
 N qqrfr,qqrfri S qqrfr="^Qa("""_qqpar2_""")"
 S Vo(qqnump,-1,27)="-",Vo(qqnump,-1,28)="-" D:$D(Arg1) CreArV(,,,"X127",Vo(qqnump,-1,27)),CreArV(,,,"X128",Vo(qqnump,-1,28))
 S Vo(qqnump,-1,23)="S (qqo,Vs(qqnump,""CurObj""))=""-1"",qqc=""""" D:$D(Arg1) CreArV(,,,"X123",Vo(qqnump,-1,23)) ;действие по входу
 S Vo(qqnump,-1,3,25)="K Vs(qqnump,""Virt"") S (qqo,Vs(qqnump,""CurObj""))=""-1"",qqc=""""" S:$D(Arg1) ^Q(1,"XView",Arg1,"XPrint",0,"X325")=Vo(qqnump,-1,3,25) ;;действие по входу (печать)
 S $$$Tree=0 D:$D(Arg1) CreArV(,,,"x121",0)
 S Vo(qqnump,-1,89)=1 ;???D:$D(Arg1) CreArV(,,,"X189",1) ;наследование релевантных
 S Vo(qqnump,-1,0,0,0)="0Аналитика/Агрегат" D:$D(Arg1) CreArV(-1,0,0,"x710",0),CreArV(-1,0,0,"X71",Vo(qqnump,-1,0,0,0))
 ;
 S Vo(qqnump,-1,0,1,0)="5$ZDT(qW.zCnv(0,qW.G(""Xc"")),4)_"" ""_$E(qW.G(""Xc""),6,255)" ;информация о создании
 D:$D(Arg1) CreArV(-1,1,0,"x70",5),CreArV(-1,1,0,"X71",$E(Vo(qqnump,-1,0,1,0),2,3000))
 G:$D(ZP)=1 CreArend ;только общие агрегаты
 S Vo(qqnump,-1,33)=qqrfr D:$D(Arg1) CreArV(-1,,,"X533",qqrfr) ;имя массива
 S Vo(qqnump,-1,2)=6 D:$D(Arg1) CreArV(-1,,,"x52",6) ;виртуальный массив
 ;
 F qi=1:1:ZP D   ;коды объектов аналитик A1, A2 
 .I qi=1 S Vo(qqnump,-1,0,2)="A1" D:$D(Arg1) CreArV(-1,2,,"X60","A1") S Vs(qqnump,12)="A1"_" C" I 1
 .E  S Vo(qqnump,"A"_(qi-1),0,1)="A"_qi D:$D(Arg1) CreArV("A"_(qi-1),1,,"X60","A"_qi)
 .S Vo(qqnump,"A"_qi)=qW.GetWoc("CxWoc",$E(ZP(qi),2,255))
 .I $D(Arg1) D CreArV("A"_qi,,,"X51",Vo(qqnump,"A"_qi))
 .S Vo(qqnump,"A"_qi,2)=6 D:$D(Arg1) CreArV("A"_qi,,,"x52",6) ;виртуальный массив
 .S Vo(qqnump,"A"_qi,40)=1 D:$D(Arg1) CreArV("A"_qi,,,"X540",6) ;Сброс уточнения
 .S qqrfr=$S(qi=1:$E(qqrfr,1,$L(qqrfr)-1)_","""_ZP(1)_""")",1:$E(qqrfr,1,$L(qqrfr)-1)_",Vs(qqnump,""Virt"","""_"A"_(qi-1)_"""),"""_ZP(qi)_""")")
 .S Vo(qqnump,"A"_qi,33)=qqrfr D:$D(Arg1) CreArV("A"_qi,,,"X533",qqrfr) ;имя массива
 .S Vs(qqnump,4,"A"_qi)=1,Vs(qqnump,12,"A"_qi,"C",3)="A"_qi,Vs(qqnump,13,2,"A"_qi_" C")=qi,Vs(qqnump,13,3,qi)="A"_qi_" C"
 .S $$$ObjLqqc("A"_qi)=255 ;????
 .S Vo(qqnump,"A"_qi,0,0,0)="2C" D:$D(Arg1) CreArV("A"_qi,0,0,"x70",2),CreArV("A"_qi,0,0,"X71","C")
 ;учитывается фиксация
 N ZPmax S ZPmax=ZP F ZP=$S($G(Vs($P(qqParent," ",2),99,"Anal",2)):1,1:ZP):1:ZPmax D
 .S qqo="",qs=$O(Vo(qqnump,"A"_ZP,0,""),-1)+qqcref F  S qqo=$O(Vs($P(qqParent," ",2),12,qqo)) Q:qqo=""  I $S($G(Vs($P(qqParent," ",2),7))="":1,1:'$G(Vs($P(qqParent," ",2),7,qqo))) D  ;qs=qqcref
 ..S qqw="" F  S qqw=$O(Vs($P(qqParent," ",2),12,qqo,qqw)) Q:qqw=""  D:$D(Vs($P(qqParent," ",2),12,qqo,qqw,4))
 ...S qs=qs+1,Vo(qqnump,"A"_ZP,0,qs,0)="0Итого: "_qW.GetWoc("CxWoc",qqw) D:$D(Arg1) CreArV("A"_ZP,qs,0,"x70",0),CreArV("A"_ZP,qs,0,"X71",$E(Vo(qqnump,"A"_ZP,0,qs,0),2,3000))
 ...S Vo(qqnump,"A"_ZP,0,qs,1)="3LA"_qqw D:$D(Arg1) CreArV("A"_ZP,qs,1,"x70",3),CreArV("A"_ZP,qs,1,"X71","LA"_qqw)
 ...S Vo(qqnump,"A"_ZP,0,qs,2)="3@ZLA."_qqw D:$D(Arg1) CreArV("A"_ZP,qs,2,"x70",3),CreArV("A"_ZP,qs,2,"X71","@ZLA."_qqw) ;проценты
 ...I ZP=ZPmax S Vs(qqnump,12,"A"_ZP,"LA"_qqw,4)="D" F qi=5:1:9 S Vs(qqnump,12,"A"_ZP,"LA"_qqw,qi)=$G(Vs($P(qqParent," ",2),12,qqo,qqw,qi))
 I qqcref D  ;ссылочные объекты (не учтен вариант нескольких вершин)
 .S qqo=$O(Vs($P(qqParent," ",2),14,"")),Vo(qqnump,"A"_ZP,0,1)=qqo M Vs(qqnump,1,qqo)=Vs($P(qqParent," ",2),1,qqo) D:$D(Arg1) CreArV("A"_ZP,1,,"X60",qqo) D CreArRnew(qqo,$NA(Vs($P(qqParent," ",2),14)),1,qqrfr) ;с переносом зачеркнутых
CreArend ;общий итог
 S qqo="",qs=5 F  S qqo=$O(Vs($P(qqParent," ",2),12,qqo)) Q:qqo=""  D
 .S qqw="" F  S qqw=$O(Vs($P(qqParent," ",2),12,qqo,qqw)) Q:qqw=""  D:$D(Vs($P(qqParent," ",2),12,qqo,qqw,4))
 ..S qs=qs+1,Vo(qqnump,-1,0,qs,0)="0Всего: "_qW.GetWoc("CxWoc",qqw) D:$D(Arg1) CreArV(-1,qs,0,"x70",0),CreArV(-1,qs,0,"X71",$E(Vo(qqnump,-1,0,qs,0),2,3000))
 ..S Vo(qqnump,-1,0,qs,1)="3LA"_qqw D:$D(Arg1) CreArV(-1,qs,1,"x70",3),CreArV(-1,qs,1,"X71","LA"_qqw)
 ..I qAnew S Vo(qqnump,-1,0,qs,2)="3@ZLA."_qqw D:$D(Arg1) CreArV(-1,qs,2,"x70",3),CreArV(-1,qs,2,"X71","@ZLA."_qqw)
 I '$D(Arg1) D ..CreVoAdd() Q:$Q "" Q
 ;Состояние
 I $D(ZP)>1 D
 .F qi=1:1 S qs=$G(Vs($P(qqParent," ",2),13,1,qi)) Q:qs=""  S $P(qs," ",1)=ZP(ZP),$P(qs," ",2)="LA"_$P(qs," ",2),Vs(qqnump,13,1,qi)=qs,Vs(qqnump,13,0,qs)=qi
 .F qi="P","M","S","R","X" M Vs(qqnump,13,qi)=Vs($P(qqParent," ",2),13,qi)
 ;сохраним состояние части исходного отображения
 F qi=3,4,12,13,14 M Vs(qqnump,"Vsold",qi)=Vs($P(qqParent," ",2),qi)
 M Vs(qqnump,"Vsold",99,"Anal")=Vs($P(qqParent," ",2),99,"Anal")
 K ^Q("V"_Arg1,"XObjStat") M ^Q("V"_Arg1,"XObjStat")=Vs(qqnump)
 Q:$Q "" Q
CreArR(qqo,qqre) ;
 N qqso M Vo(qqnump,qqo)=Vo($P(qqParent," ",2),qqo) K Vo(qqnump,qqo,11),Vo(qqnump,qqo,10) I $D(Arg1) M ^Q(1,"XView",Arg1,"CxObj",qqo)=^Q(1,"XView",Vo(qqnump),"CxObj",qqo)
 I '$G(Vo(qqnump,qqo,2)) S Vo(qqnump,qqo,2)=2 I $D(Arg1) S ^Q(1,"XView",Arg1,"CxObj",qqo,"x52")=2  ;если не виртуальный, сделаем ссылочным
 ;ссылки вниз нужно убрать,графы сдвинуть на одну влево
 S qqso="" F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""  D
 .I $G(Vo(qqnump,qqo,0,qqso))'="" K Vo(qqnump,qqo,0,qqso) K:$D(Arg1) ^Q(1,"XView",Arg1,"CxObj",qqo,"Xy",qqso) Q
 .F qi=$O(Vo(qqnump,qqo,0,qqso,""),-1):-1:0 D
 ..M Vo(qqnump,qqo,0,qqso,qi+1)=Vo(qqnump,qqo,0,qqso,qi) K Vo(qqnump,qqo,0,qqso,qi)
 ..I $D(Arg1) M ^Q(1,"XView",Arg1,"CxObj",qqo,"Xy",qqso,"Xx",qi+1)=^Q(1,"XView",Vo(qqnump),"CxObj",qqo,"Xy",qqso,"Xx",qi) K ^Q(1,"XView",Arg1,"CxObj",qqo,"Xy",qqso,"Xx",qi)
 S Vo(qqnump,qqo,0,0,0)="0@" D:$D(Arg1) CreArV(qqo,0,0,"x70",0),CreArV(qqo,0,0,"X71","@")
 D:$G(Vo(qqnump,qqo,7))'=""  ;@Dol 25.05.07 дополнительные незачеркнутые понятия
 .N qii,qqw S qii=$O(Vo(qqnump,qqo,0,0,""),-1) F qi=1:1:$L(Vo(qqnump,qqo,7)," ") S qqw=$P(Vo(qqnump,qqo,7)," ",qi) I '$G(Vs(qqnump,1,qqo,qqw)) S qii=qii+1,Vo(qqnump,qqo,0,0,qii)=2_qqw D:$D(Arg1) CreArV(qqo,0,qii,"x70",2),CreArV(qqo,0,qii,"X71",qqw)
 F  S qqso=$O(@qqre@(qqo,qqso)) Q:qqso=""  S Vo(qqnump,qqo,0,$O(Vo(qqnump,qqo,0,""),-1)+1)=qqso D:$D(Arg1) CreArV(qqo,$O(Vo(qqnump,qqo,0,""),-1)+1,,"X60",qqso) D CreArR(qqso,$NA(@qqre@(qqo)))
 Q
CreArRnew(qqo,qqre,one,qqrfr,qqoold) ;
 N qqso M Vo(qqnump,qqo)=Vo($P(qqParent," ",2),qqo) K Vo(qqnump,qqo,10),Vo(qqnump,qqo,11) I $D(Arg1) M ^Q(1,"XView",Arg1,"CxObj",qqo)=^Q(1,"XView",Vo($P(qqParent," ",2)),"CxObj",qqo) ;@Dol 27.04.05 было Vo(qqnump)
 I $G(one) S Vo(qqnump,qqo,2)=2,Vo(qqnump,qqo,40)=1,qqrfr=$E(qqrfr,1,$L(qqrfr)-1)_",Vs(qqnump,""Virt"","""_"A"_ZP_"""),"""_qqo_""")",Vo(qqnump,qqo,29)="$S('qorder:1,1:$O("_$E(qqrfr,1,$L(qqrfr)-1)_",qqc),qorder))" I $D(Arg1) S ^Q(1,"XView",Arg1,"CxObj",qqo,"x52")=2,^("X529")=Vo(qqnump,qqo,29),^("X540")=1
 I '$G(one),$D(Vs($P(qqParent," ",2),15,qqo)) S Vo(qqnump,qqo,2)=2,Vo(qqnump,qqo,40)=1,qqrfr=$E(qqrfr,1,$L(qqrfr)-1)_",Vs(qqnump,""Virt"","""_qqoold_"""),"""_qqo_""")",Vo(qqnump,qqo,29)="$S('qorder:1,1:$O("_$E(qqrfr,1,$L(qqrfr)-1)_",qqc),qorder))" I $D(Arg1) S ^Q(1,"XView",Arg1,"CxObj",qqo,"x52")=2,^("X529")=Vo(qqnump,qqo,29),^("X540")=1
 ;I '$G(Vo(qqnump,qqo,2)) S Vo(qqnump,qqo,2)=2 I $D(Arg1) S ^Q(1,"XView",Arg1,"CxObj",qqo,"x52")=2  ;если не виртуальный, сделаем ссылочным
 ;ссылки вниз нужно убрать,графы сдвинуть на одну влево
 S qqso="" F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""  D
 .I $G(Vo(qqnump,qqo,0,qqso))'="" K Vo(qqnump,qqo,0,qqso) K:$D(Arg1) ^Q(1,"XView",Arg1,"CxObj",qqo,"Xy",qqso) Q
 .F qi=$O(Vo(qqnump,qqo,0,qqso,""),-1):-1:0 D
 ..M Vo(qqnump,qqo,0,qqso,qi+1)=Vo(qqnump,qqo,0,qqso,qi) K Vo(qqnump,qqo,0,qqso,qi)
 ..I $D(Arg1) M ^Q(1,"XView",Arg1,"CxObj",qqo,"Xy",qqso,"Xx",qi+1)=^Q(1,"XView",Vo($P(qqParent," ",2)),"CxObj",qqo,"Xy",qqso,"Xx",qi) K ^Q(1,"XView",Arg1,"CxObj",qqo,"Xy",qqso,"Xx",qi)
 S Vo(qqnump,qqo,0,0,0)="0@" D:$D(Arg1) CreArV(qqo,0,0,"x70",0),CreArV(qqo,0,0,"X71","@")
 D:$G(Vo(qqnump,qqo,7))'=""  ;@Dol 25.05.07 дополнительные незачеркнутые понятия
 .N qii,qqw S qii=$O(Vo(qqnump,qqo,0,0,""),-1) F qi=1:1:$L(Vo(qqnump,qqo,7)," ") S qqw=$P(Vo(qqnump,qqo,7)," ",qi) I '$G(Vs(qqnump,1,qqo,qqw)) S qii=qii+1,Vo(qqnump,qqo,0,0,qii)=2_qqw D:$D(Arg1) CreArV(qqo,0,qii,"x70",2),CreArV(qqo,0,qii,"X71",qqw)
 F  S qqso=$O(@qqre@(qqo,qqso)) Q:qqso=""  S Vo(qqnump,qqo,0,$O(Vo(qqnump,qqo,0,""),-1)+1)=qqso D:$D(Arg1) CreArV(qqo,$O(Vo(qqnump,qqo,0,""),-1)+1,,"X60",qqso) D CreArRnew(qqso,$NA(@qqre@(qqo)),0,qqrfr,qqo)
 Q
CreArV(Obj,y,x,par,z) ;запись в отображение
 I $G(x)'="" S ^Q(1,"XView",Arg1,"CxObj",Obj,"Xy",y,"Xx",x,par)=z Q
 I $G(y)'="" S ^Q(1,"XView",Arg1,"CxObj",Obj,"Xy",y,par)=z Q
 I $G(Obj)'="" S ^Q(1,"XView",Arg1,"CxObj",Obj,par)=z Q
 S ^Q(1,"XView",Arg1,par)=z Q
]]></Implementation>
</Method>

<Method name="CreArDi">
<Description>
Построение локальных массивов диаграмм.
qqrela - слой отображения аналитики.
nxmax - максимальное кол-во точек по X (2000 по умолчанию)
Создается массив QDiag(Row,Col) .
Ряд 0 - легенда по X
колонка 0 - легенда по У
QDiag = Min Max Масштабирование XYZ Num название</Description>
<Internal/>
<FormalSpec>qqrela:%String,nxmax:%String=2000</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N viewan S viewan=Vo(qqnump)["zz"||(Vo(qqnump)["sysA") ;???$P(qview," ")
 I $G(W("Zar"))'="" S qqrela=W("Zar")
 N qq2,qq4,qq5,qq6,qnRow,Message
 S qqwA="A"_$P($G(Vs(qqnump,12))," ",2) ;главное понятие аналитики
 I viewan S qqrela=$S($P(qview," ")'["sysA":$P(qview," "),1:"A"_$P(qview,"sysA",2)) S qqwA=$P($G(Vs(qqnump,12))," ",1) ;отображение архивной аналитики
 ;I viewan S qqrela=$S(Vo(qqnump)'["sysA":Vo(qqnump),1:"A"_$P(qview,"sysA",2)) S qqwA=$P($G(Vs(qqnump,12))," ",1) ;отображение архивной аналитики
 S qq4="^Qa(qqrela,qqwA)" ;временно   
 I '$D(^Qa(qqrela)) Q "0Не построен аналитический срез "_qqrela
 I $O(Vs(qqnump,13,1,""))="" Q "0Не определен Y."
 ;Порог
 S qq2=+$G(Vs(qqnump,13,"P")) I qq2 S %1=Vs(qqnump,13,1,1),qq2=$S('viewan:Vs(qqnump,12,$P(%1," "),$P(%1," ",2),5),1:$LI($G(^Qa(qqla,$P(%1," ",2)))))*(qq2/100)
 ;
 N Nd1,Nd2,Nd3,Row,Pt 
 N Min,Max,Mid,PtMax,Sum
 N qqZ,qqwY
 S qnRow=$O(Vs(qqnump,13,1,""),-1) ;кол-во рядов
 S qqZA=$O(Vs(qqnump,13,3,""),-1)-1 ;кол-во аналитик-1
 S qqZ=qqZA>0&($G(Vs(qqnump,13,"X"))) ;диаграмма XYZ
 I qqZ S qqwY=$S('viewan:"A"_$P(Vs(qqnump,13,3,2)," ",2),1:$P(Vs(qqnump,13,3,2)," ",1))
 N QDI,QDD,QDZ,QDZ1,QDI1 ;временный массив
 K QDiag,QDiagYL
 ;заголовок X
 S %3=$G(Vs(qqnump,12,$P(Vs(qqnump,12)," "),$P(Vs(qqnump,12)," ",2),1)) S:$E(%3)="-" %3=$E(%3,2,10000)
 S:%3="" %3=$$CreArDiN($P(Vs(qqnump,12)," ",1),$P(Vs(qqnump,12)," ",2)) I 'qqZ,qqZA D  ;составное;%3=qW.GetWoc("CxWoc",$P(Vs(qqnump,12)," ",2))
 .F i=2:1:qqZA+1 S %3=%3_"~"_$$CreArDiN($P(Vs(qqnump,13,3,i)," ",1),$P(Vs(qqnump,13,3,i)," ",2)) ;qW.GetWoc("CxWoc",$P(Vs(qqnump,13,3,i)," ",2))
 S QDiag(0,0)=$TR(%3,"_"," ")_$S('qqZ:"",1:"\"_$$CreArDiN($P(Vs(qqnump,13,3,2)," ",1),$E(qqwY,2,100))) ;qW.GetWoc("CxWoc",$E(qqwY,2,100)))
 ;
 S %13=$G(Vs(qqnump,13,"M")) S:%13=1&qqZ %13=0 ;$S(qqZ:0,1:$G(Vs(qqnump,13,"M"))) ;включено масштабирование
 S %14=$S(qqZ:0,1:+$G(Vs(qqnump,13,"S"))) ;включена упорядоченность
 S %2="",Min="",Max="",Nd1=0,Mid="" 
 S %22="",%33=0,%44=0
 I 'qqZ,qqZA D  G CreArDi0 ;обход по составной аналитики
 .S qqp4=qq4 F  S qqp4=$Q(@qqp4) Q:qqp4=""  Q:$QS(qqp4,2)'=qqwA  I $QL(qqp4)=(qqZA+1*2+2),$E($QS(qqp4,$QL(qqp4)),1,2)="LA" S qqp4=$NA(@qqp4,$QL(qqp4)-1) D  S qqp4=$NA(@qqp4@("яяя"))
 ..S qq5=$$wcfxr(1),%1=$LG($G(@qqp4@($P(qq5," "))),1) Q:%1<qq2
 ..S Nd1=Nd1+1
 ..S QDI(Nd1)=qqp4
 ..;I '%14 S QDiag(0,Nd1)=qqp4
 ..F Row=1:1:qnRow S qq5=$$wcfxr(Row) D
 ...S %1=$LG($G(@qqp4@($P(qq5," "))),$P(qq5," ",2))
 ...I Row=%14 S QDD(+%1,Nd1)=qqp4
 ...I %13 S:$G(Min(Row))="" Min(Row)=+%1 S:$G(Max(Row))="" Max(Row)=+%1 S:%1<Min(Row) Min(Row)=+%1 S:%1>Max(Row) Max(Row)=+%1 S Mid(Row)=$G(Mid(Row))+%1
 ...S:Min="" Min=+%1 S:Max="" Max=+%1 S:%1<Min Min=+%1 S:%1>Max Max=+%1 ;S Mid=Mid+%1
 S Nd3=0 ;
 F Pt=0:1 S %22=$O(@qq4@(%22)) Q:%22=""  S %2=%22 D:'qqZ  Q:%33>nxmax  I qqZ S %2="" F  S %2=$O(@qq4@(%22,qqwY,%2)) Q:%2=""  D  Q:%33>nxmax
 .S qq5=$$wcfxr(1),%1=$LG($G(^(%2,$P(qq5," "))),1) Q:%1<qq2  S %33=%33+1 ;отсекаем по порогу
 .I qqZ,'$D(QDZ(%2)) S QDZ(%2)="" S:Pt %44=1 ;полный перечень значений по Y (%44=1 - наличия отсутствия значения)
 .D:'$D(QDI1(%22))
 ..S QDI1(%22)="" ;полный перечень по Х
 ..S Nd1=Nd1+1
 ..S QDI(Nd1)=%22
 ..I '%14 S QDiag(0,Nd1)=%22
 .F Row=1:1:$S(qqZ:1,1:qnRow) S qq5=$$wcfxr(Row) D
 ..S %1=$LG($G(@$S('qqZ:qq4,1:"^Qa(qqrela,qqwA,%22,qqwY)")@(%2,$P(qq5," "))),$P(qq5," ",2))
 ..I Row=%14 S QDD(+%1,Nd1)=%2
 ..I %13 S:qqZ Nd3=Nd3+1 S:$G(Min(Row))="" Min(Row)=+%1 S:$G(Max(Row))="" Max(Row)=+%1 S:%1<Min(Row) Min(Row)=+%1 S:%1>Max(Row) Max(Row)=+%1 S Mid(Row)=$G(Mid(Row))+%1
 ..S:Min="" Min=+%1 S:Max="" Max=+%1 S:%1<Min Min=+%1 S:%1>Max Max=+%1 S Mid=$G(Mid)+%1
CreArDi0 I Min="",Max="" Q "0Нет значений для заданного порога"
 I %33>nxmax S Message="Более "_nxmax_" точек. Необходимо увеличить порог" Q 0_Message ;????
 ;центровка для выводимых средних значений ; возъмем средние и откорректируем min, max (отцентрируем)
 I %13=3 D
 .I qqZ ;S Min(1)=Min,Max(1)=Max ;,Mid(1)=Mid
 .F Row=1:1:$S(qqZ:1,1:qnRow) S qq5=Vs(qqnump,13,1,Row),Mid(Row)=$S($P(qq5," ",3)'=9:Mid(Row)/$S(qqZ:Nd3,1:Nd1),1:$G(Vs(qqnump,12,$P(qq5," ",1),$P(qq5," ",2),$P(qq5," ",3)))) D:Mid(Row)'=""
 ..S %1=$ZABS(Max(Row)-Mid(Row)),%2=$ZABS(Mid(Row)-Min(Row))
 ..I %1>%2 S Min(Row)=Mid(Row)-(Max(Row)-Mid(Row)) Q
 ..I %2>%1 S Max(Row)=Mid(Row)+(Mid(Row)-Min(Row)) Q
 .I qqZ S Mid=Mid(1)
 I '%13 S qq5=Vs(qqnump,13,1,1),Mid=$S($P(qq5," ",3)'=9:"",1:$G(Vs(qqnump,12,$P(qq5," ",1),$P(qq5," ",2),$P(qq5," ",3)))) D:Mid'=""
 .S Mid(1)=Mid
 .S %1=$ZABS(Max-Mid),%2=$ZABS(Mid-Min)
 .I %1>%2 S Min=Mid-(Max-Mid) Q
 .I %2>%1 S Max=Mid+(Mid-Min) Q
 I qqZ,%44 S:Min>0 Min=0 S:Max<0 Max=0 ;отсутствие значения приравнено к 0 ???
 D
 .I %13=3,qqZ!(qnRow=1) S Min=$$norm(Min(1)-Mid(1),1),Max=$$norm(Max(1)-Mid(1),1) Q
 .I %13 S Min=$S(%13=3:-100,1:0),Max=100 Q
 .S Min=$$norm(Min,1),Max=$$norm(Max,1)
 S QDiag=Min_" "_Max_" "_%13_" "_qqZ_" "_$S(qqZ:$$wcfxh(1),1:"")_$S(%13'=3:"",'qqZ&(qnRow'=1):"",1:" Mid="_$$norm(Mid(1)))
 I %14 S %1="",%3=1 F  S %1=$O(QDD(%1)) Q:%1=""  S %2="" F  S %2=$O(QDD(%1,%2)) Q:%2=""  D
 .S QDI(%3)=QDD(%1,%2) S QDiag(0,%3)=QDI(%3),%3=%3+1
 ;I qnRow=1 S Row=1,QDiag=QDiag_" "_$TR($$wcfxh(1)_$S('%13:"",1:" "_$J(Min(Row),0,2)_"-"_$J(Max(Row),0,2)_" 1:"_$J(Max(Row)-Min(Row)/100,0,2))," ","_") ;заголовок по У, если один  ряд
 S QDI=Nd1
 I 'qqZ,qqZA D  ;сделаем правильный X для объединенных аналитик
 .F i=1:1:QDI D
 ..S %22="" F j=3:2:qqZA+1*2+1 S %22=%22_"~"_$QS(QDI(i),j)
 ..S QDiag(0,i)=$E(%22,2,30000)
 S PtMax=Nd1+1 ;-1
 D:%13=3  ;разрисуем Y-легенду
 .F i=-10:1:10 S %1="" D  S QDiagYL(i)=%1
 ..;?I '%13!qqZ S %1=$J(Min+(Max-Min*i/10),6,2) Q 
 ..F Row=1:1:qnRow D
 ...I Mid(Row)'="" S %1=%1_" "_$S(i=0:$J(Mid(Row),6,2),i>0:$J(Mid(Row)+(Max(Row)-Mid(Row)*i/10),6,2),1:$J(Mid(Row)-(Mid(Row)-Min(Row)*-i/10),6,2)) Q
 ...S %1=%1_" "_$S(i<0:$J("",9),1:$J(Min(Row)+(Max(Row)-Min(Row)*i/10),6,2))
 D:%13'=3  ;разрисуем Y-легенду
 .F i=0:1:10 S %1="" D  S QDiagYL(i)=%1
 ..I %13=2 S %1=$J(i*10_"%",4) Q  ;взвешивание
 ..I '%13!qqZ S %1=$J(Min+(Max-Min*i/10),6,2) Q 
 ..F Row=1:1:qnRow S %1=%1_" "_($J(Min(Row)+(Max(Row)-Min(Row)*i/10),6,2))
 I qqZ D
 .S %1="" F qnRow=1:1 S %1=$O(QDZ(%1)) Q:%1=""  S QDZ1(qnRow)=%1
 .S qnRow=qnRow-1
 S %14=$E($G(Vs(qqnump,13,"S")),2)="-" D:%14  ;пересортировка колонки 0 (можно было сделать получше)
 .F Pt=1:1:QDI\2 S %1=QDiag(0,Pt),QDiag(0,Pt)=QDiag(0,QDI-Pt+1),QDiag(0,QDI-Pt+1)=%1
 S Nd1="" F Row=1:1:qnRow  D
 .I 'qqZ D
 ..S qq5=$$wcfxr(Row)
 ..S QDiag(Row,0)=$$wcfxh(Row)
 .I qqZ D
 ..S qq5=$$wcfxr(1)
 ..S QDiag(Row,0)=QDZ1(Row)
 .F Pt=1:1:QDI S Nd2=$S('%14:QDI(Pt),1:QDI(QDI-Pt+1)) D
 ..S %2="",%11=$S('qqZ:$S('qqZA:$LG($G(@qq4@(Nd2,$P(qq5," "))),$P(qq5," ",2)),1:$LG($G(@Nd2@($P(qq5," "))),$P(qq5," ",2))),1:$LG($G(@qq4@(Nd2,qqwY,QDZ1(Row),$P(qq5," "))),$P(qq5," ",2))),%1=$S('$P(qq5," ",3):+%11,1:%11)
 ..D
 ...I '%13 S %2=$S(Max=Min:100,1:$J(%1-Min*100/(Max-Min),0,0)) Q
 ...I %13=1 S %2=$S(Max(Row)=Min(Row):100,1:$J(%1-Min(Row)*100/(Max(Row)-Min(Row)),0,0)) Q  ;нормирование
 ...I %13=2 S:'qqZ Sum(Row)=$G(Sum(Row))+%1 S:qqZ Sum=$G(Sum)+%1 Q  ;для средневзвешенных
 ...I %13=3,'qqZ,qnRow'=1 S %2=$S(Mid(Row)="":$J(%1-Min(Row)*100/(Max(Row)-Min(Row)),0,0),%1=Mid(Row):0,%1>Mid(Row):$J(%1-Mid(Row)*100/(Max(Row)-Mid(Row)),0,0),1:$J(%1-Mid(Row)*100/(Mid(Row)-Min(Row)),0,0)) Q
 ...I %13=3 S:%11="" %1=Mid(1) S %2=$S(Mid(1)="":$J(%1-Min(1)*100/(Max(1)-Min(1)),0,0),%1=Mid(1):0,%1>Mid(1):$J(%1-Mid(1)*100/(Max(1)-Mid(1)),0,0),1:$J(%1-Mid(1)*100/(Mid(1)-Min(1)),0,0)) S %1=%1-Mid(1) Q
 ..S QDiag(Row,Pt)=$S('$P(qq5," ",3):$$norm(%1)_" "_%2,1:%1) ;@Dol 23.03.08
 ;пересчет средневзвешенных
 I %13=2 D
 .S Max=0
 .F Row=1:1:qnRow F Pt=1:1:QDI S (%1,QDiag(Row,Pt))=$S('+($S(qqZ:Sum,1:Sum(Row))):0,1:$J(QDiag(Row,Pt)*100/$S(qqZ:Sum,1:Sum(Row)),0,1))_"%/"_QDiag(Row,Pt) S:%1>Max Max=+%1
 .Q:Max>70  S $P(QDiag," ",2)=Max
 .F i=0:1:10 D  S QDiagYL(i)=%1
 ..S %1=$J(Max-Min*i/10,6,2)_"%"
 ;получить итоги; @dol 25.12.02
 K QDiagI I 'qqZ F Row=1:1:qnRow S qq5=$$wcfxr(Row),QDiagI(Row)=$S(%13=2:"100%/",%13=3:"0/",1:"")_+$$norm($LG($G(^Qa(qqrela,$P(qq5," ",1))),$P(qq5," ",2)))
 ;K ^QDiag,^QDiagYL M ^QDiag=QDiag,^QDiagYL=QDiagYL 
 Q 1_$G(Message)
norm(n,c) ;округление
 Q:nxmax>2000 n ;@Dol 04.06.09 при выводе на печать не округлять
 I n["." S %3=$P(n,".",2),%3=$L($P(%3,$E($TR(%3,"0")))),%4=$P($ZABS(n),"."),%4=$S(%4=0:0,1:$L(%4)),n=$S($G(c):$S(%4>0:$J(n,0,0),1:$J(n,0,1)),%4>2:$J(n,0,0),%4>1:$J(n,0,1),1:$J(n,0,2+%3)) ;%4>1:$J(n,0,2),1:n) ;округление
 Q n
wcfxr(qqRow) ;получить для ряда параметры
 S qqRow=Vs(qqnump,13,1,qqRow)
 Q $S(viewan:"",1:"LA")_$P(qqRow," ",2)_" "_($P(qqRow," ",3)-4)_$S($P(qqRow," ",3)'=6:"",$G(Vs(qqnump,12,$P(qqRow," ",1),$P(qqRow," ",2),4,1)):" 1",1:"") ;@Dol 23.03.08 если Sum - значение
wcfxh(qqRow) ;получить для ряда заголовок
 N qqRow1 S qqRow=Vs(qqnump,13,1,qqRow)
 S qqRow1=$G(Vs(qqnump,12,$P(qqRow," "),$P(qqRow," ",2),1))
 I qqRow1="" S qqRow1=qARM.GetName(,$P(qqRow," "),$P(qqRow," ",2)) ;qW.GetWoc("CxWoc",$P(qqRow," ",2))
 Q $S($E(qqRow1)="-":$TR($E(qqRow1,2,1000),"_"," "),$G(Vs(qqnump,12,$P(qqRow," "),$P(qqRow," ",2),4,1)):$TR(qqRow1,"_"," "),1:$P("Num Sum Min Max Mid Dmid"," ",$P(qqRow," ",3)-4)_" "_$TR(qqRow1,"_"," "))
 ;имя;@Dol 7.12.06
CreArDiN(qo,qw)
 I $G(Vs(qqnump,12,qo,qw,1))'="" Q $S($E(Vs(qqnump,12,qo,qw,1))="-":$E(Vs(qqnump,12,qo,qw,1),2,1000),1:Vs(qqnump,12,qo,qw,1)) ;имя задано во второй строке аналитики
 Q qARM.GetName(,qo,qw)
]]></Implementation>
</Method>

<Method name="CreArY">
<Description>
Создание отображения Аналитики для вывода в Приемник-Печать
Arg1 = "" - виртуальное, иначе - код отображения архива</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;N qqpar2 
 I '$D(Arg1) S qqpar2="A"_qqpar2_$S(quser="#":"",quser="U":" "_$J,1:" "_quser)
 I $D(Arg1) N qqpar2,qqParent S qqpar2=Arg1,qqParent=" "_qqnump N qqnump S qqnump="Ar" K Vo(qqnump),Vs(qqnump),^Q(1,"XView",Arg1) ;временное псевдо-экран K ^Q(1,"XView",Arg1)
 ;
 N qqnumpold,xyz S qqnumpold=$P(qqParent," ",2) S xyz=$G(Vs(qqnumpold,13,"X")) ;S xyz=$G(Vs(qqnump,13,"X"))&'$D(QDiagI),qqnumpold=qqnump D qARM.csav() 
 N par,leg,sum,sumx,sump,sumxp,sumn,y,y1,y2,x,x1,xmax,ymax,qqdev,oZVs8,yadd,xstr,ftree,zz,flist,flistP,nP,flist1,xp,Xp,flistN,XQth,XQia,XQtc
 ;N qqnump S qqnump="D" 
 ;????,ymax=$O(QDiag(""),-1)+xyz,xmax=$O(QDiag(0,""),-1) ;xyz - трехмерная ;Xp
 S ftree=$G(Vs(qqnumpold,99,"Anal",2)) S:xyz ftree=0 ;полное дерево
 I ftree S ftree=ftree_" ",y="" F  S y=$O(Vs(qqnumpold,13,3,y)) Q:y=""  S x=Vs(qqnumpold,13,3,y) I $G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),3,1)) S ftree=ftree_y_" " ;список неподсчитываемых сумм по аналитикам
 S (flist1,flist,flistN)=" ",y="",flistP="" F  S y=$O(Vs(qqnumpold,13,1,y)) Q:y=""  S x=Vs(qqnumpold,13,1,y) S:$G(Vs(qqnumpold,13,0,x,1)) flistN=flistN_y_" " I $P(x," ",3)=6,$G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),4,1)) S flist=flist_y_" " S:$G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),4,1))=1||($G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),4,1))=4) flist1=flist1_y_" " S:$G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),4,1))=3 flistP=flistP_y_" " ;неподсчитываемые суммы, flist1 - список первых/последних значений, flistP - полные списки;@Dol 22.01.10 4 - последнее;@Dol 22.09.10 flistN - Без сумм
 I flistP'="" S flistP=" "_flistP ;@Dol 1.10.08 полные списки
 I $G(qqoQu)="" N qqoQu,query S qqoQu=99999,query=9999 ;если не запрос
 I $G(query)="" S query=9999 ;@Dol 30.04.09
 ;
 ;N qqcref 
 ;K Vs(qqnump,14) M Vs(qqnump,14)=Vs($P(qqParent," ",2),14)
 S qqcref=''$D(Vs(qqnumpold,14))
 N qqo,qqwA,qi,qii,qqso,qqref
 K ZP,ZA ;массивы понятий аналитик и значений
 K qqref S qqref="^Q(qql)" F ZP=1:1:$O(Vs(qqnumpold,13,3,""),-1) S ZP(ZP)="A"_$P(Vs(qqnumpold,13,3,ZP)," ",2),(qqref,qqref(ZP))=$E(qqref,1,$L(qqref)-1)_",ZP("_ZP_"),ZA("_ZP_"))"
 S Vo(qqnump,-1)=$S('$D(Arg1):"Аналитика...",1:$G(^Q(1,"XView",Arg1,"X11"),"Аналитика...")) D:$D(Arg1) CreArYV(,,,"X11",Vo(qqnump,-1))
 N qAnew S qAnew=1
 ;
 I qqnump="P",$G(Vo(qqnumpold))["sysY" M Vo(qqnump)=Vo(qqnumpold),Vt(qqnump)=Vt(qqnumpold) M:0 Vs(qqnump,1)=Vs(qqnumpold,1) Q "" ;,Vs(qqnump)=Vs(qqnumpold) Q "" ;печать из отображения аналитики
 N qqrfr,qqrfri S qqrfr="^Qa("""_qqpar2_""")"
 S Vo(qqnump,-1,27)="-",Vo(qqnump,-1,28)="-" D:$D(Arg1) CreArYV(,,,"X127",Vo(qqnump,-1,27)),CreArYV(,,,"X128",Vo(qqnump,-1,28))
 S Vo(qqnump,-1,23)="S (qqo,Vs(qqnump,""CurObj""))=""-1"",qqc=""""" D:$D(Arg1) CreArYV(,,,"X123",Vo(qqnump,-1,23)) ;действие по входу
 S Vo(qqnump,-1,3,25)="K Vs(qqnump,""Virt"") S (qqo,Vs(qqnump,""CurObj""))=""-1"",qqc=""""" S:$D(Arg1) ^Q(1,"XView",Arg1,"XPrint",0,"X325")=Vo(qqnump,-1,3,25) ;;действие по входу (печать)
 S $$$Tree=0 D:$D(Arg1) CreArYV(,,,"x121",0)
 S Vo(qqnump,-1,89)=1 ;???D:$D(Arg1) CreArYV(,,,"X189",1) ;наследование релевантных
 ;
 ;;S Vo(qqnump,-1,0,1,0)="5$ZDT(qW.zCnv(0,qW.G(""Xc"")),4)_"" ""_$E(qW.G(""Xc""),6,255)" D:$D(Arg1) CreArYV(-1,1,0,"x70",5),CreArYV(-1,1,0,"X71",$E(Vo(qqnump,-1,0,1,0),2,3000)) ;информация о создании
 ;
 ;создание отображения в памяти
 S par=$G(Vs(qqnumpold,13,"R")) ;@Dol 30.04.09 доп.пар. $P(par," ",8)- размер колонки Nп\п, 9 - повтор одинаковых, 10- наследование типа данных аналитик , 11 - наследование параметров аналитик, 12, 13 - агрегатов (12 пока не работает), 14 -Nп.п для A1, 15 - без ИТОГО, 16 - замена пустых (???)
 ;
 S Vo(qqnump,-1)="Таблица диаграммы"
 S yadd=ZP ;;;$L(QDiag(0,0),"~") ;колонки аналитик (A )
 S ymax=$O(Vs(qqnumpold,13,1,""),-1) ;колонки выводимых агрегатов ( Y)
 S xp=$G(Vs(qqnumpold,13,"Xp")) ;;;;; I xp D  ;@Dol 10.03.09 раскладка по последнему измерению
 ;.I $D(QDiagI) M:ftree sum=QDiagI F y1=1:1:ymax I $G(QDiagI(y1))'="" S QDiagI(y1)=0 ;сброс итоговых сумм для пересчета
 ;.S zz=1 F x=1:1:xmax D
 ;..S y=$G(Xp(0,$P(QDiag(0,x),"~",yadd))) I 'y S y=$I(Xp),Xp(0,$P(QDiag(0,x),"~",yadd))=y,Xp(y)=$P(QDiag(0,x),"~",yadd) F y1=1:1:ymax S y2=ymax*(y-1)+y1 S:flist[(" "_y1_" ") flist=flist_y2_" " S:flist1[(" "_y1_" ") flist1=flist1_y2_" " S:flistP[(" "_y1_" ") flistP=flistP_y2_" " S:flistN[(" "_y1_" ") flistN=flistN_y2_" "
 ;..I x>1 S zz=$S($P(QDiag(0,x),"~",1,yadd-1)=$P(QDiag(0,zz),"~",1,yadd-1):zz,1:x)
 ;..F y1=1:1:ymax D
 ;...S y2=ymax*(y-1)+y1 I $G(QDiagI(y1))'="",$I(QDiagI(y2),QDiag(y1,x))!1,ftree,ftree'[(" "_yadd_" "),$I(sumn(zz,y1),QDiag(y1,x))
 ;...Q:y=1&&(zz=x)  S QDiag(y2,zz)=QDiag(y1,x),QDiag(y1,x)=""
 ;..K:zz'=x QDiag(0,x)
 ;.I ftree,ftree'[(" "_yadd_" ") S Xp=Xp+1,Xp(Xp)="Всего" D
 ;..F x=1:1:xmax I $D(sumn(x))>1 F y1=1:1:ymax I $D(sumn(x,y1)) S QDiag(ymax*(Xp-1)+y1,x)=sumn(x,y1)
 ;..F y1=1:1:ymax I $D(sum(y1)) S QDiagI(ymax*(Xp-1)+y1)=sum(y1)
 ;.K sum,sumn
 ;.S yadd=yadd-1,xp=ymax,ymax=ymax*Xp
 ;;
 S Vo(qqnump,-1,9)=ymax+yadd ;+1 для N
 S $$$Tree=0
 S XQth=+$G(^Q(1,qqoQu,query,"XQth")) ;повторяющийся заголовок таблицы  2011/01/28
 S XQia=+$G(^Q(1,qqoQu,query,"XQia")) ;заменять в  промежуточных итогах "**ВСЕГО" на занчение аналитики 2011/01/28
 S XQtc=$S($G(Vs(qqnumpold,99,"Anal",2)):$G(^Q(1,qqoQu,query,"XQtc")),1:"") ;цвет фона для ячеек итогов
 S leg=$G(^Q(1,qqoQu,query,"XQLeg")) ;S:leg="" leg=ymax>5 ;&xyz ;вывести легенду
 D:'leg!1  ;ПОКА ВСЕГДА БЕЗ ЛЕГЕНДЫ
 .S Vo(qqnump,-1,0,6)="A"_1 ;ссылка на объект Xy (если будут еще строки в объекте -1, заменить 5 на первую свободную
 .F y=0:1:ymax-''xyz D
 ..I y D  Q
 ...S x=$$DiagCol(y,1) I $P(x,",",1)="",$P(par," ",13) S x=$$DiagPar(y,1)
 ...S x1="" I $P(par," ",12)!1 S x1=$$DiagName(y,1)
 ...S y1=y+yadd S:'x Vo(qqnump,-1,0,0,y1,2)=$S($P(x,",")=0:0,1:8) S Vo(qqnump,-1,0,5,y1)="0"_$S(y=ymax&xyz:"ВСЕГО",x1'="":x1,1:$TR($G(QDiag($S($G(xp):$S(y#xp:y#xp,1:xp),1:y),0)),"_"," ")),Vo(qqnump,-1,0,5,y1,2)=",1,5,,1,,,,,2" ;@Dol $S($P(x,",")=0:0,1:8) для зачеркивания  колонок
 ...S:Vo(qqnump,-1,0,5,y1)[";;" Vo(qqnump,-1,0,5,y1)="0"_$P(Vo(qqnump,-1,0,5,y1),";;",2) ;@Dol 20.05.10 для A и D
 ...S Vo(qqnump,"A"_ZP,0,0,y1,64)=1  S x1=$$Diag710(y,1) S:x1'="" Vo(qqnump,"A"_ZP,0,0,y1,10)=x1 ;тип данных ;@Dol 23.09.10 было I $P(par," ",12) S x1=
 ...S Vo(qqnump,"A"_ZP,0,0,y1,2)=$S(x'="":x,1:","_$S(flist[(" "_y_" "):",",1:"2,")_",,,,,,,2") 
 ...S:$P(Vo(qqnump,"A"_ZP,0,0,y1,2),",",2)=""&&(flist'[(" "_y_" ")) $P(Vo(qqnump,"A"_ZP,0,0,y1,2),",",2)=2 Q  ;@Dol 29.09.08 flist
 ..F y1=0:1:yadd D
 ...S x=$$DiagCol(y1,3) I $P(x,",",1)="",y1,$P(par," ",11) S x=$$DiagPar(y1,3)
 ...S x1="" I y1,$P(par," ",11)!1 S x1=$$DiagName(y1,3)
 ...S Vo(qqnump,-1,0,0,y1,2)=$S('y1:$S($P(par," ",8)="":2,1:$P(par," ",8)),$P(x,",")'="":$P(x,","),y1=1:20,1:10)
 ...S Vo(qqnump,-1,0,5,y1)="0"_$S('y1:$C(185),x1'="":x1,1:$TR($P(QDiag(y,0),"~",y1),"_"," "))
 ...S:Vo(qqnump,-1,0,5,y1)[";;" Vo(qqnump,-1,0,5,y1)=$P(Vo(qqnump,-1,0,5,y1),";;",1) ;@Dol 20.05.10 для A и D
 ...S Vo(qqnump,-1,0,5,y1,2)=",1,5,,1,,,,,2"_$S(XQth=1:",,,,,,,1",1:"") ;;;,Vo(qqnump,"A"_ZP,0,0,y1)="5$G(^CacheTempDiagXML($J,qqc,"_y1_"),""~"")"
 ...S:(y1=1)&&(XQtc'="") Vo(qqnump,"A"_ZP,0,0,y1,20)="@$S($G(^CacheTempDiagXML($J,qqc,"""_y1_"x720""))=1:""*0,"_XQtc_",,,1"",1:"""")"
 ...I y1 S x1=$$Diag710(y1,3) S:x1'="" Vo(qqnump,"A"_ZP,0,0,y1,10)=x1 ;тип данных ;@Dol 23.09.10 было I y1,$P(par," ",10)
 ...S Vo(qqnump,"A"_ZP,0,0,y1,64)=1,Vo(qqnump,"A"_ZP,0,0,y1,2)=$S(x'="":x,1:","_$S('y1:$S($P(par," ",8)="":2,1:$P(par," ",8))_",,,1",1:",,,")_",,,,,2") ;c обрамлением ячеек
 .F y1=0:1:$O(Vo(qqnump,"A"_ZP,0,0,""),-1) D DiagParC ;@Dol 20.05.10
 .Q:'xp  S Vo(qqnump,-1,0,4,0)="0"_$TR($P(QDiag(0,0),"~",yadd+1),"_"," ")_": ",Vo(qqnump,-1,0,4,0,2)=",2,,,,,,,,2"_$S(XQth=1:",,,,,,,1",1:""),x=0 F y=yadd+1:xp:ymax+yadd S Vo(qqnump,-1,0,4,y)="0"_Xp($I(x)),Vo(qqnump,-1,0,4,y,2)=",1,,,1,,,,,2"
 ;D:leg  ;ПОКА ВСЕГДА БЕЗ ЛЕГЕНДЫ
 ;.F y=1:1:ymax-''xyz S Vo(qqnump,-1,0,3+y,1)="0"_$J(y,3)_"."_$TR(QDiag($S($G(xp):y#xp+1,1:y),0),"_"," ") ;0->1
 ;.F y=0:1:ymax D
 ;..I y D  Q
 ;...S x=$$DiagCol(y,1) I $P(x,",",1)="",$P(par," ",12) S x=$$DiagPar(y,1)
 ;...S y1=y+yadd S:'x Vo(qqnump,-1,0,0,y1,2)=$S($P(x,",")=0:0,1:8) S Vo(qqnump,-1,0,3+ymax+1,y1)="0"_$S(y=ymax&xyz:"ВСЕГО:",1:$C(160)_y_$C(160)),Vo(qqnump,-1,0,3+ymax+1,y1,2)=",1,5,,1,,,,,2",Vo(qqnump,"A"_ZP,0,0,y1)="5$G(^CacheTempDiagXML($J,qqc,"_y1_"),""~"")" S Vo(qqnump,"A"_ZP,0,0,y1,2)=$S(x'="":x,1:","_$S(flist[(" "_y_" "):",",1:"2,")_",,,,,,,2") Q  ;c обрамлением ячеек
 ;..F y1=0:1:yadd D
 ;...S x=$$DiagCol(y1,3) I y1,$P(par," ",11) S x1=$$DiagName(y1,3)
 ;...S Vo(qqnump,-1,0,0,y1,2)=$S('y1:$S($P(par," ",8)="":2,1:$P(par," ",8)),$P(x,",")'="":$P(x,","),y1=1:20,1:10),Vo(qqnump,-1,0,3+ymax+1,y1)="0"_$S('y1:$C(185),1:$TR($P(QDiag(y,0),"~",y1),"_"," ")),Vo(qqnump,-1,0,3+ymax+1,y1,2)=",1,5,,1,,,,,2",Vo(qqnump,"A"_ZP,0,0,y1)="5$G(^CacheTempDiagXML($J,qqc,"_y1_"),""~"")" S Vo(qqnump,"A"_ZP,0,0,y1,2)=$S(x'="":x,1:","_$S('y1:$S($P(par," ",8)="":2,1:$P(par," ",8))_",,,1",1:",,,")_",,,,,2") ;c обрамлением ячеек
 ;.S Vo(qqnump,-1,0,3+ymax+('xyz),0)="0 " ;пустая строка
 ;.S Vo(qqnump,-1,0,3+ymax+2+('xyz))="A"_ZP
 ;
 
 S Vo(qqnump,-1,65)=2 ;вывод пустых
 ;
 ;;;;S Vo(qqnump,-1,61)=1 
 S Vo(qqnump,-1,3,21)=0 ;вывод в виде бланка
 I $G(^Q(1,qqoQu,query,"XQnp")),'$G(qqXBPrttoOOW) S Vo(qqnump,-1,3,62)="XXXNumPageR",Vo(qqnump,-1,3,620)=0 ;@Dol 05.03.10 колонтитул с номером страницы (пока для OOW нельзя)
 S Vo(qqnump,-1,3,691)=1 ;сохранять размеры колонок
 S Vo(qqnump,-1,3,698)=1 ;учет динамических параметров
 S Vo(qqnump,-1,3,699)=''$G(^Q(1,qqoQu,query,"XQew"))  ; @rda 20110408 учет флага "Не вписывать в ширину страницы" для печати в Excel
 S Vo(qqnump,-1,3,641)="1pt 1pt 1pt 1pt" ;отступы
 S Vo(qqnump,-1,3,64)=$S($G(^Q(1,qqoQu,query,"X364"))'="":^("X364"),1:" "_(ymax+yadd>7)_"  10  10") S:$P(Vo(qqnump,-1,3,64)," ",1)="" $P(Vo(qqnump,-1,3,64)," ",1)="A4" S:'$P(Vo(qqnump,-1,3,64)," ",4) $P(Vo(qqnump,-1,3,64)," ",4)=10 S:'$P(Vo(qqnump,-1,3,64)," ",6) $P(Vo(qqnump,-1,3,64)," ",6)=10 ;параметры страницы ;больше 7 колонок - албом
 S Vo(qqnump,-1,3,55)=$S($G(^Q(1,qqoQu,query,"X355"))'="":^("X355"),1:",9") ;основной фонт
 K ^CacheTempDiagXML($J)
 ;Vs(qqnumpold,120,2) - заголовок аналитики (первая строка - заголовок, затем строки подвала)
 S x=$G(^Q(1,qqoQu,query,"XQTitle")) S:$E(x)="@" @("x="_$E(x,2,30000)) S:x="" x=$P($G(Vs(qqnumpold,120,2)),$C(13,10))
 F x1=0:1:5 Q:$P($G(Vo(qqnump,-1,0,0,x1,2)),",")'=0  ;02.06.09 первая незачеркнутая
 I x="" S Vo(qqnump,-1,0,1,x1)="0"_$S(x'="":x,1:"Таблица распределения """_$TR($G(QDiag(0,0)),"~","/")_$S('xyz:"",1:" ("_$P($G(QDiag)," ",5,255)_")")_""""),Vo(qqnump,-1,0,1,x1,2)=",1,1,10,1" I 1
 E  D  ;@Dol 28.07.10 печать шапки по строкам
 .S Vo(qqnump,-1,0,1)="s"
 .S Vo(qqnump,"s",2)=6,Vo(qqnump,"s",33)="^CacheTempDiagXML($J,""s"")",Vo(qqnump,"s",0,0,x1)="5$G(^CacheTempDiagXML($J,""s"",qqc))",Vo(qqnump,"s",0,0,x1,64)=1
 .;S y1=$F(x,"<") S:y1 y1=$F(x,"</"_$P($E(x,y1,y1+255),">"),y1) ;есть XML-теги
 .I $ZCVT($E(x,1,5),"U")="NOPAR" S x=$E(x,6,32000) I 1 ;без параметров (центр, размер шрифта 10, выделенный)
 .E  S Vo(qqnump,"s",0,0,x1,2)=",1,1,10,1"
 .F y1=1:1:$L(x,$C(13,10)) S ^CacheTempDiagXML($J,"s",y1)=$P(x,$C(13,10),y1)
 ; X3694 - вывод поискового образа,  XQfcond - выражение для его обработки
 s XQfcond=$G(^Q(1,qqoQu,query,"XQfcond")) s:$E(XQfcond)="@" @("XQfcond="_$E(XQfcond,2,30000))  ;@gol 11/02/2011
 S oZVs8=$S($G(^Q(1,qqoQu,query,"X3694"),qqoQu=99999):$s(XQfcond'="":XQfcond,1:qW.oZVs8(qqnumpold,,0)),1:"")
 I oZVs8'="" S Vo(qqnump,-1,0,2,x1)="5$G(^CacheTempDiagXML($J,""Z8""))",Vo(qqnump,-1,0,2,x1,10)=3,Vo(qqnump,-1,0,2,x1,64)=1 do  S ^CacheTempDiagXML($J,"Z8")=oZVs8 ;@Dol 29.03.10 qqoQu=99999 - выводится, если не запрос
 .I $ZCVT($E(oZVs8,1,5),"U")="NOPAR" S oZVs8=$E(oZVs8,6,32000) I 1 ;без параметров ( выделенный)
 .E  s Vo(qqnump,-1,0,2,x1,2)=",1,1"
 S Vo(qqnump,-1,0,3,x1)="0 " ;пустая строка
 S x=$G(^Q(1,qqoQu,query,"XQUnd")) S:$E(x)="@" @("x="_$E(x,2,30000)) S:x="" x=$P($G(Vs(qqnumpold,120,2)),$C(13,10),2,255)
 D:x'=""  ;@Dol 28.07.10 подвал по строкам
 .S y=$O(Vo(qqnump,-1,0,""),-1)+2
 .S Vo(qqnump,-1,0,y,x1)="0 " ;пустая строка
 .;F y1=1:1:$L(x,$C(13,10)) S y=y+1,Vo(qqnump,-1,0,y,x1)="0"_$P(x,$C(13,10),y1),Vo(qqnump,-1,0,y,x1,2)=",,1,,1"
 .S Vo(qqnump,-1,0,y+1)="p"
 .S Vo(qqnump,"p",2)=6,Vo(qqnump,"p",33)="^CacheTempDiagXML($J,""p"")",Vo(qqnump,"p",0,0,x1)="5$G(^CacheTempDiagXML($J,""p"",qqc))",Vo(qqnump,"p",0,0,x1,64)=1
 .I $ZCVT($E(x,1,5),"U")="NOPAR" S x=$E(x,6,32000) I 1 ;без параметров ( выделенный)
 .E  S Vo(qqnump,"p",0,0,x1,2)=",,1,,1"
 .F y1=1:1:$L(x,$C(13,10)) S ^CacheTempDiagXML($J,"p",y1)=$P(x,$C(13,10),y1)
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;D qSYS.CreVoAdd()
 ;
 G:$D(ZP)=1 CreArYend ;только общие агрегаты
 ;супервершина. объект -1 тоже массив
 S Vo(qqnump,-1,33)=qqrfr D:$D(Arg1) CreArYV(-1,,,"X533",qqrfr) ;имя массива
 S Vo(qqnump,-1,2)=6 D:$D(Arg1) CreArYV(-1,,,"x52",6) ;виртуальный массив
 ;
 F qi=1:1:ZP D   ;коды объектов аналитик A1, A2 
 .I qi=1 I 1 ;;;;;;;;;;;S Vo(qqnump,-1,0,2)="A1" D:$D(Arg1) CreArYV(-1,2,,"X60","A1") S Vs(qqnump,12)="A1"_" C" I 1
 .E  S Vo(qqnump,"A"_(qi-1),0,1)="A"_qi D:$D(Arg1) CreArYV("A"_(qi-1),1,,"X60","A"_qi)
 .S Vo(qqnump,"A"_qi)=qW.GetWoc("CxWoc",$E(ZP(qi),2,255))
 .I $D(Arg1) D CreArYV("A"_qi,,,"X51",Vo(qqnump,"A"_qi))
 .S Vo(qqnump,"A"_qi,2)=6 D:$D(Arg1) CreArYV("A"_qi,,,"x52",6) ;виртуальный массив
 .S Vo(qqnump,"A"_qi,40)=1 D:$D(Arg1) CreArYV("A"_qi,,,"X540",1) ;Сброс уточнения
 .S qqrfr=$S(qi=1:$E(qqrfr,1,$L(qqrfr)-1)_","""_ZP(1)_""")",1:$E(qqrfr,1,$L(qqrfr)-1)_",Vs(qqnump,""Virt"","""_"A"_(qi-1)_"""),"""_ZP(qi)_""")")
 .S Vo(qqnump,"A"_qi,33)=qqrfr D:$D(Arg1) CreArYV("A"_qi,,,"X533",qqrfr) ;имя массива
 .S Vs(qqnump,4,"A"_qi)=1,Vs(qqnump,12,"A"_qi,"C",3)="A"_qi,Vs(qqnump,13,2,"A"_qi_" C")=qi,Vs(qqnump,13,3,qi)="A"_qi_" C"
 .S $$$ObjLqqc("A"_qi)=255 ;????
 .I qi=ZP S Vo(qqnump,"A"_qi,0,0,0)="5$I(W(""@Znum"",-1))" D:$D(Arg1) CreArYV("A"_qi,0,0,"x70",5),CreArYV("A"_qi,0,0,"X71","$I(W(""@Znum"",-1))")
 .S Vo(qqnump,"A"_qi,0,0,qi)="2C" D:$D(Arg1) CreArYV("A"_qi,0,qi-1,"x70",2),CreArYV("A"_qi,0,qi,"X71","C")
 .F qii=1:1:qi-1 S Vo(qqnump,"A"_qi,0,0,qii)="5Vs(qqnump,""Virt"",""A"_qii_""")" D:$D(Arg1) CreArYV("A"_qi,0,qii,"x70",5),CreArYV("A"_qi,0,qii,"X71","5Vs(qqnump,""Virt"",""A"_qii_""")")
 .I qi>1,ftree D  ;объекты промежуточных сумм (встроенные)
 ..S par="viA"_(qi-1)
 ..S Vo(qqnump,"A"_(qi-1),0,2)=par D:$D(Arg1) CreArYV("A"_(qi-1),1,,"X60",par)
 ..S Vo(qqnump,par)="Суммы_"_qW.GetWoc("CxWoc",$E(ZP(qi-1),2,255)) I $D(Arg1) D CreArYV(par,,,"X51",Vo(qqnump,par))
 ..S Vo(qqnump,par,2)=1 D:$D(Arg1) CreArYV(par,,,"x52",1) ;встроенный
 ..S Vo(qqnump,par,40)=1 D:$D(Arg1) CreArYV(par,,,"X540",1) ;Сброс уточнения
 ..S Vo(qqnump,par,0,0,qi-1)="5""Сумма по ""_qqc" D:$D(Arg1) CreArYV(par,0,qi-1,"x70",5),CreArYV(par,0,qi-1,"X71","5""Сумма по ""_qqc")
 ;учитывается фиксация
 N ZPmax S ZPmax=ZP F ZP=$S($G(Vs(qqnumpold,99,"Anal",2)):1,1:ZP):1:ZPmax D
 .S qs=ZPmax ;$O(Vo(qqnump,"A"_ZP,0,""),-1)+qqcref 
 .F qii=1:1 S qqw=$G(Vs(qqnumpold,13,1,qii)) Q:qqw=""  S qqw=$TR($P(qqw," ",2,3)," ",".") D
 ..S qs=qs+1 ;,Vo(qqnump,"A"_ZP,0,qs,0)="0Итого: "_qW.GetWoc("CxWoc",qqw) D:$D(Arg1) CreArYV("A"_ZP,qs,0,"x70",0),CreArYV("A"_ZP,qs,0,"X71",$E(Vo(qqnump,"A"_ZP,0,qs,0),2,3000))
 ..S Vo(qqnump,"A"_ZP,0,0,qs)="2@ZLAY."_qqw D:$D(Arg1) CreArYV("A"_ZP,0,qs,"x70",2),CreArYV("A"_ZP,0,qs,"X71","@ZLAY."_qqw)
 ..I $D(Vo(qqnump,"viA"_ZP)) S Vo(qqnump,"viA"_ZP,0,0,qs)="2@ZLAY."_qqw D:$D(Arg1) CreArYV("viA"_ZP,0,qs,"x70",2),CreArYV("viA"_ZP,0,qs,"X71","@ZLAY."_qqw)
 .;;I ZP=ZPmax S Vs(qqnump,12,"A"_ZP,"LA"_qqw,4)="D" F qi=5:1:9 S Vs(qqnump,12,"A"_ZP,"LA"_qqw,qi)=$G(Vs(qqnumpold,12,qqo,qqw,qi))
 I qqcref D  ;ссылочные объекты (не учтен вариант нескольких вершин)
 .S qqo=$O(Vs(qqnumpold,14,"")),Vo(qqnump,"A"_ZP,0,1)=qqo M Vs(qqnump,1,qqo)=Vs(qqnumpold,1,qqo) D:$D(Arg1) CreArYV("A"_ZP,1,,"X60",qqo) D CreArYRnew(qqo,$NA(Vs(qqnumpold,14)),1,qqrfr) ;с переносом зачеркнутых
CreArYend ;общий итог
 S qs=ZPmax,y=7 S Vo(qqnump,-1,0,y,1)="0Всего:" D:$D(Arg1) CreArYV(-1,y,1,"x70",0),CreArYV(-1,y,1,"X71",$E(Vo(qqnump,-1,0,y,1),2,3000))
 F qii=1:1 S qqw=$G(Vs(qqnumpold,13,1,qii)) Q:qqw=""  S qqw=$TR($P(qqw," ",2,3)," ",".") D
 .S qs=qs+1
 .S Vo(qqnump,-1,0,y,qs)="2@ZLAY."_qqw D:$D(Arg1) CreArYV(-1,y,qs,"x70",2),CreArYV(-1,y,qs,"X71","@ZLAY."_qqw)
 I '$D(Arg1) D ..CreVoAdd() Q:$Q "" Q
 ;Состояние
 I $D(ZP)>1 D
 .F qi=1:1 S qs=$G(Vs(qqnumpold,13,1,qi)) Q:qs=""  S $P(qs," ",1)=ZP(ZP),$P(qs," ",2)="LA"_$P(qs," ",2),Vs(qqnump,13,1,qi)=qs,Vs(qqnump,13,0,qs)=qi
 .F qi="P","M","S","R","X" M Vs(qqnump,13,qi)=Vs(qqnumpold,13,qi)
 ;сохраним состояние части исходного отображения
 F qi=3,4,12,13,14 M Vs(qqnump,"Vsold",qi)=Vs(qqnumpold,qi)
 M Vs(qqnump,"Vsold",99,"Anal")=Vs(qqnumpold,99,"Anal")
 K ^Q("V"_Arg1,"XObjStat") M ^Q("V"_Arg1,"XObjStat")=Vs(qqnump)
 Q:$Q "" Q
 ;
CreArYRnew(qqo,qqre,one,qqrfr,qqoold) ;
 N qqso M Vo(qqnump,qqo)=Vo(qqnumpold,qqo) K Vo(qqnump,qqo,10),Vo(qqnump,qqo,11) I $D(Arg1) M ^Q(1,"XView",Arg1,"CxObj",qqo)=^Q(1,"XView",Vo(qqnumpold),"CxObj",qqo) ;@Dol 27.04.05 было Vo(qqnump)
 I $G(one) S Vo(qqnump,qqo,2)=2,Vo(qqnump,qqo,40)=1,qqrfr=$E(qqrfr,1,$L(qqrfr)-1)_",Vs(qqnump,""Virt"","""_"A"_ZP_"""),"""_qqo_""")",Vo(qqnump,qqo,29)="$S('qorder:1,1:$O("_$E(qqrfr,1,$L(qqrfr)-1)_",qqc),qorder))" I $D(Arg1) S ^Q(1,"XView",Arg1,"CxObj",qqo,"x52")=2,^("X529")=Vo(qqnump,qqo,29),^("X540")=1
 I '$G(one),$D(Vs(qqnumpold,15,qqo)) S Vo(qqnump,qqo,2)=2,Vo(qqnump,qqo,40)=1,qqrfr=$E(qqrfr,1,$L(qqrfr)-1)_",Vs(qqnump,""Virt"","""_qqoold_"""),"""_qqo_""")",Vo(qqnump,qqo,29)="$S('qorder:1,1:$O("_$E(qqrfr,1,$L(qqrfr)-1)_",qqc),qorder))" I $D(Arg1) S ^Q(1,"XView",Arg1,"CxObj",qqo,"x52")=2,^("X529")=Vo(qqnump,qqo,29),^("X540")=1
 ;I '$G(Vo(qqnump,qqo,2)) S Vo(qqnump,qqo,2)=2 I $D(Arg1) S ^Q(1,"XView",Arg1,"CxObj",qqo,"x52")=2  ;если не виртуальный, сделаем ссылочным
 ;ссылки вниз нужно убрать,графы сдвинуть на одну влево
 S qqso="" F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""  D
 .I $G(Vo(qqnump,qqo,0,qqso))'="" K Vo(qqnump,qqo,0,qqso) K:$D(Arg1) ^Q(1,"XView",Arg1,"CxObj",qqo,"Xy",qqso) Q
 .F qi=$O(Vo(qqnump,qqo,0,qqso,""),-1):-1:0 D
 ..M Vo(qqnump,qqo,0,qqso,qi+1)=Vo(qqnump,qqo,0,qqso,qi) K Vo(qqnump,qqo,0,qqso,qi)
 ..I $D(Arg1) M ^Q(1,"XView",Arg1,"CxObj",qqo,"Xy",qqso,"Xx",qi+1)=^Q(1,"XView",Vo(qqnumpold),"CxObj",qqo,"Xy",qqso,"Xx",qi) K ^Q(1,"XView",Arg1,"CxObj",qqo,"Xy",qqso,"Xx",qi)
 S Vo(qqnump,qqo,0,0,0)="0@" D:$D(Arg1) CreArYV(qqo,0,0,"x70",0),CreArYV(qqo,0,0,"X71","@")
 D:$G(Vo(qqnump,qqo,7))'=""  ;@Dol 25.05.07 дополнительные незачеркнутые понятия
 .N qii,qqw S qii=$O(Vo(qqnump,qqo,0,0,""),-1) F qi=1:1:$L(Vo(qqnump,qqo,7)," ") S qqw=$P(Vo(qqnump,qqo,7)," ",qi) I '$G(Vs(qqnump,1,qqo,qqw)) S qii=qii+1,Vo(qqnump,qqo,0,0,qii)=2_qqw D:$D(Arg1) CreArYV(qqo,0,qii,"x70",2),CreArYV(qqo,0,qii,"X71",qqw)
 F  S qqso=$O(@qqre@(qqo,qqso)) Q:qqso=""  S Vo(qqnump,qqo,0,$O(Vo(qqnump,qqo,0,""),-1)+1)=qqso D:$D(Arg1) CreArYV(qqo,$O(Vo(qqnump,qqo,0,""),-1)+1,,"X60",qqso) D CreArYRnew(qqso,$NA(@qqre@(qqo)),0,qqrfr,qqo)
 Q
CreArYV(Obj,y,x,par,z) ;запись в отображение
 I $G(x)'="" S ^Q(1,"XView",Arg1,"CxObj",Obj,"Xy",y,"Xx",x,par)=z Q
 I $G(y)'="" S ^Q(1,"XView",Arg1,"CxObj",Obj,"Xy",y,par)=z Q
 I $G(Obj)'="" S ^Q(1,"XView",Arg1,"CxObj",Obj,par)=z Q
 S ^Q(1,"XView",Arg1,par)=z Q
 ;;;;из qWEB.Diag
DiagCol(ycol,y13) ;параметры колонки (y13=1 - D, 3 - A)
 N mc I $G(xp)&&(y13=1) S mc=((ycol-1)\xp)+1=Xp ;@Dol 28.01.11 колонка Всего - параметры $P(,";;",3)
 Q:'ycol "" Q:xyz "" S:$G(xp)&($G(y13)=1) ycol=$S(ycol#xp:ycol#xp,1:xp) S ycol=$G(Vs(qqnumpold,12,$P(Vs(qqnumpold,13,y13,ycol)," "),$P(Vs(qqnumpold,13,y13,ycol)," ",2),17)) Q:ycol="" "" 
 S:ycol[";;" ycol=$S($G(mc)&&($P(ycol,";;",3)'=""):$P(ycol,";;",3),1:$P(ycol,";;",y13=1+1))
 S:$P(ycol,",",10)="" $P(ycol,",",10)="5555" S:$G(mc)&&($P(ycol,",",5)="")&&($G(Vs(qqnumpold,99,"Anal",2))) $P(ycol,",",5)=1 S:$G(mc)&&($P(ycol,",",9)="") $P(ycol,",",9)=XQtc 
 Q ycol
 ;;Q:'ycol "" Q:xyz "" S:$G(xp)&($G(y13)=1) ycol=$S(ycol#xp:ycol#xp,1:xp) S ycol=$G(Vs(qqnumpold,12,$P(Vs(qqnumpold,13,y13,ycol)," "),$P(Vs(qqnumpold,13,y13,ycol)," ",2),17)) Q:ycol="" "" S:ycol[";;" ycol=$P(ycol,";;",y13=1+1) Q:ycol="" "" S:$P(ycol,",",10)="" $P(ycol,",",10)=2 Q ycol
DiagName(ycol,y13) ;название колонки (y13=1 - D, 3 - A)
 S:$G(xp)&($G(y13)=1) ycol=$S(ycol#xp:ycol#xp,1:xp)
 S y13=$P(Vs(qqnumpold,13,y13,ycol)," ",1,2) Q:y13="" "" ;код объекта и понятия
 I $G(Vs(qqnumpold,12,$P(y13," ",1),$P(y13," ",2),1))'="" Q "" ;задано в выражении аналитики
 S ycol=$P(qARM.GetPar("X7103",,$P(y13," ",1),$P(y13," ",2),,qqnumpold),"~") S:ycol="" ycol=qARM.GetName(,$P(y13," ",1),$P(y13," ",2),qqnumpold) 
 ;;;D qARM.Message(y13_"*"_ycol)
 Q ycol
DiagPar(ycol,y13) ;параметры колонки (y13=1 - D, 3 - A)
 S:$G(xp)&($G(y13)=1) ycol=$S(ycol#xp:ycol#xp,1:xp)
 S y13=$P($G(Vs(qqnumpold,13,y13,ycol))," ",1,2) Q:y13="" "" ;код объекта и понятия
 S ycol=qARM.GetPar("X72",,$P(y13," ",1),$P(y13," ",2),,qqnumpold)
 I $P(ycol,",")="" S y13=$P($G(Vo(qqnumpold,$P(y13," ",1),11,$P(y13," ",2)))," ",2) S:y13'="" $P(ycol,",",1)=$P($G(Vo(qqnumpold,-1,9,y13)),",") ;размер колонки исходного отображения
 S $P(ycol,",",10)=2 Q ycol
Diag710(ycol,y13) ;тип данных (y13=1 - D, 3 - A)
 N y13o S y13o=y13 S:$G(xp)&($G(y13)=1) ycol=$S(ycol#xp:ycol#xp,1:xp)
 S y13=$P($G(Vs(qqnumpold,13,y13,ycol))," ",1,2) Q:y13="" "" ;код объекта и понятия
 S ycol=$G(Vs(qqnumpold,12,$P(y13," ",1),$P(y13," ",2),18)) I ycol'="" S:ycol[";;" ycol=$P(ycol,";;",y13o=1+1) Q:ycol'="" ycol ;@Dol 23.09.10 тип данных в четвертой строке аналитик
 I y13o=1,'$P(par," ",12) Q ""
 I y13o=3,'$P(par," ",10) Q ""
 S ycol=qARM.GetPar("x710",,$P(y13," ",1),$P(y13," ",2),,qqnumpold)
 Q ycol
DiagParC ;@Dol 20.05.10 Доп. параметры ячеек для заголовков
 S:$P($G(Vo(qqnump,"A"_ZP,0,0,y1,2)),",",19) $P(Vo(qqnump,-1,0,5,y1,2),",",19)=$P(Vo(qqnump,"A"_ZP,0,0,y1,2),",",19),$P(Vo(qqnump,"A"_ZP,0,0,y1,2),",",19)="" ;поворот
 S:$P($G(Vo(qqnump,"A"_ZP,0,0,y1,2)),",",16) $P(Vo(qqnump,-1,0,5,0,2),",",16)=$P(Vo(qqnump,"A"_ZP,0,0,y1,2),",",16),$P(Vo(qqnump,"A"_ZP,0,0,y1,2),",",16)="" ;высота
 Q
]]></Implementation>
</Method>

<Method name="CreCol">
<Description>
Динамическое добавление ячеек c ПОНЯТИЯМИ (!!!) к строке qqso объекта qqo.
qqso="-" - удаление ячеек с понятиями из  списка qqw. 
Если qqo=-1, то qqw может содержать список удаляемых номеров колонок (!!! для всех объектов отображения)
             В этом случае (если удаление колонки из середины, размер удаляемой колонки устанавливается в 0. Если $P(qqso," ",2)=1 - это не делается
qqw - список добавляемых понятий (через ~ или $C(1))
X72-x710 - списки (через ~ или $C(1) !!!) параметров добавляемых понятий.

!!New !! В qqso (через пробел) можно поставить желаемый номер колонки начала вставки.

           Добавлятся могут и костанты/выражения (без ~). Должны начинаться с цифры 0 или 5.
julia 20080718 В метод qSYS.CreCol добавлены новые параметры X75 (значение по умолчанию), X744 (маска), X740 (обязательность значения)
            было Method CreCol(qqo, qqso, qqw, X72, X731, x730, X73, X7100, X720, X76, X7102, x710) [ Language = cache ]
julia 20080724 Добавлены новые параметры  X786 (метка табуляции), X74 (правила проверки), X745 (ограничение поля ввода)
rda 20090930 Параметр ReInit=1/0 Иницализировать/нет дерево образцов T3 - 19й параметр. По умолчанию =1.
    (если метод вызывается несколько раз, то разумнее сделать инициализацию только в конце,иначе на клиенте будет долго отрисовываться окно)
rda 20100310 Если в строках с параметрами содержится $C(1), то за разделитель принимается он
rda 20101025 При указании меток табуляции было забыто про Vt(qqnump,786)</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqso:%Library.String,qqw:%Library.String,X72:%Library.String,X731:%Library.String,x730:%Library.String,X73:%Library.String,X7100:%Library.String,X720:%Library.String,X76:%Library.String,X7102:%Library.String,x710:%Library.String,X75:%Library.String,X744:%Library.String,X740:%Library.String,X786:%Library.String,X74:%Library.String,X745:%Library.String,ReInit=1</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N xm,xi,full,sep
 s sep=$S(qqw[$C(1):$C(1),1:"~")
 f xi="X72","X731","x730","X73","X7100","X720","X76","X7102","x710","X75","X744","X740","X786","X74","X745" s sep(xi)=$S($G(@(xi))[$C(1):$C(1),1:"~")
 I $E($G(qqso))="-" D  K Vo(qqnump,-1,9) G CreColE ;удаление
 .S full=$P($G(qqso)," ",2) S:full qqso=$P(qqso," ")
 .S qqso=-qqso
 .F xi=1:1:$L(qqw,sep) D:$P(qqw,sep,xi)'=""
 ..I $P(qqw,sep,xi)?1.N K Vo(qqnump,qqo,0,qqso,$P(qqw,sep,xi)) D:qqo=-1&('qqso)  Q
 ...N qqo,qqso S qqo=-1 D:'full  F  S qqo=$O(Vo(qqnump,qqo)) Q:qqo=""  S qqso="" F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""  K:$G(Vo(qqnump,qqo,0,qqso))="" Vo(qqnump,qqo,0,qqso,$P(qqw,sep,xi)) ;удаление колонок
 ....I $O(Vo(qqnump,qqo,0,0,$P(qqw,sep,xi)))'="" S Vo(qqnump,qqo,0,0,$P(qqw,sep,xi),2)=0
 ..S xm=$G(Vo(qqnump,qqo,11,$P(qqw,sep,xi))) K:xm'="" Vo(qqnump,qqo,0,$P(xm," ",1),$P(xm," ",2)) 
 S xm=$P($G(qqso)," ",2),qqso=+$G(qqso) ;@Dol 30.11.06 xm
 S:xm="" xm=$O(Vo(qqnump,qqo,0,qqso,""),-1)+1
 F xi=xm:1:xm+$L(qqw,sep)-1 D
 .S Vo(qqnump,qqo,0,qqso,xi)=$S($E($P(qqw,sep,xi-xm+1))?1N:$P(qqw,sep,xi-xm+1),1:2_$P(qqw,sep,xi-xm+1)) ;@Dol 23.08.07 1N
 .S:$P($G(X72),sep("X72"),xi-xm+1)'="" Vo(qqnump,qqo,0,qqso,xi,2)=$P(X72,sep("X72"),xi-xm+1)
 .S:$P($G(X731),sep("X731"),xi-xm+1)'="" Vo(qqnump,qqo,0,qqso,xi,31)=$P(X731,sep("X731"),xi-xm+1)
 .S:$P($G(x730),sep("x730"),xi-xm+1)'="" Vo(qqnump,qqo,0,qqso,xi,30)=$P(x730,sep("x730"),xi-xm+1)
 .S:$P($G(X73),sep("X73"),xi-xm+1)'="" Vo(qqnump,qqo,0,qqso,xi,3)=$P(X73,sep("X73"),xi-xm+1)
 .S:$P($G(X7100),sep("X7100"),xi-xm+1)'="" Vo(qqnump,qqo,0,qqso,xi,100)=$P(X7100,sep("X7100"),xi-xm+1)
 .S:$P($G(X720),sep("X720"),xi-xm+1)'="" Vo(qqnump,qqo,0,qqso,xi,20)=$P(X720,sep("X720"),xi-xm+1)
 .S:$P($G(X76),sep("X76"),xi-xm+1)'="" Vo(qqnump,qqo,0,qqso,xi,6)=$P(X76,sep("X76"),xi-xm+1)
 .S:$P($G(X7102),sep("X7102"),xi-xm+1)'="" Vo(qqnump,qqo,0,qqso,xi,102)=$P(X7102,sep("X7102"),xi-xm+1)
 .S:$P($G(x710),sep("x710"),xi-xm+1)'="" Vo(qqnump,qqo,0,qqso,xi,10)=$P(x710,sep("x710"),xi-xm+1)
 .S:$P($G(X75),sep("X75"),xi-xm+1)'="" Vo(qqnump,qqo,0,qqso,xi,5)=$P(X75,sep("X75"),xi-xm+1)
 .S:$P($G(X744),sep("X744"),xi-xm+1)'="" Vo(qqnump,qqo,0,qqso,xi,44)=$P(X744,sep("X744"),xi-xm+1)
 .S:$P($G(X740),sep("X740"),xi-xm+1)'="" Vo(qqnump,qqo,0,qqso,xi,40)=$P(X740,sep("X740"),xi-xm+1) 
 .I $P($G(X786),sep("X786"),xi-xm+1)'="" s Vo(qqnump,qqo,0,qqso,xi,86)=$P(X786,sep("X786"),xi-xm+1) s:$G(Vt(qqnump,786))'=1 Vt(qqnump,786)=1
 .S:$P($G(X74),sep("X74"),xi-xm+1)'="" Vo(qqnump,qqo,0,qqso,xi,4)=$P(X74,sep("X74"),xi-xm+1)
 .S:$P($G(X745),sep("X745"),xi-xm+1)'="" Vo(qqnump,qqo,0,qqso,xi,45)=$P(X745,sep("X745"),xi-xm+1) 
CreColE K W("ZBtredo") ;для переиницилизации граф в wcre
 D ..CreVoAdd() D:(qqnump'="P")&&(ReInit) qARM.wipa() ;,qARM.wcro() ;,qARM.wcre()
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CreObj">
<Description>
Автоматическое Создание описания объекта.
table - стиль расположения понятий. 1 - таблица, 0 - бланк (две колонки: название - понятие)
view - код отображения. Если задан, включается в описание.
parent =1 - создавать подчиненные по описанию в объекте Объекты. 
sys=1 - включить понятие С (код экземпляра)

Vs("par",5) корректно обрабатывается (см. описание qARM.OpenWindow)</Description>
<Internal/>
<FormalSpec>Obj:%String,table:%String=1,view:%String,parent:%String=0,sys:%String=1</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I Obj=$P($G(Vs("par",5)),",") S Vs("par",5)=$P(Vs("par",5),",",2,255)
 S Vo(qqnump,Obj)="",Vo(qqnump,Obj,31)=1 ;подтверждение
 D:$G(view)'="" CreObjV(,,"X531",1)
 S $$$ObjLqqc(Obj)=$G(^Q(1,"CxObj",Obj,"X50"))
 N iw,qqw,qqwl,qqol,iiw S iiw=-1,qqwl=$G(^Q(1,"CxObj",Obj,"xWoc"))
 I table,sys D
 .S iiw=0,Vo(qqnump,Obj,0,0,0)="2C"
 .I $G(view)'="" D CreObjV(0,0,"x70",2),CreObjV(0,0,"X71","C")
 .I $E(Obj)="C" D
 ..S Vo(qqnump,Obj,0,0,1)="2CC",iiw=1
 ..I $G(view)'="" D CreObjV(0,1,"x70",2),CreObjV(0,1,"X71","CC")
 .I qW.GG("CxObj","Cx532",Obj)'=3 D
 ..S iiw=iiw+1,Vo(qqnump,Obj,0,0,iiw)="2@Zcordtu"
 ..I $G(view)'="" D CreObjV(0,iiw,"x70",2),CreObjV(0,iiw,"X71","@Zcordtu")
 I 'table D
 .S Vo(qqnump,Obj,0,0,0)="0@" D:$G(view)'="" CreObjV(0,0,"x70",0),CreObjV(0,0,"X71","@")
 .I sys S Vo(qqnump,Obj,0,0,1)="2C" D:$G(view)'="" CreObjV(0,1,"x70",2),CreObjV(0,1,"X71","C")
 I qqwl="",'sys S Vo(qqnump,Obj,0,0,0)="0@" D:$G(view)'="" CreObjV(0,0,"x70",0),CreObjV(0,0,"X71","@")
 I qqwl'="" F iw=1:1:$L(qqwl," ") S qqw=$P(qqwl," ",iw) D:qqw'=""
 .I table Q:$S('sys:0,1:"@Z"[$E(qqw))  S iiw=iiw+1,Vo(qqnump,Obj,0,0,iiw)="2"_qqw D:$G(view)'="" CreObjV(0,iiw,"x70",2),CreObjV(0,iiw,"X71",qqw) Q
 .S Vo(qqnump,Obj,0,iw,0)="0@"_qqw,Vo(qqnump,Obj,0,iw,1)="2"_qqw
 .I $G(view)'="" D CreObjV(iw,0,"x70",0),CreObjV(iw,0,"X71","@"_qqw),CreObjV(iw,1,"x70",2),CreObjV(iw,1,"X71",qqw)
 I '$G(parent) Q:$Q "" Q
 I $TR($G(Vs("par",5))," ,")'="" Q:$P(Vs("par",5),",")=-1 "" S qqol=$P(Vs("par",5),",") I 1
 E  S qqol=$G(^Q(1,"CxObj",Obj,"xObj"))
 I qqol'="" F iw=1:1:$L(qqol," ") S qqw=$P(qqol," ",iw) I qqw'="",'$G(Vs("par",5,qqw)) D
 .S %2=$O(Vo(qqnump,Obj,0,""),-1)+1,Vo(qqnump,Obj,0,%2)=qqw D:$G(view)'="" CreObjV(%2,,"X60",qqw) D ..CreObj(qqw,table,$G(view),1,sys)
 Q:$Q "" Q
CreObjV(y,x,par,z) ;запись в отображение
 I $G(x)'="" S ^Q(1,"XView",view,"CxObj",Obj,"Xy",y,"Xx",x,par)=z Q
 I $G(y)'="" S ^Q(1,"XView",view,"CxObj",Obj,"Xy",y,par)=z Q
 S ^Q(1,"XView",view,"CxObj",Obj,par)=z
 Q
]]></Implementation>
</Method>

<Method name="CreObjView">
<Description>
Создание описания объекта Obj из описания заданного отображения.
qqview - код отображения-источника
view - код отображения. Если задан, включается в описание (пока не задействован).
parent =1 - создавать подчиненные по описанию в объекте Объекты (пока не задействован). 
sys=1 - включить дату-время коррекции</Description>
<Internal/>
<FormalSpec>Obj:%String,qqview:%String,view:%String,parent:%String=0,sys:%String=0</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 D CreObjViewO(Obj)
 D:sys
 .S sys=$O(Vo(qqnump,Obj,0,""),-1)+1
 .S Vo(qqnump,Obj,0,sys,0)="2@Zcordtu"
 Q:$Q "" Q
CreObjViewO(qqObj)
 N x,y,z,qqt,qqw
 D:qqObj'=-1
 .S Vo(qqnump,qqObj)=$G(^Q(1,"XView",qqview,"CxObj",qqObj,"X51")) ;имя в отображении
 .;S Vo(qqnump,qqObj,0)=$G(^Q(1,"CxObj",qqObj,"X50")) I '$$$Tree,Vo(qqnump,qqObj,0)="" S:qqObj?1.N qerr($I(qerr))="qWord. Obj="_qqObj_" не задана длина кода" S Vo(qqnump,qqObj,0)=255
 .F z="x52","X57" D  ;ненаследуемые; "X527","X528" ???
 ..I $D(^Q(1,"XView",qqview,"CxObj",qqObj,z)) S Vo(qqnump,qqObj,$E(z,3,10))=^(z) Q
 .;I $G(Vo(qqnump,qqObj,28))!$D(Vo(qqnump,qqObj,27)) S Vt(qqnump,0)=1 ;есть постоянные условия
 .S Vo(qqnump,qqObj,0)=$G(^Q(1,"CxObj",qqObj,"X50")) I '$$$Tree,Vo(qqnump,qqObj,0)="" S:'$G(Vo(qqnump,qqObj,2))&&('$G(^Q(1,"CxObj",qqObj,"Xsys"))) qerr($I(qerr))="qWord. Obj="_qqObj_" не задана длина кода" S Vo(qqnump,qqObj,0)=255
 ;строки
 S y="" F  S y=$O(^Q(1,"XView",qqview,"CxObj",qqObj,"Xy",y)) Q:y=""  D
 .;I $D(^(y,"X60")) S Vo(qqnump,qqObj,0,y)=^("X60") ;объект-потомок
 .;ячейки
 .S x="" F  S x=$O(^Q(1,"XView",qqview,"CxObj",qqObj,"Xy",y,"Xx",x)) Q:x=""  D
 ..S qqt=$G(^(x,"x70"),0),qqw=$G(^("X71")),Vo(qqnump,qqObj,0,y,x)=qqt_qqw ;тип и содержимое
 ..F z="x710" D  I z="x710",$G(Vo(qqnump,qqObj,0,y,x,10))=2,qqt'=3 S $E(Vo(qqnump,qqObj,0,y,x))=3 
 ...I $D(^Q(1,"XView",qqview,"CxObj",qqObj,"Xy",y,"Xx",x,z)) S Vo(qqnump,qqObj,0,y,x,$E(z,3,10))=^(z) Q
 ...I qqw'="","234"[qqt,$D(^Q(1,"CxWoc",qqw,z)) S Vo(qqnump,qqObj,0,y,x,$E(z,3,10))=^(z) Q  ;наследование от понятий
 Q
]]></Implementation>
</Method>

<Method name="CreSQLObj">
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Arg1)="",$G(Vo(qqnump))="XXXSQL" D  ;для вызова из меню действий отображения XXXSQL
 .I $G(Vs(qqnump,"CurObj"))="" Q
 .I $G(Vs(qqnump,"CurObj"))="XSQL" S Arg1=qqc Q
 .I $G(Vs(qqnump,"CurObj"))="XSQLtab" S Arg2=qqc,Arg1=Vc(qqnump,$E(Vc(qqnump),1,2)) Q
 .S Arg3=qqc,Arg1=Vc(qqnump,$E(Vc(qqnump),1,2)),Arg2=Vc(qqnump,$E(Vc(qqnump),1,4)) Q
 N qqo,qqw,qqwlst
 I $G(Arg1)="" Q "Не задана база"
 N qbt S qbt=$G(^Q(1,"XSQL",Arg1,"XSQLtyp"),"SQL") ;тип базы (SQL\DBF
 I $G(Arg3)'="" Q "Создано понятие qqw="_$$CreSQLWo(Arg3)
 I $G(Arg2)'="" D  Q "Создан объект qqo="_qqo_" qqwlst="_qqwlst
 .S qqo=$$CreSQLOb(Arg2),qqwlst=""
 .;S Arg3="" F  S Arg3=$O(^Q(1,"XSQL",Arg1,"XSQLtab",Arg2,"XSQLatr",Arg3)) Q:Arg3=""  D
 .N atrlst,atrlsti S atrlst=$G(^Q(1,"XSQL",Arg1,"XSQLtab",Arg2,"XSQLatrlst"))
 .F atrlsti=1:1:$L(atrlst," ") S qqwlst=qqwlst_" "_$$CreSQLWo($P(atrlst," ",atrlsti))
 .S qqwlst=$E(qqwlst,2,30000),^Q(1,"CxObj",qqo,"xWoc")=qqwlst
 S Arg2="" F  S Arg2=$O(^Q(1,"XSQL",Arg1,"XSQLtab",Arg2)) Q:Arg2=""  D
 .S qqo=$$CreSQLOb(Arg2),qqwlst=""
 .N atrlst,atrlsti S atrlst=$G(^Q(1,"XSQL",Arg1,"XSQLtab",Arg2,"XSQLatrlst"))
 .F atrlsti=1:1:$L(atrlst," ") S qqwlst=qqwlst_" "_$$CreSQLWo($P(atrlst," ",atrlsti))
 .S qqwlst=$E(qqwlst,2,30000),^Q(1,"CxObj",qqo,"xWoc")=qqwlst
 Q "Созданы объекты и понятия для базы "_Arg1
 ;
CreSQLOb(tab)   ;создание объекта (qqo стараемся сделать равным tab)
 N qqz,qqo S qqo=tab S:"Av"[$E(qqo) qqo="o"_qqo
 S qqz=$G(^Q(1,"CxObj",qqo))
 I qqz="" D  Q qqo
 .S qqz=qbt_"tab_"_tab ;создадим уникальное имя
 .I $G(^Q(1,"xObj",qqz))'="" N i F i=1:1 I '$D(^Q(1,"xObj",qqz_"_"_i)) S qqz=qqz_"_"_i Q
 .S ^Q(1,"CxObj",qqo)=qqz,^Q(1,"xObj",qqz)=qqo
 .D CreSQLOp
 I $G(^Q(1,"CxObj",qqo,"X533"))=$S(qbt'="DBF":tab,1:"^DBF("""_tab_""")") Q qqo ;уже есть
 I $G(^Q(1,"CxObj",qqo,"X533"))="" D CreSQLOp Q qqo
 N i F i=1:1 I '$D(^Q(1,"CxObj",qqo_"_"_i)) S qqo=qqo_"_"_i Q  ;создадим уникальный код
 .S ^Q(1,"CxObj",qqo)=qqz,^Q(1,"xObj",qqz)=qqo
 .D CreSQLOp
 Q qqo
CreSQLOp S ^Q(1,"CxObj",qqo,"X533")=$S(qbt'="DBF":tab,1:"^DBF("""_tab_""")"),^Q(1,"CxObj",qqo,"x52")=$S(qbt'="DBF":7,1:6) Q  ;,^Q(1,"CxObj",qqo,"X50")=6
CreSQLWo(rec)   ;создание понятия (qqw стараемся сделать равным rec)
 N qqz,qqw S qqw="p"_rec,qqz=$G(^Q(1,"CxWoc",qqw))
 I qqz="" D  Q qqw
 .S qqz=qbt_"rec_"_rec ;создадим уникальное имя
 .I $G(^Q(1,"xWoc",qqz))'="" N i F i=1:1 I '$D(^Q(1,"xWoc",qqz_"_"_i)) S qqz=qqz_"_"_i Q
 .S ^Q(1,"CxWoc",qqw)=qqz,^Q(1,"xWoc",qqz)=qqw
 .S ^Q(1,"CxWoc",qqw,"X753")=rec
 I $G(^Q(1,"CxWoc",qqw,"X753"))=rec Q qqw ;уже есть
 I $G(^Q(1,"CxWoc",qqw,"X753"))="" S ^Q(1,"CxWoc",qqw,"X753")=rec Q qqw
 N i F i=1:1 I '$D(^Q(1,"CxWoc",qqw_"_"_i)) S qqw=qqw_"_"_i Q  ;создадим уникальный код
 .S ^Q(1,"CxWoc",qqw)=qqz,^Q(1,"xWoc",qqz)=qqw
 .S ^Q(1,"CxWoc",qqw,"X753")=rec
 Q qqw
]]></Implementation>
</Method>

<Method name="CreStr">
<Description>
Порождение строк отображения по списку понятий (Arg1) начиная со строки Arg2 в
массиве Arg3.</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%String=1,Arg3:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqw F i=Arg2:1:Arg2+$L(Arg1," ")-1 S qqw=$P(Arg1," ",i-Arg2+1),@Arg3@(i,0)="0@"_qqw,@Arg3@(i,1)="2"_qqw
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CreTB323">
<Description>
Используется в отображении описания отображений (XXXXView).
Записывает  полный XSL в понятие T323.</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
    N gloref,qqform,qOutput S qqform=qqnump D
    .I '$G(^Q(1,"XBase",0,"XBNDes")) S gloref=$NA(@$$$GloRef@(qqo,qqc,"TB323")),%2=$QS($$$GloRef,3) Q  ;код отображения
    .S gloref=$NA(@Vo(qqnump,qqo,33)@(qqc,"TB323")),%2=$QS(gloref,3)
    ;D qARM.Message(%2)
    S %1=qWEB.OpenPrint(qview,,,,,%2) I %1'="" D qARM.Message(%1) Q:$Q "" Q
    s qOutput=qARM.GetPar(320,qqc) ;;@misuno 20091009
    D qWEB.XSL(1,1,,,qOutput) ;;;;@misuno 20091009 Было D qWEB.XSL(1,1)
    D qARM.crst(,qqform) S qqnump=qqform,qwin="Q"_qqnump ;восстановим контекст
    K @gloref F qqform=0:1:$G($$$tmpGl(1,$J)) S @gloref@(qqform)=$TR($$$tmpGl(1,$J,qqform),$C(13,10)) ; 15.12.2008 Kokarev
    D:$G(^Q(1,"XBase",0,"XBNDes")) qW.G("TB323") D qARM.wwww("TB323") S qqred=""
    Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CreTitleTab">
<Description>
создание заголовков для печатных форм (ячеек констант с именами понятий для объекта -1) 
Save=1 - сохранять в описании отображения
Testw=1 учитывать свертку
Str1, Str2 - добавляемые строки текста заголовков (помимо и перед заголовком граф)
NoTab=1 - не формировать заголовки граф (только Str1 и Str2)
One=1 - только одна строка заголовка (?по умолчанию)
qqoT - объект начала формирования заголовка. По умолчанию вершина (-1)
pz=1 - учитывать постоянные заголовки ;@Dol 06.04.10</Description>
<Internal/>
<FormalSpec>Save:%Library.String,Testw:%Library.String,NoTab:%Library.String,Str1:%Library.String,Str2:%Library.String,One:%Library.String=1,qqoT:%Library.String,pz</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqo,qqw,qqz,x,y,yy,wtit,i1
 N qqview
 s qqview=$g(Vo(qqnump,-1,-1))_$s($g(Vo(qqnump,-1,-1))'="":$C(1),1:"")_Vo(qqnump) ;$P(qview," ")  ;Маслова 06.08.2010
 
 N qqoView
 S qqoView=$S($g(qqview)'[$C(1):"XView",1:$P($g(qqview),$C(1))) S:$g(qqview)[$C(1) qqview=$P($g(qqview),$C(1),2,255) ;Маслова 06.08.2010
 
 ;@Dol 27.04.06 найдем первую строку со сылкой на объекты
 S y=0 F  S y=$O(Vo(qqnump,-1,0,y)) Q:y=""  Q:$G(Vo(qqnump,-1,0,y))'=""
 S yy=$S(y="":0,1:y) ;строка для заголовка
 ;сдвинем строки объекта вершины и удалим константы
 S y="" F  S y=$O(Vo(qqnump,-1,0,y),-1) Q:y=""!(y=0)  D  Q:y=yy
 .M Vo(qqnump,-1,0,y+100)=Vo(qqnump,-1,0,y) K Vo(qqnump,-1,0,y)
 .I $G(Save) M ^Q(1,qqoView,qqview,"CxObj",-1,"Xy",y+100)=^Q(1,qqoView,qqview,"CxObj",-1,"Xy",y) K ^Q(1,qqoView,qqview,"CxObj",-1,"Xy",y)
 ;уберем постоянные заголовки
 F x=0:1:Vo(qqnump,-1,9) I $E($G(Vo(qqnump,-1,0,0,x)),2,255)'="" S:$G(pz) pz(x)=$E($P(Vo(qqnump,-1,0,0,x),"~"),2,1000) S:$G(pz)&&($E(Vo(qqnump,-1,0,0,x))=5) i1=x,@("pz(x)="_pz(x)) S Vo(qqnump,-1,0,0,x)=0 D CreTi(0,x,"x70",0),CreTi(0,x,"X71") ;@Dol 30.11.10 выражение для постоянных заголовков
 ;I $G(Str1)'="" S Vt(qqnump,"Str1")=Str1,Vo(qqnump,-1,0,yy,0)="5Vt(qqnump,""Str1"")",Vo(qqnump,-1,0,yy,0,2)=",1,1,,1,,,,,1",Vo(qqnump,-1,0,yy,0,10)=3,yy=yy+1 ;тип DOCUMENT
 ;I $G(Str2)'="" S Vt(qqnump,"Str2")=Str2,Vo(qqnump,-1,0,yy,0)="5Vt(qqnump,""Str2"")",Vo(qqnump,-1,0,yy,0,2)=",1,1,,,,,,,1",Vo(qqnump,-1,0,yy,0,10)=3,yy=yy+1
 I $G(Vs(qqnump,"ColWidth",x),99)'=0,$P($G(Vo(qqnump,-1,9,x),99),",")'=0 Q  ;@Dol 02.12.10 колонка для заголовка с учетом зачеркнутости;@Dol 25.05.11 Vo(qqnump,-1,9
 I $G(Str1)'="" S Vt(qqnump,"Str1")=Str1,Vo(qqnump,-1,0,yy,x)="5Vt(qqnump,""Str1"")",Vo(qqnump,-1,0,yy,x,2)=",1,1,,1,,,,,1",Vo(qqnump,-1,0,yy,x,10)=3,Vo(qqnump,-1,0,yy,x,64)=1,yy=yy+1 ;тип DOCUMENT ;@Dol 02.12.10 Проз XML
 I $G(Str2)'="" S Vt(qqnump,"Str2")=Str2,Vo(qqnump,-1,0,yy,x)="5Vt(qqnump,""Str2"")",Vo(qqnump,-1,0,yy,x,2)=",1,1,,,,,,,1",Vo(qqnump,-1,0,yy,x,10)=3,yy=yy+1
 D:'$G(NoTab) CreTiR($S($G(qqoT)="":-1,1:qqoT))
 Q:$Q "" Q
CreTiR(qqo)
 N y,yy0,z0
 S y="" F  S y=$O(Vo(qqnump,qqo,0,y)) Q:y=""  D  I $G(wtit),$G(One) Q  ;@Dol 3.12.06 если только одна строка
 .S z=$G(Vo(qqnump,qqo,0,y)) I z'="" D:$S('$G(Testw):1,1:'$G(Vs(qqnump,3,qqo))) CreTiR(z) Q  ;если не свернут
 .Q:qqo=-1  I $G(Testw),$G(Vs(qqnump,1,qqo))||($G(Vs(qqnump,1,qqo,y))=2) Q  ;зачеркнут объект или строка
 .I y,$G(Vs(qqnump,1,qqo,0))=-2 Q  ;@Dol 9.11.06 только первая строка
 .S x="",yy0=yy F  S x=$O(Vo(qqnump,qqo,0,y,x)) Q:x=""  S z=$G(Vo(qqnump,qqo,0,y,x),$G(pz(x))) I z'="",$E(z,2,255)'="" D  ;
 ..I $G(Testw),"234"[$E(z),$G(Vs(qqnump,1,qqo,$E(z,2,255))) Q  ;зачеркнуто понятие
 ..I $G(Testw),$G(Vs(qqnump,1,qqo,y,x)) Q 
 ..;S:yy0=yy yy=yy+1
 ..S z0=$S($G(pz(x))'="":pz(x),1:qARM.GetPar("X7103",,qqo,y,x))
 ..S z=$P($S($G(W("Zsc"_x))'="":W("Zsc"_x),z0'="":z0,"234"[$E(z):qARM.GetName(,qqo,$E(z,2,255)),1:qARM.GetPar("X7100",,qqo,y,x)),"~") Q:z=""  ;@Dol 16.06.08 $P(,"~")
 ..S:yy0=yy yy=yy+1 S Vo(qqnump,-1,0,yy,x)=0_z D CreTi(yy,x,"x70",0),CreTi(yy,x,"X71",z)
 ..S z=",,,,1,,,,,2" S:'x&&$P($G(pz)," ",2) $P(z,",",16)=$P($G(pz)," ",2) S:$P($G(pz)," ",3)&&$P($G(Vo(qqnump,-1,0,0,x,2)),",",19) $P(z,",",19)=$P($G(Vo(qqnump,-1,0,0,x,2)),",",19) S Vo(qqnump,-1,0,yy,x,2)=z D CreTi(yy,x,"X72",z) ;@Dol 11.01.2011 16 - Высота, 19 - ориентация (см. X3696)
 .S wtit=1
 Q
CreTi(y,x,par,z)
 Q:'$G(Save)
 I $G(z)="" K ^Q(1,qqoView,qqview,"CxObj",-1,"Xy",y,"Xx",x,par) Q
 S ^Q(1,qqoView,qqview,"CxObj",-1,"Xy",y,"Xx",x,par)=z Q
]]></Implementation>
</Method>

<Method name="CreVo">
<Description>
Создание массива основных параметров отображения.
NoWin=1 - для отображения не будет окна (сокращенный набор параметров).</Description>
<Internal/>
<FormalSpec>qqview:%String,NoWin:%String=0</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqObj,y,x,z,qqw,qqt,$ET,qrulsV,q155,user1,user2 ;user1,2 - переменные пользователя на время загрузки - могут использоваться в выражениях для Xmod
 K qerr
 S $ET="S qerr($I(qerr))=$ZE,$EC="""""
 //S:$G(qqview)="" qqview=Vo(qqnump) ;$P(qview," ")
 S:$G(qqview)="" qqview=$g(Vo(qqnump,-1,-1))_$s($g(Vo(qqnump,-1,-1))'="":$C(1),1:"")_Vo(qqnump) ;$P(qview," ")  ;Маслова 06.08.2010
   
 N qqoView
 S qqoView=$S($g(qqview)'[$C(1):"XView",1:$P($g(qqview),$C(1))) S:$g(qqview)[$C(1) qqview=$P($g(qqview),$C(1),2,255) ;Маслова 06.08.2010
 
 K Vo(qqnump),Vt(qqnump)
 S Vo(qqnump)=qqview,  Vo(qqnump,-1,-1)=qqoView   ;Маслова 06.08.2010
 s Vt(qqnump,"Znsp")=$ZU(5) ;текущее NameSpace
 
 I $G(qruls)'="",$D(^Q(1,"XRuls",qruls,"XViewStat",qqview)) S qrulsV=qqview D  ;@dol 25.06.03 отработка роли
 .S qqObj="" F  S qqObj=$O(^Q(1,"XRuls",qruls,"XViewStat",qqview,"CxObj",qqObj)) Q:qqObj=""  D
 ..;I $G(^(qqObj,"Ref1")) S:$G(Vs("par",2,qqObj))'=0 Vs("par",2,qqObj)=1 ;раскрыть
 ..I $G(^(qqObj,"Ref0")) S:$G(Vs("par",5,qqObj))'=0 Vs("par",5,qqObj)=1 ;не выводить
 ..S y="" F  S y=$O(^Q(1,"XRuls",qruls,"XViewStat",qqview,"CxObj",qqObj,"CxWoc",y)) Q:y=""  D
 ...I $G(^(y,"Ref0")) S:$G(Vs("par",5,qqObj,y))'=0 Vs("par",5,qqObj,y)=1
 .S:$D(Vs("par",5)) Vo(qqnump,-1,"XMod")="*"
 ;отображение
 S Vo(qqnump,-1)=$G(^Q(1,qqoView,qqview,"X11"))
 S Vo(qqnump,-1,21)=$G(^Q(1,qqoView,qqview,"x121")) ;тип 0/1 (лог/физ дерево)
 I $G(^Q(1,qqoView,qqview,"CxObj",-1,"x52")) S Vo(qqnump,-1,2)=^("x52") ;@dol 11.04.03 вершина может иметь тип (используется в отображении архива новой аналитики)
 G:NoWin CreVoEnd ;в сокращенном варианте x52 был ненаследуемым???? @dol 5.10.02
 ;;;;S (q155,Vo(qqnump,-1,55))=..BasePar("X155",$G(^Q(1,qqoView,qqview,"X155"))) ;параметры основного фонта
 S Vo(qqnump,-1,50)=..BasePar("X150",$G(^Q(1,qqoView,qqview,"X150"))) ;@Dol 4.07.05 BasePar ;;параметры констант
 S Vo(qqnump,-1,51)=..BasePar("X151",$G(^Q(1,qqoView,qqview,"X151"))) ;параметры выражений
 S Vo(qqnump,-1,52)=..BasePar("X152",$G(^Q(1,qqoView,qqview,"X152"))) ;параметры понятий
 S Vo(qqnump,-1,77)=..BasePar("X177",$G(^Q(1,qqoView,qqview,"X177"))) ;параметры понятий c запретом редактирования
 S Vo(qqnump,-1,664)=..BasePar("X1664",$G(^Q(1,qqoView,qqview,"X1664"))) ;параметры понятий c обязательным значением (X740=1)
 S Vo(qqnump,-1,60)=$G(^Q(1,qqoView,qqview,"X160"),20) ;Кол-во выводимых в дерево экземпляров
 S Vo(qqnump,-1,71)=$G(^Q(1,qqoView,qqview,"X171"),500) ;Кол-во выводимых в дерево экземпляров при фиксации или для главных объектов
 S Vo(qqnump,-1,61)=+$G(^Q(1,qqoView,qqview,"x161")) ;стиль
 S Vo(qqnump,-1,62)=$G(^Q(1,qqoView,qqview,"X162")) ;Автоизменение размеров
 S Vo(qqnump,-1,64)=$G(^Q(1,qqoView,qqview,"X164")) ;обобщение заголовка
 S Vo(qqnump,-1,65)=$G(^Q(1,qqoView,qqview,"x165")) ;Полный вывод;;@dol 25.11.02 "X165"))
 S Vo(qqnump,-1,66)=$G(^Q(1,qqoView,qqview,"X166")) ;НЕ выводить подчерк;@dol 17.01.03
 S Vo(qqnump,-1,70)=$G(^Q(1,qqoView,qqview,"X170")) ;Умолчания
 S Vo(qqnump,-1,81)=$G(^Q(1,qqoView,qqview,"x181")) ;вид кнопок дерева экземпляров
 S Vo(qqnump,-1,87)=$G(^Q(1,qqoView,qqview,"x187")) ;вывод отсутствующих экземпляров
 S Vo(qqnump,-1,670)=$G(^Q(1,qqoView,qqview,"X1670")) ;Условие немедленного редактирования
 S Vo(qqnump,-1,59)=$G(^Q(1,qqoView,qqview,"X159")) S:Vo(qqnump,-1,59)="" Vo(qqnump,-1,59)=$G(qqXB159) ;@Dol 15.04.07
 S Vo(qqnump,-1,1990)=$G(^Q(1,qqoView,qqview,"X11990")) S:Vo(qqnump,-1,1990)="" Vo(qqnump,-1,1990)=$G(qqXB11990) ;@Dol 06.03.09
 S:$G(^Q(1,qqoView,qqview,"X1660")) Vo(qqnump,-1,660)=1 ;@Dol 23.02.05
 S:$G(^Q(1,qqoView,qqview,"X1855")) Vo(qqnump,-1,855)=1 ;@Dol 27.07.06 наследование Редактирование и Администратор
 S:$TR($G(^Q(1,qqoView,qqview,"X167"))," ")'="" Vo(qqnump,-1,67)=^("X167") ;,Vt(qqnump,0)=1 ;постоянные условия отображения
 ;S Vo(qqnump,-1,194)=$G(^Q(1,qqoView,qqview,"X1194")) ;ресурс релевантных
 S:$D(^Q(1,qqoView,qqview,"X169")) Vo(qqnump,-1,69)=^("X169") ;действие по правой кнопке
 S:$D(^Q(1,qqoView,qqview,"X1821")) Vo(qqnump,-1,821)=^("X1821") ;@Dol 21.08.08 понятие для колонки релевантных
 S:$TR($G(^Q(1,qqoView,qqview,"X1669"))," ")'="" Vo(qqnump,-1,669)=^("X1669") ;@Dol 28.06.06 скролбар перемещений
 S:$TR($G(^Q(1,qqoView,qqview,"X1856"))," ")'="" Vo(qqnump,-1,856)=^("X1856") ;@Dol 19.09.06 перемещения по меткам табуляции
 K W("ZBtredo") ;чтобы запустить переинициализацию граф
 ;объекты
CreVoEnd D ..CreVoObj($S($D(Vs("par",5)):-1,1:""),qqoView_$C(1)_qqview,$D(Vs("par",5)),$G(Vs("par",5)),NoWin)
 I $D(Vo("par")) M Vo(qqnump)=Vo("par") K Vo("par") ;есть сформированный массив параметров
 I $D(Vt("par")) M Vt(qqnump)=Vt("par") K Vt("par") ;sas 20100707 есть сформированный массив рабочих переменных отображения
 ;;;;;;;;;K Vs("par",5) ;уберем невключаемые ;(а печатная форма рухнет ???)
 D ..CreVoAdd()
 I $D(qerr) N qqred S qqred="" D qARM.OpenDoc("qerr",," ","Ошибки"," ")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CreVoAdd">
<Description>
           Создание параметров колонок и таблиц понятий. </Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqObj,y,x,z,qqt,qqw,qz
 S qqObj="" F  S qqObj=$O(Vo(qqnump,qqObj)) Q:qqObj=""  K Vo(qqnump,qqObj,10),Vo(qqnump,qqObj,11) D  ;@Dol 17.02.07 K 10,11 - иначе сложности с динамическим удалением (..CreCol )
 .I $G(Vo(qqnump,qqObj,28))!$D(Vo(qqnump,qqObj,27)) S Vt(qqnump,0)=1 S:$G(Vo(qqnump,qqObj,27))="@" Vo(qqnump,qqObj,27)=$G(qqXBaseX527)  ;есть постоянные условия
 .;I $D(qrulsV),$D(^Q(1,"XRuls",qruls,"XViewStat",qrulsV,"CxObj",qqObj,"Ref5")) S Vt(qqnump,0)=1,Vo(qqnump,qqObj,27)=$S($G(Vo(qqnump,qqObj,27))="":^("Ref5"),1:Vo(qqnump,qqObj,27)_"&&("_^("Ref5")_")") ;@dol 21.07.03 условия из роли
 .I $G(Vo(qqnump,qqObj,889))'=""||$D(qrulsV),$G(qruls)'="",$D(^Q(1,"XRuls",qruls,"XViewStat",$S($G(Vo(qqnump,qqObj,889))'="":Vo(qqnump,qqObj,889),1:qrulsV),"CxObj",qqObj,"Ref5")) N cond S cond=^("Ref5"),Vt(qqnump,0)=1,Vo(qqnump,qqObj,27)=$S($G(Vo(qqnump,qqObj,27))="":$S("|!&"'[$E(cond):cond,1:1_cond),"|!&"'[$E(cond):cond,1:Vo(qqnump,qqObj,27)_cond)  ;@dol 2.12.03 условия из роли
 .S y="" F  S y=$O(Vo(qqnump,qqObj,0,y)) Q:y=""  D
 ..S x="" F  S x=$O(Vo(qqnump,qqObj,0,y,x)) Q:x=""  D
 ...S qqt=$G(Vo(qqnump,qqObj,0,y,x)),qqw=$E($P(qqt," "),2,255),qqt=+$E(qqt) I qqt=6,$E(qqw,1,3)="@ZX" S qqt=2
 ...I "234"[qqt,qqw'="" D
 .... ; @rda 20101018 добавлено взятие параметров ячейки из описания понятия, было забыто?
 .... F qz="x710","X72","X76","X77","x730","X731","X720","x760","X762","X7102","X7104","X763","X764","X784","X786","X788","X789","X7810" D  
 ..... if $G(Vo(qqnump,qqObj,0,y,x,$E(qz,3,999)))="",$G(^Q(1,"CxWoc",$S(qqw[":":$P($P(qqw,":",2),"{"),1:qqw),qz))'="" s Vo(qqnump,qqObj,0,y,x,$E(qz,3,999))=$G(^(qz))
 .... s:$G(Vo(qqnump,qqObj,0,y,x,86)) Vt(qqnump,786)=1 ;@dol 31.08.06 метка табуляции и признак наличия меток
 .... if $E($S(qqw[":":$P(qqw,":",2),1:qqw),1,3)="dat",$G(Vo(qqnump,qqObj,0,y,x,10))="" S Vo(qqnump,qqObj,0,y,x,10)=1 ;неявный тип DATE
 .... if $E($G(Vo(qqnump,qqObj,0,y,x,10)))="M",'$P($G(Vo(qqnump,qqObj,0,y,x,2)),",",2) S $P(Vo(qqnump,qqObj,0,y,x,2),",",2)=2 ;@Dol 19/06/06 деньги выравниваются вправо
 .... if $E($G(Vo(qqnump,qqObj,0,y,x,10)))="F" S $E(Vo(qqnump,qqObj,0,y,x),1)=4 ;@gol rda 20101008 тип FLAG
 .... S Vo(qqnump,qqObj,11,qqw)=y_" "_x,z=$I(Vo(qqnump,qqObj,10)),Vo(qqnump,qqObj,10,z)=qqw ;Таблица понятий
 ....;тип (временно)???? 
 ....;I $G(Vo(qqnump,qqObj,0,y,x,10)) S Vo(qqnump,-1,"Zlnum")=$G(Vo(qqnump,-1,"Zlnum"))_" "_qqw_";8" ;список дат
 ...;параметры колонок по параметрам ячеек
 ...I qqObj=-1,'y S Vo(qqnump,-1,9,x)=$G(Vo(qqnump,qqObj,0,y,x,2)) Q  ;параметры колонок
 ...S z=$G(Vo(qqnump,qqObj,0,y,x,2))
 ...S Vo(qqnump,-1,9,x)=$G(Vo(qqnump,-1,9,x)),qqw=$G(Vo(qqnump,-1,0,y,x,2))
 ...I qqt=3,'$P(z,",",3) S $P(z,",",3)=1 ;для списка
 ...I '$P(z,",",3),$G(Vo(qqnump,qqObj,0,y,x,10))=3||($E($G(Vo(qqnump,qqObj,0,y,x)),2)="T") S $P(z,",",3)=1 ;для DOCUMENT ;@Dol 29.06.10 было 5 - разбивка по пробелу
 ...Q:$TR(z,",")=""  I $P(Vo(qqnump,-1,9,x),",")'=-1,$P($G(Vo(qqnump,-1,0,0,x,2)),",")="" D  ;если указан размер в параметрах колонок, то он подавляет остальные размеры
 ....;-1 - оптимальная ширина колонки
 ....I $P(z,",")=-1 S $P(Vo(qqnump,-1,9,x),",")=-1 Q
 ....I $P(z,",")'="",$P(z,",")["px" S $P(z,",")=$J($P(z,",")/$P(W("Zfont"),",",3),0,0) ;если пиксели, приведем к условным символам
 ....S:$P(Vo(qqnump,-1,9,x),",")<$P(z,",") $P(Vo(qqnump,-1,9,x),",")=$P(z,",")
 ...;F qqt=2:1:3 I $P(qqw,",",qqt)="" S:$P(Vo(qqnump,-1,9,x),",",qqt)<$P(z,",",qqt) $P(Vo(qqnump,-1,9,x),",",qqt)=$P(z,",",qqt)
 ...S:$P(Vo(qqnump,-1,9,x),",",3)<$P(z,",",3) $P(Vo(qqnump,-1,9,x),",",3)=$P(z,",",3) ;@dol 9.03.03 SftTree4.5
 .I $G(Vo(qqnump,qqObj,7))'="" D  ;дополнительные понятия;@Dol 22.05.08 '="" ??? Почему-то иногда есть потомки???
 ..S qqt=Vo(qqnump,qqObj,7) F x=1:1:$L(qqt," ") S qqw=$P(qqt," ",x) I qqw'="",$E(qqw)'="-",'$D(Vo(qqnump,qqObj,11,qqw)) S z=$I(Vo(qqnump,qqObj,10)),Vo(qqnump,qqObj,10,z)=qqw ;@Dol 18.05.09 $E(qqw)'="-"
 S Vo(qqnump,-1,9)=$O(Vo(qqnump,-1,9,""),-1) ;кол-во граф-1
 S:$G(Vo(qqnump,-1,67))'="" Vt(qqnump,0)=1 ;постоянные условия отображения
 I $D(qrulsV),$D(^Q(1,"XRuls",qruls,"XViewStat",qrulsV,"Ref5")) N cond S cond=^("Ref5"),Vt(qqnump,0)=1,Vo(qqnump,-1,67)=$S($G(Vo(qqnump,-1,67))="":$S("|!&"'[$E(cond):cond,1:1_cond),"|!&"'[$E(cond):cond,1:Vo(qqnump,-1,67)_cond) ;@dol 1.12.03 условия из роли
 D ..CreVoRef(-1) ;построение таблицы объектных ссылок
 I '$D(Vt(qqnump,111)) Q:$Q "" Q
 ;для ссылочных и виртуальных строится список хранимых, находящихся выше
 ;S qqObj="" F  S qqObj=$O(Vt(qqnump,111,1,qqObj)) Q:qqObj=""  S z=$$$ObjRef(qqObj) F x=1:1:$L(z,",")-1 S:'$D(Vt(qqnump,111,1,$P(z,",",x))) Vt(qqnump,111,0,$P(z,",",x))=""
 S qqObj=-1 F  S qqObj=$O(Vo(qqnump,qqObj)) Q:qqObj=""   D  S:'z Vt(qqnump,111,0,qqObj)=""
 .S qqt="",z=0 F  S qqt=$O(Vt(qqnump,111,1,qqt)) Q:qqt=""  I ","_$G($$$ObjRef(qqObj))_","[(","_qqt_",") S z=1 Q
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CreVoObj">
<Description>
Построение описания объета (или объектов, если qqObj="") в массиве Vo.
YxObj=1 - отслеживать потомков по описанию
ObjRef - явная объектная ссылка
NoWin=1 - сокращенный вариант

qqObji - объект-источник для замены, если ссылка на описание
qqObje - список соответствия для ссылок на описание (список вида qqoi=qqo)</Description>
<Internal/>
<FormalSpec>qqObj:%Library.String,qqview:%Library.String,YxObj:%Library.String=0,ObjRef:%Library.String,NoWin:%Library.String,qqObji:%Library.String,qqObje:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N x,y,z,qqt,qqv,qqObjRef,xmax
 
 S:$G(qqview)="" qqview=$g(Vo(qqnump,-1,-1))_$s($g(Vo(qqnump,-1,-1))'="":$C(1),1:"")_Vo(qqnump)   ;Маслова 06.08.2010
 
 N qqoView
 S qqoView=$S(qqview'[$C(1):"XView",1:$P(qqview,$C(1))) S:qqview[$C(1) qqview=$P(qqview,$C(1),2,255) ;Маслова 06.08.2010
 
 S:$G(qqObji)="" qqObji=qqObj ;@dol 25/09/04
 D:qqObj'=""  Q:qqObj'=""  S qqObj="" F  S qqObj=$O(^Q(1,qqoView,qqview,"CxObj",qqObj)) Q:qqObj=""  S qqObji=qqObj D
 .I $S($G(W("ZBt0")):0,qqObj'=-1:0,1:$G(^Q(1,qqoView,qqview,"XMod"))'="") D  I 'x S Vo(qqnump,-1,"XMod")=$G(Vo(qqnump,-1,"XMod"))_","_qqObj S:qqObj=-1 qMessage="Отображение "_qqview_" не загружено. XMod="_^Q(1,qqoView,qqview,"XMod") Q
 ..N qqo S qqo=qqObj,x=0 I qARM.Value(^("XMod")) S x=1
 .I qqObj'=-1,$G(^Q(1,qqoView,qqview,"CxObj",qqObji,"x52"))=9,'$G(W("ZBt0")) D  Q:$D(z)  ;сысылка но описание в другом отображении
 ..S z=$G(^("X529"))
 ..S:$E(z)="@" z=qARM.Value($E(z,2,3000)) ;@dol 16.07.03
 ..S qqObji=$P(z," ",2),qqObje=$P(z," ",3,255),z=$P(z," ") S:z="*" z=Vo(qqnump) ;@dol 25.09.04
 ..I z="sysT"||(z="sysB") D ..CreObj(qqObj,z="sysT",,1,0) Q
 ..I z=""||('$D(^Q(1,"XView",z))) S qerr($I(qerr))="qWord. Obj="_qqObj_" Ссылка на несуществующее отображение "_z K z Q
 ..D  ;обеспечение указания роли для ссылочного отображения
 ...N qqview,qqObj,y S qqview=z I $G(qruls)'="",$D(^Q(1,"XRuls",qruls,"XViewStat",qqview)) D  ;@dol 25.06.03 отработка роли
 ....S qqObj="" F  S qqObj=$O(^Q(1,"XRuls",qruls,"XViewStat",qqview,"CxObj",qqObj)) Q:qqObj=""  D
 .....;I $G(^(qqObj,"Ref1")) S:$G(Vs("par",2,qqObj))'=0 Vs("par",2,qqObj)=1 ;раскрыть
 .....I $G(^(qqObj,"Ref0")) S:$G(Vs("par",5,qqObj))'=0 Vs("par",5,qqObj)=1 ;не выводить
 .....S y="" F  S y=$O(^Q(1,"XRuls",qruls,"XViewStat",qqview,"CxObj",qqObj,"CxWoc",y)) Q:y=""  D
 ......I $G(^(y,"Ref0")) S:$G(Vs("par",5,qqObj,y))'=0 Vs("par",5,qqObj,y)=1
 ...I $D(Vs("par",5)),$G(Vo(qqnump,-1,"XMod"))="" S Vo(qqnump,-1,"XMod")="*"
 ..D ..CreVoObj(qqObj,z,1,ObjRef,NoWin,qqObji,qqObje)
 .I qqObj=-1,$G(^Q(1,qqoView,qqview,"CxObj",qqObj,"X53")) S Vo(qqnump,-1,3)=1 ;@Dol 5.02.04 - вершина - главный объект
 .D:qqObj'=-1
 ..I Vo(qqnump)'=qqview||(qqObj'=qqObji) S Vo(qqnump,qqObj,889)=qqview_$S(qqObj'=qqObji:" "_qqObji,1:"") ;@dol 26.09.04 объект создан по ссылке на описание
 ..S Vo(qqnump,qqObj)=$G(^Q(1,qqoView,qqview,"CxObj",qqObji,"X51")) ;имя в отображении
 ..S z="x52" D  I 'NoWin F z="X526","X527","X528","X529","X539","X587","X540","X5870","X5242","X5245","X5246" D  ;наследуемые x52,"X54","X53"????
 ...I $G(^Q(1,qqoView,qqview,"CxObj",qqObji,z))'="" S Vo(qqnump,qqObj,$E(z,3,10))=^(z) Q
 ...I $D(^Q(1,"CxObj",qqObji,z)) S Vo(qqnump,qqObj,$E(z,3,10))=^(z) Q  ;наследование из объектов
 ..S Vo(qqnump,qqObj,247)=$G(^Q(1,"CxObj",$S($E(qqObji)'="v":qqObji,1:$E(qqObji,3,255)),"X5247")) ;@Dol 9.10.07 счетчики поддеревьев
 ..S Vo(qqnump,qqObj,0)=$G(^Q(1,"CxObj",qqObji,"X50")) I '$$$Tree,Vo(qqnump,qqObj,0)="" S:'$G(Vo(qqnump,qqObj,2))&&('$G(^Q(1,"CxObj",qqObji,"Xsys"))) qerr($I(qerr))="qWord. Obj="_qqObj_" не задана длина кода" S Vo(qqnump,qqObj,0)=255 S:$E(qqObj)="v" Vo(qqnump,qqObj,0)=$G(^Q(1,"CxObj",$E(qqObj,3,255),"X50"),255) ;@dol 23.09.03 "v"
 ..I $G(Vo(qqnump,qqObj,29))'="",$G(Vo(qqnump,qqObj,2))'=9,"*$"'[$E(Vo(qqnump,qqObj,29)),Vo(qqnump,qqObj,29)'["(",Vo(qqnump,qqObj,29)[":" D  ;есть список переходов для виртуальных, составим таблицу
 ...F x=1:1:$L(Vo(qqnump,qqObj,29)," ") S z=$P(Vo(qqnump,qqObj,29)," ",x),Vt(qqnump,529,qqObj,$P(z,":",1))=$TR($P(z,":",2),","," ") ;Vt(qqnump,529,qqo)=qqw - связь через значение понятия
 ..I 'NoWin,$D(^Q(1,qqoView,qqview,"CxObj",qqObji,"X54")) D  ;@dol 10.02.03 спец. обработка флага свертки экземпляров
 ...S z=^("X54") I "01234"[$E(z) S Vo(qqnump,qqObj,4)=z Q
 ...S Vo(qqnump,qqObj,400)=$S($E(z)'="@":z,1:$E(z,2,32000)) ;выражение для флага свертки
 ..S z="X53" D:'NoWin  F z="X57","X541","x570","X5244","X5249","X519" D  ;@Dol 10.03.06 "X527","X528", - сделаны наследуемыми ;;;ненаследуемые ;"x52","X527","X528","X57" - было по сокращенному варианту (NoWin=1)
 ...I $G(^Q(1,qqoView,qqview,"CxObj",qqObji,z))'="" S Vo(qqnump,qqObj,$E(z,3,10))=^(z)
 ..I $G(Vo(qqnump,qqObj,2)) S:Vo(qqnump,qqObj,2)'=9 Vt(qqnump,111,1,qqObj)="" S:Vo(qqnump,qqObj,2)=9 Vo(qqnump,qqObj,2)=0 ;есть ссылочные или виртуальные объекты ;@dol 20.02.03 >1 ??? встроенные
 ..S:$G(Vo(qqnump,qqObj,70)) Vt(qqnump,570)=1 ;наличие Drag&Drop
 .;строки
 .S y="",xmax=0 F  S y=$O(^Q(1,qqoView,qqview,"CxObj",qqObji,"Xy",y)) Q:y=""  I $S('y:1,$G(W("ZBt0")):1,$D(Vs("par",5,qqObj,y))=1:0,1:1) D  ;@dol 5.11.02 не включать можно любую строку, кроме 0
 ..S x=$G(^(y,"X60")),z=$G(^("X61")) I z'="",'$G(W("ZBt0")) Q:$D(Vs("par",5,qqObj,z))=1  S:$D(Vs("par",1,qqObj,z))=1 Vs("par",1,qqObj,y)=1 ;модификатор загрузки и зачеркивания по имени
 ..I $G(^("XMod"))'="",'$G(W("ZBt0")) D  Q:'z  ;@dol 2.8.03
 ...N qqo S qqo=qqObj,z=0 I qARM.Value(^("XMod")) S z=1
 ..I x'="",$G(qqObjRef)="" S qqObjRef=$P(ObjRef,",") I qqObjRef'=-1 S:qqObjRef'="" x=qqObjRef Q:$G(Vs("par",5,x))  D  Q
 ...I $S($G(W("ZBt0")):0,1:$G(^Q(1,qqoView,qqview,"CxObj",x,"XMod"))'="") D  I 'z S Vo(qqnump,-1,"XMod")=$G(Vo(qqnump,-1,"XMod"))_","_x Q
 ....N qqo S qqo=x,z=0 I qARM.Value(^("XMod")) S z=1
 ...S Vo(qqnump,qqObj,0,y)=x Q:'YxObj
 ...I $G(qqObje)'=""," "_qqObje[(" "_x_"=") N qqObji S qqObji=$P($P(" "_qqObje," "_x_"=",2)," ") K:qqObji="" Vo(qqnump,qqObj,0,y) Q:qqObji=""  I qqObji'="" S Vo(qqnump,qqObj,0,y)=qqObji D ..CreVoObj($G(qqObji),qqoView_$C(1)_qqview,1,$P(ObjRef,",",2,255),NoWin,x,$G(qqObje)) Q  ;@dol 25.09.04 
 ...D ..CreVoObj(x,qqoView_$C(1)_qqview,1,$P(ObjRef,",",2,255),NoWin) ;объект-потомок
 ..;ячейки
 ..S x="" F  S x=$O(^Q(1,qqoView,qqview,"CxObj",qqObji,"Xy",y,"Xx",x)) Q:x=""  I $S($G(W("ZBt0")):1,1:'$D(Vs("par",5,qqObj,y,x))) D
 ...S:x>xmax xmax=x S qqt=$G(^(x,"x70"),0),qqw=$G(^("X71")) I qqw="",qqt,qqt'=5 S qerr($I(qerr))="qWord. Obj="_qqObj_" Нет кода понятия для ячейки y="_y_" x="_x Q
 ...I qqt,qqt'=5,$G(Vs("par",5,qqObj,qqw)),'$G(W("ZBt0")) D  Q
 ....I x,$E($G(Vo(qqnump,qqObj,0,y,x-1)))=0 K Vo(qqnump,qqObj,0,y,x-1) ;удалим связанную константу
 ...S Vo(qqnump,qqObj,0,y,x)=qqt_qqw ;тип и содержимое
 ...S z="x710" D  I 'NoWin F z="X72","X76","X77","x730","X731","X720","x760","X762","X7102","X7104","X763" D  ;@dol 2.11.02 x731; tdv 18.03.08 X763 - Пересчитываемое выражение
 ....I $G(^Q(1,qqoView,qqview,"CxObj",qqObji,"Xy",y,"Xx",x,z))'="" S Vo(qqnump,qqObj,0,y,x,$E(z,3,10))=^(z) Q
 ....I qqw'="","234"[qqt,$D(^Q(1,"CxWoc",$S(qqw[":":$P($P(qqw,":",2),"{"),1:qqw),z)) S Vo(qqnump,qqObj,0,y,x,$E(z,3,10))=^(z) Q  ;наследование от понятий
 ...S Vo(qqnump,qqObj,0,y,x,64)=$G(^Q(1,qqoView,qqview,"CxObj",qqObji,"Xy",y,"Xx",x,"X764")) ;@rda 20090513 прозрачные теги
 ...S Vo(qqnump,qqObj,0,y,x,84)=$G(^Q(1,qqoView,qqview,"CxObj",qqObji,"Xy",y,"Xx",x,"X784")) ;@dol 20.07.04 ссылка на образец
 ...S Vo(qqnump,qqObj,0,y,x,88)=$G(^Q(1,qqoView,qqview,"CxObj",qqObji,"Xy",y,"Xx",x,"X788")) ;@SAS 20081205 количество знаков после запятой
 ...S Vo(qqnump,qqObj,0,y,x,89)=$G(^Q(1,qqoView,qqview,"CxObj",qqObji,"Xy",y,"Xx",x,"X789")) ;@SAS 20081205 вариант ввода дробной части
 ...S Vo(qqnump,qqObj,0,y,x,810)=$G(^Q(1,qqoView,qqview,"CxObj",qqObji,"Xy",y,"Xx",x,"X7810")) ;sas 20100714 для DEC включение групп разрядов
 ...S (z,Vo(qqnump,qqObj,0,y,x,86))=$G(^Q(1,qqoView,qqview,"CxObj",qqObji,"Xy",y,"Xx",x,"X786")) S:z Vt(qqnump,786)=1 ;@dol 31.08.06 метка табуляции и признак наличия меток
 ...I $E($G(Vo(qqnump,qqObj,0,y,x,10)))="M",'$P($G(Vo(qqnump,qqObj,0,y,x,2)),",",2) S $P(Vo(qqnump,qqObj,0,y,x,2),",",2)=2 ;@Dol 19/06/06 деньги выравниваются вправо
 ...//I $E($G(Vo(qqnump,qqObj,0,y,x,10)))="F" S $E(Vo(qqnump,qqObj,0,y,x),1)=4 ;@gol rda 20101008 для понятий типа FLAG ставим принуительно вывод в в отобр. в виде флага
 ...I qqt=4 I $E($G(Vo(qqnump,qqObj,0,y,x,10)))="F" S $E(Vo(qqnump,qqObj,0,y,x),1)=4 ;@gol rda 20101008 для понятий типа FLAG ставим принуительно вывод в в отобр. в виде флага @sas 20101122 добавлено условие переопределения только для понятий
 .I $G(Vo(qqnump,qqObj,41))>1 D  ;несколько экземпляров в одной строке
 ..S y="" F  S y=$O(Vo(qqnump,qqObj,0,y)) Q:y=""  S x="" F  S x=$O(Vo(qqnump,qqObj,0,y,x)) Q:x>xmax  D
 ...S qqt=$G(Vo(qqnump,qqObj,0,y,x)) F z=1:1:Vo(qqnump,qqObj,41) D
 ....M:z'=1 Vo(qqnump,qqObj,0,y,x+(z-1*(xmax+1)))=Vo(qqnump,qqObj,0,y,x)
 ....S:qqt'="" Vo(qqnump,qqObj,0,y,x+(z-1*(xmax+1)))=$E(qqt)_$E(100+z,2,3)_$E(qqt,2,30000)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CreVoRef">
<Description>
Создание объектных ссылок
qql0 - породить заведомо несуществующие коды в  слое qqlo. Используется
для вывода дерева с пустыми значениями. В этом случае - qqc0 - начальный код экземпляра.</Description>
<Internal/>
<FormalSpec>qqObj:%String,qql0:%String,qqc0:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N y,z,qqc1,z0,qxObj
 S y="",z0=0,qxObj="" F  S y=$O(Vo(qqnump,qqObj,0,y)) Q:y=""  S z=$G(Vo(qqnump,qqObj,0,y)) D:z'=""
 .I '$D(Vo(qqnump,z)) K Vo(qqnump,qqObj,0,y) S qerr($I(qerr))="qWord. Obj="_qqObj_" y="_y_" ссылка "_z_" не существует" Q  ;???K ^Q(1,"XView",Vo(qqnump),"CxObj",qqObj,"Xy",y) Q  ;ссылка на несуществующий объект
 .I qqObj=-1 S Vo(qqnump,z,5)=z,Vo(qqnump,-1,6,z)="" I 1
 .E  S (qqt,Vo(qqnump,z,5))=Vo(qqnump,qqObj,5)_","_z,Vo(qqnump,-1,6,qqt)="",z0=1
 .I $G(qql0)'="" D  D ..CreVoRef(z,qql0,qqc1) Q  ;для построения Пояснений (первая ссылка на подчиненный объкт в этом случае - 1000 (см.qSYS.sysView (V)
 ..I '$G($$$Tree) S qqc1=qqc0_$TR($J("",$S($G($$$ObjLqqc(z),1)<255:$G($$$ObjLqqc(z),1),1:1)-$L(qqc0))," ","*"),^Q(qql0,z,qqc1)="" Q  ;""-(y-999)
 ..S qqc1=$NA(@qqc0@(z,y-999)),@qqc1=""
 .S qxObj=qxObj_" "_z
 .D ..CreVoRef(z)
 S Vo(qqnump,qqObj,"xObj")=$E(qxObj,2,30000) ;@dol 19.10.02 текущий список потомков
 S:qqObj'=-1 Vo(qqnump,-1,6,Vo(qqnump,qqObj,5))=z0 ;если последний в иерархии, то 0
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CreXDBF">
<Internal/>
<FormalSpec>Arg1:%Library.String,file:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;qARM("qpars",N)
 N str,stri,tab,atr,ind,atrtyp,atrlen,atrcom,atrlst,ifile,i
 S ifile=$S($G(file)'="":"",1:$O(qARM("qpars",""),-1)) I ifile'="" S file=qARM("qpars",0)
 S tab="" Q:$G(file)="" ""
 S:$G(Arg1)="" Arg1=$P(file,"\",$L(file,"\")-1) ;используем имя директории
 S ^Q(1,"XSQL",Arg1,"XSQLtyp")="DBF"
 ;K ^Q(1,"XSQL",Arg1)
 I ifile="" S str=$$CreXDBFf() Q:$Q Arg1 Q
 F ifile=0:1:ifile S file=qARM("qpars",ifile),str=$$CreXDBFf() Q:'str  ;вызов из qARM.OpenWinDialog()
 Q:$Q Arg1 Q
CreXDBFf()  K Fld I '(..DBF(file,1,,1)) D qARM.Message("Ошибка открытия "_file) Q ""
 S tab=$P($P(file,"\",$L(file,"\")),".")
 K ^Q(1,"XSQL",Arg1,"XSQLtab",tab) S ^(tab)="",atrlst=""
 F i=1:1:Fld D:$G(Fld(i,"L"))
 .S atr=Fld(i,"N"),^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr)="",atrlst=atrlst_" "_atr
 .S ^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr,"XSQLtyp")=Fld(i,"T")
 .S ^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr,"XSQLlen")=Fld(i,"L")
 .S ^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr,"XSQLcom")="Поле_"_i
 S ^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatrlst")=$E(atrlst,2,30000)
 Q 1
]]></Implementation>
</Method>

<Method name="CreXSQL">
<Description>
Загрузка Script-файла SQL-базы в отображение XXXSQL</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,file:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N str,stri,tab,atr,ind,atrtyp,atrlen,atrcom,atrlst
 S tab="" I $G(file)="" Q:$Q "" Q
 S:$G(Arg1)="" Arg1=$P(file,"\",$L(file,"\"))
 O file::5 I '$T D qARM.Message("Ошибка открытия "_file) Q:$Q "" Q
 K ^Q(1,"XSQL",Arg1)
 F  U file R str Q:$ZEOF=-1  D
 .I str["CREATE TABLE"  D  Q
 ..S str=$ZSTRIP($P(str,"CREATE TABLE",2,255),"<>W")
 ..I str[".[" S tab=$P($P(str,".[",2,1000),"]") I 1
 ..E  S tab=$P(str," ")
 ..K ^Q(1,"XSQL",Arg1,"XSQLtab",tab) S ^(tab)="",atrlst=""
 .I tab'="",$E(str)=")" D  S tab="" Q
 ..S ^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatrlst")=$E(atrlst,2,30000)
 ..S str=$P(str,"[PRIMARY]",2,255),str=$ZSTRIP(str,"<>W")
 ..I str'="" S ^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLprim")=str
 .I tab'="",str["[" D  Q
 ..S atr=$P($P(str,"]"),"[",2),str=$P(str,"]",2,1000),^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr)="",atrlst=atrlst_" "_atr
 ..S atrtyp=$P($P(str,"]"),"[",2),str=$P(str,"]",2,1000),^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr,"XSQLtyp")=atrtyp
 ..S atrlen="" I $E(str,2)="(" S atrlen=$P($P(str,")"),"(",2),str=$P(str,")",2,1000),^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr,"XSQLlen")=atrlen
 ..S atrcom=$ZSTRIP(str,"<>W") I atrcom'="" S ^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr,"XSQLcom")=atrcom
 .I tab'="" D  Q
 ..S str=$ZSTRIP(str,"<>W")
 ..Q:str=""  Q:"()"[$E(str)
 ..I " REFERENCES CONSTRAINT IDENTITY PRIMARY "[(" "_$P($P(str," "),"(")_" ") Q:atr=""  S ^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr,"XSQLcom")=$G(^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr,"XSQLcom"))_" "_str Q
 ..S atr=$P(str," "),^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr)="",atrlst=atrlst_" "_atr
 ..S str=$ZSTRIP($P(str," ",2,30000),"<>W")
 ..S atrtyp=$P(str," "),^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr,"XSQLtyp")=$P(atrtyp,"(")
 ..S atrlen="" I atrtyp["(" S atrlen=$P($P(atrtyp,")"),"(",2),^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr,"XSQLlen")=atrlen
 ..S str=$ZSTRIP($P(str," ",2,30000),"<>W")
 ..S atrcom=$ZSTRIP(str,"<>W") I atrcom'="" S ^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr,"XSQLcom")=atrcom
 .I $TR(str," ")["CREATEINDEX" D  S tab="" Q
 ..S str=$P(str,"INDEX",2,255)
 ..S ind=$P($P(str,"]"),"[",2),str=$P(str," ON ",2,255)
 ..S tab=$P($P(str,".[",2,1000),"]"),str=$TR($P($P(str,"(",2,30000),")"),"]["," ") F stri=1:1:$L(str," ") S atr=$P(str," ",stri) D:atr'=""
 ...S ^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr,"XSQLind")=$S($G(^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr,"XSQLind"))="":ind,1:^Q(1,"XSQL",Arg1,"XSQLtab",tab,"XSQLatr",atr,"XSQLind")_" "_ind)
 C file
 Q:$Q Arg1 Q
]]></Implementation>
</Method>

<Method name="CreXXX0">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 K ^Q(1,"XView","XXX0")
 S ^Q(1,"XView","XXX0","X11")="Пояснения"
 S ^Q(1,"XView","XXX0","X123")="S W(""Zqqnump"")=$P(qqParent,"" "",2),Vs(qqnump,99,""Pic"")=1"
 S ^Q(1,"XView","XXX0","X169")="D qARM.Print(,1) S qqend=1"
 S ^Q(1,"XView","XXX0","XPrint",0,"X325")="S Vs(qqnump,99,""Pic"")=1,W(""Zqqnump"")=$P(qqParent,"" "",2) S:Vo(W(""Zqqnump""))=""XXX0"" W(""Zqqnump"")=$P(Vt(W(""Zqqnump""),""Zparent""),"" "",2)"
 S ^Q(1,"XView","XXX0","XPrint",0,"x321")=0
 S ^Q(1,"XView","XXX0","XPrint",0,"X367")=-1
 S ^Q(1,"XView","XXX0","x161")=2,^("X160")=500,^("X129")=",,0,11",^("X162")=1
 ;
 S ^Q(1,"XView","XXX0","CxObj",-1,"Xy",0,"Xx",0,"X72")=25,^Q(1,"XView","XXX0","CxObj",-1,"Xy",0,"Xx",1,"X72")=50
 S ^Q(1,"XView","XXX0","CxObj",-1,"Xy",1,"Xx",0,"X71")="""Пояснения к отображению: ""_$S($G(WS(W(""Zqqnump""),""Zadm"")):Vo(W(""Zqqnump""))_"" "",1:"""")_$G(Vo(W(""Zqqnump""),-1))",^("x70")=5,^("X72")=",,,,1,11" ;,^("X76")="""F,otree.jpg,1"""
 S ^Q(1,"XView","XXX0","CxObj",-1,"Xy",2,"Xx",0,"X71")="qW.GT(""XView"",""Thlp"",Vo(W(""Zqqnump"")))",^("x70")=5,^("X710")=3
 ;S ^Q(1,"XView","XXX0","CxObj",-1,"Xy",3,"Xx",0,"X71")="""Установлен режим: ""_$S($G(WS(W(""Zqqnump""),""Zadm"")):""Администратор"",$G(Vs(W(""Zqqnump""),""Analit"")):""Аналитик"",1:""Пользователь"")",^("x70")=5
 S ^Q(1,"XView","XXX0","CxObj",-1,"Xy",4,"Xx",0,"X71")="""Вид: ""_qW.GetWoc(""Cx161"",+$G(Vo(W(""Zqqnump""),-1,61)))",^("x70")=5
 S ^Q(1,"XView","XXX0","CxObj",-1,"Xy",5,"Xx",0,"X71")="$S($G(WS(W(""Zqqnump""),""ZBtred"")):""Включен режим редактирования""_$S($O(Vo(W(""Zqqnump""),-1))="""":"""",$G(WS(W(""Zqqnump""),""Zsform""))=1!($G(WS(W(""Zqqnump""),""Zsform""))>9):"" (F4 - ввод, F8 - удаление)"",1:""""),1:"""")",^("x70")=5
 S ^Q(1,"XView","XXX0","CxObj",-1,"Xy",6,"Xx",0,"X71")="qSYS.vi(7)",^("x70")=5
 S ^Q(1,"XView","XXX0","CxObj",-1,"Xy",7,"Xx",0,"X71")="qSYS.vi(173)",^("x70")=5 ;стиль выхода
 S ^Q(1,"XView","XXX0","CxObj",-1,"Xy",20,"X60")="v0CxObj"
 N i F i=0:1:9 D
 .I 'i S ^Q(1,"XView","XXX0","CxObj","v"_i_"CxObj","Xy",0,"Xx",0,"X71")="Объекты",^("X72")=",,,,4",^("x70")=0,^("X76")="""F,otree.jpg,1""" I 1
 .E  D
 ..S ^Q(1,"XView","XXX0","CxObj","v"_i_"CxObj","Xy",0,"Xx",0,"X71")="qSYS.vi(1)",^("x70")=5,^("X72")=",,,,1",^("X76")="""F,fldopen.jpg,1""" ;имя объекта
 ..S ^Q(1,"XView","XXX0","CxObj","v"_i_"CxObj","Xy",0,"Xx",1,"X71")="qSYS.vi(10)",^("x70")=5,^("x710")=3 ;Пояснения
 .S ^Q(1,"XView","XXX0","CxObj","v"_i_"CxObj","Xy",8,"X60")="v"_i_"Xx"
 .S ^Q(1,"XView","XXX0","CxObj","v"_i_"Xx","Xy",0,"Xx",0,"X71")="qSYS.vi(2)",^("x70")=5,^("X76")="""F,bollb.jpg,1""",^("X72")=",,5,,1,,,8388608" ;,16777215,2" ;Имя понятия
 .S ^Q(1,"XView","XXX0","CxObj","v"_i_"Xx","Xy",0,"Xx",1,"X71")="qSYS.vi(20)",^("x70")=5,^("x710")=3 ;,^("X72")=",,,,,,,8388608,16777215,2" ;Пояснения
 .S ^Q(1,"XView","XXX0","CxObj","v"_i_"Xx","Xy",1,"Xx",1,"X71")="qSYS.vi(21)",^("x70")=5,^("x710")=3 ;,^("X72")=",,,,,,,,16777215,2" ;Редактирование
 .I i'=9 S ^Q(1,"XView","XXX0","CxObj","v"_i_"CxObj","Xy",9,"X60")="v"_(i+1)_"CxObj"
 ;Отображения вызова
 S ^Q(1,"XView","XXX0","CxObj",-1,"Xy",22,"X60")="v0XView"
 S ^Q(1,"XView","XXX0","CxObj","v0XView","Xy",0,"Xx",0,"X71")="@",^("x70")=0,^("X72")=",,,,4"
 S ^Q(1,"XView","XXX0","CxObj","v0XView","Xy",1,"X60")="viXView"
 S ^Q(1,"XView","XXX0","CxObj","viXView","Xy",0,"Xx",0,"X71")="qSYS.vi(100)",^("x70")=5,^("X72")=",,,,1" ;,,,8388608,16777215,2"
 S ^Q(1,"XView","XXX0","CxObj","viXView","Xy",0,"Xx",1,"X71")="Thlp",^("x70")=2,^("x710")=3 ;,^("X72")=",,,,,,,8388608,16777215,2"
 ;Отображения печати
 S ^Q(1,"XView","XXX0","CxObj",-1,"Xy",23,"X60")="v1XView"
 S ^Q(1,"XView","XXX0","CxObj","v1XView","Xy",0,"Xx",0,"X71")="@",^("x70")=0,^("X72")=",,,,4"
 S ^Q(1,"XView","XXX0","CxObj","v1XView","Xy",1,"X60")="vjXView"
 S ^Q(1,"XView","XXX0","CxObj","vjXView","Xy",0,"Xx",0,"X71")="qSYS.vi(200)",^("x70")=5,^("X72")=",,,,1" ;,,,8388608,16777215,2"
 S ^Q(1,"XView","XXX0","CxObj","vjXView","Xy",0,"Xx",1,"X71")="Thlp",^("x70")=2,^("x710")=3 ;,^("X72")=",,,,,,,8388608,16777215,2"
 ;
 ;Запросы
 S ^Q(1,"XView","XXX0","CxObj",-1,"Xy",24,"X60")="v7XQuery"
 S ^Q(1,"XView","XXX0","CxObj","v7XQuery","Xy",0,"Xx",0,"X71")="@",^("x70")=0,^("X72")=",,,,4"
 S ^Q(1,"XView","XXX0","CxObj","v7XQuery","Xy",0,"Xx",1,"X71")="$S($G(WS(W(""Zqqnump""),""Zsform""))=1!($G(WS(W(""Zqqnump""),""Zsform""))>9):"" (вызов по F2)"",1:"""")",^("x70")=5
 S ^Q(1,"XView","XXX0","CxObj","v7XQuery","Xy",1,"X60")="vqXQuery"
 S ^Q(1,"XView","XXX0","CxObj","vqXQuery","Xy",0,"Xx",0,"X71")="qSYS.vi(700)",^("x70")=5,^("X72")=",,,,1" ;,,,8388608,16777215,2"
 S ^Q(1,"XView","XXX0","CxObj","vqXQuery","Xy",0,"Xx",1,"X71")="Thlp",^("x70")=2,^("x710")=3 ;,^("X72")=",,,,,,,8388608,16777215,2"
 ;Действия
 S ^Q(1,"XView","XXX0","CxObj",-1,"Xy",25,"X60")="v7XQuest"
 S ^Q(1,"XView","XXX0","CxObj","v7XQuest","Xy",0,"Xx",0,"X71")="@",^("x70")=0,^("X72")=",,,,4"
 ;S ^Q(1,"XView","XXX0","CxObj","v7XQuest","Xy",0,"Xx",1,"X71")="$S($G(WS(W(""Zqqnump""),""Zsform""))=1!($G(WS(W(""Zqqnump""),""Zsform""))>9):"" (вызов по F2)"",1:"""")",^("x70")=5
 S ^Q(1,"XView","XXX0","CxObj","v7XQuest","Xy",1,"X60")="vqXQuest"
 S ^Q(1,"XView","XXX0","CxObj","vqXQuest","Xy",0,"Xx",0,"X71")="XX20",^("x70")=2,^("X72")=",,,,1" ;,,,8388608,16777215,2" ;XX20 - см. qW.G для массива
 S ^Q(1,"XView","XXX0","CxObj","vqXQuest","Xy",0,"Xx",1,"X71")="qSYS.vi(888)",^("x70")=5,^("x710")=3 ;,^("X72")=",,,,,,,8388608,16777215,2"
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CreZcordtu">
<Description>
         Создание/удаление (Arg1=1/0) колонки с @Zcordtu.</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqObj,xm
 S xm=Vo(qqnump,-1,9)+''Arg1
 S qqObj=-1 F  S qqObj=$O(Vo(qqnump,qqObj)) Q:qqObj=""  D
 .K Vo(qqnump,qqObj,10),Vo(qqnump,qqObj,11)
 .I 'Arg1 K Vo(qqnump,qqObj,0,0,xm),Vo(qqnump,qqObj,0,0,xm+1) Q
 .S Vo(qqnump,qqObj,0,0,xm)="2@Zcordtu",Vo(qqnump,qqObj,0,0,xm+1)="2TBXPeek"
 K W("ZBtredo") ;для переиницилизации граф в wcre
 D ..CreVoAdd(),qARM.wcro(),qARM.wcre()
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="CreateDBFFOX">
<Description><![CDATA[
Данные из глобала @G описанной выше структуры переносятся в глобал ^CacheTempDBF($J)
в соответствии с заголовком файла, содержащимся в массиве Fld
и записываются по указанному пути file
<br><br> Структура массива Fld:
<br> Fld - количество полей; для каждого поля i:
<br> Fld(i,"F")=0
<br> Fld(i,"L") = длина поля (в байтах)
<br> Fld(i,"N") = наименование поля
<br> Fld(i,"O") = смещение: Fld(1)=0; Fld(i+1,"O") = Fld(i,"O") + Fld(i,"L") (пока не используется и вроде бы не требуется)
<br> Fld(i,"T") = тип данных: "C" - текст, "N" - числовой, "D" - дата, "M" - мемо (пока не работает)
<br> NB! Дополнительные узлы Fld, даже если заданы, игнорируются. Узел Fld("N") перезаписывается.
<br><br> CodeTable - если задан, глобал ^CacheTempDBF будет закодирован по данной таблице; может быть указана любая таблица из
текущей локализации Cache; для кодирования в DOS следует указать "CP866".
Записи в глобале G должны быть записаны следующим образом:
     G(номер записи) =" "
     G(номер записи,номер поля) = значение поля
<br> Если задан CLIPF, после заголовка файла пишется не $c(13), а $c(13,0).
flag - выдача сообщения о создании файла.
ПРИМЕР:d qSYS.CreateDBFFOX("c:\sasha2.dbf","^Temp1(3232)",.Fld,"CP1251")
alex&sasha]]></Description>
<Internal/>
<FormalSpec>file:%String,G:%String,Fld:%String,CodeTable:%String,CLIPF:%String,flag:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 i $G(file)="" d qARM.Message("Не выбран файл для создания dbf!") q 
 N B,D,DUM,FLD,I,J,MEMOF,ML,Off,S,dataoff,reclen
 k ^CacheTempDBF($J)
 S Gldbf="^CacheTempDBF($J)"
 S:$E(G)'="^" G="^"_G
 I $O(@G@(1,""),-1)'=Fld d qARM.Message("Количество столбцов в глобале"_G_" с данными не равно количеству столбцов в "_Fld) Q
 s Fld("N")=$O(@G@(""),-1) ; кол-во записей в формируемом образе dbf-файла
 s S=$tr($j("",32)," ",$c(0))
 s $e(S)=$c(3) ; FoxBASE+/dBASE III +, без memo - 0х03
 s dataoff=(1+Fld)*32+1 ; Положение первой записи с данными
 s reclen=1 f I=1:1:Fld s reclen=reclen+Fld(I,"L") ; Длина одной записи с данными
 O 63 V 0:0:-$l(S):S,4:0:4:Fld("N"),3:0:1:+$P($ZD($H,4,,6),"/") ;$ZD ;AM01+
 V 8:0:2:dataoff,10:0:2:reclen
 V 2:0:1:+$P($ZD($H,4,,6),"/",2) S D=$P($ZD($H,4,,6),"/",3) ;AM01-
 V 1:0:1:$S($L(D)=2:+D,1:+$E(D,3,4))
 S S=$V(0,0,-$L(S)) C 63
 d Xec(S)
 for I=1:1:Fld { ; формируем подзаписи полей
     s S=$tr($j("",32)," ",$c(0))
     s $e(S,1,$l(Fld(I,"N")))=Fld(I,"N") ; название поля
     s $e(S,12)=Fld(I,"T") ; тип данных
     ;s $e(s,13,16)=Fld(I,"O") ; Расположение поля внутри записи (вроде бы можно не заполнять)
     s $e(S,17)=$c(Fld(I,"L")) ;de! ; Длина поля (в байтах) ;исправить (не Юникод!)
     i Fld(I,"T")="N" s:$G(Fld(I,"F")) $e(S,18)=$c(Fld(I,"F")) ;отсутствовала длина дробной части
     d Xec(S)
 }
 d Xec($C(13)) d:$D(CLIPF) Xec($C(0)) F I=1:1:Fld("N") S S=$G(@G@(I)," ") d Xec(S) D
 .F J=1:1:Fld D 
 ..S FLD=@G@(I,J) G @("PG"_Fld(J,"T"))
 d qARM.wM("-qARM","FileFastSave",Gldbf,file) d:$G(flag)=1 qARM.Message("Создан файл "_file) Q

PGN..S FLD=$J(FLD,Fld(J,"L"),Fld(J,"F")) D  G PGQ
 ...I $L(FLD)>Fld(J,"L") S FLD=$E(FLD,1,Fld(J,"L")) G PGQ
PGM ..I FLD="" S FLD="          " G PGQ
 ..D  S FLD=$J(FLD,Fld(J,"L")) G PGQ
 ...S ML=$L(FLD)+7\Fld("M")+1*Fld("M"),FLD=$C(0,0,0,1,0,0,$L(FLD)\256,$L(FLD)#256)_$E(FLD_$TR($J("",ML-8)," ",$C(0)),1,ML-8)
 ...S FLD=$ZB-ML\Fld("M") G PGQ
PGD ..S FLD=$E(FLD_$J("",8),1,8) G PGQ
PGL ..;
PGC ..S DUM=$J("",Fld(J,"L")),FLD=$E(FLD_DUM,1,Fld(J,"L")) s:$G(CodeTable)'="" FLD=$zcvt(FLD,"O",CodeTable) G PGQ
PGQ ..d Xec(FLD) Q
 .Q
 d Xec($C(26))
 I $D(Fld("M")) S B=$ZB\Fld("M") ;F->%F ;AM02 
 Q:'$D(Fld("M")) 1
 d Xec($C(B\262144,B\65536#256,B\256#256,B#256,0,0,Fld("M")\256,Fld("M")#256))
 S B="",$P(B,$C(0),505)="" d Xec(B) C %F
 Q 1
Xec(expr)
 ;;i $g(^rOBJ("%GMan00x7"))="" d Xec^%GMan00x6("s @Gldbf@($i(@Gldbf))=expr")
 ;;e  d Xec^%GMan00x7("s @Gldbf@($i(@Gldbf))=expr")
 ;;sas 20090409
 d Xec^%GMan00x7("s @Gldbf@($i(@Gldbf))=expr")
]]></Implementation>
</Method>

<Method name="CresysL">
<Description>
Формирование отображение для создания формы ввода значений для списка понятий (sysL)
Вызывается из qSYS.sysView.</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 ;отображение для создания формы ввода значений для списка понятий
 S Vo(qqnump,-1)="-"_$G(^Q(1,$S($G(query)="":"XQuery",1:qqoQu),$S($G(query)="":"---",1:query),"XQName"),"Запрос") ;@dol 9.06.03
 S Vo(qqnump,-1,61)=1 ;отсутствие сетки
 S Vo(qqnump,-1,65)=2 ;вывод пустых
 S Vo(qqnump,-1,62)=1 ;авторазмер
 S Vo(qqnump,-1,19)=4 ;выделение ячейки
 S Vo(qqnump,-1,74)="X798 X798 X798" ;замещение пояснений на пояснения к поисковому образу
 S Vo(qqnump,-1,51)=",,,,4" ;псевдокнопки
 S Vo(qqnump,-1,52)=",,,,,,,,16777215" ;16776960" ;параметры
 S Vo(qqnump,-1,23)="S W(""ZBtred"")=1,W(""Zdomod"")=2,qqo=-1,Vs(qqnump,""CurObj"")=-1 D qARM.wcre(),qARM.NextEdit("""",1)" ;qARM.OpenTimer(50,""D qARM.NextEdit("""""""")"")" ; D qARM.wwww(W(""Z0""))"
 S Vo(qqnump,-1,0,0,0,2)="-1,2" ;,Vo(qqnump,-1,0,0,1,2)=15 ;?????
 S $$$Tree=0
 S Vo(qqnump,-1,22)="S qqend=1" ;по выходу
 S Vo(qqnump,-1,0,1,0)="0"
 ;описание (через запятую)
 ;1 -qqo; 2 - qqw   (если не задано qqw - то будем считать это константой)
 ;3 - заголовок строки
 ;4 - qqs - стиль: 1 - от-до.; 4 - флаг; в противном случае обычное поле для ввода
 ;5 - понятие развертки (параметры развертки);6 - вариант редактирования;7 - тип развертки
 ;8 - размер поля  
 ;9 - маска. Если 1 - дата
 ;10 - регистр (x742)
 ;11 - язык (x743) 0 -текущий, 1- основной, 2 -англ, 3 -русский
 ;12 - значение по умолчанию
 ;13 - параметры для ячейки X72 (форматирование заголовка) (через ~)
 N qqw,qqwi,qqo,qqww,qqs,qqt,qqwa
 S qqpar2=cond F qqwi=2:1:..PQ(qqpar2)+1 S qqww=..PQ(qqpar2,qqwi-1),qqo=$P(qqww,","),qqw=$P(qqww,",",2),qqs=$P(qqww,",",4) D:qqww'=""  ;@dol 2.04.04 qqw'=""
 .S qqwa=..PSYN(qqww,",",3,,,1),qqwa=$S(qqwa="":qW.GetWoc("CxWoc",qqw),$E(qqwa)'="@":$TR(qqwa,"~"," "),qqwa'="@":qARM.Value($E(qqwa,2,2000)),1:qARM.GetName($G(Vo($P(qqParent," ",2))),qqo,qqw)) ;@Dol 23.09.05 получение имени
 .I qqs'=1 D  Q
 ..S Vo(qqnump,-1,0,qqwi,0)="0"_qqwa  ;заголовок строки
 ..S Vo(qqnump,-1,0,qqwi,0,2)=$TR(..PSYN(qqww,",",13),"~""",",")  ;параметры для ячейки заголовка X72 @gol 08/10/10
 ..i qqw="" S Vo(qqnump,-1,0,qqwi,1)="0" quit  ;если задана просто константа @gol 08/10/10
 ..D  
 ...I $E(qqw,1,3)="@ZX" S Vo(qqnump,-1,0,qqwi,1)="2"_qqw Q
 ...S Vo(qqnump,-1,0,qqwi,1)=$S(qqs=4:4,1:2)_"Z"_qqwi  ;тип данных  @gol 08/10/10 (было "2Z"_qqwi)
 ...S W("Z"_qqwi)=qSYS.Vs8P(qqo,qqw)
 ...S Vo(qqnump,-1,0,qqwi,1,4)="qSYS.Vs8P("""_qqo_""","""_qqw_""",1)"  ;правило проверки
 ..S Vo(qqnump,-1,0,qqwi,1,30)=$S(..PSYN(qqww,",",7)'="":..PSYN(qqww,",",7),"@MLTX"[$E(qqw):-1,1:0)
 ..S Vo(qqnump,-1,0,qqwi,1,31)=$S(..PSYN(qqww,",",6,,,1)="":$S($E(qqw)="@":"",1:qqw),1:..PSYN(qqww,",",6,,,1))
 ..S Vo(qqnump,-1,0,qqwi,1,3)=$S(..PSYN(qqww,",",5,,,1)="":$S($E(qqw)="@":"",1:qqw),1:..PSYN(qqww,",",5,,,1))
 ..S:Vo(qqnump,-1,0,qqwi,1,30)=3!(..PSYN(qqww,",",9,,,1)=1) Vo(qqnump,-1,0,qqwi,1,10)=1 ;явная дата
 ..S:..PSYN(qqww,",",9,,,1)=6 Vo(qqnump,-1,0,qqwi,1,10)=6 ;явная дата ГГГГММ
 ..S:..PSYN(qqww,",",8)'="" Vo(qqnump,-1,0,qqwi,1,2)=..PSYN(qqww,",",8)  ;размер поля
 ..I ..PSYN(qqww,",",9,,,1)'="","16"'[..PSYN(qqww,",",9,,,1) S Vo(qqnump,-1,0,qqwi,1,44)=..PSYN(qqww,",",9,,,1)
 ..S:..PSYN(qqww,",",10)'="" Vo(qqnump,-1,0,qqwi,1,42)=..PSYN(qqww,",",10) ;регистр
 ..S:..PSYN(qqww,",",11)'="" Vo(qqnump,-1,0,qqwi,1,43)=..PSYN(qqww,",",11) ;язык
 ..do:..PSYN(qqww,",",12)'="" 
 ... s W("Z"_qqwi)=..PSYN(qqww,",",12) ;значение по умолчанию @gol 08/10/10
 ... s Vs($P(qqParent," ",2),8,qqo,qqw)=W("Z"_qqwi) ;правило проверки
 .I qqs=1 D  Q  ;вариант от - до
 ..S Vo(qqnump,-1,0,qqwi,0)="0"_qqwa_" от:"
 ..S Vo(qqnump,-1,0,qqwi,1)="2Za"_qqwi,W("Za"_qqwi)=qSYS.Vs8P(qqo,qqw,,1)
 ..S qqt=qARM.GetPar("x710",Vo($P(qqParent," ",2)),qqo,qqw) S:($E(qqw,1,3)="dat") qqt=1 I qqt=1!(qqt=6) S (Vo(qqnump,-1,0,qqwi,1,10),Vo(qqnump,-1,0,qqwi,3,10))=qqt  ;дата
 ..S Vo(qqnump,-1,0,qqwi,1,4)="qSYS.Vs8P("""_qqo_""","""_qqw_""",1,1)"
 ..S Vo(qqnump,-1,0,qqwi,1,30)=$S(..PSYN(qqww,",",7)'="":..PSYN(qqww,",",7),"@MLTX"[$E(qqw):-1,1:0)
 ..S Vo(qqnump,-1,0,qqwi,1,31)=$S(..PSYN(qqww,",",6,,,1)="":$S($E(qqw)="@":"",1:qqw),1:..PSYN(qqww,",",6,,,1))
 ..S Vo(qqnump,-1,0,qqwi,1,3)=$S(..PSYN(qqww,",",5,,,1)="":$S($E(qqw)="@":"",1:qqw),1:..PSYN(qqww,",",5,,,1))
 ..S:Vo(qqnump,-1,0,qqwi,1,30)=3!(..PSYN(qqww,",",9,,,1)=1)!(qqt=1) Vo(qqnump,-1,0,qqwi,1,10)=1 ;явная дата
 ..S:(..PSYN(qqww,",",9,,,1)=6)!(qqt=6) Vo(qqnump,-1,0,qqwi,1,10)=6 ;явная дата
 ..S:..PSYN(qqww,",",8)'="" Vo(qqnump,-1,0,qqwi,1,2)=..PSYN(qqww,",",8)
 ..I ..PSYN(qqww,",",9,,,1)'="","16"'[..PSYN(qqww,",",9,,,1) S Vo(qqnump,-1,0,qqwi,1,44)=..PSYN(qqww,",",9,,,1)
 ..S:..PSYN(qqww,",",10)'="" Vo(qqnump,-1,0,qqwi,1,42)=..PSYN(qqww,",",10) ;регистр
 ..S:..PSYN(qqww,",",11)'="" Vo(qqnump,-1,0,qqwi,1,43)=..PSYN(qqww,",",11) ;язык
 ..S Vo(qqnump,-1,0,qqwi,2)="0 до:",Vo(qqnump,-1,0,qqwi,2,2)=5
 ..S Vo(qqnump,-1,0,qqwi,3)="2Zb"_qqwi,W("Zb"_qqwi)=qSYS.Vs8P(qqo,qqw,,2)
 ..S Vo(qqnump,-1,0,qqwi,3,4)="qSYS.Vs8P("""_qqo_""","""_qqw_""",1,2)"
 ..S Vo(qqnump,-1,0,qqwi,3,30)=$S(..PSYN(qqww,",",7)'="":..PSYN(qqww,",",7),"@MLTX"[$E(qqw):-1,1:0) ;qqt=1:1
 ..S Vo(qqnump,-1,0,qqwi,3,31)=$S(..PSYN(qqww,",",6,,,1)="":$S($E(qqw)="@":"",1:qqw),1:..PSYN(qqww,",",6,,,1))
 ..S Vo(qqnump,-1,0,qqwi,3,3)=$S(..PSYN(qqww,",",5,,,1)="":$S($E(qqw)="@":"",1:qqw),1:..PSYN(qqww,",",5,,,1))
 ..S:Vo(qqnump,-1,0,qqwi,3,30)=3!(..PSYN(qqww,",",9,,,1)=1)!(qqt=1) Vo(qqnump,-1,0,qqwi,3,10)=1 ;явная дата
 ..S:(..PSYN(qqww,",",9,,,1)=6)!(qqt=6) Vo(qqnump,-1,0,qqwi,3,10)=6 ;явная дата
 ..S:..PSYN(qqww,",",8)'="" Vo(qqnump,-1,0,qqwi,3,2)=..PSYN(qqww,",",8)
 ..I ..PSYN(qqww,",",9,,,1)'="","16"'[..PSYN(qqww,",",9,,,1) S Vo(qqnump,-1,0,qqwi,3,44)=..PSYN(qqww,",",9,,,1)
 ..S:..PSYN(qqww,",",10)'="" Vo(qqnump,-1,0,qqwi,3,42)=..PSYN(qqww,",",10) ;регистр
 ..S:..PSYN(qqww,",",11)'="" Vo(qqnump,-1,0,qqwi,3,43)=..PSYN(qqww,",",11) ;язык
 I $D(XQpars(1)) D  ;есть диалоговая модификация
 .S Vt(qqnump,111)="" ;признак наличия виртуальных объектов
 .S qqwi=qqwi+1,Vo(qqnump,-1,0,qqwi,0)="0 ",qqwi=qqwi+1,Vo(qqnump,-1,0,qqwi,0)="0Зачеркнутые объекты и понятия",Vo(qqnump,-1,0,qqwi,0,2)=",0,,,1"
 .S qqwi=qqwi+1,Vo(qqnump,-1,0,qqwi)="X1"
 .S Vo(qqnump,"X1",2)=6,Vo(qqnump,"X1",33)="XQpars(1)"
 .S Vo(qqnump,"X1")="",Vo(qqnump,"X1",0,0,0)="5qARM.GetName(,qqc)",Vo(qqnump,"X1",0,0,0,2)=",0,,,1",Vo(qqnump,"X1",0,0,1)="4CC" S:0 Vo(qqnump,"X1",0,0,1,53)="1 ~" S Vo(qqnump,"X1",0,0,1,2)=",0,,,,,,,-2147483633",Vo(qqnump,"X1",0,0,1,31)="@$S($G(XQpars(1,qqc))="""":-1,1:0)",Vo(qqnump,"X1",0,0,1,6)="@$S($G(XQpars(1,qqc))="""":""R,136"",1:"""")",Vo(qqnump,"X1",0,0,1,4)=1
 .S Vo(qqnump,"X1",0,1)="Xy",Vo(qqnump,"Xy")="",Vo(qqnump,"Xy",2)=6,Vo(qqnump,"Xy",33)="XQpars(1,Vs(qqnump,""Virt"",""X1""))"
 .S Vo(qqnump,"Xy",0,0,0)="5qARM.GetName(,Vs(qqnump,""Virt"",""X1""),qqc)",Vo(qqnump,"Xy",0,0,0,2)=",0,,,0,,,8388608",Vo(qqnump,"Xy",0,0,0,6)="R,117",Vo(qqnump,"Xy",0,0,1)="4CC" S:0 Vo(qqnump,"Xy",0,0,1,53)="1 ~" S Vo(qqnump,"Xy",0,0,1,2)=",0,,,,,,,-2147483633",Vo(qqnump,"Xy",0,0,1,4)=1
 ;Сделаем кнопки
 S qqwi=qqwi+1,Vo(qqnump,-1,0,qqwi,0)="0",qqwi=qqwi+1
 S Vo(qqnump,-1,0,qqwi,1)="6@ZXXFind" ;2
 S Vo(qqnump,-1,0,qqwi,1,31)=1,Vo(qqnump,-1,0,qqwi,1,30)=9,Vo(qqnump,-1,0,qqwi,1,2)=",1,,,1"
 S Vo(qqnump,-1,0,qqwi,1,3)="D qARM.WrWin("""",0,"""",""qWEB.Query(1,"""""_$G(viewquery)_""""","""""_($G(find))_""""","_(+$G(anal))_","_(+$G(diag))_$S($D(print):","""""_print_"""""",1:",")_",,,"_$S($D(open):""""""_open_"""""",1:"")_","_$G(notmess)_","_$G(OpenFile)_","_$G(qqdev)_")"") S:$D(qwin(""Q0"")) qqend=1" ;@dol 01.04.03 - явно qqnump="Q"  ;T.D.V 27.03.2003 - добавлен notmess; 15.10.2003 - добавлены OpenFile,qqdev
 ;S Vo(qqnump,-1,0,qqwi,1)="6@ZXXCancel" ;2
 ;S Vo(qqnump,-1,0,qqwi,1,31)=1,Vo(qqnump,-1,0,qqwi,1,30)=9,Vo(qqnump,-1,0,qqwi,1,3)="S qqend=1"
 S Vo(qqnump,-1,75)="F:-1,@ZXXFind" ; C:-1,@ZXXCancel" ;горячие клавиши
 D ..CreVoAdd() Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="DBF">
<Description>
Проход по DBF - файлу.
Если Xec="", то заполняется массив ^DBF(имя_файла,N,код_реквизита)=значение
!!!!   где N=1,2,3... или значение реквизита ID (если он есть и это первое поле)
В противном случае - Xec - выполняемое по Xecute действие для каждой записи.
Значения реквизитов в W(код_реквизита). W - список кодов реквизита.
Kill W недопустим !!!!. I,J и некоторые другие переменные (см текст метода) зарезервированы.
Если Arg1=1 - только расшифровка заголовка (создание массива Fld).
Arg2=1 - не ставить подчерк для содержимого полей

Обрабатываются ссылки на Memo-поля ( Fld(J,"T")="M" ) в файле *.dbt. Преобразуются в формат текстовых понятий.
В ^DBFerr(dbf,rek,id) - мемо-поля содержащие спецсимволы.

***qSYS.DBFr – чтение DBF файла в поток
***qSYS.DBFn – обработка считанных строк DBF файла.
***Вызов старого метода qSYS.DBF можно заменить на вызов qSYS.DBFr. Сигнатуры у этих методов одинаковые. 

dels=0 не включать удалённые, dels=1 - включать
в узлах ^DBF(dbf,i)=1 - запись не удалена ^DBF(dbf,i)=0 - удалена
d KonvGKH.DBF("d:\f.dbf",,,,,1) - включает удалённые в ^DBF
d KonvGKH.DBF("d:\f.dbf",,,,,0) или d KonvGKH.DBF("d:\f.dbf") - не включает удалённые в ^DBF
</Description>
<Internal/>
<FormalSpec>file:%String,Xec:%String="",Dos:%Library.String=1,Arg1:%Library.String,Arg2:%Library.String,dels:%Library.String=0</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 O file:("F":32):5 I '$T Q:$Q 0 Q  ;нет файла 
 N S,I,II,RecNum,DOff,RecLen,REC,J,dbf,FLD,file1,memo,memoi,mem,memoii,mtype,delcntr
 S dbf=$P($P(file,"\",$L(file,"\")),".")
 K:Xec="" ^DBF(dbf) S:Xec'="" W="" K ^DBFerr(dbf)
 U file R S S RecNum=$ZLA(S,5),DOff=$ZWA(S,9)
 S RecLen=$ZWA(S,11) K Fld S Fld=DOff\32-1,Fld("N")=RecNum
 S Fld("L")=RecLen,Fld("O")=DOff K C,C1 S Off=1
 F I=1:1:Fld R S S C(I)=$P(S,$C(0)) D  ;@dol 1.12.02 Q:'$A(S,17) - длина 0 (а MEMO????)
 .S Fld(I,"N")=$P(S,$C(0)) S:Xec="" ^DBF(dbf,0,I)=Fld(I,"N") S:Xec'="" W=W_$S(W="":"",1:" ")_Fld(I,"N") S Fld(I,"T")=$E(S,12) ;$V(11,0,1,1)
 .S Fld(I,"L")=$A(S,17),Fld(I,"?")=$A(S,18) ;,$V(16,0,1),Fld(I,"?")=$V(17,0,1)
 .S Fld(I,"O")=Off,Off=Off+Fld(I,"L")
 .I Fld(I,"T")="M" S file1=1 ;есть MEMO
 C file I $G(Arg1) Q:$Q 1 Q 
 ;
 D:$G(file1)  ;;@dol 12.08.03 разборка с memo-полями в отдельном файле
 .S file1=file,$P(file1,".",$L(file1,"."))="dbt" ;бывает "fpt" но с другим размером блока (не 512)
 .O file1:($S(Dos:"K\CP866\",1:""):/UNDEFINED):1 I '$T K file1 ;нет файла   
 ;I Dos O file:("K\CP866\") I 1
 ;E  O file 
 I Dos O file:("K\CP866\":/UNDEFINED) I 1 ;@ЯГД для корректной обработки конца файла
 E  O file:(/UNDEFINED)
 U file:Fld("O") ;"K\OEM\" - у нас;"K\CP866\"
 ;F II=1:1:Fld("N") S I=II R REC#Fld("L") D  ;U 0 W !,REC U file ;@dol 3.5.04 II=.... I=II
 s delcntr=0  ;@Kam-Pav 08.06.2007                                                                                                                     
 F II=1:1:Fld("N") S I=II-delcntr R REC#Fld("L") s ^DBF(dbf,I)=($A($E(REC))=32) s:(dels=0)&&($A($E(REC))'=32) delcntr=delcntr+1 D:(dels=1)!($A($E(REC))=32)
 .F J=1:1:Fld Q:'Fld(J,"L")  D  ;@dol 1.12.02 Q:'Fld(J,"L")
 ..S FLD=$E(REC,Fld(J,"O")+1,Fld(J,"O")+Fld(J,"L"))
 ..G @("DBF"_Fld(J,"T"))
DBFC ..
 ..F K=$L(FLD):-1 Q:$E(FLD,K)'=" "
 ..S FLD=$E(FLD,1,K) G DBFQ:FLD'[$C(0)
 ..I Xec="" S:FLD'="" ^DBF(dbf,I,Fld(J,"N"))=FLD Q
 ..S W(Fld(J,"N"))=FLD Q
DBFN ..
 ..S FLD=+$TR(FLD," ","") G DBFQ
DBFD ..G DBFQ
DBFL ..
 ..F K=$L(FLD):-1 Q:$E(FLD,K)'=$C(0)
 ..I Xec="" S ^DBF(dbf,I,Fld(J,"N"))="L"_$E(FLD,1,K) Q
 ..S W(Fld(J,"N"))="L"_$E(FLD,1,K) Q
DBFM ..
 ..I $G(file1)'="" Q:$TR(FLD," ")=""  D  Q  ;@dol 12.08.03 разборка с memo-полями в отдельном файле;@dol 6.10.03 $G(file1)
 ...S memo="",mem=$TR(FLD," "),FLD=mem*512 U file1:FLD I Xec="" S ^DBF(dbf,I,Fld(J,"N"))=mem
 ...S mtype="" F  R FLD#512 Q:FLD=""  D   Q:mtype=0  Q:FLD[$C(26)  ;@dol 2.05.04 mtype
 ....I mtype="",$E(FLD,3)=$C(8) S mtype=$A(FLD,6)\2,memo=memo_$P($E(FLD,9,512),$C(0)) Q  ;блочный формат
 ....I mtype'="" S memo=memo_$P(FLD,$C(0)),mtype=mtype-1 Q
 ....I $L(memo)+$L($P(FLD,$C(26)))>32767 S mtype=0 Q
 ....S memo=memo_$P(FLD,$C(26))
 ...U file S memoii=$L(memo,$C(10)) F memoi=1:1:memoii D  ;$C(16*8+13,10)вместо $C(13,10) да еще может преобразоваться в русское Н!
 ....S FLD=$P(memo,$C(10),memoi) S:memoi'=memoii FLD=$E(FLD,1,$L(FLD)-1) I FLD?.e1c.e S FLD=$TR(FLD,$C(9,0)," "),^DBFerr(dbf,Fld(J,"N"),I)=""
 ....I Xec="" S ^DBF(dbf,I,Fld(J,"N"),memoi-1)=FLD Q
 ....S W(Fld(J,"N"),memoi-1)=FLD
 ..I Xec="" S:FLD'="" ^DBF(dbf,I,Fld(J,"N"))=FLD Q
 ..S W(Fld(J,"N"))=FLD Q
DBFQ ..
 ..I $TR(FLD," ")="",Xec="" Q  ;@Dol 25.06.06 Xec=""
 ..S FLD=$ZSTRIP(FLD,"<>W") S:'$G(Arg2) FLD=$TR(FLD," ","_") I Xec="" S:J=1&&(Fld(J,"N")="ID") I=FLD S ^DBF(dbf,I,Fld(J,"N"))=FLD Q  ;@dol 2.5.04
 ..S W(Fld(J,"N"))=FLD Q
 .X:Xec'="" Xec
 C file C:$G(file1)'="" file1
 Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="DBFInd">
<Description>
Построение индексов в массиве ^DBF по описанию в XSQL (Отображение XXXSQL)
Arg1 - код базы (не задан - все)
Arg2 - код таблицы (не задан - все)

Строится массив:
^DBF("Index",Tab,имя_индекса,значение,номер_записи)=""
^DBF("Index",Tab,имя_индекса,значение)=номер_записи

Имя индекса берется из XSQLind объекта XSQLatr.
если 1, совпадает с кодом реквизита.

Имя может быть составным:
код_рек1_","_код_рек1_","....
В этом случае:
^DBF("Index",Tab,имя_индекса,значение1,значение2,...,номер_записи)=""
^DBF("Index",Tab,имя_индекса,значение1,значение2,...)=номер_записи

Если задан Arg3, то это список индексов</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqw,indlst,qqz,I,i,qqs
 I $G(Arg1)'=""||($G(Arg3)'=""),$G(Arg2)'="" D DBFIndD($G(Arg1),Arg2,$G(Arg3)) Q:$Q "" Q
 I $G(Arg1)'="" D  Q:$Q "" Q
 .S Arg2="" F  S Arg2=$O(^Q(1,"XSQL",Arg1,"XSQLtab",Arg2)) Q:Arg2=""  D DBFIndD(Arg1,Arg2)
 S Arg1="" F  S Arg1=$O(^Q(1,"XSQL",Arg1)) Q:Arg1=""  S Arg2="" F  S Arg2=$O(^Q(1,"XSQL",Arg1,"XSQLtab",Arg2)) Q:Arg2=""  D DBFIndD(Arg1,Arg2)
 Q:$Q "" Q
DBFIndD(Arg1,Arg2,Arg3)
 I $G(Arg3)'="" S indlst=" "_Arg3_" " G DBFIndD1
 ;проход по описанию и поиск индексов
 S qqw="",indlst="" F  S qqw=$O(^Q(1,"XSQL",Arg1,"XSQLtab",Arg2,"XSQLatr",qqw)) Q:qqw=""  S qqz=$G(^(qqw,"XSQLind")) D:qqz'=""
 .I qqz=1 S indlst=indlst_" "_qqw Q  ;имя индекса соответствует коду реквизита
 .S indlst=indlst_" "_qqz  ;составной индекс (qqw1_","_qqw2)
 Q:indlst=""  S indlst=indlst_" "
 ;Индексация
DBFIndD1 K ^DBF("Index",Arg2)
 F I=1:1:$O(^DBF(Arg2,""),-1) D
 .F i=2:1:$L(indlst," ")-1 S qqw=$P(indlst," ",i) D
 ..N i ;@Misuno 11.01.06
 ..I qqw'["," S qqz=$G(^DBF(Arg2,I,qqw)) S:qqz'="" ^DBF("Index",Arg2,qqw,qqz,I)="",^DBF("Index",Arg2,qqw,qqz)=I Q
 ..S qqs="^DBF(""Index"",Arg2,qqw," F i=1:1:$L(qqw,",") S qqz=$G(^DBF(Arg2,I,$P(qqw,",",i))) S:qqz="" qqz="?" S qqz(i)=qqz,qqs=qqs_"qqz("_i_"),"
 ..S qqs=qqs_"I)",@qqs="",@($P(qqs,",I)")_")=I")
 Q
]]></Implementation>
</Method>

<Method name="DBFf">
<Internal/>
<FormalSpec>Arg1:%Library.String,DOS:%Library.String,filelst:%Library.String,indexlst:%Library.String,dir:%Library.String,pref:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(filelst)'="" N file,filei D  Q:$Q "" Q
 .F filei=1:1:$L(filelst," ") s file=$P(filelst," ",filei) I file'="",'qSYS.DBF($G(dir)_"\"_file_$G(pref)_".dbf",,+$G(DOS)) D qARM.Message("Нет файла "_$G(dir)_"\"_file_$G(pref)_".dbf")
 .F filei=1:1:$L(indexlst," ") s file=$P(indexlst," ",filei) I file'=""  D qSYS.DBFInd(,$P(file,":")_$G(pref),$TR($P(file,":",2),";"," "))
 I '$G(Arg1) D qARM.OpenWinDialog("D qSYS.DBFf(1,"_+$G(DOS)_")") Q:$Q "" Q
 N file,filei F filei=0:1 s file=$G(qARM("qpars",filei)) Q:file=""  D qSYS.DBF(file,,+$G(DOS))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="DBFn">
<Description>
Проход по DBF - файлу.
Если Xec="", то заполняется массив ^DBF(имя_файла,N,код_реквизита)=значение
!!!! где N=1,2,3... или значение реквизита ID (если он есть и это первое поле)
В противном случае - Xec - выполняемое по Xecute действие для каждой записи.
Значения реквизитов в W(код_реквизита). W - список кодов реквизита.
Kill W недопустим !!!!. I,J и некоторые другие переменные (см текст метода) зарезервированы.
Если Arg1=1 - только расшифровка заголовка (создание массива Fld).
Arg2=1 - не ставить подчерк для содержимого полей

Обрабатываются ссылки на Memo-поля ( Fld(J,"T")="M" ) в файле *.dbt. Преобразуются в формат текстовых понятий.
В ^DBFerr(dbf,rek,id) - мемо-поля содержащие спецсимволы.
Arg3=1 - есть мемо-файл
Arg4 - индекс временной глобали, содержащей строки потока DBF-файла (по умолчанию "D")
с 16.12.08 внесены изменения в обработку заголовка файла (изменение структуры DBF файла обнаружено при загрузке КЛАДР)
ank 20110511 Изменена обработка заголовка файла. Изменён порядок чтения файла - полное чтение, вместо построчного</Description>
<Internal/>
<FormalSpec>file:%Library.String,Xec:%Library.String="",Dos:%Library.String=1,Arg1:%Library.String="",Arg2:%Library.String="",Arg3:%Library.String="",Arg4:%Library.String="D"</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ;;обработка файла
 ;N S,I,II,RecNum,DOff,RecLen,REC,J,dbf,FLD,file1,memo,memoi,mem,memoii,mtype,S0,I0
 ;S dbf=$P($P(file,"\",$L(file,"\")),".")
 ;K:Xec="" ^DBF(dbf) S:Xec'="" W="" K ^DBFerr(dbf)
 ;S S=$G(^mtemp($J,Arg4,0)) F I=1:1 Q:$E($G(^mtemp($J,Arg4,I)))'=$C(0)  S S=S_$C(13)_$G(^mtemp($J,Arg4,I))  ;??? $C(14)
 ;S I0=I
 ;S RecNum=$ZLA(S,5),DOff=$ZWA(S,9)
 N S,I,II,RecNum,DOff,RecLen,REC,J,dbf,FLD,file1,memo,memoi,mem,memoii,mtype,S0,I0,ns ;@nin 16.12.08
 S dbf=$P($P(file,"\",$L(file,"\")),".")
 K:Xec="" ^DBF(dbf) S:Xec'="" W="" K ^DBFerr(dbf)
 ;@ank 20110511 Закомментировал
 ;S S=$G(^mtemp($J,Arg4,0)),ns=1
 ;I $E(S)=$C(3) S S=S_$C(13)_$G(^mtemp($J,Arg4,1)),ns=2    ;@Tat 23.11.2009
 ;F I=ns:1 Q:$E($G(^mtemp($J,Arg4,I)))'=$C(0)  S S=S_$C(13)_$G(^mtemp($J,Arg4,I)) ;??? $C(14) ;@nin 16.12.08
 ;S I0=I
 ;@ ank 20110511 Добавил
 S S=$P($G(^mtemp($J,Arg4,0)),$C(13))_$C(13)
 S ns=$L(S)+1
 S I0=0
 ;
 S RecNum=$ZLA(S,5),DOff=$ZWA(S,9)
 ;
 S RecLen=$ZWA(S,11) K Fld S Fld=DOff\32-1,Fld("N")=RecNum
 S Fld("L")=RecLen,Fld("O")=DOff K C,C1 S Off=1
 S S0=$E(S,33,$L(S))
 F I=1:1:Fld S S=$E(S0,1,32) D
 .S C(I)=$P(S,$C(0))   ;@dol 1.12.02 Q:'$A(S,17) - длина 0 (а MEMO????)
 .S Fld(I,"N")=$P(S,$C(0)) S:Xec="" ^DBF(dbf,0,I)=Fld(I,"N") S:Xec'="" W=W_$S(W="":"",1:" ")_Fld(I,"N") 
 .S Fld(I,"T")=$E(S,12) ;$V(11,0,1,1)
 .S Fld(I,"L")=$A(S,17),Fld(I,"?")=$A(S,18) ;,$V(16,0,1),Fld(I,"?")=$V(17,0,1)
 .S Fld(I,"O")=Off,Off=Off+Fld(I,"L")
 .I Fld(I,"T")="M" S file1=1 ;есть MEMO
 .S S0=$E(S0,33,$L(S0))
 I $G(Arg1) Q:$Q 1 Q 
 ;
 I $G(Arg3)'=1 K file1 ;нет мемо-файла
 ;раскомпоновка содержимого
 S S0=$E($G(^mtemp($J,Arg4,I0)),ns,$L($G(^mtemp($J,Arg4,I0)))) ; @ank 20110511 Было просто $G(^mtemp($J,Arg4,I0))
 S S0=$S(Dos:qW.windos(S0,0),1:S0)
 F II=1:1:Fld("N") S I=II S:$L(S0)<Fld("L") I0=$O(^mtemp($J,Arg4,I0)),S0=S0_$S(I0="":"",Dos:qW.windos($G(^mtemp($J,Arg4,I0)),0),1:$G(^mtemp($J,Arg4,I0))) S REC=$E(S0,1,Fld("L")) D  ;U 0 W !,REC U file ;@dol 3.5.04 II=.... I=II
 .F J=1:1:Fld Q:'Fld(J,"L")  D  ;@dol 1.12.02 Q:'Fld(J,"L")
 ..S FLD=$E(REC,Fld(J,"O")+1,Fld(J,"O")+Fld(J,"L"))
 ..G @("DBF"_Fld(J,"T")_"n")
DBFCn ..
 ..F K=$L(FLD):-1 Q:$E(FLD,K)'=" "
 ..S FLD=$E(FLD,1,K) G DBFQn:FLD'[$C(0)
 ..I Xec="" S:FLD'="" ^DBF(dbf,I,Fld(J,"N"))=FLD Q
 ..S W(Fld(J,"N"))=FLD Q
DBFNn ..
 ..S FLD=+$TR(FLD," ","") G DBFQn
DBFDn ..G DBFQn
DBFLn ..
 ..F K=$L(FLD):-1 Q:$E(FLD,K)'=$C(0)
 ..I Xec="" S ^DBF(dbf,I,Fld(J,"N"))="L"_$E(FLD,1,K) Q
 ..S W(Fld(J,"N"))="L"_$E(FLD,1,K) Q
DBFMn ..
 ..I $G(file1)'="" Q:$TR(FLD," ")=""  D  Q  ;@dol 12.08.03 разборка с memo-полями в отдельном файле;@dol 6.10.03 $G(file1)
 ...S memo="",mem=$TR(FLD," "),FLD=mem*512    ;U file1:FLD 
 ...I Xec="" S ^DBF(dbf,I,Fld(J,"N"))=mem
 ...S SM=$S(Dos:qW.windos($G(^mtemp($J,"M",0))),1:$G(^mtemp($J,"M",0))),IM=0 
 ...S mtype="" F  S:$L(SM)<512 IM=$O(^mtemp($J,"M",IM)),SM=SM_$S(IM="":"",Dos:qW.windos($G(^mtemp($J,"M",IM)),0),1:$G(^mtemp($J,"D",IM))) S FLD=$E(SM,1,512) Q:FLD=""  D   Q:mtype=0  Q:FLD[$C(26)  ;@dol 2.05.04 mtype
 ....I mtype="",$E(FLD,3)=$C(8) S mtype=$A(FLD,6)\2,memo=memo_$P($E(FLD,9,512),$C(0)) Q  ;блочный формат
 ....I mtype'="" S memo=memo_$P(FLD,$C(0)),mtype=mtype-1 Q
 ....I $L(memo)+$L($P(FLD,$C(26)))>32767 S mtype=0 Q
 ....S memo=memo_$P(FLD,$C(26))
 ...S memoii=$L(memo,$C(10)) F memoi=1:1:memoii D  ;$C(16*8+13,10)вместо $C(13,10) да еще может преобразоваться в русское Н!
 ....S FLD=$P(memo,$C(10),memoi) S:memoi'=memoii FLD=$E(FLD,1,$L(FLD)-1) I FLD?.e1c.e S FLD=$TR(FLD,$C(9,0)," "),^DBFerr(dbf,Fld(J,"N"),I)=""
 ....I Xec="" S ^DBF(dbf,I,Fld(J,"N"),memoi-1)=FLD Q
 ....S W(Fld(J,"N"),memoi-1)=FLD
 ..I Xec="" S:FLD'="" ^DBF(dbf,I,Fld(J,"N"))=FLD Q
 ..S W(Fld(J,"N"))=FLD Q
DBFQn ..
 ..I $TR(FLD," ")="",Xec="" Q  ;@Dol 25.06.06 Xec=""
 ..S FLD=$ZSTRIP(FLD,"<>W") S:'$G(Arg2) FLD=$TR(FLD," ","_") I Xec="" S:J=1&&(Fld(J,"N")="ID") I=FLD S ^DBF(dbf,I,Fld(J,"N"))=FLD Q  ;@dol 2.5.04
 ..S W(Fld(J,"N"))=FLD Q
 .X:Xec'="" Xec
 .S S0=$E(S0,Fld("L")+1,$L(S0))
 Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="DBFr">
<Description>
Чтение файла DBF  в потоке в глобаль ^mtemp и вызов метода для разкомпоновки содержимого файла.
Если Xec="", то заполняется массив ^DBF(имя_файла,N,код_реквизита)=значение
!!!!   где N=1,2,3... или значение реквизита ID (если он есть и это первое поле)
В противном случае - Xec - выполняемое по Xecute действие для каждой записи.
Значения реквизитов в W(код_реквизита). W - список кодов реквизита.
Kill W недопустим !!!!. I,J и некоторые другие переменные (см текст метода) зарезервированы.
Если Arg1=1 - только расшифровка заголовка (создание массива Fld).
Arg2=1 - не ставить подчерк для содержимого полей

Обрабатываются ссылки на Memo-поля ( Fld(J,"T")="M" ) в файле *.dbt. Преобразуются в формат текстовых понятий.
В ^DBFerr(dbf,rek,id) - мемо-поля содержащие спецсимволы.

***qSYS.DBFr – чтение DBF файла в поток
***qSYS.DBFn – обработка считанных строк DBF файла.
***Вызов старого метода qSYS.DBF можно заменить на вызов qSYS.DBFr. Сигнатуры у этих методов одинаковые. 
@ank 20110511 Изменён порядок чтения dbf файла, вместо построчного теперь полное чтение</Description>
<Internal/>
<FormalSpec>file:%Library.String,Xec:%Library.String="",Dos:%Library.String=1,Arg1:%Library.String="",Arg2:%Library.String=""</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 N ret,gl,file1,Arg3 S ret=0
 K ^mtemp($J,"D") D qARM.ReadClientFile(file,0,"^mtemp($J,""D"")","S ret=2") I ret=2 Q:$Q 0 Q
 S file1=file,$P(file1,".",$L(file1,"."))="dbt" ;мемо-файл
 K ^mtemp($J,"M") D qARM.ReadClientFile(file1,-1,"^mtemp($J,""M"")","S ret=2")
 S Arg3=$S(ret=2:"",1:1)    
 D qARM.Wait("D qSYS.DBFn("""_file_""","""_Xec_""","_Dos_","_Arg1_","_Arg2_","_Arg3_")")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="DColor">
<Description>
Динамические параметры (цвета) для описания параметров ячеек</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
    N qqw1,qqw2,DColor I $E(qqw,$L(qqw))#2 S qqw1=$E(qqw,1,$L(qqw)-1)_($E(qqw,$L(qqw))-1),qqw2=qqw I 1
    E  S qqw2=$E(qqw,1,$L(qqw)-1)_($E(qqw,$L(qqw))+1),qqw1=qqw
    S DColor=qW.GE(qqw1)_","_qW.GE(qqw2) Q DColor_","_DColor
    ;;;I " "_$G(qqwchg)_" "'[(" "_
]]></Implementation>
</Method>

<Method name="DCpar">
<Description>
Динамические параметры редактирования текущей ячейки.
Предназначен для использования X731  выражения в виде @qSYS.DCpar("строка параметров")
Arg1 - список параметров (через запятую, каждый параметр содержащий запятую должен заключаться в кавычки.
(1) - X731 - Вариант редактирования;
(2) - x730 Тип развертки
(3) - X73 Параетры развертки
(4) - X740 Обязательность значения
(5) - X741 Режим одного слова
(6) - x742 язык
(7) - X744 Маска
(8) - X74 правило проверки
(9) - X75 Значение по умолчанию
(10) - x710 -Тип данных
(11) -X745 - ограничение поля ввода
(12) -X747 - Универсальная маска
(13) -X72 - параметры ячейки
(14) -x760 - стиль вывода
(15) -X761 - параметры стиля
Arg2=1 НЕ учитывать пустой параметр как сброс установленного ранее
Arg3 - список неменяемых параметров. Например, для использования в качестве выражения для варианта редактирования нужно использовать @qSYS.DCpar(...,,31) чтобы при следующем вызове опять сработал метод ;@Dol 22.03.10</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N stri,strii,str I $D(qqdat),$D(qqx)
 E  N qqdat,qqx S qqdat=$G(W("Zpos",2,"d")),qqx=$G(W("Zpos",2,"x"))
 S strii=0 F stri=31,30,3,40,41,42,44,4,5,10,45,20,6,47,2,60,61 I $I(strii),$S($G(Arg3)="":1,1:" "_Arg3_" "'[(" "_stri_" ")) S str=..PSYN(Arg1,",",strii,,,1) S:$S($G(Arg2):str'="",1:1) Vo(qqnump,$P(qqdat," ",2),0,$P(qqdat," ",3),qqx,stri)=str
 Q:$Q ..PSYN(Arg1,",",1,,,1) Q
]]></Implementation>
</Method>

<Method name="DelA">
<Description>
@gol,@rda 20110406 Удаление столбцов "аналитика" и перестроение массива. Редактирование граф 3-9 дерева объектов.
qqx - значение столбца в запросе:
      3 - аналитический срез (A)
      4 - агрегация (D)
      5 - num
      6 - sum
      7 - min
      8 - max
      9 - mid
Если qqx  не задан, то удаляются все ссылки для заданного qqo:qqw</Description>
<Internal/>
<FormalSpec>qqo,qqw,qqx</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 s qqo=$G(qqo),qqw=$G(qqw),qqx=$G(qqx) q:qqo=""  q:qqw=""
 N qqdat,%1,%2,%3,%4,%5
 s qqdat=qqo_" "_qqw 
 Do
 .S %2=$P(qqdat," ",2) ;код понятия
 .; Y - num,sum,min,max,mid
 .Do:qqx=""!(qqx>4)  Q:qqx'=""    
 ..Q:$G(Vs(qqnump,12,qqo,%2,4))=""
 ..S %1=qqo_" "_%2_" "_qqx
 ..S %4=$G(Vs(qqnump,13,0,%1)) I '%4 Q
 ..; сотрем текущий и сменим номера остальным
 ..K Vs(qqnump,13,0,%1),Vs(qqnump,13,1,%4)
 ..F  S %4=$O(Vs(qqnump,13,1,%4)) Q:%4=""  D
 ...S %1=Vs(qqnump,13,1,%4),Vs(qqnump,13,0,%1)=%4-1 K Vs(qqnump,13,1,%4) S Vs(qqnump,13,1,%4-1)=%1
 .; A - аналитический срез
 .Do:qqx=""!(qqx=3)  Q:qqx'=""  
 ..S %4=$G(Vs(qqnump,13,2,qqdat)) I '%4 Q
 ..;сотрем текущий и сменим номера остальным
 ..K Vs(qqnump,13,2,qqdat),Vs(qqnump,13,3,%4),Vs(qqnump,12,qqo,%2,3)
 ..F  S %4=$O(Vs(qqnump,13,3,%4)) Q:%4=""  S %1=Vs(qqnump,13,3,%4),Vs(qqnump,13,2,%1)=%4-1,Vs(qqnump,12,$P(%1," "),$P(%1," ",2),3)="A"_(%4-1) K Vs(qqnump,13,3,%4) S Vs(qqnump,13,3,%4-1)=%1
 ..S Vs(qqnump,12)=$G(Vs(qqnump,13,3,1))
 .; D - агрегаты
 .Do:qqx=""!(qqx=4) 
 ..K Vs(qqnump,12,qqo,%2,4) S Vs(qqnump,12,qqo,%2)=0 F %5=5:1:11 D  K Vs(qqnump,12,qqo,%2,%5)
 ...S %1=qqo_" "_%2_" "_%5,%4=$G(Vs(qqnump,13,0,%1)) Q:'%4
 ...; уберем Y диаграмм сотрем текущий и сменим номера остальным
 ...K Vs(qqnump,13,0,%1),Vs(qqnump,13,1,%4) 
 ...F  S %4=$O(Vs(qqnump,13,1,%4)) Q:%4=""  D
 ....S %1=Vs(qqnump,13,1,%4),Vs(qqnump,13,0,%1)=%4-1 K Vs(qqnump,13,1,%4) S Vs(qqnump,13,1,%4-1)=%1
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Diag">
<Description>
Построение диаграммы. Старый вариант. Перенесен из qWEB ;@Dol 05.03.10
Arg1 =1-VRML, 2 -IE,3-Word, 4-Excel,5- htm -файл</Description>
<Internal/>
<FormalSpec>Arg1:%String,view:%String,diagfile:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N Message
 S:'$D(Arg1) Arg1=$G(Vs(qqnump,13,"R")) I Arg1<1 Q "????"
 S:'$D(view) view=qview
 S:$G(diagfile)="" diagfile="qwordD" S diagfile=$P(diagfile,".")
 ;если вывод в IE,Word или Excel, количество аналитик больше 2 и признак XYZ, то выполняем метод DiagWE
 S Vs(qqnump,13,"Xp")=0 I $G(Vs(qqnump,13,"X")),$O(Vs(qqnump,13,3,""),-1)>2||($O(Vs(qqnump,13,1,""),-1)'=1)||$G(Vs(qqnump,99,"Anal",2)) S Vs(qqnump,13,"X")=0 S Vs(qqnump,13,"Xp")=1 ;@Dol 28.11.06 ;;I Arg1>1,Arg1<5,$O(Vs(qqnump,13,3,""),-1)>2,$G(Vs(qqnump,13,"X")) S Message=qWEB.DiagWE("A"_view,Arg1-2) Q Message
 S Message=qSYS.CreArDi("A"_view,$S(Arg1>1:100000,1:1000)) Q:'Message $E(Message,2,1000)
 If ( +$G(Vs(qqnump,13,"R")) = 6 ) d qWEB.OpenWebDiag()  Q ""
 I Vs(qqnump,13,"Xp") S Vs(qqnump,13,"X")=1
 N qqnumpold,xyz S xyz=$G(Vs(qqnump,13,"X"))&'$D(QDiagI),qqnumpold=qqnump N par,leg,sum,sumx,sump,sumxp,sumn,qqnump,y,y1,y2,x,x1,xmax,ymax,qqdev,oZVs8,yadd,xstr,ftree,zz,flist,flistP,nP,flist1,xp,Xp S qqnump="D",ymax=$O(QDiag(""),-1)+xyz,xmax=$O(QDiag(0,""),-1) ;xyz - трехмерная ;Xp
 S ftree=$G(Vs(qqnumpold,99,"Anal",2)) S:xyz ftree=0 ;полное дерево
 I ftree S ftree=ftree_" ",y="" F  S y=$O(Vs(qqnumpold,13,3,y)) Q:y=""  S x=Vs(qqnumpold,13,3,y) I $G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),3,1)) S ftree=ftree_y_" " ;список неподсчитываемых сумм по аналитикам
 S (flist1,flist)=" ",y="",flistP="" F  S y=$O(Vs(qqnumpold,13,1,y)) Q:y=""  S x=Vs(qqnumpold,13,1,y) I $P(x," ",3)=6,$G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),4,1)) S flist=flist_y_" " S:$G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),4,1))=1||($G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),4,1))=4) flist1=flist1_y_" " S:$G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),4,1))=3 flistP=flistP_y_" " ;неподсчитываемые суммы, flist1 - список первых/последних значений, flistP - полные списки;@Dol 22.01.10 4 - последнее
 I flistP'="" S flistP=" "_flistP ;@Dol 1.10.08 полные списки
 I $G(qqoQu)="" N qqoQu,query S qqoQu=99999,query=9999 ;если не запрос
 I $G(query)="" S query=9999 ;@Dol 30.04.09
 ;создание отображения в памяти
 S par=$G(Vs(qqnumpold,13,"R")) ;@Dol 30.04.09 доп.пар. $P(par," ",8)- размер колонки Nп\п, 9 - повтор одинаковых, 10- наследование типа данных аналитик , 11 - наследование параметров аналитик, 12, 13 - агрегатов (12 пока не работает), 14 -Nп.п для A1, 15 - без ИТОГО, 16 - замена пустых (???)
 K Vo(qqnump) S Vo(qqnump)=view
 S Vo(qqnump,-1)="Таблица диаграммы"
 S yadd=$L(QDiag(0,0),"~") ;дополнительные колонки (если многомерная диаграмма и не установлено xyz)
 S xp=$G(Vs(qqnumpold,13,"Xp")) I xp D  ;@Dol 10.03.09 раскладка по последнему измерению
 .I $D(QDiagI) M:ftree sum=QDiagI F y1=1:1:ymax I $G(QDiagI(y1))'="" S QDiagI(y1)=0 ;сброс итоговых сумм для пересчета
 .S zz=1 F x=1:1:xmax D
 ..S y=$G(Xp(0,$P(QDiag(0,x),"~",yadd))) I 'y S y=$I(Xp),Xp(0,$P(QDiag(0,x),"~",yadd))=y,Xp(y)=$P(QDiag(0,x),"~",yadd) F y1=1:1:ymax S y2=ymax*(y-1)+y1 S:flist[(" "_y1_" ") flist=flist_y2_" " S:flist1[(" "_y1_" ") flist1=flist1_y2_" " S:flistP[(" "_y1_" ") flistP=flistP_y2_" "
 ..I x>1 S zz=$S($P(QDiag(0,x),"~",1,yadd-1)=$P(QDiag(0,zz),"~",1,yadd-1):zz,1:x)
 ..F y1=1:1:ymax D
 ...S y2=ymax*(y-1)+y1 I $G(QDiagI(y1))'="",$I(QDiagI(y2),QDiag(y1,x))!1,ftree,ftree'[(" "_yadd_" "),$I(sumn(zz,y1),QDiag(y1,x))
 ...Q:y=1&&(zz=x)  S QDiag(y2,zz)=QDiag(y1,x),QDiag(y1,x)=""
 ..K:zz'=x QDiag(0,x)
 .I ftree,ftree'[(" "_yadd_" ") S Xp=Xp+1,Xp(Xp)="Всего" D
 ..F x=1:1:xmax I $D(sumn(x))>1 F y1=1:1:ymax I $D(sumn(x,y1)) S QDiag(ymax*(Xp-1)+y1,x)=sumn(x,y1)
 ..F y1=1:1:ymax I $D(sum(y1)) S QDiagI(ymax*(Xp-1)+y1)=sum(y1)
 .K sum,sumn
 .S yadd=yadd-1,xp=ymax,ymax=ymax*Xp
 S Vo(qqnump,-1,9)=ymax+yadd ;+1 для N
 S $$$Tree=0
 ;;Vs(qqnumpold,120,2) - заголовок аналитики (первая строка - заголовок, затем строки подвала)
 ;S x=$G(^Q(1,qqoQu,query,"XQTitle")) S:$E(x)="@" @("x="_$E(x,2,30000)) S:x="" x=$P($G(Vs(qqnumpold,120,2)),$C(13,10))
 ;S Vo(qqnump,-1,0,1,1)="0"_$S(x'="":x,1:"Таблица распределения """_$TR(QDiag(0,0),"~","/")_$S('xyz:"",1:" ("_$P(QDiag," ",5,255)_")")_""""),Vo(qqnump,-1,0,1,1,2)=",1,1,10,1"
 ;S oZVs8=$S($G(^Q(1,qqoQu,query,"X3694"),1):qW.oZVs8(qqnumpold,,1),1:"") I oZVs8'="" S Vo(qqnump,-1,0,2,1)="5 ",Vo(qqnump,-1,0,2,1,2)=",1,1",Vo(qqnump,-1,0,2,1,10)=3 ;S Vo(qqnump,-1,0,2,0)="0Условия поиска:___",Vo(qqnump,-1,0,2,0,2)=",2,,,1",Vo(qqnump,-1,0,2,1)="5 ",Vo(qqnump,-1,0,2,1,2)=",,1",Vo(qqnump,-1,0,2,1,10)=3 ;если был поиск с условиями
 ;S Vo(qqnump,-1,0,3,1)="0 " ;пустая строка
 S leg=$G(^Q(1,qqoQu,query,"XQLeg")) ;S:leg="" leg=ymax>5 ;&xyz ;вывести легенду
 D:'leg
 .S Vo(qqnump,-1,0,6)="Xy" ;ссылка на объект Xy (если будут еще строки в объекте -1, заменить 5 на первую свободную
 .F y=0:1:ymax-''xyz D
 ..I y D  Q
 ...S x=$$DiagCol(y,1) I $P(x,",",1)="",$P(par," ",13) S x=$$DiagPar(y,1)
 ...S x1="" I $P(par," ",12) S x1=$$DiagName(y,1)
 ...S y1=y+yadd S:'x Vo(qqnump,-1,0,0,y1,2)=8 S Vo(qqnump,-1,0,5,y1)="0"_$S(y=ymax&xyz:"ВСЕГО",x1'="":x1,1:$TR($G(QDiag($S($G(xp):$S(y#xp:y#xp,1:xp),1:y),0)),"_"," ")),Vo(qqnump,-1,0,5,y1,2)=",1,5,,1,,,,,2"
 ...S Vo(qqnump,"Xy",0,0,y1)="5 " I $P(par," ",12) S x1=$$Diag710(y,1) S:x1'="" Vo(qqnump,"Xy",0,0,y1,10)=x1 ;тип данных
 ...S Vo(qqnump,"Xy",0,0,y1,2)=$S(x'="":x,1:","_$S(flist[(" "_y_" "):",",1:"2,")_",,,,,,,2") 
 ...S:$P(Vo(qqnump,"Xy",0,0,y1,2),",",2)=""&&(flist'[(" "_y_" ")) $P(Vo(qqnump,"Xy",0,0,y1,2),",",2)=2 Q  ;@Dol 29.09.08 flist
 ..F y1=0:1:yadd D
 ...S x=$$DiagCol(y1,3) I $P(x,",",1)="",y1,$P(par," ",11) S x=$$DiagPar(y1,3)
 ...S x1="" I y1,$P(par," ",11) S x1=$$DiagName(y1,3)
 ...S Vo(qqnump,-1,0,0,y1,2)=$S('y1:$S($P(par," ",8)="":2,1:$P(par," ",8)),$P(x,",")'="":$P(x,","),y1=1:20,1:10)
 ...S Vo(qqnump,-1,0,5,y1)="0"_$S('y1:$C(185),x1'="":x1,1:$TR($P(QDiag(y,0),"~",y1),"_"," "))
 ...S Vo(qqnump,-1,0,5,y1,2)=",1,5,,1,,,,,2",Vo(qqnump,"Xy",0,0,y1)="5 "
 ...I y1,$P(par," ",10) S x1=$$Diag710(y1,3) S:x1'="" Vo(qqnump,"Xy",0,0,y1,10)=x1 ;тип данных
 ...S Vo(qqnump,"Xy",0,0,y1,2)=$S(x'="":x,1:","_$S('y1:$S($P(par," ",8)="":2,1:$P(par," ",8))_",,,1",1:",,,")_",,,,,2") ;c обрамлением ячеек
 .Q:'xp  S Vo(qqnump,-1,0,4,0)="0"_$TR($P(QDiag(0,0),"~",yadd+1),"_"," ")_": ",Vo(qqnump,-1,0,4,0,2)=",2,,,,,,,,2",x=0 F y=yadd+1:xp:ymax+yadd S Vo(qqnump,-1,0,4,y)="0"_Xp($I(x)),Vo(qqnump,-1,0,4,y,2)=",1,,,1,,,,,2"
 D:leg
 .F y=1:1:ymax-''xyz S Vo(qqnump,-1,0,3+y,1)="0"_$J(y,3)_"."_$TR(QDiag($S($G(xp):y#xp+1,1:y),0),"_"," ") ;0->1
 .;F y=0:1:ymax S Vo(qqnump,-1,0,0,y,2)=$S('y:20,y=ymax:5,1:3),Vo(qqnump,-1,0,3+ymax+1,y)="0"_$S(y=ymax&xyz:"ВСЕГО",'y:QDiag(y,0),1:y),Vo(qqnump,-1,0,3+ymax+1,y,2)=",1,5,,1,,,,,2",Vo(qqnump,"Xy",0,0,y)="5 " S Vo(qqnump,"Xy",0,0,y,2)=$S(y:",2",1:",")_",,,,,,,,2" ;c обрамлением ячеек
 .F y=0:1:ymax D
 ..I y D  Q
 ...S x=$$DiagCol(y,1) I $P(x,",",1)="",$P(par," ",12) S x=$$DiagPar(y,1)
 ...S y1=y+yadd S:'x Vo(qqnump,-1,0,0,y1,2)=5 S Vo(qqnump,-1,0,3+ymax+1,y1)="0"_$S(y=ymax&xyz:"ВСЕГО:",1:$C(160)_y_$C(160)),Vo(qqnump,-1,0,3+ymax+1,y1,2)=",1,5,,1,,,,,2",Vo(qqnump,"Xy",0,0,y1)="5 " S Vo(qqnump,"Xy",0,0,y1,2)=$S(x'="":x,1:","_$S(flist[(" "_y_" "):",",1:"2,")_",,,,,,,2") Q  ;c обрамлением ячеек
 ..F y1=0:1:yadd D
 ...S x=$$DiagCol(y1,3) I y1,$P(par," ",11) S x1=$$DiagName(y1,3)
 ...S Vo(qqnump,-1,0,0,y1,2)=$S('y1:$S($P(par," ",8)="":2,1:$P(par," ",8)),$P(x,",")'="":$P(x,","),y1=1:20,1:10),Vo(qqnump,-1,0,3+ymax+1,y1)="0"_$S('y1:$C(185),1:$TR($P(QDiag(y,0),"~",y1),"_"," ")),Vo(qqnump,-1,0,3+ymax+1,y1,2)=",1,5,,1,,,,,2",Vo(qqnump,"Xy",0,0,y1)="5 " S Vo(qqnump,"Xy",0,0,y1,2)=$S(x'="":x,1:","_$S('y1:$S($P(par," ",8)="":2,1:$P(par," ",8))_",,,1",1:",,,")_",,,,,2") ;c обрамлением ячеек
 .S Vo(qqnump,-1,0,3+ymax+('xyz),0)="0 " ;пустая строка
 .S Vo(qqnump,-1,0,3+ymax+2+('xyz))="Xy"
 ;
 S Vo(qqnump,-1,3,21)=0 ;вывод в виде бланка
 ;;;S Vo(qqnump,-1,3,62)="XXXNumPageR",Vo(qqnump,-1,3,620)=0 ;@Dol 24.08.09 колонтитул с номером страницы
 S Vo(qqnump,-1,3,691)=1 ;сохранять размеры колонок
 S Vo(qqnump,-1,3,641)="1pt 1pt 1pt 1pt" ;отступы
 S Vo(qqnump,-1,3,64)=$S($G(^Q(1,qqoQu,query,"X364"))'="":^("X364"),1:" "_(ymax+yadd>7)_"  10  10") S:$P(Vo(qqnump,-1,3,64)," ",1)="" $P(Vo(qqnump,-1,3,64)," ",1)="A4" S:'$P(Vo(qqnump,-1,3,64)," ",4) $P(Vo(qqnump,-1,3,64)," ",4)=10 S:'$P(Vo(qqnump,-1,3,64)," ",6) $P(Vo(qqnump,-1,3,64)," ",6)=10 ;параметры страницы ;больше 7 колонок - албом
 S Vo(qqnump,-1,3,55)=$S($G(^Q(1,qqoQu,query,"X355"))'="":^("X355"),1:",9") ;основной фонт
 ;Vs(qqnumpold,120,2) - заголовок аналитики (первая строка - заголовок, затем строки подвала)
 S x=$G(^Q(1,qqoQu,query,"XQTitle")) S:$E(x)="@" @("x="_$E(x,2,30000)) S:x="" x=$P($G(Vs(qqnumpold,120,2)),$C(13,10))
 F x1=0:1:5 Q:$P($G(Vo(qqnump,-1,0,0,x1,2)),",")'=0  ;02.06.09 первая незачеркнутая
 S Vo(qqnump,-1,0,1,x1)="0"_$S(x'="":x,1:"Таблица распределения """_$TR(QDiag(0,0),"~","/")_$S('xyz:"",1:" ("_$P(QDiag," ",5,255)_")")_""""),Vo(qqnump,-1,0,1,x1,2)=",1,1,10,1"
 S oZVs8=$S($G(^Q(1,qqoQu,query,"X3694"),1):qW.oZVs8(qqnumpold,,1),1:"") I oZVs8'="" S Vo(qqnump,-1,0,2,x1)="5 ",Vo(qqnump,-1,0,2,x1,2)=",1,1",Vo(qqnump,-1,0,2,x1,10)=3 
 S Vo(qqnump,-1,0,3,x1)="0 " ;пустая строка
 S x=$G(^Q(1,qqoQu,query,"XQUnd")) S:$E(x)="@" @("x="_$E(x,2,30000)) S:x="" x=$P($G(Vs(qqnumpold,120,2)),$C(13,10),2,255)
 D:x'=""  ;@Dol 26.05.06 подвал
 .S y=$O(Vo(qqnump,-1,0,""),-1)+1
 .S Vo(qqnump,-1,0,y,x1)="0 " ;пустая строка
 .F y1=1:1:$L(x,$C(13,10)) S y=y+1,Vo(qqnump,-1,0,y,x1)="0"_$P(x,$C(13,10),y1),Vo(qqnump,-1,0,y,x1,2)=",,1,,1"
 D qSYS.CreVoAdd()
 D qWEB.XSL(1,,,,Arg1-2) ;@Dol 17.12.08 построение диаграммы в Exsel блокировано. надо переделать ;$S(Arg1-2=2:20,1:Arg1-2)) ;@Mike 21.03.03 вывод диаграммы в Excel
 D qARM.OpenIE(1,qWEB.ClientPath()_$G(diagfile)_".xsl",0) ;формирование
 ;формирование XML ;@Dol 17.12.08 добавлено qW.CXML(
 S qqdev=2
 D qWEB.OpenDev(2)
 D qWEB.write("<?xml version='1.0' encoding='windows-1251'?>") D qWEB.write("<?xml-stylesheet type='text/xsl' href='"_$G(diagfile)_".xsl'?>")
 D qWEB.write("<baseO>")
 I oZVs8'="" D qWEB.write("<Zs2c1>"_oZVs8_"</Zs2c1>") ;@Dol 02.02.09 _qW.CXML(oZVs8)_
 S xstr="",sumxp=$G(QDiag(1,1))["%"
 N num1,num0 S:$P(par," ",14) num1=0 S num0=0 ;@Dol 20.01.10 num0 - счетчик строк (вместо x)
 F x=1:1:xmax D:$D(QDiag(0,x))
 .D qWEB.write("<OXy>") S sum=0,sump=0,zz=QDiag(0,x)
 .S nP=0 F y=0:1:ymax D
 ..I y,ftree F y1=1:1:yadd-1 I $E(ftree,2,255)'[(" "_y1_" "),$I(sumn($P(zz,"~",1,y1),y)),$I(sum($P(zz,"~",1,y1),y),$G(QDiag(y,x))) ;@Dol 1.12.06 промежуточные суммы
 ..I y,xyz D
 ...S sum=$G(sum)+$G(QDiag(y,x)),sumx(y)=$G(sumx(y))+$S(y=ymax:sum,1:$G(QDiag(y,x))) ;sym - сумма по ряду, symx(y) - по колонке
 ...I $G(sumxp) S sump=$G(sump)+$P($G(QDiag(y,x)),"/",2),sumxp(y)=$G(sumxp(y))+$S(y=ymax:sump,1:$P($G(QDiag(y,x)),"/",2)) ;если %
 ..I y S y1=y+yadd S:$G(QDiag(y,x))["???"&&($TR($P(par," ",16),"?")'="") QDiag(y,x)=qW.zChSym(QDiag(y,x),"???",$P(par," ",16)) D qWEB.write("<Zs0c"_y1_">"_$S(y=ymax&xyz:sum_$S('sumxp:"",1:"%/"_sump),flist'[(" "_y_" "):$S($G(Vo(qqnump,"Xy",0,0,y1,10))'="":qW.GtoExt(Vo(qqnump,"Xy",0,0,y1,10),$P($G(QDiag(y,x))," ")),1:$P($G(QDiag(y,x))," ")),flistP[(" "_y_" "):$TR($P($G(QDiag(y,x))," "),"_"," "),flist1[(" "_y_" "):$TR($G(QDiag(y,x)),"_"," "),1:$G(QDiag(y,x)))_"</Zs0c"_y1_">") D:flistP[(" "_y_" ")  Q  ;qW.GtoExt(2,QDiag(y,x),,,1)
 ...I nP<$L($G(QDiag(y,x))," ") S nP=$L($G(QDiag(y,x))," ")
 ..I ftree,xstr'="",$P(QDiag(y,x),"~",1,yadd-1)'=$P(xstr,"~",1,yadd-1) F y1=yadd-1:-1:1 I $E(ftree,2,255)'[(" "_y1_" "),$P(QDiag(y,x),"~",1,y1)'=$P(xstr,"~",1,y1),$G(sumn($P(xstr,"~",1,y1),1))>1 D  ;@Dol 1.12.06 промежуточные итоги;23.12.09 Было $G(sumn($P(xstr,"~",1,y1),y1))>1
 ...D qWEB.write("<Zs0c0> </Zs0c0>") F y2=1:1:y1 D qWEB.write("<Zs0c"_y2_">"_$S(y2<y1:" ",1:"*ВСЕГО:")_"</Zs0c"_y2_">") ;D qWEB.write("<Zs0c"_y2_">"_$S(y2<y1:" ",1:$TR($P(xstr,"~",y2),"_"," ")_" ВСЕГО:")_"</Zs0c"_y2_">")
 ...F y2=1:1:ymax I flist'[(" "_y2_" ") S x1=$G(sum($P(xstr,"~",1,y1),y2)) S:$G(Vo(qqnump,"Xy",0,0,(y2+yadd),10))'="" x1=qW.GtoExt(Vo(qqnump,"Xy",0,0,(y2+yadd),10),x1) D qWEB.write("<Zs0c"_(y2+yadd)_">"_qW.CXML(x1)_"</Zs0c"_(y2+yadd)_">")
 ...D qWEB.write("</OXy>") D qWEB.write("<OXy>")
 ..F y1=0:1:yadd S x1=$S('y1:$S($G(num1)="":$I(num0),($P(QDiag(y,x),"~",1,$P(par," ",14))=$P(xstr,"~",1,$P(par," ",14))):"",1:$I(num1)),xyz:$TR($P(QDiag(y,x),"~",y1),"_"," "),'$P(par," ",9)&&($P(QDiag(y,x),"~",1,y1)=$P(xstr,"~",1,y1)):" ",1:$TR($P(QDiag(y,x),"~",y1),"_"," ")) S:x1["@#@" @("x1="_$P(x1,"@#@",2,255)) S:x1="???"&&($P(par," ",16)'="") x1=$P(par," ",16) S:x1'=""&&($G(Vo(qqnump,"Xy",0,0,y1,10))'="") x1=qW.GtoExt(Vo(qqnump,"Xy",0,0,y1,10),x1) D qWEB.write("<Zs0c"_y1_">"_qW.CXML(x1)_"</Zs0c"_y1_">") ;@Dol 29.06.09 x1["@#@" ;20.01.10 x->$I(num0)
 ..S:'xyz xstr=QDiag(y,x)
 .D qWEB.write("</OXy>")
 .I nP>1 F nP=2:1:nP D qWEB.write("<OXy>") D  D qWEB.write("</OXy>") ;@Dol 1.10.08 строки для полных списков
 ..D qWEB.write("<Zs0c0> </Zs0c0>") F y=1:1:ymax S y1=y+yadd D qWEB.write("<Zs0c"_y1_">"_qW.CXML($S(y=ymax&xyz:"",flistP[(" "_y_" "):$TR($P($G(QDiag(y,x))," ",nP),"_"," "),1:""))_"</Zs0c"_y1_">")
 .I ftree,x=xmax  F y1=yadd-1:-1:1 I $E(ftree,2,255)'[(" "_y1_" "),$G(sumn($P(xstr,"~",1,y1),1))>1 D  ;23.12.09 Было $G(sumn($P(xstr,"~",1,y1),y1))>1
 ..D qWEB.write("<OXy>") D qWEB.write("<Zs0c0> </Zs0c0>") F y2=1:1:y1 D qWEB.write("<Zs0c"_y2_">"_$S(y2<y1:" ",1:"*ВСЕГО:")_"</Zs0c"_y2_">") ;@Dol 26.09.08 D qWEB.write("<Zs0c"_y2_">"_$S(y2'=y1:" ",1:$TR($P(xstr,"~",y2),"_"," ")_" ВСЕГО:")_"</Zs0c"_y2_">")
 ..F y2=1:1:ymax I flist'[(" "_y2_" ") S x1=$G(sum($P(xstr,"~",1,y1),y2)) S:$G(Vo(qqnump,"Xy",0,0,(y2+yadd),10))'="" x1=qW.GtoExt(Vo(qqnump,"Xy",0,0,(y2+yadd),10),x1) D qWEB.write("<Zs0c"_(y2+yadd)_">"_qW.CXML(x1)_"</Zs0c"_(y2+yadd)_">")
 ..D qWEB.write("</OXy>")
 D:$D(QDiagI)&&'$P(par," ",15)  ;Всего @dol 25.12.02
 .S y="",x=0 F  S y=$O(QDiagI(y)) Q:y=""  I flist'[(" "_y_" ") S x=$TR($G(QDiagI(y))," ")'="" Q:x  ;@Dol 30.04.09 пустые итоги
 .Q:'x
 .D qWEB.write("<OXy>")
 .F y=0:1:ymax D
 ..I y s y1=y+yadd D:flist'[(" "_y_" ") qWEB.write("<Zs0c"_y1_">"_qW.CXML($S($G(Vo(qqnump,"Xy",0,0,y1,10))'="":qW.GtoExt(Vo(qqnump,"Xy",0,0,y1,10),$G(QDiagI(y))),1:$G(QDiagI(y))))_"</Zs0c"_y1_">") Q
 ..S x1=0 F y1=0:1:yadd S:'x1 x1=y1&&($P($G(Vo(qqnump,-1,0,0,y1,2)),",")'=0) D qWEB.write("<Zs0c"_y1_">"_$S(x1=1:"ИТОГО:",1:" ")_"</Zs0c"_y1_">") S:x1=1 x1=2
 .D qWEB.write("</OXy>")
 D:xyz  ;Всего @dol 25.12.02
 .D qWEB.write("<OXy>")
 .F y=0:1:ymax S y1=y+1 D qWEB.write("<Zs0c"_y1_">"_qW.CXML($S('y:"ИТОГО:",y=ymax&sumxp:"100%/"_sumxp(y),1:$G(sumx(y))_$S('sumxp:"",1:"%/"_sumxp(y))))_"</Zs0c"_y1_">") ;@dol 16.01.02
 .D qWEB.write("</OXy>")
 D qWEB.write("</baseO>")
 D qWEB.CloseDev(2)
 I Arg1=1 Q "" ;VRML
 D qWEB.SendXML(2,Arg1-2,$G(diagfile),,Arg1'=5)
 Q $E(Message,2,1000)
DiagCol(ycol,y13) ;параметры колонки (y13=1 - D, 3 - A)
 Q:'ycol "" Q:xyz "" S:$G(xp)&($G(y13)=1) ycol=$S(ycol#xp:ycol#xp,1:xp) S ycol=$G(Vs(qqnumpold,12,$P(Vs(qqnumpold,13,y13,ycol)," "),$P(Vs(qqnumpold,13,y13,ycol)," ",2),17)) Q:ycol="" "" S:$P(ycol,",",10)="" $P(ycol,",",10)=2 Q ycol
DiagName(ycol,y13) ;название колонки (y13=1 - D, 3 - A)
 S:$G(xp)&($G(y13)=1) ycol=$S(ycol#xp:ycol#xp,1:xp)
 S y13=$P(Vs(qqnumpold,13,y13,ycol)," ",1,2) Q:y13="" "" ;код объекта и понятия
 I $G(Vs(qqnumpold,12,$P(y13," ",1),$P(y13," ",2),1))'="" Q "" ;задано в выражении аналитики
 S ycol=$P(qARM.GetPar("X7103",,$P(y13," ",1),$P(y13," ",2),,qqnumpold),"~") S:ycol="" ycol=qARM.GetName(,$P(y13," ",1),$P(y13," ",2),qqnumpold) Q ycol
DiagPar(ycol,y13) ;параметры колонки (y13=1 - D, 3 - A)
 S:$G(xp)&($G(y13)=1) ycol=$S(ycol#xp:ycol#xp,1:xp)
 S y13=$P($G(Vs(qqnumpold,13,y13,ycol))," ",1,2) Q:y13="" "" ;код объекта и понятия
 S ycol=qARM.GetPar("X72",,$P(y13," ",1),$P(y13," ",2),,qqnumpold)
 I $P(ycol,",")="" S y13=$P($G(Vo(qqnumpold,$P(y13," ",1),11,$P(y13," ",2)))," ",2) S:y13'="" $P(ycol,",",1)=$P($G(Vo(qqnumpold,-1,9,y13)),",") ;размер колонки исходного отображения
 S $P(ycol,",",10)=2 Q ycol
Diag710(ycol,y13) ;тип данных (y13=1 - D, 3 - A)
 S:$G(xp)&($G(y13)=1) ycol=$S(ycol#xp:ycol#xp,1:xp)
 S y13=$P($G(Vs(qqnumpold,13,y13,ycol))," ",1,2) Q:y13="" "" ;код объекта и понятия
 S ycol=qARM.GetPar("x710",,$P(y13," ",1),$P(y13," ",2),,qqnumpold)
 Q ycol
]]></Implementation>
</Method>

<Method name="DynPar">
<Internal/>
<FormalSpec>qqw:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ;$S(qW.GG("Xx","Cx730",Vs(qqnump,"Virt","Xx"))=0:"*12632256",1:"")
 N x730 I Vo(qqnump)'["XXX" S x730=qW.GG("linkT","Cx730",W("linkT")) G DynParE ;for Julia
 I Vo(qqnump)["CxWoc" S x730=qW.GG("CxWoc","Cx730",Vs(qqnump,"Virt","CxWoc")) I x730="" I "234"[$G(^Q(1,"CxWoc",Vs(qqnump,"Virt","CxWoc"),"x70")) S x730=$G(^Q(1,"CxWoc",qW.GG("CxWoc","X71",Vs(qqnump,"Virt","CxWoc")),"x730"))
 I Vo(qqnump)="XXXXNView" S x730=qW.GG("Xx","Cx730",Vs(qqnump,"Virt","Xx")) I x730="" I "234"[$G(@Vo(qqnump,"Xx",33)@(Vs(qqnump,"Virt","Xx"),"x70")) S x730=$G(^Q(1,"CxWoc",qW.GG("Xx","X71",Vs(qqnump,"Virt","Xx")),"x730"))
DynParE Q:x730=0!(x730=5) $S(+$e(qqw,5,6)>9:"*12632256",1:"")
 Q:x730=1||(x730=21) $S(" 17 18 14 "[(" "_(+$e(qqw,5,6))_" "):"*12632256",+$e(qqw,5,6)=1!(+$e(qqw,5,6)>5&(+$e(qqw,5,6)<25)):"",1:"*12632256") ;@Dol 25.09.08
 Q:x730=2 $s(+$e(qqw,5,6)=1!(+$e(qqw,5,6)=6)!(+$e(qqw,5,6)>13&(+$e(qqw,5,6)<20)):"",1:"*12632256") 
 Q:x730=12 $s(+$e(qqw,5,6)=1!(+$e(qqw,5,6)=6)!(+$e(qqw,5,6)=11)!(+$e(qqw,5,6)>13&(+$e(qqw,5,6)<20)):"",1:"*12632256")
 ;Q:x730=21 $s(+$e(qqw,5,6)=1!(+$e(qqw,5,6)>5&(+$e(qqw,5,6)<12))!(+$e(qqw,5,6)=13)!(+$e(qqw,5,6)=16)!(+$e(qqw,5,6)>19):"",1:"*12632256")
 Q ""
]]></Implementation>
</Method>

<Method name="Encrypt">
<Description>
Получение хэша строки, заданной в @Arg1@(0)
Т.е. пусть A(0)=строка, тогда вызов: =qSYS.Encrypt("A")</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[ q ..SECSHA(Arg1)
]]></Implementation>
</Method>

<Method name="FDragDrop">
<Description>
Перенос поддерева в формате потока через файл
Arg1=0 - сохранение поддерева текущего экземпляра объекта
Arg1=1 - восстановление (замещение текущего экземпляра)
Arg1=2 - восстановление (создание нового)
LineChObj - см. метод qW.StreemImp</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,mas:%Library.String,LineChObj:%Library.String,qqofrom:%Library.String,Nofile:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(mas)'="" D  S qqend=1 Q:$Q "" Q  ;действие после восстановления (по qARM("Pars",9) )
 .N WwW M WwW=W N W M W=WwW ;@Dol 02.10.08 чтобы не портить W
 .;?????S quser="sys" ;@Dol 26.02.08 зачем портить ;;;;I '$D(^Q(1,"CxObj",@mas@(3))) Q  ;восстанавливаемого объекта нет в базе;;в @mas@(6) возвращается новый код вершины
 .I '$G(@mas@(5)) S @mas@(6)=qW.StreemImp($NA(@mas@(2)),,,@mas@(3),,,,@mas@(4),,$G(@mas@(7))) Q  ;замещение текущего экземпляра
 .I $E($G(@mas@(3)))="C" S @mas@(6)=qW.StreemImp($NA(@mas@(2)),,,@mas@(3)) Q  ;Словари
 .S @mas@(6)=qW.StreemImp($NA(@mas@(2)),,,@mas@(3),,0,,@mas@(4),,$G(@mas@(7))) ;@Dol 01.11.07 было 0,0,@mas@(4) ;cqqc=0 - всегда порождать новые коды - НЕ схранялись коды экземпляров
 S mas=$NA(^mtempQW(qARM("ComputerName")))
 I $G(Arg1)=10 D  Q  ;действие по выбору меню из метода OnOLEDrop
 .I $E(qqchoice,9)=0 D qSYS.FDragDrop(2,,LineChObj,qqofrom,1),qARM.Wait("S qqc=$G("_$NA(@mas@(6))_") D qARM.wcre()",1) Q  ;добавить
 .I $E(qqchoice,9)=1 D qSYS.FDragDrop(1,,LineChObj,qqofrom,1),qARM.Wait("D qARM.wqqotree()",1) Q  ;заместить
 .Q  ;отказ
 I $G(Arg1)=11 D  Q  ;@Dol 19.09.06 действие по восстановлению (добавление) см. qARM.TestPaste
 .S qBuFfXec="D qSYS.FDragDrop(2,,"""_LineChObj_""","""_qqofrom_""",1) S qqc=$G("_$NA(@mas@(6))_") D qARM.wcre()" d qARM.wM("-qARM","LoadFromClipbrd")
 I $G(Arg1)=12 D  Q  ;действие по восстановлению (замещение) см. qARM.TestPaste
 .S qBuFfXec="D qSYS.FDragDrop(1,,"""_LineChObj_""","""_qqofrom_""",1) D qARM.wqqotree()" d qARM.wM("-qARM","LoadFromClipbrd")
 ;****Далее - Старые варианты. Вроде не используются 
 N file S file=qWEB.ClientPath()_"qWORDrDrop.dat" G:$G(Arg1) FDrag1
FDrag0 ;сохранение
 K @mas@(2) D qW.StreemExp($NA(@mas@(2)),$$$CurObj,qqc,,,,,1,,0) ;@Dol 25.09.08 было ,1) сохранялось по описанию объекта. теперь все физически существующие в объекте. Проблема с характеристиками - переносятся только при копировании объекта ww
 S @mas@(0)="K "_$NA(@mas@(2))
 S @mas@(1)="s mas="""_qSYS.dblqw(mas)_""" D qSYS.FDragDrop(,mas)"        ;,qARM(""Pars"",9)=""D qSYS.FDragDrop(,mas)"",qa=##class(%TqARM).%New() d qa.Create()" 
 ;D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -C -D -S -F"_$TR(file," ","*")_" -G"_$NA(@mas@(2))_" -H -A"_mas)
 D qARM.wM("-qARM","SaveGlbToFile",$NA(@mas@(2)),mas,file)
 Q
FDrag1 ;восстановление 
 S @mas@(3)=$S($G(qqofrom)="":$$$CurObj,1:qqofrom),@mas@(4)=qqc,@mas@(5)=Arg1-1,@mas@(7)=$G(LineChObj)
 ;;;;D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -C -R -X -F"_$TR(file," ","*")_" -H"),qARM.wM(qwin,"SetFocus") Q  ;??? -X - удалить после востановления
 I '$G(Nofile) D qARM.wM("-qARM","LoadGlbFromFile",file) Q  ;,qARM.wM(qwin,"SetFocus") Q
 D qSYS.FDragDrop(,mas) Q
]]></Implementation>
</Method>

<Method name="FileLoad">
<Internal/>
<FormalSpec>file:%Library.String,e:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;;misuno 20080806 закрывать файл при ошибке
 s $zt="FileLoadE"
 
 n t o file:("RF":32000):0
 u file f i=0:1  r t q:$zeof<0  s @e@(i)=t

FileLoadE
 c file q
]]></Implementation>
</Method>

<Method name="FileSave">
<Internal/>
<FormalSpec>file:%Library.String,e:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n i o file:"nw" u file for i=0:1:$O(@e@(""),-1) w @e@(i)
 c file q
]]></Implementation>
</Method>

<Method name="FindClass">
<Description>
Определяет есть ли указанный класс пакета в области. формат д.б. следующий:
Имя пакета.Имя класса
Второй параметр, старый метод определения по умолчанию, для версий с 4
1 - новый метод, с версии 5.1</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%String=0</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 i Arg2=0 s cdef = ##class(%Library.ClassDefinition).%OpenId(Arg1)
 e  s cdef =##class(%Dictionary.ClassDefinition).%OpenId(Arg1)
 ;if $isobject(cdef) k cdef q 1
 ;из за 4, пока работает такой вариант, более грубый sas 200101224 
 if cdef'="" k cdef q 1
 k cdef
 q 0
]]></Implementation>
</Method>

<Method name="GP">
<Description>
Унаследованное значение параметра для вывода в описании отображений.
Arg1=1 - вернуть код_объекта:код_понятия</Description>
<Internal/>
<FormalSpec>qqpar:%String,Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N Obj,qqt,qqc1 S Obj=qqo,qqc1=qqc
 I $G(^Q(1,"XBase",0,"XBNDes"))=1||($E(Vo(qqnump),1,6)="XXXXNV") G GPnew
 I qqo="Xx" S qqt=$G(@qqref@(qqo,qqc,"x70")) Q:qqt="" "" S:"234"[qqt qqc1=qW.GG(qqo,"X71",qqc) I "234"'[qqt Q:$G(qqpar)'="" "" Q:qqt'=0 "" S qqc1=qW.GG(qqo,"X71",qqc) Q:$E(qqc1)'="@" "" Q $S($L(qqc1)=1:qW.GetWoc("CxObj",$QS(qqref,5)),1:qW.GetWoc("CxWoc",$E(qqc1,2,30)))
 S Obj="C"_$S(qqo="Xx":"xWoc",1:"xObj")
 I $G(Arg1) Q:Obj="CxObj" qqc1 Q $P(qqref,"CxObj"",",2)_":"_qqc1
 S:qqc1[":" qqc1=$P($P(qqc1,":",2),"{")
 I $G(qqpar)="" Q $G(^Q(1,Obj,qqc1))
 S qqt=$G(^Q(1,Obj,qqc1,qqpar)) Q:qqt="" ""
 I $E(qqpar)="x" S qqt=$G(^Q(1,"C"_qqpar,qqt))
 ;I $E(qqpar,2)="F" S qqt=$S('qqt:"нет",1:"да")
 Q qqt
 ;;;;;;;;;;;;;;;;;
GPnew 
 ;S qqref=$NA(@Vo(qqnump,qqo,33))
 I ","_$$$ObjRef(qqo)_","[(",Xx,") S qqc1=$S(qqo="Xx":qqc,1:Vs(qqnump,"Virt","Xx")),qqref=$NA(@Vo(qqnump,"Xx",33)),Obj="CxWoc",qqt=$G(@qqref@(qqc1,"x70")) Q:qqt="" "" S:"234"[qqt qqc1=qW.GG("Xx","X71",qqc1) I "234"'[qqt Q:$G(qqpar)'="" "" Q:"06"'[$E(qqt) "" S qqc1=qW.GG("Xx","X71",qqc1) Q:$E(qqc1)'="@" "" Q $S($L(qqc1)=1:qW.GetWoc("CxObj",$QS(qqref,5)),1:qW.GetWoc("CxWoc",$E(qqc1,2,30)))
 I ","_$$$ObjRef(qqo)_","'[(",Xx,") S Obj="CxObj",qqc1=$S(qqo="CxObj":qqc,1:Vs(qqnump,"Virt","CxObj")),qqref=$NA(@Vo(qqnump,"CxObj",33))
 I $G(Arg1) Q:Obj="CxObj" qqc1 Q $P(qqref,"CxObj"",",2)_":"_qqc1
 S:qqc1[":" qqc1=$P($P(qqc1,":",2),"{") ;@Dol 22.04.08
 I $G(qqpar)="" Q $G(^Q(1,Obj,qqc1))
 S qqt=$G(^Q(1,Obj,qqc1,qqpar)) Q:qqt="" ""
 I $E(qqpar)="x" S qqt=$G(^Q(1,"C"_qqpar,qqt))
 ;I $E(qqpar,2)="F" S qqt=$S('qqt:"нет",1:"да")
 Q qqt
]]></Implementation>
</Method>

<Method name="GenWoc">
<Description>
создание словарей для понятия qqw и включение их в отображение view.
Объекты Словаря:
100
"w"_qqw
"ww"_qqw (данные -  понятие qqw)

ver=1 - проверка наличия всех "ww"_qqw в отображении view
ver=2 - исправление. Добавление в отображение;; для "ww"_*_"Dic" создание "ww"_*
ver=3 - изьятие из отображения словарей *_"Dic

pref - позволяет создать альтернативный словарь pref_qqw</Description>
<Internal/>
<FormalSpec>qqw:%Library.String,view:%Library.String,ver:%Library.String,pref:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qql S qql=1 S:$G(view)="" view="adm_Voc" S pref=$G(pref) ;@dol 15.02.04 pref
 I view="" Q:$Q "" Q
 I $G(qqw)="",$$$ReFind S qql=$$$Relind_qview ;учет режима уточнения
 G:$G(ver) GenWocVer
 I $G(qqw)'="" D GenWocqqw(qqw,pref) Q:$Q "" Q
 S qqw="" F  S qqw=$O(^Q(qql,"CxWoc",qqw)) Q:qqw=""  D GenWocqqw(qqw,pref)
 Q:$Q "" Q
GenWocqqw(qqw,pref) N qqo,qqc,qqwz,qi,qqci,qqz,y,qqc100,pr
 S pr=$G(pref),pref=$G(pref)_qqw
 S qqc100=$O(^Q(1,100,"")) I qqc100="" S qqc100="B",^Q(1,100,qqc100)=""
 S qqwz=$G(^Q(1,"CxWoc",qqw)) I qqwz="" S qqwz="?Понятие_"_qqw,^Q(1,"CxWoc",qqw)=qqwz,^Q(1,"xWoc",qqwz)=qqw
 ;создадим объекты
 F qi="w","ww" S qqo=qi_pref D  ;qqw D
 .D:'$D(^Q(1,"CxObj",qqo))
 ..S ^Q(1,"CxObj",qqo)=qi_pr_qqwz,^Q(1,"xObj",qi_pr_qqwz)=qqo
 ..S ^Q(1,"CxObj",qqo,"X50")=$S(qi="w":2,1:5)
 ..I qi="w" S ^Q(1,"CxObj",qqo,"X520")=1,^Q(1,"CxObj",qqo,"xObj")="w"_qqo,^Q(1,"CxObj",100,"xObj")=$S($G(^Q(1,"CxObj",100,"xObj"))="":"",1:^("xObj")_" ")_qqo ;@dol 13.02.04 - исправим и схему (xObj - потомки)
 ..I qi="ww" S ^Q(1,"CxObj",qqo,"xWoc")=qqw,^Q(1,"CxObj",qqo,"X522")=qqw
 .;создадим экземпляры
 .I qi="w" S ^Q(1,qqo)=1,^Q(1,qqo,qqc100_"A")="",^Q(1,qqo,qqc100_"A","Xch")=1 Q  ;@dol 24.08.03 Xch
 .I $D(^Q(1,qqo)) D qW.rDelAll(qqo) ;удаление текущего словаря
 .S qqz="" F qqci=0:1 S qqz=$O(^Q(1,"C"_qqw,qqz)) Q:qqz=""  S W(qqw)=^(qqz) S qqc=$P(qW.rNew(qqo,qqc100_"A")," ") D qW.rCor(qqo,qqc,qqw)
 .S ^Q(1,qqo)=qqci
 ;отображение
GenWocV Q:$D(^Q(1,"XView",view,"CxObj","ww"_pref))  ;уже есть
 I '$D(^Q(1,"XView",view,"CxObj",100)) D   ;@dol 21.06.03
 .S ^Q(1,"XView",view,"CxObj",-1,"Xy",1,"X60")=100
 .S ^Q(1,"XView",view,"CxObj",100,"Xy",0,"Xx",0,"x70")=0,^("X71")="@"
 S y=$O(^Q(1,"XView",view,"CxObj",100,"Xy",""),-1)+1
 S ^Q(1,"XView",view,"CxObj",100,"Xy",y,"X60")="w"_pref
 S ^Q(1,"XView",view,"CxObj",100,"xObj")=$S($G(^Q(1,"XView",view,"CxObj",100,"xObj"))="":"",1:^("xObj")_" ")_"w"_pref ;@dol 9.07.04
 S ^Q(1,"XView",view,"CxObj","w"_pref,"xObj")=$S($G(^Q(1,"XView",view,"CxObj","w"_pref,"xObj"))="":"",1:^("xObj")_" ")_"ww"_pref ;@dol 9.07.04
 S ^Q(1,"XView",view,"CxObj","w"_pref,"Xy",0,"Xx",0,"x70")=0,^("X71")="@"
 S ^Q(1,"XView",view,"CxObj","w"_pref,"Xy",1,"Xx",0,"x70")=4,^("X71")="Xch",^("X72")=",2"
 S ^Q(1,"XView",view,"CxObj","w"_pref,"Xy",1,"Xx",1,"x70")=0,^("X71")="@Xch"
 S ^Q(1,"XView",view,"CxObj","w"_pref,"Xy",2,"X60")="ww"_pref
 S ^Q(1,"XView",view,"CxObj","ww"_pref,"Xy",0,"Xx",0,"x70")=2,^("X71")=qqw,^("X741")=1,^("x742")=1
 S ^("X731")=0,^("x730")=1,^("X73")=qqw,^("X740")=1,^("X74")="""""",^("X75")="@"""""
 Q
GenWocView(qqw) S pref=$G(pref)_qqw G GenWocV
GenWocVer ;проверка
 N qerr,qqw,qqwd,qqc100 S qqc100=$O(^Q(1,100,"")) I qqc100="" S qqc100="B",^Q(1,100,qqc100)=""
 S qerr="",qqw="ww" F  S qqw=$O(^Q(qql,"CxObj",qqw)) Q:$E(qqw,1,2)'="ww"  D
 .I '$D(^Q(qql,"CxObj",$E(qqw,2,255))) S qerr=qerr_" ??"_$E(qqw,2,255) Q  ;нет вершины
 .I '$D(^Q(1,"XView",view,"CxObj",qqw)),'$D(^Q(1,"XView","adm_vocH","CxObj",qqw)) S qerr=qerr_" ?"_view_"-"_qqw D:$G(ver)=2  ;нет в отображении
 ..I $ZCVT(qqw,"U")'?1.E1"DIC" D GenWocView($E(qqw,3,255)) S qerr=qerr_" добавлен"
 .;I '$D(^Q(qql,"CxWoc",$E(qqw,3,255))) S qerr=qerr_" ?"_qqw_"-нет_понятия" Q
 .I $D(^Q(1,qqw))<10 S qerr=qerr_" ?"_qqw_"-пуст"
 .I $ZCVT(qqw,"U")?1.E1"DIC" D
 ..I $D(^Q(qql,"CxObj",$E(qqw,1,$L(qqw)-3))) S qerr=qerr_" ?"_qqw_"="_$E(qqw,1,$L(qqw)-3) I $D(^Q(1,$E(qqw,1,$L(qqw)-3)))>1||($D(^Q(1,qqw))<10) D:ver=3  Q  ;два словаря
 ...;изъятие, если не пуст правильный
 ...N y S y=1 F  S y=$O(^Q(1,"XView",view,"CxObj",100,"Xy",y)) Q:y=""  I ^Q(1,"XView",view,"CxObj",100,"Xy",y,"X60")=$E(qqw,2,255) K ^("X60")
 ...K ^Q(1,"XView",view,"CxObj",qqw),^Q(1,"XView",view,"CxObj",$E(qqw,2,255))
 ...S qerr=qerr_"-изъят из "_view
 ..S qerr=qerr_" ?"_qqw ;*dic
 ..Q:ver=1
 ..S qqwd=$E(qqw,3,$L(qqw)-3) D GenWocqqw(qqwd)
 ..D qW.rDelAll("ww"_qqwd)
 ..N qqc,qqci,qqcn S qqc="" F qqci=0:1 S qqc=$O(^Q(1,qqw,qqc)) Q:qqc=""  D
 ...S W(qqwd)=qW.GG(qqw,$E(qqw,3,255),qqc) S qqcn=$P(qW.rNew("ww"_qqwd,qqc100_"A")," ") D qW.rCor("ww"_qqwd,qqcn,qqwd)
 ..S ^Q(1,qqo)=qqci,qerr=qerr_"-создан ww"_qqwd
 Q:$Q qerr Q
]]></Implementation>
</Method>

<Method name="GenWocXch">
<Description>
Добавление к отображению словарей флага Xch (и установка его в 1)</Description>
<Internal/>
<FormalSpec>view:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qq,y,x
 S qq="" F  S qq=$O(^Q(1,"XView",view,"CxObj",qq)) Q:qq=""  I $E(qq)="w",$E(qq,2)'="w" D
 .S y=$O(^Q(1,"XView",view,"CxObj",qq,"Xy",""),-1)
 .M ^Q(1,"XView",view,"CxObj",qq,"Xy",y+1)=^Q(1,"XView",view,"CxObj",qq,"Xy",y) K ^Q(1,"XView",view,"CxObj",qq,"Xy",y)
 .S ^Q(1,"XView",view,"CxObj",qq,"Xy",y,"Xx",0,"x70")=4,^("X71")="Xch",^("X72")=",2"
 .S ^Q(1,"XView",view,"CxObj",qq,"Xy",y,"Xx",1,"x70")=0,^("X71")="@Xch"
 .S x=$O(^Q(1,qq,"")) I x'="",$O(^Q(1,qq,x))="" S ^Q(1,qq,x,"Xch")=1
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="History">
<Description>
??????????Вроде лишний (попал из mse)</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Arg1)="" D  Q Arg1 ;вызов в качестве обобщения
 .K Vt(qqnump,"History",qqo) S Arg1="",Vt(qqnump,"History",qqo,1)="R,136" ;вариант картинки
 .Q:'W("ZBtred")  N qqwz,qqwc I qqo=186 S qqwz=qW.GE("pAN"),qqwc="pAN" Q:qqwz=""  ;для 186 - название специалиста
 .N qqcc S qqcc=$$HistoryO("",$G(qqwc),$G(qqwz)) Q:qqcc=""
 .I $D(Vt(qqnump,"ZTmpYTnew",qqo)) S Arg1="Есть обновление",Vt(qqnump,"History",qqo)=qqc,Vt(qqnump,"History",qqo,1)="R,238" Q  ; ,qW.zNum(qqo,,153)>1:"Есть история",1:"%")_$S(W("Zadm"):$G(Vt(qqnump,"ZTmpYT",qqo)),1:"")
 .I qqcc'=qqc||($$HistoryO(qqcc,$G(qqwc),$G(qqwz))'="") S Arg1="Есть история",Vt(qqnump,"History",qqo)=qqc,Vt(qqnump,"History",qqo,1)="R,230" Q
 I $G(Arg1)=1 D  Q "" ;действие по возврату
 .N qqcnew,qqcadd S Arg1=Vt(qqnump,"History"),qqcnew=$E(qqc,1,$$$ObjLqqc(Arg1)) Q:qqcnew=Vt(qqnump,"History",Arg1)  ;ничего не изменилось
 .I qARM.GetPar("X5280",,Arg1)'="" D  D qARM.wqqotree(,,qqcnew) Q  ;задействована темпоральная коррекция
 ..S qqcadd=$E(qqc,Vt(qqnump,"ZTmpL")+1,Vo(qqnump,Arg1,0))
 ..K Vt(qqnump,"ZTmpYTnew",Arg1) S Vt(qqnump,"ZTmpYT",Arg1)=qqcadd,$P(Vt(qqnump,"ZTmpYT")," ",2)=1
 .D qW.rCopyTree(Arg1,Vt(qqnump,"History",Arg1),,qqcnew)
 .D qARM.wqqotree()
 ;вызов просмотра и выбора
 N qqoname S qqoname=$TR(qW.GetWoc("CxObj",qqo),"_"," ")
 S Vt(qqnump,"History")=qqo
 S Vo("par",-1)="-"_qqoname
 S Vs("par",5)=qqo,Vo("par",qqo,2)=0,Vo("par",qqo,27)=$S(qqo'=186:1,1:"qW.G(""pAN"")="""_qW.GE("pAN")_""""),Vo("par",qqo,28)=0
 S Vs("par",7)=153,Vo("par",-1,23)="S Vs(qqnump,""CondFind"")=""        ""_$E(qqc,1,7)_"" ""_$E(qqc,1,7)" ;организация фиксации на отсутствующий 153
 S Vo("par",-1,3)=1 ;вершина-главный (чтобы выводились все экземпляры)
 S Vo("par",-1,64)="" ;Обобщение для заголовка ???? нужен вывод дат ???
 S Vo("par",-1,62)=1 ;авторазмеры
 S Vo("par",-1,83)="" ;убрать доп.панель
 S Vo("par",-1,73)=1,Vo("par",-1,72)="1  D qUSER.oHistory(1)" ;действие по возврату     
 D qARM.OpenWindow(,,",,0,11,,1",qqc,,Vo(qqnump))
 Q ""
HistoryO(qqcc,qqw,qqz)
 F  S qqcc=$$$UserOrd(-1,qqo,qqcc,$E(qqc,1,Vt(qqnump,"ZTmpL"))) Q:$G(qqw)=""  Q:qqcc=""  Q:qW.GG(qqo,qqw,qqcc)=qqz
 Q qqcc
]]></Implementation>
</Method>

<Method name="Ind2">
<Description>
Создание вторичного индекса для заданного понятия.</Description>
<Internal/>
<FormalSpec>qqw:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N cqqw,qqz,qqza,I,i K ^Qi(qqw)
 S cqqw="C"_qqw,qqz="" F I=1:1 S qqz=$O(^Q(1,cqqw,qqz)) Q:qqz=""  S qqza=^(qqz) F i=1:1:$L(qqza) S:$I(^Qi(qqw,$E(qqza,i))) ^($E(qqza,i),qqza)=""
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="ListqqoCh">
<Internal/>
<FormalSpec>Arg1:%Library.String,qqx730:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 Q:qorder=0 1 Q:qqc'="" ""
 I $D(qqx730) G ListqqoChe
 N qqx71,qqcc ;@Dol 10/08/06 S qqcc= в следующей строке чтобы можно было показывать объект Xx3 развернутым
 I Vo(qqnump)["CxWoc" S qqcc=$G(Vs(qqnump,"Virt","CxWoc")) S:qqcc="" (Vs(qqnump,"Virt","CxWoc"),qqcc)=$G(W("CxWoc"),qqcc0) S qqx730=qW.GG("CxWoc","Cx730",qqcc) I qqx730="" I "234"[$G(^Q(1,"CxWoc",qqcc,"x70")) S qqx71=qW.GG("CxWoc","X71",qqcc) I qqx71'="" S qqx730=$G(^Q(1,"CxWoc",qqx71,"x730"))
 I Vo(qqnump)="XXXXNView"||(Vo(qqnump)="XXXXNV") S qqx730=qW.GG("Xx","Cx730",Vs(qqnump,"Virt","Xx")) I qqx730="" I "234"[$G(@Vo(qqnump,"Xx",33)@(Vs(qqnump,"Virt","Xx"),"x70")) S qqx71=qW.GG("Xx","X71",Vs(qqnump,"Virt","Xx")) I qqx71'="" S qqx730=$G(^Q(1,"CxWoc",qqx71,"x730"))
ListqqoChe I Arg1=2 Q:qqx730="" "X73"
 I Arg1=2 Q:" 4 7 8 9 10 11 "[(" "_qqx730_" ") "X73"
 I Arg1=1 Q:" 0 1 2 5 12 21 "[(" "_qqx730_" ") "X73"
 I Arg1=3 Q:qqx730=6 "X73"
 Q ""
 ;qW.GG("Xx","Cx730",Vs(qqnump,"Virt","Xx"))=""&(qqc=""):"X73"
]]></Implementation>
</Method>

<Method name="LoadFile">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 n file,glreq,glref,val,ndlen,cgn,cnt,bf
 ;------------------------
 r "FileName: ",file,!
 s glreq=511,glref="^QRes"
 ;r "GlobalName: ",glref,!
 r "GlobalNodeLength: ",ndlen,!
 ;------------------------
 s cgn=$TR(file,"QWERTYUIOPASDFGHJKLZXCVBNMЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ","qwertyuiopasdfghjklzxcvbnmйцукенгшщзхъфывапролджэячсмитьбю"),cnt=0 k @glref@(cgn)
 o file:("RU"):7 if '$T w !,"The file named "_file_" have not been opened" Q:$Q "" Q
 u file:0
 f  r bf#glreq  d GloSave i $L(bf)<glreq q
 c file
 ; w val
 Q:$Q "" Q
GloSave 
 i $L(bf)>0 d  q
 .n mk,val,t,v,l s v=$G(@glref@(cgn,cnt)),t=$L(v)+1,mk=1,qt=0
 .f  s val=$E(bf,mk,mk+ndlen-t),l=$L(val) s:l @glref@(cgn,cnt)=v_val q:l<(ndlen-t+1)  s cnt=cnt+1,mk=mk+ndlen-t+1,t=1,v=""
 q
]]></Implementation>
</Method>

<Method name="LoadMas">
<Internal/>
<FormalSpec>qqpar1:%Library.String,glref:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n file,glreq,val,ndlen,cgn,cnt,bf,i
 S qqpar1=$G(qqpar1)
 s glreq=511,glref=$S($G(glref)="":"^QRes",1:glref),ndlen=32000
 ;M AAA=qARM("qpars")
 F i=0:1:0 s file=$G(qARM("qpars",i)) Q:file=""  S cgn=$TR(file,"QWERTYUIOPASDFGHJKLZXCVBNMЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ","qwertyuiopasdfghjklzxcvbnmйцукенгшщзхъфывапролджэячсмитьбю") S:qqpar1'="" cgn=qqpar1 D
 .S cnt=0 k @glref
 .o file:("RU"):2 if '$T D qARM.Message(file_" нет") q
 .u file ;:0
 .f  r bf#glreq  d  i $L(bf)<glreq q
 ..i $L(bf)>0 d  q
 ...n mk,val,t,v,l s v=$G(@glref@(cnt)),t=$L(v)+1,mk=1,qt=0
 ...f  s val=$E(bf,mk,mk+ndlen-t),l=$L(val) s:l @glref@(cnt)=v_val q:l<(ndlen-t+1)  s cnt=cnt+1,mk=mk+ndlen-t+1,t=1,v=""
 .c file
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="LoadQRes">
<Description>
Для использования в действии (Arg1) метода qARM.OpenWinDialog
Загружает в ^QRes выбранные файлы.
qqpar1 - имя ссылки в ^QRes. Если не задан - имя файла.
glref - ссылка на массив (по умолчанию -  ^QRes )</Description>
<Internal/>
<FormalSpec>qqpar1:%Library.String,glref:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n file,glreq,val,ndlen,cgn,cnt,bf,i
 S qqpar1=$G(qqpar1)
 s glreq=511,glref=$S($G(glref)="":"^QRes",1:glref),ndlen=32000
 ;M AAA=qARM("qpars")
 F i=0:1 s file=$G(qARM("qpars",i)) Q:file=""  S cgn=$TR(file,"QWERTYUIOPASDFGHJKLZXCVBNMЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ","qwertyuiopasdfghjklzxcvbnmйцукенгшщзхъфывапролджэячсмитьбю") S:qqpar1'="" cgn=qqpar1 D
 .S cnt=0 k @glref@(cgn)
 .o file:("RU"):2 if '$T D qARM.Message(file_" нет") q
 .u file ;:0
 .f  r bf#glreq  d  i $L(bf)<glreq q
 ..i $L(bf)>0 d  q
 ...n mk,val,t,v,l s v=$G(@glref@(cgn,cnt)),t=$L(v)+1,mk=1,qt=0
 ...f  s val=$E(bf,mk,mk+ndlen-t),l=$L(val) s:l @glref@(cgn,cnt)=v_val q:l<(ndlen-t+1)  s cnt=cnt+1,mk=mk+ndlen-t+1,t=1,v=""
 .c file
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Local">
<Description>
Создание словаря локализации</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
    n gl s gl=$na(^Q(1,"CxLocal"))
    
    ;Сохраняем введенные значения
    k ^mtempLoc m ^mtempLoc=@gl
    
    k @gl
    
    ;Обход отображений
    n win,obj,Xy,Xx,X71
    s win=""
    f  {
        s win=$o(^Q(1,"XView",win))
        q:win=""
        ;Обход объектов в отображении
        s obj=""
        f  {
            s obj=$o(^Q(1,"XView",win,"CxObj",obj))
            q:obj=""
            ;Обходим ячейки
            s Xy=""
            f  {
                s Xy=$o(^Q(1,"XView",win,"CxObj",obj,"Xy",Xy))
                q:Xy=""
                s Xx=""
                f  {
                    s Xx=$o(^Q(1,"XView",win,"CxObj",obj,"Xy",Xy,"Xx",Xx))
                    q:Xx=""
                    ;Тип ячейки - константа
                    i $g(^Q(1,"XView",win,"CxObj",obj,"Xy",Xy,"Xx",Xx,"x70"))=0 {
                        s X71=$g(^Q(1,"XView",win,"CxObj",obj,"Xy",Xy,"Xx",Xx,"X71"))
                        ;Если наименование понятия
                        i $e(X71)="@" {
                            ;s X71=$S(1!'$G(W("Zadm")):"",$L(X71)=2:obj_" ",1:$E(X71,3,2000)_" ")_$TR($S($L(X71)=2:qARM.GetName(,obj),1:qARM.GetName(,obj,$E(X71,3,2000))),"%")
                            ;s:$e(X71,2,$l(X71))'="" X71=$g(^Q(1,"CxWoc",$e(X71,2,$l(X71))))
                            s:$e(X71,2,$l(X71))'="" X71=$tr($tr($g(^Q(1,"CxWoc",$e(X71,2,$l(X71)))),"%"),"_"," ")
                        }
                        ;Запись в массив значений
                        i (X71'="")&(X71'?.N) s:'$d(@gl@(X71)) @gl=$i(@gl) s @gl@(X71)="" m @gl@(X71)=^mtempLoc(X71)
                    }
                }
            }
            
        }   
    }
    
    
    d qARM.wcre()
    q
]]></Implementation>
</Method>

<Method name="MenuObj">
<Description>
             Меню редактирования дерева объектов отображения.</Description>
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$D(qwin(qwin,"PO")) D  Q:$Q "" Q  ;D qARM.wP(qwin_".PO","AutoPopup",Arg1) Q
 .;d qARM.wC("TqPopupMenu",qwin_".PO",qwin_".T1")
 .d qARM.wC("TPopupMenu",qwin_".PO")
 .S qwin(qwin,"PO")=1
 .D qARM.wcrm("PO90",0,"Свойства")
 .D qARM.wcrm("PO970",0,"-","",0)
 .D qARM.wcrm("PO91",0,"Вставить","",0)
 .D qARM.wcrm("91_1",0,"Строку")
 .D qARM.wcrm("91_2",0,"Ячейку")
 .D qARM.wcrm("91_5",0,"Колонку")
 .D qARM.wcrm("91_3",0,"Объект текущего уровня","",0)
 .;
 .D qARM.wcrm("91_3_1",0,"Объект")
 .D qARM.wcrm("91_3_2",0,"Объект+Понятия(таблица)")
 .D qARM.wcrm("91_3_3",0,"Объект+Понятия(бланк)")
 .D qARM.wcrm("91_3_4",0,"Поддерево+Понятия(таблица)")
 .D qARM.wcrm("91_3_5",0,"Поддерево+Понятия(бланк)")
 .;
 .D qARM.wcrm("91_4",0,"Объект нижнего уровня","",0)
 .;
 .D qARM.wcrm("91_4_1",0,"Объект")
 .D qARM.wcrm("91_4_2",0,"Объект+Понятия(таблица)")
 .D qARM.wcrm("91_4_3",0,"Объект+Понятия(бланк)")
 .D qARM.wcrm("91_4_4",0,"Поддерево+Понятия(таблица)")
 .D qARM.wcrm("91_4_5",0,"Поддерево+Понятия(бланк)")
 .;
 .D qARM.wcrm("PO92",0,"Удалить","",0)
 .D qARM.wcrm("92_1",0,"Строку")
 .D qARM.wcrm("92_2",0,"Ячейку")
 .D qARM.wcrm("92_5",0,"Колонку")
 .D qARM.wcrm("92_3",0,"Объект(с подобъектами)")
 .D qARM.wcrm("PO96",0,"Копировать","",0)
 .D qARM.wcrm("96_1",0,"Объект")
 .D qARM.wcrm("96_2",0,"Поддерево")
 .D qARM.wcrm("96_3",0,"Отображение")
 .D qARM.wcrm("96_4",0,"Ячейку") //sasha 20080717
 .D qARM.wcrm("PO93",0,"Отображение","",0)
 .D qARM.wcrm("93_1",0,"Сохранить в буфер")
 .D qARM.wcrm("93_2",0,"Восстановить из буфера")
 .D qARM.wcrm("93_3",0,"Печатать","",0)
 .D qARM.wcrm("93_3_1",0,"Структуру")
 .D qARM.wcrm("93_3_2",0,"Полное дерево")
 .D qARM.wcrm("PO94",0,"Перетаскивать","",0)
 .S Vt(qqnump,"Zmenu94")=1
 .D qARM.wcrm("94_1",0,"Перетаскивать ячейку",",1")
 .D qARM.wcrm("94_2",0,"Копировать параметры")
 .D qARM.wcrm("94_3",0,"Копировать ячейку")
 .D qARM.wcrm("PO971",0,"-","",0)
 .D qARM.wcrm("PO95",0,"Описания","",0)
 .D qARM.wcrm("95_1",0,"Отображения")
 .D qARM.wcrm("95_2",0,"Объекты")
 .D qARM.wcrm("95_3",0,"Понятия")
 .D qARM.wcrm("PO98",0,"Действия","",0)
 .D qARM.wcrm("98_1",0,"Выполнить")
 .D qARM.wcrm("98_2",0,"Заменить")
 .D qARM.wcrm("98_3",0,"Увеличить","",0)
 .D qARM.wcrm("98_3_1",0,"*1",","_($G(W("Zoom"),1)=1))
 .D qARM.wcrm("98_3_2",0,"*2",","_($G(W("Zoom"),1)=2))
 .D qARM.wcrm("98_3_4",0,"*4",","_($G(W("Zoom"),1)=4))
 .D qARM.wcrm("98_4",0,"Создать Заголовок")
 .D qARM.wcrm("98_5",0,"Создать колонки")
 .D qARM.wcrm("98_6",0,"Переход на объект")
 .D qARM.wcrm("PO972",0,"-","",0)
 .D qARM.wcrm("PO99",0,"?")
 ;меню существует
 S Vt(qqnump,"Zmenu94")=1
 D qARM.wcrm("94_1",1,"",",1")
 D qARM.wcrm("94_2",1,"",",0")
 D qARM.wcrm("94_3",1,"",",0")
 D qARM.wcrm("98_3_1",1,"*1",","_($G(W("Zoom"),1)=1))
 D qARM.wcrm("98_3_2",1,"*2",","_($G(W("Zoom"),1)=2))
 D qARM.wcrm("98_3_4",1,"*4",","_($G(W("Zoom"),1)=4))
 Q:$Q "" Q  ;97,94
]]></Implementation>
</Method>

<Method name="MenuServ">
<Description>
               Меню сервиса в режиме Администратора.</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$D(qwin(qwin,"Adm")),$G(W("Zsform"))#10'=1 D
 .S qwin(qwin,"Adm")=""
 .D qARM.wcrm("P667",0,"Выполнить")
 .D qARM.wcrm("P662",0,"Состояние отображения","",0)
 .D qARM.wcrm("62_1",0,"Просмотр")
 .D qARM.wcrm("62_2",0,"Сохранение")
 .D qARM.wcrm("62_3",0,"Восстановление")
 .D qARM.wcrm("62_4",0,"Сохранение Меню")
 .D qARM.wcrm("62_5",0,"Сохранение размеров окна"_$C(9)_"Ctrl+W")
 .D qARM.wcrm("62_6",0,"Сохранение размеров граф дерева объектов")
 .D qARM.wcrm("62_7",0,"Сохранение размеров граф дерева зкземпляров")
 .;
 .D qARM.wcrm("P660",0,"-","",0)
 .;
 .D qARM.wcrm("P661",0,"Импорт/Экспорт (массив^QS(1))","",0)
 .D qARM.wcrm("61_1",0,"Сохранить","",0)
 .D qARM.wcrm("61_1_1",0,"Текущее поддерево")
 .D qARM.wcrm("61_1_2",0,"Поддеревья релевантных")
 .D qARM.wcrm("61_1_3",0,"Отображение (с учетом релевантных)")
 .D qARM.wcrm("61_2",0,"Восстановить","",0)
 .D qARM.wcrm("61_2_1",0,"без включения в релевантные")
 .D qARM.wcrm("61_2_2",0,"c включением в релевантные")
 .;D qARM.wcrm("61_5",0,"Восстановить (старый вариант с ""O"")")
 .D qARM.wcrm("61_3",0,"Просмотреть")
 .D qARM.wcrm("61_4",0,"Удалить",$D(^QS(1))>1)
 .;@Sveta 5.04.04
 .D qARM.wcrm("61_5",0,"Сохранить в файл","",0)
 .D qARM.wcrm("61_5_1",0,"Текущее поддерево")
 .D qARM.wcrm("61_5_2",0,"Поддеревья релевантных")
 .D qARM.wcrm("61_5_3",0,"Отображение (с учетом релевантных)")
 .D qARM.wcrm("61_6",0,"Восстановить из файла","",0)
 .D qARM.wcrm("61_6_1",0,"без включения в релевантные")
 .D qARM.wcrm("61_6_2",0,"c включением в релевантные")
 .D qARM.wcrm("61_7",0,"Сохранить в файл (GM виртуальный поток)",,0) ;quser="Dol",0)
 .D qARM.wcrm("61_7_1",0,"Текущее поддерево (GM)")
 .D qARM.wcrm("61_7_2",0,"Поддеревья релевантных (GM)")
 .D qARM.wcrm("61_7_3",0,"Отображение (с учетом релевантных) (GM)")
 .D qARM.wcrm("61_8",0,"Восстановить из файла (GM виртуальный поток)") ;quser="Dol")

 .;
 .D qARM.wcrm("P671",0,"Импорт/Экспорт (XML-файл)","",0)
 .D qARM.wcrm("71_1",0,"Сохранить")
 .;D qARM.wcrm("71_1_1",0,"Текущее поддерево")
 .;D qARM.wcrm("71_1_2",0,"Поддеревья релевантных")
 .;D qARM.wcrm("71_3",0,"Всю базу")
 .D qARM.wcrm("71_2",0,"Восстановить","",0)
 .D qARM.wcrm("71_2_1",0,"без включения в релевантные")
 .D qARM.wcrm("71_2_2",0,"c включением в релевантные")
 .;
 .D qARM.wcrm("P664",0,"-","",0)
 .D qARM.wcrm("P663",0,"Удалить перечень релевантных")
 .;D qARM.wcrm("P663",0,"Размер буфера обмена","",0)
 .;D qARM.wcrm("63_1",0,"1000",","_(length=1000))
 .;D qARM.wcrm("63_2",0,"2000",","_(length=2000))
 .;D qARM.wcrm("63_5",0,"5000",","_(length=5000))
 .;D qARM.wcrm("63_10",0,"10000",","_(length=10000))
 .;D qARM.wcrm("63_20",0,"20000",","_(length=20000))
 .;D qARM.wcrm("63_30",0,"30000",","_(length=30000))
 .D qARM.wcrm("P665",0,"Пересчитать кол-во экземпляров текущего объекта")
 .D qARM.wcrm("P669",0,"Преобразовать","",0)
 .D qARM.wcrm("69_1",0,"текущий объект")
 .D qARM.wcrm("69_2",0,"все объекты отображения")
 .D qARM.wcrm("69_3",0,"все объекты отображения последовательно")
 .D qARM.wcrm("P666",0,"Загрузить картинки")
 .D qARM.wcrm("P668",0,"Коррекция Создание Слежение")
 .;D qARM.wcrm("P672",0,"Тестирование нового варианта поиска",","_(''$g(OlegFind)))
 .D qARM.wcrm("P672",0,"Выводить ошибки в обобщениях",","_(''$g(qqGERROR))) ;@Dol 24.08.09
 .D qARM.wcrm("P670",0,"?")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="NoqW">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqwlst,qqwlsts,qqw,qqwi,atr,lst1,lst2,lst3
 S lst1="",lst2=""
 S qqwlsts=qW.G("XSQLatrlst")
 S qqwlst=$TR($P($P($G(^Q(1,"CxObj",qqc,"X529")),":",2),";"),","," ") ;а если несколько???
 S qqwlst=$G(^Q(1,"CxObj",qqc,"xWoc"))_" "_qqwlst
 F qqwi=1:1:$L(qqwlst," ") s qqw=$P(qqwlst," ",qqwi) D:qqw'=""
 .S atr=$P($G(^Q(1,"CxWoc",qqw,"X753"))," ")
 .I " "_qqwlsts_" "[(" "_atr_" ") S lst1=lst1_" "_atr Q
 .S lst2=lst2_" "_atr Q
 S lst3=""
 F qqwi=1:1:$L(qqwlsts," ") s atr=$P(qqwlsts," ",qqwi) D:atr'=""
 .I " "_lst1_" "'[(" "_atr_" ") S lst3=lst3_" "_atr
 Q $S(lst2'="":"Лишние:"_lst2,1:"")_$S(lst3'="":" Отсутствуют:"_lst3,1:"")
]]></Implementation>
</Method>

<Method name="ObjLqqc">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 K ^Qerr S o=-1 F  S o=$O(^Q1(1,"CxObj",o)) Q:o=""  Q:o'?1.n   D
 .S l=$G(^(o,"X50"))
 .S l1=$L($O(^Q(1,o,""),-1))
 .S l2=$S(l<3:l,l=5:7,1:l-5\3*2+7)
 .I l1'=l2 S ^Qerr($I(^Qerr))="o="_o_" длина старя/новая "_l_"/"_l2_" ("_l1_"/"_$L($O(^Q1(1,o,""),-1))
 .;S ^Q(1,"CxObj",o,"X50")=$S(l1:l1,1:l2)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="ObjNqARM">
<Description>
Возвращает 1 если объект qqo НЕ содержится в списке (через пробел) qARM("Pars",Arg1)
Для использования в выражении Модификация (Xmod) описания объекта отображения.
Позволяет не включать заданные объекты (и их потомков) при загрузке отображения.</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ Q:'$G(Arg1) 1 Q " "_$G(qARM("Pars",Arg1))_" "'[(" "_qqo_" ")
]]></Implementation>
</Method>

<Method name="ObjShift">
<Description>
Сдвиг экземляров (или замена, если ch=1).
Arg1 - добовляемый/замещаемый в начало фрагмент кода.
Arg2 - текущаядлина кода
Arg3 - позиция, c которой будет вставлен Arg1 

При модификации длины, изменяется и длина кода экземпляра в описании объекта (и всех синонимов v*qqo)</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,Arg1:%Library.String,Arg2:%Library.String,ch:%Library.String=0,Arg3:%Library.String=1</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqc,qqw,qqz,qqzi,qqzz,qqzzz,qqcnew,qqwv
 S:$G(Arg2)="" Arg2=^Q(1,"CxObj",qqo,"X50") ;длина кода экземпляра
 S qqc="" F  S qqc=$O(^Q(1,qqo,qqc)) Q:qqc=""  D:$S('ch:$L(qqc)=Arg2,1:$E(qqc,Arg3,Arg3+$L(Arg1)-1)'=Arg1)
 .;S qqcnew=$S('ch:Arg1_qqc,1:Arg1_$E(qqc,$L(Arg1)+1,255))
 .S qqcnew=qqc D  ;@dol 27.06.04
 ..I ch S $E(qqcnew,Arg3,Arg3+$L(Arg1)-1)=Arg1 Q
 ..S $E(qqcnew,Arg3)=Arg1_$E(qqc,Arg3)
 .S qqw="" F  S qqw=$O(^Q(1,qqo,qqc,qqw)) Q:qqw=""  I "xXLTYM"'[$E(qqw),'qW.rWocx711(qqw,qqo) D  ;@Dol 13.10.07 'qW.rWocx711(qqw,qqo)
 ..S qqz=^Q(1,qqo,qqc,qqw) F qqzi=1:1:$L(qqz," ") S qqzz=$P(qqz," ",qqzi) D:qqzz'=""
 ...I $E(qqw)="D" K ^Q(1,qqw,qqzz,qqo,qqc) S ^Q(1,qqw,qqzz,qqo,qqcnew)=qqzi-1 Q
 ...I $E(qqw)="R" S qqwv=$E(qqw,3,255) S qqzzz=$G(^Q(1,"C"_qqwv,qqzz)) Q:qqzzz=""  K ^Q(1,qqwv,qqzzz,qqo,qqc,$E(qqw,2)) S ^Q(1,qqwv,qqzzz,qqo,qqcnew,$E(qqw,2))=$S(qqzi=1:"",1:qqzi-1) Q  ;@Dol 31.10.06
 ...S qqzzz=^Q(1,"C"_qqw,qqzz) K ^Q(1,qqw,qqzzz,qqo,qqc) S ^Q(1,qqw,qqzzz,qqo,qqcnew)=$S(qqzi=1:"",1:qqzi-1)
 .M ^Q(1,qqo,qqcnew)=^Q(1,qqo,qqc) K ^Q(1,qqo,qqc)
 S:'ch Arg2=Arg2+$L(Arg1)
 I Arg2'=^Q(1,"CxObj",qqo,"X50") S ^Q(1,"CxObj",qqo,"X50")=Arg2 D  ;;@dol 27.06.04 Синонимы
 .S Arg1="v" F  S Arg1=$O(^Q(1,"CxObj",Arg1)) Q:$E(Arg1)'="v"  S:$E(Arg1,3,255)=qqo ^Q(1,"CxObj",Arg1,"X50")=Arg2
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="PQ">
<Description>
Синтаксически чистая расшифровка списка диалоговых условий запроса XQcond.
Arg1 - списоки (через пробел или $C(13,10) ; параметры - через запятую)
Arg2 - номер списка параметров (если "") - кол-во
Arg3 - номер параметра .Если не задан, возврат списка. Если "" - кол-во параметров в списке.</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 Q:$G(Arg2)="" $S(Arg1[$C(13,10):$L(Arg1,$C(13,10)),1:..PSYN(Arg1," "))
 S Arg1=$S(Arg1[$C(13,10):$P(Arg1,$C(13,10),Arg2),1:..PSYN(Arg1," ",Arg2))
 Q:'$D(Arg3) Arg1 Q ..PSYN(Arg1,",",Arg3,,,1)
]]></Implementation>
</Method>

<Method name="PSYN">
<Description>
Синтаксически чистая функция $Piece относительно Arg5 (по умолчанию - ").
Если Arg3 не задан - синтаксически чистый аналог $L(Arg1,Arg2).
если Arg6=1 и возвращаемое значение получилось в кавычках, они убираются</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String,Arg4:%Library.String,Arg5:%Library.String,Arg6:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 N Arg2i,Ii S:$G(Arg5)="" Arg5=""""
 S Arg2i="" F Ii=1:1:$L(Arg2) S $E(Arg2i,Ii)=$C(Ii) ;замещающий разделитель
 S Ii=1 F  S Ii=$F(Arg1,Arg2,Ii) Q:'Ii  S:$L($E(Arg1,1,Ii-$L(Arg2)-1),Arg5)#2 $E(Arg1,Ii-$L(Arg2),Ii-1)=Arg2i ;замена синтаксически чистых ра
 Q:$G(Arg3)="" $L(Arg1,Arg2i) ;подсчет фрагментов (аналог $L)
 S:$G(Arg4)="" Arg4=Arg3 S Arg1=$TR($P(Arg1,Arg2i,Arg3,Arg4),Arg2i,Arg2) I $G(Arg6),$E(Arg1)="""",$E(Arg1,$L(Arg1))="""" S @("Arg1="_Arg1)
 Q Arg1
]]></Implementation>
</Method>

<Method name="PutXMLfile">
<Description>
??????? есть в qWEB ?????????</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 ;SampleX3         ; образец 3
 n file,files,qqpa
 S qqpa=$P(Vt(qqnump,"Zparent")," ",2) ;qqnump отображения вывода
 S file=qW.G("XRes") Q:file="" "Не задан файл"
 S files=+qW.G("CxRes") ;файл на сервере?
 n T,D,P,Tw,Sw,S,Dw,Rw,temp
 ;s T=1,T(1)="^Q(1,""1"",""B"")"
 s D="^Q(1)" ;"^Q(1,""XView"",""###a"")"  ; 
 I qW.G("XFView") s S=2,S(1)="^Q(1,""XView"","""_Vo(qqpa)_""")",S(2)="^Q(1)" I 1
 E  s S=1,S(1)="^Q(1)"

 s P("TreeT")=0 ; 0/1 - лог./физ. дерево
 D  ;вывод на сервер или клиент
 .I files S P("TargT")=2,P("TargN")=file Q  ;файл на сервере
 .K $$$tmpGl(1,$J) S P("TargT")=0,P("TargN")=$na($$$tmpGl(1,$J)) Q  ;файл на клиенте (передадим после формирования в массиве) ; 15.12.2008 Kokarev
 s P("Title")="<?xml version='1.0' encoding='windows-1251'?>" ; пролог XML-документа
 s P("EndDoc")="" ; то, что надо вписать после вывода узлов
 D  ;вариант вывода
 .N var S var=+qW.G("CxExp")
 .;s P("Coll")=0 ; 0/1 - один узел/коллекция узлов
 .;s P("qqoRoot")="1" ; для одного узла и коллекции - qqo корневого элемента
 .;s P("qqcRoot")="B" ; для одного узла - qqc корневого элемента
 .;??s P("qqcBegin")="" ; для коллекции - первый узел (НЕ включительно)
 .;??s P("qqcEnd")="" ; для коллекции - последний узел (включительно)
 .I 'var S P("Coll")=0,P("qqoRoot")=qW.G("CxObj"),P("qqcRoot")=qW.G("XID"),T=1,T(1)="^Q(1,"""_P("qqoRoot")_""","""_P("qqcRoot")_""")" Q  ;поддерево текущего экземпляра
 .I var=1 D  Q
 ..S P("Coll")=1,P("qqoRoot")=qW.G("CxObj")
 ..S a=Vs(qqpa,"Relind")_Vo(qqpa)_$S(quser="#":"",quser="U":" "_$J,1:" "_quser)
 ..s P("qqcRoot")="",P("qqcBegin")="",P("qqcEnd")="яяя"
 ..S T=2,T(1)="^Q("""_a_""","""_P("qqoRoot")_""")",T(2)="^Q(1,"""_P("qqoRoot")_""")"
 s P("Pos")=0 ; 0/1 - несч./считать qqc позиц.кодом и по нему сортировать
 s P("CodeN")=+qW.G("Cxqqoqqw") ; 0/1 - выводить имена/их коды
 s P("CodeV")=0 ; 0/1 - выводить значения/их коды
 s P("GetC")=+qW.G("XFqqc") ;1 ; 0/1-невыводить/выводить коды узлов qqc
 s P("GetCC")=0 ; 0/1 - невыводить/выводить не пустые значения об. узлов
 s P("Format")=1 ; 0/1 - выводить атрибуты в строку/столбец
 s P("DirCh")=0 ; 0/1 - нет/да-список дочерних не искать в опис., а составлять
 s P("Error")=0 ; запись ошибок
 s P("ListNS")="@ qq" ; список префиксов тех NS, которые д.б.декларированы в корне
 s P("GetDTD")=0 ; 0/1-нет/да подать DTD, включающее компоненты и нотации
 s P("ListEnt")="" ; список компонент, которые д.б.декларированы в DTD
 s P("ListNot")="" ; список нотаций, которые д.б.декларированы в DTD
 s P("AttAsElem")=0 ; 0/1-нет/да выводить атрибуты как элементы

 ;s temp=$ZU(140,5,P("TargN")) ;уничтожение файла
 ;s T=1,T(1)="^QJJ(1,""*1"",""AAB"")"
 ;s D="^QJJ(3)"  ; ==добавлено
 ;s S=1,S(1)="^QJJ(2)"

 ;s P("TreeT")=0 ; 0/1 - лог./физ. дерево
 ;s P("Coll")=0 ; 0/1 - один узел/коллекция узлов
 ;s P("TargT")=2 ; 0/1/2 - вывод результата в: перменная/текущ.устр./файл
 ;s P("TargN")="d:\test0.xml" ; имя файла или переменной
 ;s P("Title")="<?xml version='1.0' encoding='windows-1251'?>" ; пролог XML-документа
 ;s P("EndDoc")="" ; то, что надо вписать после вывода узлов
 ;s P("qqoRoot")="*1" ; для одного узла и коллекции - qqo корневого элемента
 ;s P("qqcRoot")="AAB" ; для одного узла - qqc корневого элемента
 ;s P("qqcBegin")="" ; для коллекции - первый узел (НЕ включительно)
 ;s P("qqcEnd")="" ; для коллекции - последний узел (включительно)       
 ;s P("Pos")=0 ; 0/1 - несч./считать qqc позиц.кодом и по нему сортировать
 ;s P("CodeN")=0 ; 0/1 - выводить имена/их коды
 ;s P("CodeV")=0 ; 0/1 - выводить значения/их коды
 ;s P("GetC")=0 ; 0/1-невыводить/выводить коды узлов qqc
 ;s P("GetCC")=0 ; 0/1 - невыводить/выводить не пустые значения об. узлов
 ;s P("DirCh")=0 ; 0/1 - нет/да-список дочерних не искать в опис., а составлять
 ;s P("Format")=1 ; 0/1 - выводить атрибуты в строку/столбец
 ;s P("Error")=0 ; запись ошибок
 ;s P("ListNS")="qq" ; список префиксов тех NS, которые д.б.декларированы в корне
 ;s P("GetDTD")=0 ; 0/1-нет/да подать DTD, включающее компоненты и нотации               
 ;s P("ListEnt")="" ; список компонент, которые д.б.декларированы в DTD
 ;s P("ListNot")="" ; список нотаций, которые д.б.декларированы в DTD


 d qWEB.GetXML(.P,.T,.S,.D)
 ;
 ;k P,T,S,D
 I 'files D qARM.OpenIE(1,file,0) ;передача файла на клиента
 Q file_" сформирован на "_$S(files:"сервере",1:"клиенте")
]]></Implementation>
</Method>

<Method name="QUWoc">
<Description>
Импорт-экспорт словарей с запрещеннной сборкой мусора</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 G:'$G(Arg1) QUWocI
 ;Экспорт
 N qq,qqw,qqc,qqz,i,z K ^QUWoc
 ;понятия
 S qq="" F  S qq=$O(^Q(1,"CxWoc",qq)) Q:qq=""  I "Xx"'[$E(qq),'$G(^(qq,"Xsys")),$G(^("xGrCol"))=2 D
 .M ^QUWoc(1,"C"_qq)=^Q(1,"C"_qq)
 .S ^QUWoc(1,qq)=$G(^Q(1,qq))
 ;объекты справочников
 S qq="" F  S qq=$O(^Q(1,"CxObj",qq)) Q:qq=""  I "Xx"'[$E(qq),'$G(^(qq,"Xsys")),$G(^("Xspr")) D
 .S ^QUWoc(1,qq)=$G(^Q(1,qq))
 .S qqc="" F  S qqc=$O(^Q(1,qq,qqc)) Q:qqc=""  D
 ..M ^QUWoc(1,qq,qqc)=^Q(1,qq,qqc)
 ..S qqw="" F  S qqw=$O(^Q(1,qq,qqc,qqw)) Q:qqw=""  I "MFXTDL"'[$E(qqw) S qqz=^(qqw) S ^QUWoc(1,qqw)=$G(^Q(1,qqw)) F i=1:1:$L(qqz," ") S z=$P(qqz," ",i) I z'="" M ^QUWoc(1,"C"_qqw,z)=^Q(1,"C"_qqw,z)
 S qq=$H,^QUWoc=qq
 Q:$Q "" Q
QUWocI ;Импорт
 I $G(^QUWoc)="" D qARM.Message("Массив ^QUWoc не существует") Q ""
 N qq,qqq,qqc,qqw,qqz,i,z
 ;удаление лишнего???
 ;понятия
 S qq="" F  S qq=$O(^QUWoc(1,qq)) Q:qq=""   D:$E(qq)="C"
 .M ^Q(1,qq)=^QUWoc(1,qq) S qqq="" F  S qqq=$O(^QUWoc(1,qq,qqq)) Q:qqq=""  S ^Q(1,$E(qq,2,255),^QUWoc(1,qq,qqq))=qqq
 ;объекты справочников
 S qq="" F  S qq=$O(^QUWoc(1,qq)) Q:qq=""   D:$E(qq)'="C"
 .S ^Q(1,qq)=^QUWoc(1,qq)
 .S qqc="" F  S qqc=$O(^QUWoc(1,qq,qqc)) Q:qqc=""  D
 ..M ^Q(1,qq,qqc)=^QUWoc(1,qq,qqc) S qqw="" F  S qqw=$O(^QUWoc(1,qq,qqc,qqw)) Q:qqw=""  I "MFXTL"'[$E(qqw) D
 ...S qqz=^(qqw) F i=1:1:$L(qqz," ") S z=$P(qqz," ",i) I z'="",$S($E(qqw)="D":1,1:$G(^Q(1,"C"_qqw,z))'="") S ^Q(1,qqw,$S($E(qqw)="D":z,1:^Q(1,"C"_qqw,z)),qq,qqc)=i-1
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="QUser">
<Description>
Экспорт (Arg1=1)/импорт пользовательских описаний в массив ^QUser.
Arg2=1 - сохранять/восстанавливать описания на usr* или помеченнные флагом Xusr
Arg3=1 - не выгружать пользовательские классы</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%Library.String,Arg3:%Library.String=""</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 S Arg2=+$G(Arg2) G:'$G(Arg1) QUserI ;@dol 3.8.03 добавлен Arg2 и анализ на usr*
 ;Экспорт
 N qq K ^QUser
 ;отображения 
 S qq="" F  S qq=$O(^Q(1,"XView",qq)) Q:qq=""  I $E(qq,1,3)'="XXX",'$G(^(qq,"Xsys")),$S(Arg2:1,$G(^("Xusr")):0,1:$E(qq,1,3)'="usr")  M ^QUser(1,"XView",qq)=^Q(1,"XView",qq)
 ;объекты
 S qq="" F  S qq=$O(^Q(1,"CxObj",qq)) Q:qq=""  I "Xx"'[$E(qq),'$G(^(qq,"Xsys")),$S(Arg2:1,$G(^("Xusr")):0,1:$E(qq,1,3)'="usr") D
 .I $G(^Q(1,"CxObj",qq))="" D qARM.Message("???Объект без имени "_qq) Q  ;испорченный объект
 .M ^QUser(1,"CxObj",qq)=^Q(1,"CxObj",qq)
 .S ^QUser(1,"xObj",^Q(1,"CxObj",qq))=qq
 ;понятия
 S qq="" F  S qq=$O(^Q(1,"CxWoc",qq)) Q:qq=""  I "Xx"'[$E(qq),'$G(^(qq,"Xsys")),$S(Arg2:1,$G(^("Xusr")):0,1:$E(qq,1,3)'="usr") D
 .I $G(^Q(1,"CxWoc",qq))="" D qARM.Message("???Понятие без имени "_qq) Q  ;испорченный понятие
 .M ^QUser(1,"CxWoc",qq)=^Q(1,"CxWoc",qq)
 .S ^QUser(1,"xWoc",^Q(1,"CxWoc",qq))=qq 
 .;I $E(qq)'="X",$E(qq)'="C",qq'="xObj",qq'="xWoc",$E(qq)'="@" M ^QUser("C"_qq)=^Q(1,"C"_qq)
 ;запросы
 S qq="" F  S qq=$O(^Q(1,"XQuery",qq)) Q:qq=""  I $E(qq,1,3)'="XXX",'$G(^(qq,"Xsys")),$S(Arg2:1,$G(^("Xusr")):0,1:$E(qq,1,3)'="usr") D
 .M ^QUser(1,"XQuery",qq)=^Q(1,"XQuery",qq)
 ;база
 F qq="XBColor","XBTempor","XBaseX5280","XBaseX527","XUDoBeg","XUDoEnd","CxObj","XPbut9","XFNewAn","XBDate","XBprwr","XBvers","XBName","XBTempList","XFJUser","XMJRUser","XMJUser","XMCrUser","XMCrUserEND","XBNDes","X155","X150","X151","X152","X177","X1664","X1194","XBp","XBf","XBadd","XBdel","R0x181","R3x181","XBz","XB1720","XBLg","XBpre","XBLastWin","XB2help","XB186","XBPrt2","XBPrt2XXL","XBPrt2NotMIME","XBNoRlf","XBTRAN","XB159","XBRDop","XBMesTime","XBFws","XBwids","XBupdate","xBrefrExprMode","XBrefrExpr","XBAllDlgUpd","XBErrVar","XBErrMet","XBnoFK","XB11990","XBOpenDoc","XBwsize","xBGrSt","XBviorg" D  ;@Dol 03.06.09 ,"XBPrttoOOW" НЕ НАДО
 .M ^QUser(1,"XBase",0,qq)=^Q(1,"XBase",0,qq)
 ;замечания по реализации приложения
 M ^QUser(1,"XDocRNU1")=^Q(1,"XDocRNU1")
 ;Обновления ;@dol 4.12.03
 S qq="" F  S qq=$O(^Q(1,"XUpg",qq)) Q:qq=""  I $E(qq,1,4)'="Xsys" M ^QUser(1,"XUpg",qq)=^Q(1,"XUpg",qq)
 ;Обновления @sasha 20.09.07
 S qq="" F  S qq=$O(^Q(1,"XGM",qq)) Q:qq=""  I $E(qq,1,4)'="Xsys" M ^QUser(1,"XGM",qq)=^Q(1,"XGM",qq)
 ;;Обновления @sasha 20090402
 S qq="" F  S qq=$O(^Q(1,"XGM1",qq)) Q:qq=""  I $E(qq,1,4)'="Xsys" M ^QUser(1,"XGM1",qq)=^Q(1,"XGM1",qq)
 ;Доп классы
 M ^QUser(1,"XUClass")=^Q(1,"XUClass") ;@Dol 20.04.05
 S qq=$H,^QUser=qq ;,^Q(1,"XView","XXXX")=qq ;запишем дату и время
 ;пользовательские классы
 I $g(Arg3)=1 Q:$Q "" Q
 M ^QUser("User.qUSER")=^oddDEF("User.qUSER")
 N class S qq="" F  S qq=$O(^Q(1,"XUClass",qq)) Q:qq=""  S class=$G(^(qq)) M:qq'="qUSER" ^QUser("User."_qq)=^oddDEF("User."_class)  ;@Dol 2.07.05
 I 'Arg2 S qq="" F  S qq=$O(^QUser("User.qUSER","method",qq)) Q:qq=""  K:$E(qq,1,3)="usr" ^QUser("User.qUSER","method",qq)
 Q:$Q "" Q
QUserI ;Импорт
 I $G(^QUser)="" Q "Массив ^QUser не существует"
 ;
 N qqend I $G(^QUser(1,"XBase",0,"XUDoBeg"))'="" X ^QUser(1,"XBase",0,"XUDoBeg") ;Действие перед восстановлением
 I $D(qqend),qqend'=0 Q $S(qqend=1:"НЕ восстановлен",1:qqend)
 ;
 N qq,qqq,error
 ;удаление лишнего???
 ;отображения
 S qq="" F  S qq=$O(^Q(1,"XView",qq)) Q:qq=""  I $E(qq,1,3)'="XXX",'$G(^(qq,"Xsys")),$S(Arg2:1,$G(^("Xusr")):0,1:$E(qq,1,3)'="usr")  K ^Q(1,"XView",qq)
 ;объекты
 S qq="" F  S qq=$O(^Q(1,"CxObj",qq)) Q:qq=""  I "Xx"'[$E(qq),'$G(^(qq,"Xsys")),$S(Arg2:1,$G(^("Xusr")):0,1:$E(qq,1,3)'="usr") D
 .I $G(^Q(1,"CxObj",qq))="" D:0 qARM.Message("???Объект без имени "_qq) K ^Q(1,"CxObj",qq) Q  ;испорченный объект
 .K ^Q(1,"xObj",^Q(1,"CxObj",qq)),^Q(1,"CxObj",qq)
 ;понятия
 S qq="" F  S qq=$O(^Q(1,"CxWoc",qq)) Q:qq=""  I "Xx"'[$E(qq),'$G(^(qq,"Xsys")),$S(Arg2:1,$G(^("Xusr")):0,1:$E(qq,1,3)'="usr") D
 .I $G(^Q(1,"CxWoc",qq))="" D:0 qARM.Message("???Понятие без имени "_qq) K ^Q(1,"CxWoc",qq) Q  ;испорченный понятие
 .K ^Q(1,"xWoc",^Q(1,"CxWoc",qq)),^Q(1,"CxWoc",qq)
 ;запросы
 S qq="" F  S qq=$O(^Q(1,"XQuery",qq)) Q:qq=""  I $E(qq,1,3)'="XXX",'$G(^(qq,"Xsys")),$S(Arg2:1,$G(^("Xusr")):0,1:$E(qq,1,3)'="usr") D
 .K ^Q(1,"XQuery",qq)
 ;зам по реализ. приложения
 K ^Q(1,"XDocRNU1") ;@Dol 20.04.05
 F qq="XBColor","XBTempor","XBaseX5280","XBaseX527","CxObj","XPbut9","XFNewAn","XBDate","XBprwr","XFJUser","XMJUser","XMJRUser","XMCrUser","XMCrUserEND","XBNDes","X155","X150","X151","X152","X177","X1664","X1194","XBp","XBf","XBadd","XBdel","R0x181","R3x181","XBz","XB1720","XBLg","XBpre","XBLastWin","XB2help","XB186","XBPrt2","XBPrt2XXL","XBPrt2NotMIME","XBNoRlf","XBTRAN","XB159","XBRDop","XBMesTime","XBFws","XBwids","xBrefrExprMode","XBrefrExpr","XBErrVar","XBErrETN","XBErrMet","XBnoFK","XB11990","XBOpenDoc","XBwsize","xBGrSt","XBviorg" D  ;@Dol 03.06.09 ,"XBPrttoOOW" НЕ НАДО
 .K ^Q(1,"XBase",0,qq)
 ;классы @Dol 22.11.07
 S qq="" F  S qq=$O(^Q(1,"XUClass",qq)) Q:qq=""  I $S(Arg2:1,$G(^Q(1,"XUClass",qq,"Xusr")):0,1:$E(qq,1,3)'="usr") K ^Q(1,"XUClass",qq)
 ;
 M ^Q(1)=^QUser(1) ;@dol 3.8.03 было ^Q=^QUser ????
 ;класс qUSER
 I $D(^QUser("User.qUSER")) D
 .I Arg2 D Delite^%apiOBJ("User.qUSER","-cdf",.error) K ^oddDEF("User.qUSER"),error I 1
 .E  S qq="" F  S qq=$O(^oddDEF("User.qUSER","method",qq)) Q:qq=""  K:$E(qq,1,3)'="usr" ^oddDEF("User.qUSER","method",qq)
 .M ^oddDEF("User.qUSER")=^QUser("User.qUSER") D Compile^%apiOBJ("User.qUSER","-dfk",.error)
 .S:'error error="" X:'error "S qUSER=##class(qUSER).%New()"
 .I error S qq=error,error="Ошибка компиляции класса qUSER" F qqq=1:1:qq S error=error_$C(13,10)_error(qq)
 ;@Dol 2.07.05 остальные пользовательские классы
 N err,qi,class S qqq="User." F  S qqq=$O(^QUser(qqq)) Q:$E(qqq,1,5)'="User."  D:qqq'="User.qUSER"
 .S class=$G(^Q(1,"XUClass",qqq))
 .D Delite^%apiOBJ(class,"-cdf",.error) K ^oddDEF(class),err
 .M ^oddDEF(class)=^QUser(qqq) D Compile^%apiOBJ(class,"-dfk",.err)
 .S:'err err="" X:'err "S "_$P(qqq,".",2)_"=##class("_$P(class,".",2)_").%New()"
 .I err S qq=err,error=$G(error)_$C(13,10)_"Ошибка компиляции класса "_$P(class,".",2) F qi=1:1:qq S error=error_$C(13,10)_err(qi)
 ;
 I $G(^QUser(1,"XBase",0,"XUDoEnd"))'="" X ^QUser(1,"XBase",0,"XUDoEnd") ;Действие после восстановлением
 K ^Q(1,"XBase",0,"XUDoEnd"),^Q(1,"XBase",0,"XUDoBeg")
 Q:$Q $G(error) Q
]]></Implementation>
</Method>

<Method name="QView">
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 G:'$G(Arg1) QViewI
 ;Экспорт
 N qq K ^%QView
 ;отображения 
 S qq="XXX" F  S qq=$O(^Q(1,"XView",qq)) Q:$E(qq,1,3)'="XXX"  M ^%QView("XView",qq)=^Q(1,"XView",qq)
 ;Запросы 
 S qq="XXX" F  S qq=$O(^Q(1,"XQuery",qq)) Q:$E(qq,1,3)'="XXX"  M ^%QView("XQuery",qq)=^Q(1,"XQuery",qq)
 ;объекты
 S qq="" F  S qq=$O(^Q(1,"CxObj",qq)) Q:qq=""  I $G(^(qq,"Xsys")) D  ;I "Xx"[$E(qq)!(qq="CxObj")!(qq="CxWoc")!(qq?1"v"1E1"X".E)!(qq?1"v"1E1"Cx".E) D
 .M ^%QView("CxObj",qq)=^Q(1,"CxObj",qq)
 M ^%QView("XPict")=^Q(1,"XPict") ;описание внутренних картинок
 M ^%QView("XDocH1")=^Q(1,"XDocH1") ;документация
 M ^%QView("XDocS1")=^Q(1,"XDocS1")
 M ^%QView("XDocRN1")=^Q(1,"XDocRN1")
 M ^%QView("XSave")=^Q(1,"XSave")
 M ^%QView("XSClass")=^Q(1,"XSClass")
 ;понятия
 S qq="" F  S qq=$O(^Q(1,"CxWoc",qq)) Q:qq=""  I $G(^(qq,"Xsys")) D  ;I "Xx"[$E(qq)!(qq="Thlp")!(qq="CxObj")!(qq="CxWoc")!(qq="xObj")!(qq="xWoc")!(qq="TB323")!(qq="TB363")!(qq="TB362")!(qq="C")!(qq="CC")!($E(qq,1,2)="@Z"&($E(qq,3)'="X"))!($E(qq,1,4)="@ZXX") D
 .M ^%QView("CxWoc",qq)=^Q(1,"CxWoc",qq) 
 .I $E(qq)'="X",$E(qq,1,3)'="sys",$E(qq)'="C",qq'="xObj",qq'="xWoc",$E(qq)'="@" M ^%QView("C"_qq)=^Q(1,"C"_qq)  ;@Dol 18.05.06 sys*
 ;Классы
 ;F qq="qARM","TqARM","qWEB","qSYS","qWORD" M ^%QView("%Library."_qq)=^oddDEF("%Library."_qq)  ;,"qWORD1"
 ;Обновления ;@dol 4.12.03
 S qq="" F  S qq=$O(^Q(1,"XUpg",qq)) Q:qq=""  I $E(qq,1,4)="Xsys" M ^%QView("XUpg",qq)=^Q(1,"XUpg",qq)
 ;Обновления ;@sasha 20.09.07
 S qq="" F  S qq=$O(^Q(1,"XGM",qq)) Q:qq=""  I $E(qq,1,4)="Xsys" M ^%QView("XGM",qq)=^Q(1,"XGM",qq)
 ;Обновления ;@sas 20090402
 S qq="" F  S qq=$O(^Q(1,"XGM1",qq)) Q:qq=""  I $E(qq,1,4)="Xsys" M ^%QView("XGM1",qq)=^Q(1,"XGM1",qq)
 S qq=$H,^%QView=qq,^Q(1,"XView","XXXX")=qq ;запишем дату и время
 Q:$Q "" Q
QViewI ;Импорт
 I $G(^%QView)="" D qARM.Message("Массив ^%QView не существует") Q:$Q 1 Q  ;@Dol 30.01.09 Q 1
 N qq,qqq
 ;удаление лишнего???
 S qq="" F  S qq=$O(^Q(1,"CxObj",qq)) Q:qq=""  I $G(^(qq,"Xsys")) K ^Q(1,"xObj",$G(^Q(1,"CxObj",qq),"???")),^Q(1,"CxObj",qq) ;I "Xx"[$E(qq)!(qq="CxObj")!(qq="CxWoc")!(qq?1"v"1E1"X".E)!(qq?1"v"1E1"Cx".E) K ^Q(1,"xObj",^Q(1,"CxObj",qq)),^Q(1,"CxObj",qq) ;;@Dol 18.12.08 $G(
 S qq="" F  S qq=$O(^Q(1,"CxWoc",qq)) Q:qq=""  I $G(^(qq,"Xsys")) D  ;I "Xx"[$E(qq)!(qq="CxObj")!(qq="CxWoc")!(qq="Thlp")!(qq="xObj")!(qq="xWoc")!(qq="TB323")!(qq="T323") D
 .K ^Q(1,"xWoc",$G(^Q(1,"CxWoc",qq),"???")),^Q(1,"CxWoc",qq) ;@Dol 18.12.08 $G(
 .I $E(qq)'="X",$E(qq)'="C",qq'="xObj",qq'="xWoc",$E(qq,1,3)'="sys" K ^Q(1,"C"_qq),^Q(1,qq)
 ;отображения
 S qq="" F  S qq=$O(^%QView("XView",qq)) Q:qq=""  K ^Q(1,"XView",qq) M ^Q(1,"XView",qq)=^%QView("XView",qq)
 ;Запросы
 S qq="" F  S qq=$O(^%QView("XQuery",qq)) Q:qq=""  K ^Q(1,"XQuery",qq) M ^Q(1,"XQuery",qq)=^%QView("XQuery",qq)
 ;объекты
 S qq="" F  S qq=$O(^%QView("CxObj",qq)) Q:qq=""  K ^Q(1,"CxObj",qq) M ^Q(1,"CxObj",qq)=^%QView("CxObj",qq) S ^Q(1,"xObj",^%QView("CxObj",qq))=qq
 ;понятия
 S qq="" F  S qq=$O(^%QView("CxWoc",qq)) Q:qq=""   D
 .K ^Q(1,"CxWoc",qq) M ^Q(1,"CxWoc",qq)=^%QView("CxWoc",qq)
 .S ^Q(1,"xWoc",^%QView("CxWoc",qq))=qq
 .Q:$E(qq)="X"!($E(qq)="C")!(qq="xWoc")!(qq="xObj")!($E(qq)="@")!($E(qq,1,3)="sys")  ;@Dol 18.05.06 sys*
 .K ^Q(1,"C"_qq),^Q(1,qq) M ^Q(1,"C"_qq)=^%QView("C"_qq)
 .S qqq="" F  S qqq=$O(^Q(1,"C"_qq,qqq)) Q:qqq=""  S ^Q(1,qq,^Q(1,"C"_qq,qqq))=qqq
 S:'$D(^Q(1,"XBase",0)) ^Q(1,"XBase",0)=""
 K ^Q(1,"XSClass") M ^Q(1,"XSClass")=^%QView("XSClass")
 K ^Q(1,"XPict") M ^Q(1,"XPict")=^%QView("XPict")
 K ^Q(1,"XDocH1") M ^Q(1,"XDocH1")=^%QView("XDocH1")
 K ^Q(1,"XDocS1") M ^Q(1,"XDocS1")=^%QView("XDocS1")
 K ^Q(1,"XDocRN1") M ^Q(1,"XDocRN1")=^%QView("XDocRN1")
 K ^Q(1,"XSave","AB") M ^Q(1,"XSave","AB")=^%QView("XSave","AB") ;пример ????
 M ^Q(1,"XUpg")=^%QView("XUpg")
 M ^Q(1,"XGM")=^%QView("XGM")
 M ^Q(1,"XGM1")=^%QView("XGM1")
 ;выведем замечания по реализации от даты предыдущего восстановления
 ;S qq=$ZD(+$G(^Q(1,"XView","XXXX")),8) D:$G(Arg2) qARM.OpenWindow(,,",,0,1 1 20","XDocRN1"_" "_qq_"  ^Q(1,""XDocRN1"","_qq_")",,"XXXRNw")
 ;@Dol 30.01.09 Следующий фрагмент уже давно ненужен
 ;D  ;I qq<20021103 D  ;замена x787 на X787
 ;.N v,c,ic,iv,y,x
 ;.S v="" F  S v=$O(^Q(1,"XView",v)) Q:v=""  I $E(v,1,3)'="XXX" D
 ;..;I $D(^(v,"X165")) S ^("x165")=^("X165") K ^("X165")
 ;..S c="" F  S c=$O(^Q(1,"XView",v,"CxObj",c)) Q:c=""  D
 ;...S y="" F  S y=$O(^Q(1,"XView",v,"CxObj",c,"Xy",y)) Q:y=""  S x="" F  S x=$O(^Q(1,"XView",v,"CxObj",c,"Xy",y,"Xx",x)) Q:x=""  I $D(^(x,"x787")),'$D(^("X787")) S ^("X787")=^("x787") K ^("x787")
 ;.S c="" F  S c=$O(^Q(1,"CxWoc",c)) Q:c=""  I "Xx"'[$E(c,1) I $D(^(c,"x787")),'$D(^("X787")) S ^("X787")=^("x787") K ^("x787")
 S ^Q(1,"XView","XXXX")=^%QView ;обновим дату и время
 K ^Q("User.qUSER") ;@dol 3.8.03 удалим мусор вследствии неправильного восстановления ^QUser (см. метод qSYS.QUser)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="QueryCSP">
<Description>
!!!Cache
Формирование CSP страниц на основе запроса.</Description>
<Internal/>
<FormalSpec>query:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ;030602
 n path,q,namespace,appl,ns,dir,l,code
 s password="1"
 s code=0      //////////////////Вывод на страницу кода понятия поиска code=1
 S q=$TR(query,"#","x")
 s namespace=$zu(5)

 s l=$s($e($lg(^|"%SYS"|%SYS("CSP","Applications","/apps/documatic"),2))="/":1,1:0)
 s appl="",path="",dir=""
 f   {
 s appl=$o(^|"%SYS"|%SYS("CSP","Applications",appl))
 q:appl=""
 s ns=$lg(^|"%SYS"|%SYS("CSP","Applications",appl),9)
 i ns=namespace s path=$lg(^|"%SYS"|%SYS("CSP","Applications",appl),2)_$S(l=1:"/",1:"\") q
 }
 s:path="" dir=$zu(140,9,$zu(168)_$S(l=1:"/",1:"\")_"csp"),path=$zu(168)_"csp"_$S(l=1:"/",1:"\")

 ;s query="###aqqC"
 i '$d(^Q(1,"XQuery",$G(query,"***")))  Q "Нет такого запроса" ;w "Нет такого запроса",!  q
 s f=path_q_".csp"
 o f:"nw":7
 u f
 w "<html>",!
 w "<head>",!
 w "<script language=""JavaScript"">",!
 w "function openWin3() {",!
 w "myWin= open("""", ""displayWindow"", ",!
 w """width=500,height=400,scrollbars,status=no,toolbar=no,menubar=no"");",!
 // открыть объект document для последующей печати 
 w "myWin.document.open();",!
 // генерировать новый документ 
 w "myWin.document.write(""<html><head><title>Правила"");",!
 w "myWin.document.write(""</title></head><body>"");",!
 w "myWin.document.write(""<center><font size=+3>"");",!
 w "myWin.document.write(""Варианты задания условия"");",!
 w "myWin.document.write(""</font></center>"");",!
 w "myWin.document.write(""<p>1.  Задается конкретное значение для поиска, например: Лекарства</p>"");",!
 w "myWin.document.write(""<p>2.  Задается условие в виде ШАБЛОНа -  сочетание любых символов с двумя "
 _"специальными знаками шаблона."
 _"Символ  *  - заменяет сколько угодно любых символов;"
 _"символ ?  - заменяет один любой символ, например:"
 _"ИНВ* - есть слово, начинающееся на ИНВ."
 _"*ОВ - есть слово, заканчивающееся на ОВ"
 _"О????О - есть слово из шести букв, начинающееся и заканчивающееся на О.</p>"");",!
 w "myWin.document.write(""<p>3.  Задается структура начала и окончания поискового образа, например:"
 _"ИНВ* ГРУПП - подойдет для значения ИНВАЛИДЫ I И II ГРУПП.</p>"");",!
 w "myWin.document.write(""<p>4. ОТРИЦАНИЕ - элементом сложного условия может служить знак минус (-). "
 _"В   этом случае  следующее за ним условие трактуется как отрицание, например: "
 _"- САНКТ-ПЕТЕРБУРГ -  любой город, кроме САНКТ-ПЕТЕРБУРГ "
 _"(!!! задается минус пробел САНКТ-ПЕТЕРБУРГ)</p>"");",!
 w "myWin.document.write(""<p>5. АЛЬТЕРНАТИВЫ - вышеперечисленные условия могут объединятся по ИЛИ (!!)."
 _"Например, ИНВ*!!*ЧЕРНОБЫЛЬСКОЙ- подходящими будут значения, которые" 
 _"начинаются на ИНВ или содержат внутри фразы слово ЧЕРНОБЫЛЬСКОЙ .</p>"");",!
 w "myWin.document.write(""<p>6. Условие * обеспечивает выбор всех экземпляров объекта, имеющих не пустое значение.</p>"");",!
 w "myWin.document.write(""</body></html>"");",!
 // закрыть документ
 w "myWin.document.close();  ",!
 w "}",!
 w "</script>",!
 ;w "<meta http-equiv='Content-Type' content='text/html;'>",!
 w "</head>",!

 w "<body bgcolor=#99CCFF>",!
 w "<table>",!
 w "<tr> <td width=""60%"">",!
 w "<p align=left><font color=""#006600"" size=""2pt"">Корректное отображение результата запроса возможно только при использовании IE5.5 и msxml-3 (или более поздних версий).</font></p>",!
 w "</td><td>",!
 w "<h4 align=right><b> <font color=""#800000"" size=""2pt"">Сегодня  #($zd($h,2,"" января февраля марта апреля мая июня июля августа сентября октября ноября декабря""))# года.</font></b></h4> ",!     
 w "</td></tr>",!
 w "</table>",!
 w "<h3 align=center><b>Запрос ""#($g(^Q(1,""XQuery"","""_query_""",""XQName"")))#"".</b></h2>",!
 w "<input type=button value=""Правила задания поискового образа"" onClick=""openWin3()"">",!
 w "<form method=""POST"" action="""_q_"resp.csp"">",!
 w "<script language=""Cache"" runat=""server""> ",!
 w "w ""<table border=""""0pt"""">""",!

 w "For i = 1:1 {",!
 w "q:$p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i)=""""",!
 // Условия формирования запроса
 w "s properts=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",2)",!       ;код свойства
 w "s obj=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",1)",!        ;код объекта  
 w "s np=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",3)",!         ;имя свойства на странице
 w "s pr=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",5)",!         ;код понятия развертки
 w "s vr=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",6)",!         ;вариант редактирования

 ;w "s opa(obj,properts)=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",4)",!

 ;w "zw opa",!
 w "s z="""",f=0",!
 w "For  {",!
 w "s z=$o(opa(z))  q:z=""""",!
 w "s zz=""""",!
 w "For  {",!
 w "s zz=$o(opa(z,zz))  q:zz=""""",!
 w "s:zz=obj f=1,opa(z,zz,properts)=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",4),opa(z,zz,properts,""np"")=$g(np),opa(z,zz,properts,""pr"")=$g(pr),opa(z,zz,properts,""vr"")=$g(vr)",!
 w "}",!
 w "}",!
 w "s:f=0 opa(i,obj,properts)=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",4),opa(i,obj,properts,""np"")=$g(np),opa(i,obj,properts,""pr"")=$g(pr),opa(i,obj,properts,""vr"")=$g(vr)",!

 w "}",!

 w "s xx=""""",!         
 w "For  {",!
 w "s xx=$o(opa(xx))  q:xx=""""",!
 w "s x=""""",!
 w "For  {",!                         
 w "s x=$o(opa(xx,x))  q:x=""""",!

 w "w ""<tr>""",!
 w "w ""<td width=""""100%"""" colspan=""""3"""" style='border:solid windowtext .5pt;'><p align=""""center""""><font color=""""#000000"""" size=""""3pt"""">""_^Q(1,""CxObj"",x)_"" (""_x_"")</font></p></td>"",!",!
 w "w ""</tr>""",!   
 w "s y=""""",!
 w "F count=1:1  {",!                                                    ///Подсчет количества свойств в объекте
 w "s y=$o(opa(xx,x,y))  q:y=""""",!
 w "}",!
 w "s y=""""",!
 w "For i=1:1 {",!
 w "s y=$o(opa(xx,x,y))  q:y=""""",!
 ///Разрешение редактирования данных запроса
 w "i (opa(xx,x,y,""vr"")'=1),(opa(xx,x,y,""vr"")'=-1)  {",!
 w "w ""<tr>""",!
 w "i opa(xx,x,y)=1  {",!
 w "w ""<td width=""""30%"""">Поиск по <font color=""""#800000"""" size=""""2pt"""">""_$s(opa(xx,x,y,""np"")="""":^Q(1,""CxWoc"",y),1:opa(xx,x,y,""np""))_$s("""_code_"""=1:"" (""_y_"")"",1:"""")_""</font> </td><td width=""""15%"""">&#160;&#160; от &#160;&#160;&#160;&#160;<input size=""""10%"""" type=""""text"""" name=""""~A,""_x_"",""_y_""""""></td><td width=""""15%"""">до &#160;&#160;&#160;&#160;<input size=""""10%"""" type=""""text"""" name=""""~B,""_x_"",""_y_""""""><input type=""""hidden"""" name=""""*,""_x_"",""_y_"""""">"",!",!
 w "w ""</td>"",!",!
 w "}",!
 w "else  {",!
 w "w ""<td width=""""30%"""">Поиск по <font color=""""#800000"""" size=""""2pt"""">""_$s(opa(xx,x,y,""np"")="""":^Q(1,""CxWoc"",y),1:opa(xx,x,y,""np""))_$s("""_code_"""=1:"" (""_y_"")"",1:"""")_""</font></td><td width=""""15%""""> <input size=""""15%"""" type=""""text"""" name=""""""_x_"",""_y_""""""></td> <td width=""""15%"""">"",!",!
 w "w ""</td>"",!",!                                                                     
 w "}",!
 w "w ""</tr>"",!",!
 w "}",!

 ///Запрет редактирования данных запроса            
 w "i (opa(xx,x,y,""vr"")=1)!(opa(xx,x,y,""vr"")=-1)  {",!
 w "i opa(xx,x,y)=1  {",!
 w "w ""<input size=""""10%"""" type=""""hidden"""" name=""""~A,""_x_"",""_y_""""""><input size=""""10%"""" type=""""hidden"""" name=""""~B,""_x_"",""_y_""""""><input type=""""hidden"""" name=""""*,""_x_"",""_y_"""""">"",!",!
 w "}",!
 w "else  {",!
 w "w ""<input size=""""15%"""" type=""""hidden"""" name=""""""_x_"",""_y_"""""">"",!",!
 w "}",!
 w "}",!
 ///
 ;w "w ""<input type=""""hidden"""" name=""""!*,""_x_"",""_y_"""""">"",!",!
 ;w "w ""<input type=""""hidden"""" value="""""""" name=""""!~A,""_x_"",""_y_"""""">"",!",!
 ;w "w ""<input type=""""hidden"""" value="""""""" name=""""!~B,""_x_"",""_y_"""""">"",!",!
 ;w "i $e(y)'=""@""  {",!
 ///Разрешение развертки
 w "i (opa(xx,x,y,""vr"")'=0),(opa(xx,x,y,""vr"")'=-1)  {",!                                    
 w "w ""<tr>""",!
 w "s pr=$s(opa(xx,x,y,""pr"")="""":y,1:opa(xx,x,y,""pr""))",!      //понятие развертки                                                                         
 w "i opa(xx,x,y)=1  {",!
 w "w ""<td width=""""30%""""><font color=""""#006600"""" size=""""3pt"""">Развертка по </font><font color=""""#800000"""" size=""""2pt"""">""_^Q(1,""CxWoc"",y)_$s("""_code_"""=1:"" (""_y_"")"",1:"""")_""</font> </td><td width=""""15%""""><SELECT size=""""1"""" name=""""!~A,""_x_"",""_y_"""""">"",!",!
 w "w ""<OPTION selected=1></OPTION>""",!
 w "s cc=""""  f sl=1:1:200 {",!
 w "s cc=$o(^Q(1,pr,cc)) q:cc=""""",!
 w "w ""<OPTION>""_cc_""</OPTION>""",! 
 w "}",!
 w "w ""</SELECT>""",!
 w "w ""&#160;&#160; до </td><td width=""""15%""""><SELECT size=""""1"""" name=""""!~B,""_x_"",""_y_"""""">"",!",!
 w "w ""<OPTION selected=1></OPTION>""",!
 w "s cc=""""  f sl=1:1:200 {",!
 w "s cc=$o(^Q(1,pr,cc)) q:cc=""""",!
 w "w ""<OPTION>""_cc_""</OPTION>""",! 
 w "}",!
 w "w ""</SELECT>""",!
 w "w ""<input type=""""hidden"""" name=""""!*,""_x_"",""_y_""""""></td>"",!",!
 w "}",!
 w "else  {",!
 w "w ""<td width=""""30%""""><font color=""""#006600"""" size=""""3pt"""">Развертка по </font><font color=""""#800000"""" size=""""2pt"""">""_^Q(1,""CxWoc"",y)_$s("""_code_"""=1:"" (""_y_"")"",1:"""")_""</font></td><td width=""""15%""""><SELECT size=""""1"""" name=""""!""_x_"",""_y_"""""">"",!",!
 w "w ""<OPTION selected=1></OPTION>""",!
 w "s cc=""""  f sl=1:1:200 {",!
 w "s cc=$o(^Q(1,pr,cc)) q:cc=""""",!
 w "w ""<OPTION>""_cc_""</OPTION>""",! 
 w "}",!
 w "w ""</SELECT>""",!
 w "w ""</td> <td width=""""15%""""></td>"",!",!
 w "}",!
 w "w ""</tr>"",!",!
 ;w "}",!                               
 w "w:i'=(count-1) ""<tr><td colspan=""""3"""">&nbsp;</td></tr>"",!",!
 w "}",!                        ///
 ;w "}",!               


 ///Запрет развертки
 w "i (opa(xx,x,y,""vr"")=0)!(opa(xx,x,y,""vr"")=-1)  {",!
 w "w ""<tr><td colspan=""""3"""">&nbsp;</td></tr>"",!",!                                   
 w "i opa(xx,x,y)=1  {",!
 w "w ""<input type=""""hidden"""" name=""""!*,""_x_"",""_y_"""""">"",!",!
 w "}",!
 w "else  {",!
 w "w ""<input type=""""hidden"""" name=""""!""_x_"",""_y_"""""">"",!",!
 w "}",!    
 w "}",!                ///

 w "}",!                
 w "}",!                       
 w "}",!

 w "w ""</table>""",!  
 w "</script>",!
 w "<p><input type=""submit"" value=""Получить данные"" name="""">&nbsp;&nbsp;&nbsp;&nbsp;<input type=""reset"" value=""Очистить форму"" name="""">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"
 ;w "<button onClick='window.open("""_q_"raz.csp"",""navigat"",""height=300,width=400,status=no,toolbar=no,menubar=yes, location=no,scrollbars=yes,resizable=yes"");'>Развертка по словарю</button></p>",!
 w "</form>",!
 w "</body>",!
 w "</html>",!
 c f


 s f=path_q_"resp.csp"
 o f:"nw":7
 u f
 w "<html>",!
 w "<head>",!
 ;w "<meta http-equiv=Content-Type content=""text/html;"">",!            
 /////////////////////////// Прием и обработка данных из формы 
 w "<script language=""Cache"" runat=""server""> ",!
 w "s nameprop=""""",!
 w "s qqnump=0",!
 w "s qview=$s($d(^Q(1,""XQuery"","""_query_""",""XQName"")):^Q(1,""XQuery"","""_query_""",""XQName""),1:""noname"")",!
 w "k tempa",! 
 ;w "k ^opa",!    ;для работы не нужен
 w "For i = 1:1 {",!
 w "q:%request.Next(nameprop)=""""",!

 w "s nameprop=%request.Next(nameprop)",!

 ;w "s ^opa(nameprop)=$g(%request.Data(""!""_nameprop,1))",!

 w "i $e(nameprop,1,3)'=""CSP""  {",!
 w "i $e(nameprop)=""*""  {",!
 w "s obj=$p(nameprop,"","",2)",!
 w "s properts=$p(nameprop,"","",3)",!
 w "s nameA=$tr(nameprop,""*"",""""),nameA=""~A""_nameA",!
 w "s nameB=$tr(nameprop,""*"",""""),nameB=""~B""_nameB",!
 w "s propA=%request.Data(nameA,1)",!
 w "s propB=%request.Data(nameB,1)",!
 w "s:propA="""" nameA=$tr(nameprop,""*"",""""),nameA=""!~A""_nameA,propA=$g(%request.Data(nameA,1))",!
 w "s:propB="""" nameB=$tr(nameprop,""*"",""""),nameB=""!~B""_nameB,propB=$g(%request.Data(nameB,1))",!
 w "s:(propA'="""")!(propB'="""") Vs(""par"",8,obj,properts)=propA_"">>""_propB",!
 w "s tempa(i,""obj"")=obj_"" ""_properts",!
 w "s tempa(i,""propA"")=propA",!
 w "s tempa(i,""propB"")=propB",!

 ;w "s ^opa(obj,properts)=propA_""<>""_propB",!

 w "}",!
 w "i $e(nameprop)'=""*"",$e(nameprop)'=""~"",$e(nameprop)'=""!""  {",!  
 w "s obj=$p(nameprop,"","",1)",!
 w "s properts=$p(nameprop,"","",2)",!

 w "s prop=%request.Data(nameprop,1)",!
 w "s:prop="""" prop=%request.Data(""!""_nameprop,1)",!
 w "s:prop'="""" Vs(""par"",8,obj,properts)=prop",!
 w "s tempa(i,""obj"")=obj_"" ""_properts",!                     ;для вывода условий поиска
 w "s tempa(i,""prop"")=prop",!                                          ;для вывода условий поиска

 ;w "s ^opa(obj,properts)=prop_"" nameprop=""_nameprop",!

 w "}",!
 w "}",!
 w "}",!
 w "s qWEB=##class(%qWEB).%New()",!
 w "s qW=##class(%qWORD).%New()",!
 w "s qARM=##class(%TqARM).%New()",!
 w "s qSYS=##class(%qSYS).%New()",!
 w "X ""S qUSER=##class(qUSER).%New()""",!
 w "s qqc=""""",!

 ;w "w $zu(67,15,$j)",!
 ;w "s i="""" for  s i=$O(%request.CgiEnvs(i))  q:i=""""  Write !,""<br>""_i_"": ""_%request.CgiEnvs(i)",!
 w "s IP=$p(%request.CgiEnvs(""HTTP_REFERER""),""/"",3),IP=$S(IP=""localhost"":""127.0.0.1"",1:IP)",!
 w "S qARM(""CntStr"")=""cn_iptcp:""_IP_""[1972]:"_$ZU(5)_"""",! ;girl""",! ;;132.32.32.123[1972]:girl""",!
 ;s Vs(qqnump,99,"Pic")=1;-------ввести в QueryExt для отображения фоток
 ;w "zw Vs",!
 w "m Vs(""par"")=^Q(1,""XQuery"","""_query_""",""XObjStat"")",!        ;учет состояния отображения запроса
 w "k ^VstempCSP(%session.SessionId)",!
 w "m ^VstempCSP(%session.SessionId)=Vs",!
 ;;w "s %session.Preserve=1",!   ;сохранение всей локальной области сессии

 ;w "s Vs(""par"",8,3)=""""",!
 ;w "s Vs(""par"",99,""Find"")=1",!
 ;w "zw Vs",!

 w "D qWEB.QueryExt($s($g(^Q(1,""XQuery"","""_query_""",""XQView""))'="""":^Q(1,""XQuery"","""_query_""",""XQView""),1:$p("""_query_""",""qq""))_"" U"",1)",!

 ;Релевантные в ^Q(Vs(qqnump,"Relind")_qview)
 ;w "zw ^Q(Vs(qqnump,""Relind"")_qview)",!
 ;w "w $g(Vs(qqnump,""Relind""))",!
 ;w "w $g(qview)",!

 /////////////////////////////////////////////

 ///////////////////////////////   Если что-то найдено, создать xml xsl островки
 w "i $g(Vs(qqnump,""RelNum""))=1  {",!      
 w "w ""<XML id='source'>""",!   
 w "d qWEB.XML(0,1,1,0,1,0,10000,1)",!
 w "w ""</XML>""",!
 w "w ""<!--p>СП.АРМ ПАВЕЛ :)<p-->""",!   
 w "w ""<XML id='style'>""",!
 w "D qWEB.XSL(0,1,1,0,,1)",!     
 w "w ""</XML>""",! 
 ///////// Обработка островков

 w "w ""<""_""script FOR=""""window"""" EVENT=""""onload"""">""",!
 w "w ""xslTarget.innerHTML = source.transformNode(style.XMLDocument);""",!
 w "w ""<""_""/script>""",!    

 w "}",! 
 ////////////////////////////////////////////////////
 w "</script>",! 
 w "</head>",!


 ///////////////////////////////////////////// Формирование страницы результата


 w "<body bgcolor=#C8D7AA>",!   
 w "<h2 align=center><font color=""#000000""><b>Результат запроса ""#($g(^Q(1,""XQuery"","""_query_""",""XQName"")))#"".</b></font></h2>",! 
 w "<p align=""center""><font color=""#800000"" size=""2pt""><a href=""javascript:history.go(-1);"">НОВЫЙ ПОИСК</a></font></p>"

 w "<script language=""Cache"" runat=""server""> ",! 
 w "i $g(Vs(qqnump,""RelNum""))=1 {",!
 w "w ""<p align=""""center"""">""",!
 w "w ""<form method=""""POST"""" action="""""_q_"cor.csp"""">""",!
 w "w ""<INPUT type=""""password"""" name=""""password"""">""",!
 w "w ""<INPUT type=""""submit"""" value=""""Вход в режим администратора"""">""",!
 w "w ""</form>""",!
 w "w ""</p>""",!
 w "}",!
 w "</script>",! 

 //////////////////////////////////////////////////// Вывод условий поиска
 w "<script language=""Cache"" runat=""server""> ",!     
 w "w ""<font color=""""#000000""""><b>Условия поиска:</b></font>""",!
 w "s x=""""",!
 w "f k=1:1  {",!
 w "s x=$o(tempa(x))",!
 w "q:x=""""",!
 ;w "w x,!",!
 w "i $d(tempa(x,""prop"")) {",!                         
 w "i tempa(x,""prop"")'=""""   w ""<p><font color=""""#800000"""" size=""""2pt"""">""_^Q(1,""CxWoc"",$p(tempa(x,""obj""),"" "",2))_"" ""_$p(tempa(x,""obj""),"" "",2)_""=""_tempa(x,""prop"")_""</font></p>""",!
 w "}",!
 w "else {",!    
 w "i (tempa(x,""propA"")'="""")!(tempa(x,""propB"")'="""")  w ""<p><font color=""""#800000"""" size=""""2pt"""">""_^Q(1,""CxWoc"",$p(tempa(x,""obj""),"" "",2))_"" ""_$p(tempa(x,""obj""),"" "",2)_""=от ""_tempa(x,""propA"")_"" до ""_tempa(x,""propB"")_""</font></p>""",!
 w "}",!                                    
 w "}",!
 ;w "w $zu(131,1)",!
 ;w "w $zu(67,15,$J)",!
 w "</script>",!
 //////////////////////////////////////////////////////

 w "<script language=""Cache"" runat=""server""> ",!
 w "i $g(Vs(qqnump,""RelNum""))=1  {",!

 w "w ""<div id=""""xslTarget""""></div>""",!   
 w "w ""<p align=""""center""""><font color=""""#800000"""" size=""""2pt""""><a href=""""javascript:history.go(-1);"""">НОВЫЙ ПОИСК</a></font></p>""",! 
 w "}",!

 //////////////////////////////////////// Если ничего не найдено
 w "i $g(Vs(qqnump,""RelNum""))'=1  {",!
 w "w ""<p align=""""center""""><font color=""""#FF0000"""" size=""""5pt"""">Ничего не найдено!</font></p>""",!
 w "}",!
 ///////////////////////////////////////
 w "</script>",!


 w "</body>",!


 w "</html>",!
 c f




 ;;;;;;;;;;;;;;;;;;;;Страница приема новых данных

 s f=path_q_"cor.csp"
 o f:"nw":7
 u f
 w "<html>",!
 w "<head>",!
 ;w "<meta http-equiv=Content-Type content=""text/html;"">",!            
 /////////////////////////// Прием и обработка данных из формы 
 w "<script language=""Cache"" runat=""server""> ",!

 w "i $g(%request.Data(""password"",1))="""_password_"""  {",!

 w "s qWEB=##class(%qWEB).%New()",!
 w "s qW=##class(%qWORD).%New()",!
 w "s qARM=##class(%TqARM).%New()",!
 w "s qSYS=##class(%qSYS).%New()",!
 w "X ""S qUSER=##class(qUSER).%New()""",!
 w "s qqc=""""",!

 ;w "w $zu(67,15,$j)",!
 ;w "s i="""" for  s i=$O(%request.CgiEnvs(i))  q:i=""""  Write !,""<br>""_i_"": ""_%request.CgiEnvs(i)",!
 w "s IP=$p(%request.CgiEnvs(""HTTP_REFERER""),""/"",3),IP=$S(IP=""localhost"":""127.0.0.1"",1:IP)",!
 w "S qARM(""CntStr"")=""cn_iptcp:""_IP_""[1972]:"_$ZU(5)_"""",! ;girl""",! ;;132.32.32.123[1972]:girl""",!
 ;s Vs(qqnump,99,"Pic")=1;-------ввести в QueryExt для отображения фоток




 w "m Vs=^VstempCSP(%session.SessionId)",!
 ;w "zw Vs",!
 w "D qWEB.QueryExt($s($g(^Q(1,""XQuery"","""_query_""",""XQView""))'="""":^Q(1,""XQuery"","""_query_""",""XQView""),1:$p("""_query_""",""qq""))_"" U"",1)",!
 ;w "w ""opa""_Vs(qqnump,""RelNum"")",!

 ;Релевантные в ^Q(Vs(qqnump,"Relind")_qview)
 ;w "zw ^Q(Vs(qqnump,""Relind"")_qview)",!
 ;w "w $g(Vs(qqnump,""Relind""))",!
 ;w "w $g(qview)",!

 /////////////////////////////////////////////

 ///////////////////////////////   Если что-то найдено, создать xml xsl островки
 w "i $g(Vs(qqnump,""RelNum""))=1  {",!      
 w "w ""<XML id='source'>""",!   
 w "d qWEB.XML(0,1,1,0,1,0,10000,1)",!
 w "w ""</XML>""",!
 w "w ""<!--p>СП.АРМ ПАВЕЛ :)<p-->""",!   
 w "w ""<XML id='style'>""",!
 w "D qWEB.XSLcor(0,1,1,0,,"""_q_""",1)",!     
 w "w ""</XML>""",! 

 ;w "s %session.Preserve=0",!
 ///////// Обработка островков

 w "w ""<""_""script FOR=""""window"""" EVENT=""""onload"""">""",!
 w "w ""xslTarget.innerHTML = source.transformNode(style.XMLDocument);""",!
 w "w ""<""_""/script>""",!    

 w "}",! 

 w "}",!   ;закрытие if  на пароль
 ////////////////////////////////////////////////////
 w "</script>",! 
 w "</head>",!


 ///////////////////////////////////////////// Формирование страницы результата


 w "<body bgcolor=#C8D7AA>",!

 w "<csp:IF CONDITION='$g(%request.Data(""password"",1))="""_password_"""'>",!

 w "<h2 align=center><font color=""#000000""><b>Результат запроса ""#($g(^Q(1,""XQuery"","""_query_""",""XQName"")))#"".</b></font></h2>",! 
 w "<p align=center><font color=""#FF0000"" size=""3pt""><b>Режим администратора.</b></font></p>",! 
 w "<p align=""center""><font color=""#800000"" size=""2pt""><a href="""_q_".csp"">НОВЫЙ ПОИСК</a></font></p>" ;                       
 /////////////////////////////////////////////////// Вывод условий поиска
 /*
 w "<script language=""Cache"" runat=""server""> ",!     
 w "w ""<font color=""""#000000""""><b>Условия поиска:</b></font>""",!
 w "s x=""""",!
 w "f k=1:1  {",!
 w "s x=$o(tempa(x))",!
 w "q:x=""""",!
 ;w "w x,!",!
 w "i $d(tempa(x,""prop"")) {",!                         
 w "i tempa(x,""prop"")'=""""   w ""<p><font color=""""#800000"""" size=""""2pt"""">""_^Q(1,""CxWoc"",$p(tempa(x,""obj""),"" "",2))_"" ""_$p(tempa(x,""obj""),"" "",2)_""=""_tempa(x,""prop"")_""</font></p>""",!
 w "}",!
 w "else {",!    
 w "i (tempa(x,""propA"")'="""")!(tempa(x,""propB"")'="""")  w ""<p><font color=""""#800000"""" size=""""2pt"""">""_^Q(1,""CxWoc"",$p(tempa(x,""obj""),"" "",2))_"" ""_$p(tempa(x,""obj""),"" "",2)_""=от ""_tempa(x,""propA"")_"" до ""_tempa(x,""propB"")_""</font></p>""",!
 w "}",!                                    
 w "}",!
 ;w "w $zu(131,1)",!
 ;w "w $zu(67,15,$J)",!
 w "</script>",!
 */
 //////////////////////////////////////////////////////

 w "<script language=""Cache"" runat=""server""> ",!
 w "i $g(Vs(qqnump,""RelNum""))=1  {",!

 w "w ""<div id=""""xslTarget""""></div>""",!   
 w "w ""<p align=""""center""""><font color=""""#800000"""" size=""""2pt""""><a href="""""_q_".csp"""">НОВЫЙ ПОИСК</a></font></p>""",! 
 w "}",!

 //////////////////////////////////////// Если ничего не найдено
 w "i $g(Vs(qqnump,""RelNum""))'=1  {",!
 w "w ""<p align=""""center""""><font color=""""#FF0000"""" size=""""5pt"""">Ничего не найдено!</font></p>""",!
 w "}",!
 ///////////////////////////////////////
 w "</script>",!
 w "<csp:ELSE>",!
 w "<p align=""center""><font color=""#FF0000"" size=""5pt"">ДОСТУП ЗАКРЫТ!</font></p>",!
 w "<p align=""center""><font color=""#800000"" size=""4pt""><a href=""javascript:history.go(-1);"">Назад</a></font></p>"
 w "</csp:IF>",!

 w "</body>",!


 w "</html>",!
 c f




 ;;;;;;;;;;;;;;;;;;;;Страница корректировки и отображения откорректированных данных

 s f=path_q_"respcor.csp"
 o f:"nw":7
 u f
 w "<html>",!
 w "<head>",!
 ;w "<meta http-equiv=Content-Type content=""text/html;"">",!            
 /////////////////////////// Прием и обработка данных из формы 
 w "<script language=""Cache"" runat=""server""> ",!
 w "s qWEB=##class(%qWEB).%New()",!
 w "s qW=##class(%qWORD).%New()",!
 w "s qARM=##class(%TqARM).%New()",!
 w "s qSYS=##class(%qSYS).%New()",!
 w "X ""S qUSER=##class(qUSER).%New()""",!
 w "s qqc=""""",!
 w "s nameprop=""""",!
 w "s qqnump=0",!
 w "s qview=$s($d(^Q(1,""XQuery"","""_query_""",""XQName"")):^Q(1,""XQuery"","""_query_""",""XQName""),1:""noname"")",!
 w "k tempa",!
 w "s oz=$s($g(^Q(1,""XQuery"","""_query_""",""XQView""))'="""":^Q(1,""XQuery"","""_query_""",""XQView""),1:$p("""_query_""",""qq""))",!
 w "D qWEB.Init()  D qWEB.OpenPrint(,1,,,,oz_"" U"",""Q"")",!
 w "For i = 1:1 {",!
 w "q:%request.Next(nameprop)=""""",!

 w "s nameprop=%request.Next(nameprop)",!
 ;w "s ^ups(i)=nameprop",!                      //////////
 w "i $e(nameprop,1,3)'=""CSP""  {",!

 w "s obj=$p(nameprop,"" "",1)",!
 w "s properts=$p(nameprop,"" "",2)",!
 w "s qqc=$p(nameprop,"" "",3)",!
 w "s prop=%request.Data(nameprop,1)",!
 ;w "s ^ups(i,""prop"")=prop",!                     //////////

 w "s:$e(prop,($l(prop)-1),$l(prop))=$C(13,10) $e(prop,($l(prop)-1),$l(prop))=""""",!
 w "s prop=$tr(prop,"" "",""_"")",!
 w "s:$e(properts)=""d"" prop=$p(prop,""."",3)_$p(prop,""."",2)_$p(prop,""."",1)",!
 ;корректировка базы
 w "s:$e(properts)'=""T"" W(properts)=prop",!
 w "i $e(properts)=""T""  {",!
 w "s numpol=$l(prop,$c(13,10))",!
 w "f kkk=1:1:numpol   {",!
 w "s W(properts,(kkk-1))=$p(prop,$c(13,10),kkk)",!                              
 w "}",!
 w "}",!

 w "d qW.rCor(obj,qqc,properts)",!               ;

 ;w "I prop'="""" { ",!
 ;w "s:$d(Vs(""par"",8,obj,properts)) Vs(""par"",8,obj,properts)=Vs(""par"",8,obj,properts)_""!!""_prop",!
 ;w "s:'$d(Vs(""par"",8,obj,properts)) Vs(""par"",8,obj,properts)=prop",!
 ;w "}",!

 w "I prop'="""" { ",!
 w "s:$d(Vs(""par"",8,obj,""C"")) Vs(""par"",8,obj,""C"")=Vs(""par"",8,obj,""C"")_""!!""_qqc",!
 w "s:'$d(Vs(""par"",8,obj,""C"")) Vs(""par"",8,obj,""C"")=qqc",!
 w "}",!

 w "s tempa(i,""obj"")=obj_"" ""_properts",!                     ;для вывода условий поиска
 w "s tempa(i,""prop"")=prop",!                                          ;для вывода условий поиска

 w "}",!

 w "}",!

 ;w "m ^VsTemp=Vs",!                            ////////////////
 ;w "w $zu(67,15,$j)",!
 ;w "s i="""" for  s i=$O(%request.CgiEnvs(i))  q:i=""""  Write !,""<br>""_i_"": ""_%request.CgiEnvs(i)",!
 w "s IP=$p(%request.CgiEnvs(""HTTP_REFERER""),""/"",3),IP=$S(IP=""localhost"":""127.0.0.1"",1:IP)",!
 w "S qARM(""CntStr"")=""cn_iptcp:""_IP_""[1972]:"_$ZU(5)_"""",! ;girl""",! ;;132.32.32.123[1972]:girl""",!
 ;w "zw Vs",!
 w "m Vs(""par"")=^Q(1,""XQuery"","""_query_""",""XObjStat"")",!        ;учет состояния отображения запроса
 w "D qWEB.QueryExt($s($g(^Q(1,""XQuery"","""_query_""",""XQView""))'="""":^Q(1,""XQuery"","""_query_""",""XQView""),1:$p("""_query_""",""qq""))_"" U"",1)",!
 ;w "w ""opa""_Vs(qqnump,""RelNum"")",!

 ;Релевантные в ^Q(Vs(qqnump,"Relind")_qview)
 ;w "zw ^Q(Vs(qqnump,""Relind"")_qview)",!
 ;w "w $g(Vs(qqnump,""Relind""))",!
 ;w "w $g(qview)",!

 /////////////////////////////////////////////

 ///////////////////////////////   Если что-то найдено, создать xml xsl островки
 w "i $g(Vs(qqnump,""RelNum""))=1  {",!      
 w "w ""<XML id='source'>""",!   
 w "d qWEB.XML(0,1,1,0,1,0,10000,1)",!
 w "w ""</XML>""",!
 w "w ""<!--p>СП.АРМ ПАВЕЛ :)<p-->""",!   
 w "w ""<XML id='style'>""",!
 w "D qWEB.XSLcor(0,1,1,0,,"""_q_""",1)",!     
 w "w ""</XML>""",! 
 ///////// Обработка островков

 w "w ""<""_""script FOR=""""window"""" EVENT=""""onload"""">""",!
 w "w ""xslTarget.innerHTML = source.transformNode(style.XMLDocument);""",!
 w "w ""<""_""/script>""",!    

 w "}",! 
 ////////////////////////////////////////////////////
 w "</script>",! 
 w "</head>",!


 ///////////////////////////////////////////// Формирование страницы результата


 w "<body bgcolor=#C8D7AA>",!   
 w "<h2 align=center><font color=""#000000""><b>Результат корректировки базы запроса ""#($g(^Q(1,""XQuery"","""_query_""",""XQName"")))#"".</b></font></h2>",! 
 w "<p align=center><font color=""#FF0000"" size=""3pt""><b>Режим администратора.</b></font></p>",!
 w "<p align=""center""><font color=""#800000"" size=""2pt""><a href="""_q_".csp"">НОВЫЙ ПОИСК</a></font></p>"                     
 /////////////////////////////////////////////////// Вывод условий поиска
 /*
 w "<script language=""Cache"" runat=""server""> ",!     
 w "w ""<font color=""""#000000""""><b>Условия поиска:</b></font>""",!
 w "s x=""""",!
 w "f k=1:1  {",!
 w "s x=$o(tempa(x))",!
 w "q:x=""""",!
 ;w "w x,!",!
 w "i $d(tempa(x,""prop"")) {",!                         
 w "i tempa(x,""prop"")'=""""   w ""<p><font color=""""#800000"""" size=""""2pt"""">""_^Q(1,""CxWoc"",$p(tempa(x,""obj""),"" "",2))_"" ""_$p(tempa(x,""obj""),"" "",2)_""=""_tempa(x,""prop"")_""</font></p>""",!
 w "}",!
 w "else {",!    
 w "i (tempa(x,""propA"")'="""")!(tempa(x,""propB"")'="""")  w ""<p><font color=""""#800000"""" size=""""2pt"""">""_^Q(1,""CxWoc"",$p(tempa(x,""obj""),"" "",2))_"" ""_$p(tempa(x,""obj""),"" "",2)_""=от ""_tempa(x,""propA"")_"" до ""_tempa(x,""propB"")_""</font></p>""",!
 w "}",!                                    
 w "}",!
 ;w "w $zu(131,1)",!
 ;w "w $zu(67,15,$J)",!
 w "</script>",!
 //////////////////////////////////////////////////////
 */

 w "<script language=""Cache"" runat=""server""> ",!
 w "i $g(Vs(qqnump,""RelNum""))=1  {",!

 w "w ""<div id=""""xslTarget""""></div>""",!   
 w "w ""<p align=""""center""""><font color=""""#800000"""" size=""""2pt""""><a href="""""_q_".csp"""">НОВЫЙ ПОИСК</a></font></p>""",! 
 w "}",!

 //////////////////////////////////////// Если ничего не найдено
 w "i $g(Vs(qqnump,""RelNum""))'=1  {",!
 w "w ""<p align=""""center""""><font color=""""#FF0000"""" size=""""5pt"""">Ничего не найдено!</font></p>""",!
 w "}",!
 ///////////////////////////////////////
 w "</script>",!


 w "</body>",!


 w "</html>",!
 c f
 i dir'="" d qARM.Message("Приложения CSP области """_namespace_""" нет в конфигурации Cache. Файлы CSP созданы в "_path_". Первая страница обращения "_q_".csp")  q
 d qARM.Message("Файлы CSP созданы в "_path_". Первая страница обращения "_appl_"/"_q_".csp")
 q
]]></Implementation>
</Method>

<Method name="QueryCSPXML">
<Description>
!!!Cache</Description>
<Internal/>
<FormalSpec>query:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;141002
 n path,q,namespace,appl,ns,dir,l,code,qqoQu
 S qqoQu=$S(query'[":":"XQuery",1:$P(query,":")) S:query[":" query=$P(query,":",2,255) ;@Dol 18.03.08
 s password="1"
 s ObjId=3     ;корень для вывода на страницу
 s numroot=4   ;количество выводимых экземпляров корня на странице
 S q=$TR(query,"#","x")
 s namespace=$zu(5)

 s l=$s($e($lg(^|"%SYS"|%SYS("CSP","Applications","/apps/documatic"),2))="/":1,1:0)
 s appl="",path="",dir=""
 f   {
 s appl=$o(^|"%SYS"|%SYS("CSP","Applications",appl))
 q:appl=""
 s ns=$lg(^|"%SYS"|%SYS("CSP","Applications",appl),9)
 i ns=namespace s path=$lg(^|"%SYS"|%SYS("CSP","Applications",appl),2)_$S(l=1:"/",1:"\") q
 }
 s:path="" dir=$zu(140,9,$zu(168)_$S(l=1:"/",1:"\")_"csp"),path=$zu(168)_"csp"_$S(l=1:"/",1:"\")

 ;s query="###aqqC"
 i '$d(^Q(1,qqoQu,$G(query,"***")))  Q "Нет такого запроса" ;w "Нет такого запроса",!  q
 s f=path_q_".csp"
 o f:"nw":7
 u f

 w "<?xml version=""1.0"" encoding=""windows-1251""?>",!
 w:$g(^Q(1,qqoQu,query,"XQCSPxsl1"))'="" "<?xml:stylesheet href="""_^Q(1,qqoQu,query,"XQCSPxsl1")_""" type=""text/xsl""?>",!
 w "<response>",!
 w "<link>",!
 w "<message>Hello qWord</message>",!
 w "<display>СП АРМ</display>",!
 w "<href>http://www.sparm.com</href>",!
 w "</link>",!
 w "<query>",!
 w "<nextp>xxxaqqMresp.csp</nextp>",!


 w "<script language=""Cache"" runat=""server""> ",!
 w "For i = 1:1 {",!
 w "q:$p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i)=""""",!
 // Условия формирования запроса
 w "s properts=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",2)",!       ;код свойства
 w "s obj=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",1)",!        ;код объекта  
 w "s np=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",3)",!         ;имя свойства на странице
 w "s pr=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",5)",!         ;код понятия развертки
 w "s vr=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",6)",!         ;вариант редактирования

 ;w "s opa(obj,properts)=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",4)",!

 ;w "zw opa",!
 w "s z="""",f=0",!
 w "For  {",!
 w "s z=$o(opa(z))  q:z=""""",!
 w "s zz=""""",!
 w "For  {",!
 w "s zz=$o(opa(z,zz))  q:zz=""""",!
 w "s:zz=obj f=1,opa(z,zz,properts)=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",4),opa(z,zz,properts,""np"")=$g(np),opa(z,zz,properts,""pr"")=$g(pr),opa(z,zz,properts,""vr"")=$g(vr)",!
 w "}",!
 w "}",!
 w "s:f=0 opa(i,obj,properts)=$p($p(^Q(1,""XQuery"","""_query_""",""XQcond""),"" "",i),"","",4),opa(i,obj,properts,""np"")=$g(np),opa(i,obj,properts,""pr"")=$g(pr),opa(i,obj,properts,""vr"")=$g(vr)",!
 w "}",!        ;конец for

 w "m ^opa=opa",!

 w "s xx=""""",!         
 w "For  {",!
 w "s xx=$o(opa(xx))  q:xx=""""",!
 w "s x=""""",!
 w "For  {",!                         
 w "s x=$o(opa(xx,x))  q:x=""""",!
 w "w ""<obj qqo='""_x_""'>"",!",!      
 w "s y=""""",!
 w "For i=1:1 {",!
 w "s y=$o(opa(xx,x,y))  q:y=""""",!
 w "w ""<property qqw='""_y_""'>"",!",!
 ;Если введено имя, то создать тег
 w "i $g(opa(xx,x,y,""np""))'="""" {",!

 w "}",!
 ;Если введено понятие развертки, то закачать первые 200
 w "i $g(opa(xx,x,y,""pr""))'="""" {",!
 w "w ""<list></list>"",!",!
 w "s cc=""""  f sl=1:1:200 {",!
 w "s cc=$o(^Q(1,opa(xx,x,y,""pr""),cc)) q:cc=""""",!
 w "w ""<list>""_cc_""</list>"",!",! 
 w "}",!
 w "}",!
 w "w ""<edit>""_$s($g(opa(xx,x,y,""vr""))'="""":opa(xx,x,y,""vr""),1:0)_""</edit>"",!",!                   
 w "w ""</property>"",!",!
 w "}",!
 w "w ""</obj>"" ",!
 w "}",!
 w "}",!    



 w "</script>",!

 w "</query>",!
 w "</response>",!

 c f


 s f=path_q_"resp.csp"
 o f:"nw":7
 u f

 w "<?xml version=""1.0"" encoding=""windows-1251""?>",!
 w:$g(^Q(1,qqoQu,query,"XQCSPxsl1"))'="" "<?xml:stylesheet href="""_^Q(1,qqoQu,query,"XQCSPxsl2")_""" type=""text/xsl""?>",!
 w "<answer xmlns:qq=""aaaaaa"">",!
 /////////////////////////// Прием и обработка данных из формы 
 w "<script language=""Cache"" runat=""server""> ",!
 w "s nameprop=""""",!
 w "s qqnump=0",!
 w "s qview=$s($d(^Q(1,""XQuery"","""_query_""",""XQName"")):^Q(1,""XQuery"","""_query_""",""XQName""),1:""noname"")",!
 w "k tempa",! 
 ;w "k ^opa",!    ///для работы не нужен
 w "s nump=""""",!
 w "For i = 1:1 {",!
 w "q:%request.Next(nameprop)=""""",!

 w "s nameprop=%request.Next(nameprop)",!

 ;w "s ^opa(nameprop)=$g(%request.Data(nameprop,1))",! ///не нужен для работы

 w "i $e(nameprop,1,3)'=""CSP""  {",!
 w "s nump=nump+1",! ;подсчет полученных свойств
 w "s Vs(""par"",8,$p(nameprop,"",""),$p(nameprop,"","",2))=$g(%request.Data(nameprop,1))",!
 w "}",!
 w "}",!


 w "s qWEB=##class(%qWEB).%New()",!
 w "s qW=##class(%qWORD).%New()",!
 w "s qARM=##class(%TqARM).%New()",!
 w "s qSYS=##class(%qSYS).%New()",!
 w "X ""S qUSER=##class(qUSER).%New()""",!
 w "s qqc=""""",!

 ;w "w $zu(67,15,$j)",!
 ;w "s i="""" for  s i=$O(%request.CgiEnvs(i))  q:i=""""  Write !,""<br>""_i_"": ""_%request.CgiEnvs(i)_""</br>""",!

 w "s IP=%request.CgiEnvs(""SERVER_NAME""),IP=$S(IP=""localhost"":""127.0.0.1"",1:IP)",!
 ;w "s IP=%request.CgiEnvs(""REMOTE_ADDR""),IP=$S(IP=""localhost"":""127.0.0.1"",1:IP)",!

 ;w "w ""IP=""_%request.CgiEnvs(""REMOTE_ADDR"")",!
 w "S qARM(""CntStr"")=""cn_iptcp:""_IP_""[1972]:"_$ZU(5)_"""",! 

 ;s Vs(qqnump,99,"Pic")=1;-------ввести в QueryExt для отображения фоток

 ;w "zw Vs",!

 w "m Vs(""par"")=^Q(1,""XQuery"","""_query_""",""XObjStat"")",!        ;учет состояния отображения запроса
 w "k ^VstempCSP(%session.SessionId)",!
 w "m ^VstempCSP(%session.SessionId)=Vs",!
 ;;w "s %session.Preserve=1",!   ;сохранение всей локальной области сессии

 w "D:nump'="""" qWEB.QueryExt($s($g(^Q(1,""XQuery"","""_query_""",""XQView""))'="""":^Q(1,""XQuery"","""_query_""",""XQView""),1:$p("""_query_""",""qq""))_"" U"",1)",!
 w "s ViewId=$s($g(^Q(1,""XQuery"","""_query_""",""XQView""))'="""":^Q(1,""XQuery"","""_query_""",""XQView""),1:$p("""_query_""",""qq""))",!
 ;w "w $s($g(^Q(1,""XQuery"","""_query_""",""XQView""))'="""":^Q(1,""XQuery"","""_query_""",""XQView""),1:$p("""_query_""",""qq""))_"" U""",!



 ;Релевантные в ^Q(Vs(qqnump,"Relind")_qview)
 ;w "w nump",!
 ;w "zw ^Q(Vs(qqnump,""Relind"")_qview)",!
 ;w "w $g(Vs(qqnump,""Relind""))",!
 ;w "w $g(qview)",!

 /////////////////////////////////////////////



 ///////////////////////////////   Если что-то найдено, создать xml
 w "i $g(Vs(qqnump,""RelNum""))=1,nump'=""""  {",!      

 w "n P,T,S,D",!

 ;w "i $g(ViewId)="""" s ViewId=""###a""",!
 w "i $g(ObjId)="""" s ObjId="""_ObjId_"""",!          ;корень для вывода на страницу
 w "i $g(RelevId)="""" s RelevId=""0""_ViewId_"" ""_$J",!

 w "s T=2",!
 w "s T(1)=""^Q(""""""_RelevId_"""""",""""""_ObjId_"""""")""",!
 w "s T(2)=""^Q(1,""""""_ObjId_"""""")""",!
 w "s nump=$s(@T(1)#"_numroot_"=0:@T(1)\"_numroot_",1:(@T(1)\"_numroot_"+1))",! ;определение количества страниц для вывода результата


 w "s x="""",y=1  f  {",!
 w "s x=$o(@T(1)@(x)) q:x=""""",!
 ;w "w x,!",!
 w "}",!


 /////////////            Запись в xml информации о количестве страниц и их "координатах"
 w "w ""<pages num='""_nump_""'>"",!",!
 w "i nump=1 w ""<page num='1'><beg></beg><end>[</end></page>"",!",!
 w "",!
 w "s x="""",y=1  f  {",!
 w "s x=$o(@T(1)@(x)) ",!
 w "i y#"_numroot_"=0,nump'=1   { ",!
 w "s np=(y\"_numroot_")",!
 w "w ""<page num='""_np_""'>"",!",!
 w "i np=1 s beg=x  w ""<beg></beg><end>""_x_""</end>"",!",!
 w "i np'=1 w ""<beg>""_beg_""</beg><end>""_x_""</end>"",!  s beg=x",!
 w "w ""</page>"",!",!
 w "}",!
 w "i x="""",@T(1)#"_numroot_"'=0,nump'=1 w ""<page num='end'><beg>""_$g(beg)_""</beg><end>[</end></page>""",!
 w "q:x=""""",!
 w "s y=y+1",!
 w "}",!
 w "w ""</pages>"",!",!
 /////////////

 w "s S=1",!
 ;s S(1)="^Q(1,""XView"","""_ViewId_""")",!
 w "s S(1)=""^Q(1)""",!

 w "s D=""^Q(1)""",!


 w "s P(""TreeT"")=0",! ; 0/1 - лог./физ. дерево
 w "s P(""Coll"")=1",! ; 0/1 - один узел/коллекция узлов
 w "s P(""TargT"")=1",! ; 0/1/2 - вывод результата в: перменная/текущ.устр./файл
 w "s P(""TargN"")=""c:\TestRel.xml""",! ; имя файла или переменной
 w "s P(""Title"")=""""",! ; пролог XML-документа
 w "s P(""EndDoc"")=""""",! ; то, что надо вписать после вывода узлов
 ;w "s P(""qqoRoot"")=""3""",! ; для одного узла и коллекции - qqo корневого элемента
 w "s P(""qqcRoot"")=""""",! ; для одного узла - qqc корневого элемента
 w "s P(""qqcBegin"")=""""",! ; для коллекции - первый узел (НЕ включительно)
 w "s P(""qqcEnd"")=""[""",! ; для коллекции - последний узел (включительно)       
 w "s P(""Pos"")=0",! ; 0/1 - несч./считать qqc позиц.кодом и по нему сортировать
 w "s P(""CodeN"")=0",! ; 0/1/2 - выводить имена/их коды/и то и другое
 w "s P(""CodeV"")=0",! ; 0/1 - выводить значения/их коды
 w "s P(""GetC"")=1",! ; 0/1-невыводить/выводить коды узлов qqc
 w "s P(""GetCC"")=0",! ; 0/1 - невыводить/выводить не пустые значения об. узлов
 w "s P(""Format"")=1",! ; 0/1 - выводить атрибуты в строку/столбец
 w "s P(""Error"")=0",! ; запись ошибок
 w "s P(""ListNS"")=""""",! ; список префиксов тех NS, которые д.б.декларированы в корне
 w "s P(""GetDTD"")=0",! ; 0/1-нет/да подать DTD, включающее компоненты и нотации
 w "s P(""ListEnt"")=""""",! ; список компонент, которые д.б.декларированы в DTD
 w "s P(""DirCh"")=0",! ; 0/1 - нет/да-список дочерних не искать в опис., а составлять
 w "s P(""ListNot"")=""""",! ; список нотаций, которые д.б.декларированы в DTD
 w "s P(""AttAsElem"")=1",! ; 0/1-нет/да выводить атрибуты как элементы 



 w "d qWEB.GetXML(.P,.T,.S,.D)",!



 ;w "d qWEB.XML(0,1,1,0,1,0,10000,1)",!


 w "}",! 
 ////////////////////////////////////////////////////


 w "</script>",!

 w "</answer>",!

 c f





 i dir'="" d qARM.Message("Приложения CSP области """_namespace_""" нет в конфигурации Cache. Файлы CSP созданы в "_path_". Первая страница обращения "_q_".csp")  q
 d qARM.Message("Файлы CSP созданы в "_path_". Первая страница обращения "_appl_"/"_q_".csp")
 q
]]></Implementation>
</Method>

<Method name="RNote">
<Description>
Вызов замечаний по реализации и отметка их прочитанности</Description>
<Internal/>
<FormalSpec>Arg:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Arg)=1 Q $G(^Q(1,"XView","XXXX","Rnote",quser)) ;проверка непрочитанности
 I $G(Arg)=2 D  Q  ;создание нового ресурса для кнопки тулбара
 .I '$D(qwin("ILRNote")) D qARM.wC("TCustomImageList","ILRNote") D qARM.wM(,"Fill",$TR("R,337 R,338"," ",$C(13))) S qwin("ILRNote")=1
 .D qARM.wP(qwin_".TBH","Images","ILRNote")
 .I $G(^Q(1,"XView","XXXX","Rnote",quser)) D qARM.wP(qwin_".TBH.b101","ImageIndex",1),qARM.wP(qwin_".TBH.b101","Hint","Текущие Замечания по реализации qWORD'а ("_$ZD($G(^%QView,$H),4)_")") Q
 .D qARM.wP(qwin_".TBH.b101","ImageIndex",0),qARM.wP(qwin_".TBH.b101","Hint","Есть новые Замечания по реализации qWORD'а ("_$ZD($G(^%QView,$H),4)_")") Q
 N qqLasT S ^Q(1,"XView","XXXX","Rnote",quser)=1
 S qqLasT=$G(^Q(1,"XView","XXXX","Rnote"),$ZD($H,8)) ;дата предыдущего обновления
 D:$G(qqLasT)'="" qARM.OpenWindow(,,",,0,1 1 20",qqLasT_" XDocRN1",,"XXXRNw")
]]></Implementation>
</Method>

<Method name="RedCC">
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 q:'$D(W("CC")) ""
 D:qqo="Xo29"!(qqo="Xo72") 
 .N i F i=$L(W("CC"),","):-1:1  Q:$P(W("CC"),",",i)'=""
 .S W("CC")=$P(W("CC"),",",1,i) S:$G(qqwchg)'["CC" qqwchg=$G(qqwchg)_" "_"CC"
 Q ""
]]></Implementation>
</Method>

<Method name="RedDCpar">
<Description>
Развертка для редактирования понятия %Хранимые параметры (XDCpar)
Arg3 - откуда брать значение</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N str S str="X731 x730 X73 X740 X741 x742 X744 X74 X75 x710 X745 X720 X76 X747 X72 x760 X761"
 G:$G(Arg2)'="" @Arg2
 N zzz S zzz=$s($g(Arg3)'="":@Arg3,1:qW.GE(qqw)) K qqwold
 G DCparC:zzz["," ;,DCparW
 D qARM.MenuWoc(qqw,"Редактирование параметров~Выбор образца","",1,"D qSYS.RedDCpar(,""DCparM"""_$S($g(Arg3)'="":","""_qSYS.dblqw(Arg3)_"""",1:"")_")")
 Q
DCparM ;выбор по меню
 I $E(qqchoice,$L(qqchoice))=1 D qARM.StartEdit(1,1,"CxWoc     $E(Z,1,2)=""Zt""||($E(Z,1,2)=""MS"")") Q
DCparC ;Вызов редактирования параметров ячейки
 S:$G(Arg1)="" Arg1=qqnump
 N DCpar S DCpar=$s($g(Arg3)'="":@Arg3,1:qW.G("XDCpar")) 
 S ^Q(1,"XView","redSTATUS"_quser,"CxObj","DCpar","Xy",0,"Xx",0)=""
 N i F i=1:1:$L(str," ") S ^Q(1,"XView","redSTATUS"_quser,"CxObj","DCpar","Xy",0,"Xx",0,$P(str," ",i))=..PSYN(DCpar,",",i,,,1)
 S Vo("par",-1,72)="0 D qSYS.RedDCpar("_Arg1_",""DCpar123"""_$S($g(Arg3)'="":","""_qSYS.dblqw(Arg3)_"""",1:"")_")"
 S Vo("par",-1,73)=1
 D ..CallDCpar("redSTATUS"_quser,"DCpar",0,0)
 Q ""
DCpar123 N i S W("XDCpar")="" F i=1:1:$L(str," ") S Z=$G(^Q(1,"XView","redSTATUS"_quser,"CxObj","DCpar","Xy",0,"Xx",0,$P(str," ",i))) S:Z["," Z=""""_..dblqw(Z)_"""" S W("XDCpar")=$G(W("XDCpar"))_Z_$S(i<$L(str," "):",",1:"") 
 K ^Q(1,"XView","redSTATUS"_quser)
 i $g(Arg3)'="" s @Arg3=W("XDCpar") d qARM.wwrefr() Q
 D qW.rCor(Vs(qqnump,"CurObj"),qqc,"XDCpar",,0) D qARM.wwww("XDCpar")
 Q ""
]]></Implementation>
</Method>

<Method name="Redview">
<Description>
Редактирование отображения</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%String,Arg3:%String,Arg4:%String,Arg5:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 N i,x,y,Obj,qfl,xmax,qqview
 S qqview=Vo(qqnump) ;@dol 11.09.03 $P(qview," ") ;код отображения
 I $E(Arg1)?1N,Arg1<20,$G(W("ZBt0")) S Obj=$P(W("Zpos",1,"d")," "),y=$P(W("Zpos",1,"d")," ",2),x=W("Zpos",1,"x")-1 ;объект строка ячейка
 ;D qARM.Message("-"_Arg1_"-")
 G @$S(Arg1?1.N:"Redv"_Arg1,1:Arg1)
Redv0
 S W("Zomod")=1 D qARM.wP("-qARM","Cursor",-11),qARM.wcro(),qARM.wM(,"M9",1,0,Obj_" "_y,1) Q:$Q "" Q
Redv1   ;Вставить новую строку после текущей
 F i=$O(Vo(qqnump,Obj,0,""),-1):-1:y+1 I $D(Vo(qqnump,Obj,0,i)) D
 .M Vo(qqnump,Obj,0,i+1)=Vo(qqnump,Obj,0,i) K Vo(qqnump,Obj,0,i)
 .M ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",i+1)=^Q(1,"XView",qqview,"CxObj",Obj,"Xy",i) K ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",i)
 S y=y+1,Vo(qqnump,Obj,0,y,0)="0..."
 S ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",0,"x70")=0,^("X71")="..."
 I $I(W("Zpos",1,"y"))
 G Redv0
Redv2   ;Удалить текущую строку в дереве обектов
 I 'y D qARM.Message("Недопустимо. Первая строка объекта") Q:$Q 1 Q
 K Vo(qqnump,Obj,0,y),^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y) I $I(W("Zpos",1,"y"),-1)
 D qARM.wM(qwin_".T1","M9",1,0,W("Zpos",1,"d"),0,0) ;найти и свернуть
 D qARM.wM(,"M6","",0)
 D qARM.wP(,"Selected",1,W("Zpos",1,"y"))
 ;D qARM.wM(,"M9",1,0,Obj_" "_(y-1),1)
 S W("Zomod")=1 Q:$Q "" Q
Redv30   ;вставить колонку в дереве объектов
 N Obj,y,x S Obj="",x=W("Zpos",1,"x")-1 F  S Obj=$O(^Q(1,"XView",qqview,"CxObj",Obj)) Q:Obj=""  D
 .S y="" F  S y=$O(^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y)) Q:y=""  D:$G(^(y,"X60"))=""
 ..S xmax=$O(Vo(qqnump,Obj,0,y,""),-1),qfl=$S(Vo(qqnump,-1,9)-1<xmax:0,1:1)
 ..I 'qfl,$I(Vo(qqnump,-1,9))
 ..F i=xmax:-1:x+1 D:$D(Vo(qqnump,Obj,0,y,i))
 ...M Vo(qqnump,Obj,0,y,i+1)=Vo(qqnump,Obj,0,y,i) K Vo(qqnump,Obj,0,y,i)
 ...M ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",i+1)=^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",i) K ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",i)
 S W("Zomod")=1 G Redv0
 ;
Redv3   ;вставить ячейку в дереве объектов
 S xmax=$O(Vo(qqnump,Obj,0,y,""),-1),qfl=$S(Vo(qqnump,-1,9)-1<xmax:0,1:1)
 I 'qfl,$I(Vo(qqnump,-1,9))
 F i=xmax:-1:x+1 D:$D(Vo(qqnump,Obj,0,y,i))
 .M Vo(qqnump,Obj,0,y,i+1)=Vo(qqnump,Obj,0,y,i) K Vo(qqnump,Obj,0,y,i)
 .M ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",i+1)=^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",i) K ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",i)
 .D:qfl qARM.wP(qwin_".T1","List",qARM.wcroCell(Obj,y,i+1),W("Zpos",1,"y"),i+2) ;Vo(qqnump,Obj,0,y,i+1),W("Zpos",1,"y"),i+2)
 S x=x+1,Vo(qqnump,Obj,0,y,x)="0 "
 S ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",x,"x70")=0,^("X71")=" "
 D:qfl qARM.wP(qwin_".T1","List",qARM.wcroCell(Obj,y,x),W("Zpos",1,"y"),x+1) ;Vo(qqnump,Obj,0,y,x),W("Zpos",1,"y"),x+1)
 S W("Zomod")=1 I qfl Q:$Q "" Q
 G Redv0
 ;
Redv40   ;удалить колонку в дереве объектов
 N Obj,y,xx S Obj="",x=W("Zpos",1,"x")-1 F  S Obj=$O(^Q(1,"XView",qqview,"CxObj",Obj)) Q:Obj=""  D
 .S y="" F  S y=$O(^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y)) Q:y=""  D:$G(^(y,"X60"))=""
 ..F i=x:1:$O(Vo(qqnump,Obj,0,y,""),-1) D
 ...K Vo(qqnump,Obj,0,y,i) M Vo(qqnump,Obj,0,y,i)=Vo(qqnump,Obj,0,y,i+1)
 ...K ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",i) M ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",i)=^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",i+1)
 S W("Zomod")=1 G Redv0
Redv4   ;удалить ячейку в дереве объектов
 F i=x:1:$O(Vo(qqnump,Obj,0,y,""),-1) D
 .K Vo(qqnump,Obj,0,y,i) M Vo(qqnump,Obj,0,y,i)=Vo(qqnump,Obj,0,y,i+1)
 .K ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",i) M ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",i)=^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",i+1)
 .D qARM.wP(qwin_".T1","List",qARM.wcroCell(Obj,y,i),W("Zpos",1,"y"),i+1) ;$G(Vo(qqnump,Obj,0,y,i)),W("Zpos",1,"y"),i+1)
 S W("Zomod")=1 Q:$Q "" Q
Redv5   ;Вставить новый объект нижнего уровня после текущей строки в дереве обектов
 ;вызов отображения выбора объекта
 S Vo("par",-1,23)="S W(""Zdomod"")=1" ;действие по входу   
 S Vo("par",-1,22)="D qSYS.Redview(50)" ;действие после выхода  
 D qARM.OpenWindow("","","",$P(W("Zpos",1,"d")," ")_" CxObj","","XXXCxObj")
 Q:$Q "" Q
Redv50 ;выполняется из отображения выбора объекто
 N NewObj,nump S NewObj=qqc,nump=qqnump Q:qqc[" "  ;@Dol 25.05.05 [" "
 ;I $D(Vo($P(qqParent," ",2),NewObj)) D qARM.Message("Выбранный объект есть в отображении") S qqend=0 Q
 I $D(^Q(1,"XView",Vo($P(qqParent," ",2)),"CxObj",NewObj)) D qARM.Message("Выбранный объект есть в отображении") S qqend=0 Q:$Q 1 Q
 D qARM.csav(),qARM.crst(,$P(qqParent," ",2)) S qwin="Q"_qqnump ;войдем в контекст вызова
 S qqview=Vo(qqnump) ;S qqview=$P(qview," ")
 S Obj=$P(W("Zpos",1,"d")," "),y=$P(W("Zpos",1,"d")," ",2),x=W("Zpos",1,"x")-1
 F i=$O(Vo(qqnump,Obj,0,""),-1):-1:y+1 D:$D(Vo(qqnump,Obj,0,i))
 .M Vo(qqnump,Obj,0,i+1)=Vo(qqnump,Obj,0,i) K Vo(qqnump,Obj,0,i)
 .M ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",i+1)=^Q(1,"XView",qqview,"CxObj",Obj,"Xy",i) K ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",i)
 S y=y+1,Vo(qqnump,Obj,0,y)=NewObj
 S ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"X60")=NewObj
 I $I(W("Zpos",1,"y"))
 S Vo(qqnump,NewObj)="@",Vo(qqnump,NewObj,0,0,0)="0@",Vo(qqnump,NewObj,0)=$G(^Q(1,"CxObj",NewObj,"X50"))
 S ^Q(1,"XView",qqview,"CxObj",NewObj,"X531")=1
 S ^Q(1,"XView",qqview,"CxObj",NewObj,"Xy",0,"Xx",0,"x70")=0,^("X71")="@"
 D qARM.wP("-qARM","Cursor",-11)
 I $G(W("Zcrea"))'="" D qSYS.CreObj(NewObj,$P(W("Zcrea")," ",1),qqview,$P(W("Zcrea")," ",2),0)
 D ..CreVo(),qARM.wcro(),qARM.wM(,"M9",1,0,NewObj_" "_0,1),qARM.csav(),qARM.crst(,nump) S qwin="Q"_qqnump S qqend=1
 S W("Zomod")=1 Q:$Q "" Q
Redv6   ;Вставить новый объект текущего уровня после текущей строки в дереве обектов
 I 'W("Zpos",1,"y") G Redv5 ;для вершины - только вставка нижнего уровня
 ;вызов отображения выбора объекта
 S Vo("par",-1,23)="S W(""Zdomod"")=1" ;действие по входу   
 S Vo("par",-1,22)="D qSYS.Redview(60)" ;действие после выхода  
 D qARM.OpenWindow("","","",$P(W("Zpos",1,"d")," ")_" CxObj","","XXXCxObj")
 Q:$Q "" Q
Redv60 ;выполняется из отображения выбора объекто
 N NewObj,nump S NewObj=qqc,nump=qqnump Q:qqc[" "  ;@Dol 25.05.05 [" "
 ;I $D(Vo($P(qqParent," ",2),NewObj)) D qARM.Message("Выбранный объект есть в отображении") S qqend=0 Q 1
 I $D(^Q(1,"XView",Vo($P(qqParent," ",2)),"CxObj",NewObj)) D qARM.Message("Выбранный объект есть в отображении") S qqend=0 Q:$Q 1 Q
 D qARM.csav(),qARM.crst(,$P(qqParent," ",2)) S qwin="Q"_qqnump ;войдем в контекст вызова
 S qqview=Vo(qqnump) ;S qqview=$P(qview," ")
 S Obj=$P(W("Zpos",1,"d")," "),y=$P(W("Zpos",1,"d")," ",2),x=W("Zpos",1,"x")-1
 ;
 N Obj1 S Obj1=$G($$$ObjRef(Obj)),Obj1=$P(Obj1,",",$L(Obj1,",")-1) S:Obj1="" Obj1=-1 ;объект-родитель
 S y="" F  S y=$O(Vo(qqnump,Obj1,0,y)) Q:y=""  Q:$G(Vo(qqnump,Obj1,0,y))=Obj
 S Obj=Obj1
 F i=$O(Vo(qqnump,Obj,0,""),-1):-1:y+1 D:$D(Vo(qqnump,Obj,0,i))
 .M Vo(qqnump,Obj,0,i+1)=Vo(qqnump,Obj,0,i) K Vo(qqnump,Obj,0,i)
 .M ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",i+1)=^Q(1,"XView",qqview,"CxObj",Obj,"Xy",i) K ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",i)
 S y=y+1,Vo(qqnump,Obj,0,y)=NewObj
 S ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"X60")=NewObj
 I $I(W("Zpos",1,"y"))
 S Vo(qqnump,NewObj)="@",Vo(qqnump,NewObj,0,0,0)="0@",Vo(qqnump,NewObj,0)=$G(^Q(1,"CxObj",NewObj,"X50"))
 S ^Q(1,"XView",qqview,"CxObj",NewObj,"X531")=1 ;подтверждение ввода
 S ^Q(1,"XView",qqview,"CxObj",NewObj,"Xy",0,"Xx",0,"x70")=0,^("X71")="@"
 D qARM.wP("-qARM","Cursor",-11)
 I $G(W("Zcrea"))'="" D qSYS.CreObj(NewObj,$P(W("Zcrea")," ",1),qqview,$P(W("Zcrea")," ",2),0)
 D ..CreVo(),qARM.wcro(),qARM.wM(,"M9",1,0,NewObj_" "_0,1),qARM.csav(),qARM.crst(,nump) S qwin="Q"_qqnump S qqend=1
 S W("Zomod")=1 Q:$Q "" Q
Redv7   ;Удалить текущий объект (и все нижележащие)
 I Obj=-1 D qARM.Message("Вершину отображения удалять нельзьзя") Q:$Q 1 Q
 I y D qARM.Message("Необходимо встать на первую строку объекта") Q:$Q 1 Q
 N Obj1 S Obj1=$$$ObjRef(Obj),Obj1=$P(Obj1,",",$L(Obj1,",")-1) S:Obj1="" Obj1=-1 ;объект-родитель
 S y="" F  S y=$O(Vo(qqnump,Obj1,0,y)) Q:y=""  Q:$G(Vo(qqnump,Obj1,0,y))=Obj
 K Vo(qqnump,Obj1,0,y),^Q(1,"XView",qqview,"CxObj",Obj1,"Xy",y) ;убрали ссылку из родителя
 S (x,Obj1)=$$$ObjRef(Obj)
 K Vo(qqnump,Obj),$$$MObjRef(x),^Q(1,"XView",qqview,"CxObj",Obj) ;убрали текущий объект
 F  S x=$O($$$MObjRef(x)) Q:x=""  Q:$P(x,",",1,$L(Obj1,","))'=Obj1  K $$$MObjRef(x),Vo(qqnump,$P(x,",",$L(x,","))),^Q(1,"XView",qqview,"CxObj",$P(x,",",$L(x,","))) ;уберем потомков
 D qARM.wM(qwin_".T1","M9",1,0,W("Zpos",1,"d"),0,0) ;найти и свернуть
 D qARM.wM(,"M6","",0)
 ;D qARM.wM(qwin_".T1","DeleteDependents",W("Zpos",1,"y")),qARM.wM(qwin_".T1","RemoveItem",W("Zpos",1,"y"))
 D qARM.wP(,"Selected",1,W("Zpos",1,"y")-1)
 S W("Zomod")=1 Q:$Q "" Q
 ;
Redv10
 ;перевывод ячейки (после редактирования содержимого)
 ;D qARM.Message("???")
 ;basmode - перенесенный из текущего окна (см. qARM.WrWin )признак модификации базы W("Zbasmod")
 I 'basmod Q:$Q "" Q
 S W("Zomod")=1
 I '$G(W("ZBt0")) D:$G(Vo(qqnump,-1,720)) qARM.wM(qwin_".StdBottomBar","Destroy") D qSYS.CreVo(),qARM.Grid() D qARM.wipa(),qARM.wcre(1) Q:$Q "" Q  ;@dol 3.2.04 Grid
 K Vo(qqnump,Obj,0,y,x) D
 .I $G(^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",x,"x70"))=9 K ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",x) Q  ;@dol 25.11.02 удалить из описания
 .S Vo(qqnump,Obj,0,y,x)=$G(^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",x,"x70"))_$G(^("X71"))
 D qARM.wP(qwin_".T1","List",qARM.wcroCell(Obj,y,x),W("Zpos",1,"y"),W("Zpos",1,"x"))
 I Obj=-1,'y N qk S qk=$P($G(Vo(qqnump,-1,0,y,x,2)),",") D:qk'="" qARM.wP(,"ColumnWidth",$S(qk["px":+qk,qk["%":$J(qARM("Screen","Width")*qk/100,0,0),1:qk*$P(W("Zfont"),",",3)),x+1)
 Q:$Q "" Q
Redv11
 ;перевывод отображения
 I 'basmod Q:$Q "" Q
 S W("Zomod")=1 D qARM.wP("-qARM","Cursor",-11),qSYS.CreVo(),qARM.Grid(),qARM.wcro() D:$G(W("ZBt0")) qARM.wM(qwin_".T1","M9",1,0,$G(W("Zpos",1,"d")),1) D:'$G(W("ZBt0")) qARM.wipa(),qARM.MenuView("",-1),qARM.MenuView(W("Zadm")),qARM.wcre(),qARM.MenuAn("F") Q:$Q "" Q
Redv12 ;копирование ячейки (в объект Arg2, стр Arg3 кол Arg4 из объекта текущего Obj)
 S W("Zomod")=1
 I $G(Vt(qqnump,"Zmenu94"))'=2 D  I 1
 .K ^Q(1,"XView",qqview,"CxObj",Arg2,"Xy",Arg3,"Xx",Arg4) K Vo(qqnump,Arg2,0,Arg3,Arg4)
 .M ^Q(1,"XView",qqview,"CxObj",Arg2,"Xy",Arg3,"Xx",Arg4)=^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",x)
 .M Vo(qqnump,Arg2,0,Arg3,Arg4)=Vo(qqnump,Obj,0,y,x)
 E  D
 .K ^Q(1,"XView",qqview,"CxObj",Arg2,"Xy",Arg3,"Xx",Arg4,"X72") K Vo(qqnump,Arg2,0,Arg3,Arg4,2)
 .M ^Q(1,"XView",qqview,"CxObj",Arg2,"Xy",Arg3,"Xx",Arg4,"X72")=^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",x,"X72")
 .M Vo(qqnump,Arg2,0,Arg3,Arg4,2)=Vo(qqnump,Obj,0,y,x,2)
 I $G(Vt(qqnump,"Zmenu94"),1)=1 K ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",x) K Vo(qqnump,Obj,0,y,x)
 D qARM.wP(qwin_".T1","List",qARM.wcroCell(Arg2,Arg3,Arg4),Arg5,Arg4+1) D:$G(Vt(qqnump,"Zmenu94"),1)=1 qARM.wP(,"List","",W("Zpos",1,"y"),W("Zpos",1,"x"))
 Q:$Q "" Q
Redv13 ;заменить параметры всех ячеек
 S Arg3=$P(Arg2,">>",1),Arg2=$P(Arg2,">>",2) I Arg3="" D qARM.Message("Замена пустых недопустима") Q:$Q "" Q
 S Arg1=..ChViewPar("X72",Arg3,Arg2) D qARM.Message("Заменено вхождений: "_Arg1),..CreVo() G Redv0
Redv14 ;создать для вершины ячейки с константами заголовков строк всех объектов
 D ..CreTitleTab(1) G Redv0
Redv15 ;Переместить строки\объекты
 I 'y D  S Obj=Arg2,y=0 G Redv0 ;перенос объекта
 .N Obj1 S Obj1=$$$ObjRef(Obj),Obj1=$P(Obj1,",",$L(Obj1,",")-1) S:Obj1="" Obj1=-1 ;объект-родитель
 .S y="" F  S y=$O(Vo(qqnump,Obj1,0,y)) Q:y=""  Q:$G(Vo(qqnump,Obj1,0,y))=Obj
 .S Obj=Obj1
 .I Obj'=Arg2,$G(Vt(qqnump,"Zmenu94"),1)=1 D qARM.Message("Перенос только в пределах общего потомка") Q
 .K Vo(qqnump,Arg2,0,Arg3) S Vo(qqnump,Arg2,0,Arg3)=Vo(qqnump,Obj,0,y)
 .K ^Q(1,"XView",qqview,"CxObj",Arg2,"Xy",Arg3) S ^Q(1,"XView",qqview,"CxObj",Arg2,"Xy",Arg3,"X60")=Vo(qqnump,Obj,0,y)
 .K Vo(qqnump,Obj,0,y),^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y)
 ;перенос строки
 K Vo(qqnump,Arg2,0,Arg3) M Vo(qqnump,Arg2,0,Arg3)=Vo(qqnump,Obj,0,y)
 K ^Q(1,"XView",qqview,"CxObj",Arg2,"Xy",Arg3) M ^Q(1,"XView",qqview,"CxObj",Arg2,"Xy",Arg3)=^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y)
 K:Obj=Arg2 Vo(qqnump,Obj,0,y),^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y) ;:Obj=Arg2 @Dol 7.01.06
 S Obj=Arg2,y=Arg3 G Redv0
Redv16 ;Создать колонки
 Q:'Text "" S Vo(qqnump,-1,9)=Text-1
 F y=0:1:Text-1 S Vo(qqnump,-1,0,0,y,2)=$P(Text,",",2,255),^Q(1,"XView",qqview,"CxObj",-1,"Xy",0,"Xx",y,"X72")=Vo(qqnump,-1,0,0,y,2) S:$G(Vo(qqnump,-1,0,0,y))="" Vo(qqnump,-1,0,0,y)=0,^Q(1,"XView",qqview,"CxObj",-1,"Xy",0,"Xx",y,"x70")=0 ;@Dol 22.09.04
 G Redv0
 ;Сохранение во временном массиве ;@dol 12.10.02 более корректная обработка блокировки ; 15.12.2008 Kokarev
SavTmp n refTmpGl s refTmpGl=$na($$$tmpGl("qview",$ZU(5),qqview)) ; 15.12.2008 Kokarev
 N stat S stat=$G(@refTmpGl)
 I stat'="",$P(stat," ")'=$j D  I stat'="" D qARM.Question("Отображение блокировано (?редактируется) "_$TR($ZDT($P(stat," ",2),4),"/",".")_" """_$P(stat," ",3)_""". Разблокировать",0,"","K "_refTmpGl) D qARM.wbut(1) Q:$Q 1 Q  ;@Dol 07.05.08 Разблокировка
 .I $H>$P(stat," ",2)!($G(qARM("ComputerName"))=$P(stat," ",3)) K @refTmpGl S stat=""
 I '$D(@refTmpGl) M @refTmpGl=^Q(1,"XView",qqview) S @refTmpGl=$j_" "_$H_" "_$G(qARM("ComputerName")) ;сохранили состояние
 ;S W("Zomod")=1 
 Q:$Q "" Q
 ;восстановление из временного массива ; 15.12.2008 Kokarev
Rest I $P($G($$$tmpGl("qview",$ZU(5),qqview))," ")=$j K ^Q(1,"XView",qqview) M ^Q(1,"XView",qqview)=$$$tmpGl("qview",$ZU(5),qqview)
 S W("Zomod")=0 Q:$Q 1 Q
 ;Удаление временного массива ; 15.12.2008 Kokarev
Kill K $$$tmpGl("qview",$ZU(5),qqview) Q:$Q "" Q
 ;сохранить в буфере ; 15.12.2008 Kokarev
SavBuf K $$$tmpGl("qbuf",$J) M $$$tmpGl("qbuf",$J)=^Q(1,"XView",qqview) Q:$Q "" Q
 ;восстановить из буфера ; 15.12.2008 Kokarev
RestBuf I '$D($$$tmpGl("qbuf",$J)) D qARM.Message("Нет сохраненного состояния") Q:$Q 1 Q
 D qARM.Question("Восстановить ранее сохраненное состояние",1,"","D qSYS.Redview(""Restore"")") Q:$Q "" Q
 ; 15.12.2008 Kokarev
Restore N qqX,qqXc S qqX=$G(^Q(1,"XView",qqview,"X")),qqXc=$G(^Q(1,"XView",qqview,"Xc")) ;@dol 22.10.02 сохранить дату/время коррекции
 K ^Q(1,"XView",qqview) S W("Zomod")=1
 M ^Q(1,"XView",qqview)=$$$tmpGl("qbuf",$J)
 S ^Q(1,"XView",qqview,"X")=qqX,^Q(1,"XView",qqview,"Xc")=qqXc
 D qARM.wP("-qARM","Cursor",-11),..CreVo(),qARM.wcro() Q:$Q "" Q
 ;копирование описания объекта
ResObj I 'W("Zpos",1,"y") D qARM.Message("Не выбран объект") Q:$Q "" Q  ;для вершины - только вставка нижнего уровня
 S Obj=$P(W("Zpos",1,"d")," ")
 S x=0,y="" F  S y=$O(Vo(qqnump,Obj,0,y)) Q:y=""  S x=$G(Vo(qqnump,Obj,0,y))'=""
 I x D qARM.Message("У текущего объекта не должно быть потомков") Q ""
 ;вызов отображения выбора отображения
 S Vo("par",-1,29)=",,0,11",Vo("par",-1,62)=1 ;,Vo("par",-1,61)=1
 S Vo("par",-1,72)="1  D qSYS.Redview(""ResObjDo"","_+$G(Arg2)_")"
 S Vo("par",-1,73)=1
 D qARM.OpenWindow(,,,,,"XXXXVCH")
 Q:$Q "" Q
 ;копирование описания объекта Arg2 из другого отображения Arg3 (объект Arg4, для общности)
ResObjDo S Obj=$P(W("Zpos",1,"d")," ")
 I '$D(^Q(1,"XView",qqc,"CxObj",Obj,"Xy")) D qARM.Message("В отображении "_qqc_"нет объекта"_Obj) Q:$Q 1 Q
 K ^Q(1,"XView",qqview,"CxObj",Obj) S W("Zomod")=1
 M ^Q(1,"XView",qqview,"CxObj",Obj)=^Q(1,"XView",qqc,"CxObj",Obj)
 I '$G(Arg2) D  I 1  ;один объект - удалим ссылки на потомков
 .S y="" F  S y=$O(^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y)) Q:y=""  I $G(^(y,"X60"))'="" K ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y)
 E  D ResDoo(Obj) ; поддерево - скопируем потомков
 D qARM.wP("-qARM","Cursor",-11),..CreVo(),qARM.wcro() Q:$Q "" Q
ResDoo(Obj) N y,x S y="" F  S y=$O(^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y)) Q:y=""  S x=$G(^(y,"X60")) I x'="" M ^Q(1,"XView",qqview,"CxObj",x)=^Q(1,"XView",qqc,"CxObj",x) D ResDoo(x)
 Q
 ;копирование отображения
ResView S x=0,y="" F  S y=$O(Vo(qqnump,-1,0,y)) Q:y=""  S x=$G(Vo(qqnump,-1,0,y))'=""
 I x D qARM.Message("Текущее отображение должно быть пустым") Q:$Q "" Q
 ;вызов отображения выбора отображения
 S Vo("par",-1,29)=",,0,11",Vo("par",-1,62)=1 ;,Vo("par",-1,61)=1
 S Vo("par",-1,72)="1  D qSYS.Redview(""ResViewDo"")"
 S Vo("par",-1,73)=1
 D qARM.OpenWindow(,,,,,"XXXXVCH")
 Q:$Q "" Q
 ;копирование отображения
ResViewDo N qqX,qqXc S qqX=$G(^Q(1,"XView",qqview,"X")),qqXc=$G(^Q(1,"XView",qqview,"Xc")) ;@dol 22.10.02 сохранить дату/время коррекции
 K ^Q(1,"XView",qqview) S W("Zomod")=1 M ^Q(1,"XView",qqview)=^Q(1,"XView",qqc)
 S ^Q(1,"XView",qqview,"X")=qqX,^Q(1,"XView",qqview,"Xc")=qqXc
 D qARM.wP("-qARM","Cursor",-11),..CreVo(),qARM.wcro()
 Q:$Q "" Q
 ;сохранение ячейки sasha 20080717 ; 15.12.2008 Kokarev
SavCell S Obj=$P(W("Zpos",1,"d")," "),y=$P(W("Zpos",1,"d")," ",2),x=W("Zpos",1,"x")-1 ;объект строка ячейка
 K $$$tmpGl("qbufcell",$J) M $$$tmpGl("qbufcell",$J)=^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",x)
 Q:$Q "" Q
ResCell
 //проверка на наличие данных в ячейке  при копировании sasha 20080718
 S Obj=$P(W("Zpos",1,"d")," "),y=$P(W("Zpos",1,"d")," ",2),x=W("Zpos",1,"x")-1 ;объект строка ячейка
 I $G(Vo(qqnump,Obj,0,y,x))'="" d qARM.Question("Заместить",1,"","D qSYS.Redview(""ResCell1"")") Q:$Q "" Q
 e  d ResCell1
 Q:$Q "" Q
 ;копирование ячейки из bufcell  sasha 20080717 ; 15.12.2008 Kokarev
ResCell1 I '$D($$$tmpGl("qbufcell",$J)) d qARM.Message("Нет сохраненной ячейки") Q:$Q 1 Q
 S Obj=$P(W("Zpos",1,"d")," "),y=$P(W("Zpos",1,"d")," ",2),x=W("Zpos",1,"x")-1 ;объект строка ячейка
 S W("Zomod")=1
 K ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",x) K Vo(qqnump,Obj,0,y,x)
 M ^Q(1,"XView",qqview,"CxObj",Obj,"Xy",y,"Xx",x)=$$$tmpGl("qbufcell",$J)
 d qARM.wP(qwin_".T1","List",qARM.wcroCell(Obj,y,x),W("Zpos",1,"y"),x+1)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="RelView">
<Internal/>
<FormalSpec>qqo:%Library.String,qqc:%Library.String,Rel:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N Reli S Reli=$$$Relind
 I '$D(qqo) N qview S qview="XXXX"_$S(quser="#":"",quser="U":" "_$J,1:" "_quser) D  ;вызов из запроса
 .S qqo=$G(Vs($P(qqParent," ",2),"CurObj")),qqc=$G(Vs($P(qqParent," ",2),"ID")),Reli=$G(Vs($P(qqParent," ",2),"Relind"))
 I qqo'="CxObj",qqo'="XView" Q:$Q 0 Q
 I '$D(qview) S qview=$G(Vo(qqnump))_" "_$G(quser,$J) K ^Q(Reli_qview) ;@dol 11.10.03
 N qqrn,Lqqw,Lqqo,ii,qqoo,qqww,qq,y,x,z S qqrn=$S('$G(Rel):1,$D(^Q(Reli_qview,qqo))>1:Reli_qview,1:1)
 I qqo="XView" D  Q:$Q 1 Q  ;обход объектов отображения
 .D:qqrn=1  Q:qqrn=1  S qqc="" F  S qqc=$O(^Q(qqrn,qqo,qqc)) Q:qqc=""  D
 ..S qqoo="" F  S qqoo=$O(^Q(1,qqo,qqc,"CxObj",qqoo)) Q:qqoo=""  D:$D(^Q(1,"CxObj",qqoo))!(qqoo=-1)
 ...I qqoo'=-1,'$D(^Q(Reli_qview,"CxObj",qqoo)),$I(^Q(Reli_qview,"CxObj")) S ^Q(Reli_qview,"CxObj",qqoo)="" ;включение объекта в релевантные
 ...S qq=$G(^Q(1,qqo,qqc,"CxObj",qqoo,"X57")) F ii=1:1:$L(qq," ") S qqww=$P(qq," ",ii) I qqww'="",$D(^Q(1,"CxWoc",qqww)),'$D(^Q(Reli_qview,"CxWoc",qqww)),$I(^Q(Reli_qview,"CxWoc")) S ^Q(Reli_qview,"CxWoc",qqww)="" ;включение доп.понятия в релевантные
 ...S y="" F  S y=$O(^Q(1,qqo,qqc,"CxObj",qqoo,"Xy",y)) Q:y=""  S x="" F  S x=$O(^Q(1,qqo,qqc,"CxObj",qqoo,"Xy",y,"Xx",x)) Q:x=""  I "234"[$G(^(x,"x70")) D
 ....S qqww=$G(^("X71")) I qqww'="",$D(^Q(1,"CxWoc",qqww)),'$D(^Q(Reli_qview,"CxWoc",qqww)),$I(^Q(Reli_qview,"CxWoc")) S ^Q(Reli_qview,"CxWoc",qqww)=""
 ..I qqrn=1,'$D(^Q(Reli_qview,"XView",qqc)),$I(^Q(Reli_qview,"XView")) S ^Q(Reli_qview,"XView",qqc)=""
 ;обход понятий объектов
 D:qqrn=1  Q:qqrn=1 1 S qqc="" F  S qqc=$O(^Q(qqrn,qqo,qqc)) Q:qqc=""  D
 .S qq=$G(^Q(1,"CxObj",qqc,"xWoc")) F ii=1:1:$L(qq," ") S qqww=$P(qq," ",ii) I qqww'="",$D(^Q(1,"CxWoc",qqww)),'$D(^Q(Reli_qview,"CxWoc",qqww)),$I(^Q(Reli_qview,"CxWoc")) S ^Q(Reli_qview,"CxWoc",qqww)="" ;включение понятия в релевантные
 Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="RepObjView">
<Description>
Arg1 - спискок пар объектов через пробел (old:new)
Arg2 - код отображения</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 Q:$G(Arg1)=""
 N oldo,newo,X0Ref,q0,n,xObj  
 F i=1:1:$L(Arg1," ")  D:$P(Arg1," ",i)'="" 
 .S oldo=$P($P(Arg1," ",i),":"),newo=$P($P(Arg1," ",i),":",2) I oldo="" I newo="" Q
 .D:0 qARM.Message(oldo_""_newo)
 .S XORef=^Q(1,"CxObj",oldo,"XORef"),q0=$L(XORef,",") 
 .S:q0'="" ^Q(1,"CxObj",newo,"XORef")=$P(XORef,",",1,q0-1)_","_newo,XORef=$P(XORef,",",q0-1)
 .S ^Q(1,"CxObj",newo,"xObj")=$G(^Q(1,"CxObj",oldo,"xObj"))
 .I $D(^Q(1,"XView",Arg2,"CxObj",oldo)) M ^Q(1,"XView",Arg2,"CxObj",newo)=^Q(1,"XView",Arg2,"CxObj",oldo) K ^Q(1,"XView",Arg2,"CxObj",oldo) D 
 ..S n="" F  S n=$O(^Q(1,"XView",Arg2,"CxObj",XORef,"Xy",n)) Q:n=""  D:$G(^Q(1,"XView",Arg2,"CxObj",XORef,"Xy",n,"X60"))=oldo
 ...S ^Q(1,"XView",Arg2,"CxObj",XORef,"Xy",n,"X60")=newo
 ...S xObj=^Q(1,"XView",Arg2,"CxObj",XORef,"xObj"),^Q(1,"XView",Arg2,"CxObj",XORef,"xObj")=$P(xObj," "_oldo_" ")_" "_newo_" "_$P(xObj," "_oldo_" ",2)
 Q
]]></Implementation>
</Method>

<Method name="RulSave">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 G @("Rul"_Arg1)
RulXusr N beg0,end0,dobf0,beg,end,dobf S dobf0="D qSYS.QUser(1,,1)",beg0="K ^QUser",end0="D qSYS.QUser(,1,1)",beg=qW.GE("XUDoBeg"),end=qW.GE("XUDoEnd"),dobf=qW.GE("XRef2")
 I Z=1 S W("XUDoBeg")=$G(beg)_$S(beg[beg0:"",1:$S($G(beg)="":"",1:" ")_beg0),W("XUDoEnd")=$G(end)_$S(end[end0:"",1:$S($G(end)="":"",1:" ")_end0),W("XRef2")=$G(dobf)_$S(dobf[dobf0:"",1:$S($G(dobf)="":"",1:" ")_dobf0)
 I Z=0 S W("XUDoBeg")=$S(beg[beg0:qW.zReplace(beg,beg0,""),1:beg),W("XUDoEnd")=$S(end[end0:qW.zReplace(end,end0,""),1:end),W("XRef2")=$S(dobf[dobf0:qW.zReplace(dobf,dobf0,""),1:dobf)
 D qARM.wwww("XUDoBeg XUDoEnd XRef2") S qqwchg=$G(qqwchg)_" XUDoBeg XUDoEnd XRef2"
 Q 1
RulXRef3 S Z=$S(Z="полные поддеревья релевантных":1,Z="строго по перечню":2,1:"")
 Q 1
]]></Implementation>
</Method>

<Method name="RulsDo">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N View,i,qq S View=$S(qqo="XUser":$S(qW.G("XView")'="":qW.G("XView"),1:qW.GG("XRuls","XView",qW.G("XRef"))),1:$S(qW.G("XXView")'="":qW.G("XXView"),1:qW.GG("XRuls","XView",qqc)))
 S qruls=$S(qqo="XUser":qW.G("XRef"),1:qqc)
 ;параметры (ставятся принудительно)
 I qqo="XUser" D  I 1
 .F i=3:1:6 D
 ..S qq=qW.GG("XUser","Xpar"_i,quser) I qq'="" S qARM("Pars",i)=qq Q
 ..S qq=qW.GG("XRuls","Xpar"_i,qruls) I qq'="" S qARM("Pars",i)=qq Q
 E  D
 .F i=3:1:6 D
 ..S qq=$G(^Q(1,"XUser",quser,"XRulsUsr",qruls,"Xpar"_i)) I qq'="" S qARM("Pars",i)=qq Q
 ..S qq=qW.GG("XRuls","Xpar"_i,qruls) I qq'="" S qARM("Pars",i)=qq Q
 D qARM.OpenWindow(,,,,,View) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="SECEncrLet">
<Internal/>
<FormalSpec>dt:%Library.String,do:%Library.String,key:%Library.String,sbox:%Library.String,f:%Library.String,z:%Library.String,o:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 //dt -inp data; do - outp data; f -from; z -number; o - new keys
 n t,i,n,s,p s n=0,t=do k @do s do=t
 s s=..SECGetKey(dt),p=..SECGetSbox()
 s t=1+$O(@dt@(""),-1),@dt@(t)="::"_$Zhex(+$P($H,","))_":"_$Zhex(+$P($H,",",2))_":"_f_":"_$Tr(s_":"_p_":"," ","")_z_":"
 f i=0:1:t s n=n+$L(@dt@(i))
 s i=n\8*8-n i i<0 s @dt@(t)=@dt@(t)_$J("",0-i)
 s n=..SECSHA(dt),n=..SECxBsToHs(n),$P(@dt@(t),":",2)=n
 d ..SECg28147(dt,do,key,sbox,1) s o("key")=s,o("sbox")=p
 q
]]></Implementation>
</Method>

<Method name="SECGetKey">
<Internal/>
<FormalSpec>d:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n k,e,i,t,b,o,dz s k=..SECSHA(d) 
 f i=1:1:12 s k=k_$C($R(256))
 s k=..SECxBsToHs(k),k=..SECxInsSpace(k,8)
 s dz(0)="" f i=1:1:32 s dz(0)=dz(0)_$C($R(256)) //$Tr($J($Zhex($A($R(256))),2)," ",0)
 s b=..SECGetSbox() 
 d ..SECg28147("dz","o",k,b,1)
 s k=..SECxBsToHs(o(0)),k=..SECxInsSpace(k,8)
 q k
]]></Implementation>
</Method>

<Method name="SECGetSbox">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 n e,t,j,x s j=0,t="" f i=0:1:15 s t(i)=-1
GetSboxl
 s x=$R(16) s e=0 f i=0:1:15 i t(i)=x s e=1
 i e=0 s t(j)=x,j=j+1 g:j=16 GetSboxe g GetSboxl
 i e=1 g GetSboxl
GetSboxe 
 f i=0:1:15 s t=t_$Zhex(t(i)),t(i)=-1
 s j=0 g:$L(t)<128 GetSboxl
 q ..SECxInsSpace(t,8)
]]></Implementation>
</Method>

<Method name="SECSHA">
<Internal/>
<FormalSpec>dt:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 n h0,h1,h2,h3,h4,a,b,c,d,e,w,t,i,j,k,r,n
 s h0=$Zhex("67452301h"),h1=$Zhex("EFCDAB89h"),h2=$Zhex("98BADCFEh"),h3=$Zhex("10325476h"),h4=$Zhex("C3D2E1F0h")
 //s w(0)=$Zhex("61626380"),w(15)=$Zhex("18") for i=1:1:14 s w(i)=0
 s j=1,k=0,n=$O(@dt@(""),-1),t=""
SHAdat 
 i $L(n)=0 g SHAend
 s i=$L(t),t=t_$E(@dt@(k),j,j+63-i),j=j+64-i
 i $L(t)<64 s k=k+1,j=1 i k<(n+1) g SHAdat
 i $L(t)=0 g SHAend
 i $L(t)<64 s t=t_$Tr($J("",64-$L(t))," ",$C(0)),n=-1
 for i=0:1:15 s w(i)=..SECx32bToInt($E(t,i*4+1,i*4+4)) // w "i: "_$Zhex(w(i))_" "_w(i),! //$E(t,i*4+1,i*4+4)
 //s w(0)=$Zhex("61626380"),w(15)=$Zhex("18") for i=1:1:14 s w(i)=0
SHAbeg
 for i=16:1:79 s w(i)=..SECxshiftL($Zboolean($Zboolean(w(i-3),w(i-8),6),$Zboolean(w(i-14),w(i-16),6),6),1) if w(i)>$Zhex("FFFFFFFFh") w "err"
 s a=h0,b=h1,c=h2,d=h3,e=h4
 for i=0:1:79 s t=..SECxshiftL(a,5) d  s t=t+e+w(i)+$S(i<20:$Zhex("5A827999h"),i<40:$Zhex("6ED9EBA1h"),i<60:$Zhex("8F1BBCDCh"),1:$Zhex("CA62C1D6h")),t=$Zboolean(t,$Zhex("FFFFFFFFh"),1) s e=d,d=c,c=..SECxshiftL(b,30),b=a,a=t
 .if i<20 s t=t+$Zboolean($Zboolean(b,c,1),$Zboolean($Zboolean(b,d,4),$Zhex("FFFFFFFFh"),1),7) q
 .if i<40 s t=t+$Zboolean($Zboolean(b,c,6),d,6) q
 .if i<60 s t=t+$Zboolean($Zboolean($Zboolean(b,c,1),$Zboolean(b,d,1),7),$Zboolean(c,d,1),7) q
 .if i<80 s t=t+$Zboolean($Zboolean(b,c,6),d,6) q
 s h0=$Zboolean(h0+a,$Zhex("FFFFFFFFh"),1),h1=$Zboolean(h1+b,$Zhex("FFFFFFFFh"),1),h2=$Zboolean(h2+c,$Zhex("FFFFFFFFh"),1),h3=$Zboolean(h3+d,$Zhex("FFFFFFFFh"),1),h4=$Zboolean(h4+e,$Zhex("FFFFFFFFh"),1)
 //w $$padd($Zhex(h0))_" "_$$padd($Zhex(h1))_" "_$$padd($Zhex(h2))_" "_$$padd($Zhex(h3))_" "_$$padd($Zhex(h4)),!
 i n>-1 s t="" g SHAdat   
SHAend
 q ..SECxIntTo32b(h0)_..SECxIntTo32b(h1)_..SECxIntTo32b(h2)_..SECxIntTo32b(h3)_..SECxIntTo32b(h4)
]]></Implementation>
</Method>

<Method name="SECUEncrLet">
<Internal/>
<FormalSpec>dt:%Library.String,do:%Library.String,key:%Library.String,sbox:%Library.String,o:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 d ..SECg28147(dt,do,key,sbox,-1)
 s n=$O(@do@(""),-1) i n="" q -2
 s t=$Re(@do@(n)) i $L(t,":")<8 q -3
 s k=$L($Re($P(t,":")))+2
 s x=$Re($P(t,":",8)),$P(t,":",8)="" s @do@(n)=$Re(t)
 s y=..SECxBsToHs(..SECSHA(do))
 s t=$Re($P(t,":",2,8)),@do@(n)=$E(@do@(n),1,$L(@do@(n))-$L(t)-k)
 s o("number")=$P(t,":",7),o("from")=$P(t,":",4),o("key")=$P(t,":",5),o("sbox")=$P(t,":",6),n=$Zhex($P(t,":",2))_","_$Zhex($P(t,":",3)),o("data")=$Zd(n),o("time")=$Zt(n)
 q:x=y 0 q -1
 q 1
]]></Implementation>
</Method>

<Method name="SECg28147">
<Internal/>
<FormalSpec>dt:%Library.String,do:%Library.String,key:%Library.String,sbox:%Library.String,dir:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 //dt -ссылка нв входн  данные; do -ссылка нв выходн данные
 //расширение материала ключа
 n keye,j,d1,d2,i,t,n,r,k
 s keye="",r=0
 for i=0:1:2 s keye=keye_key_" "
 for i=8:-1:1 s keye=keye_$P(key," ",i) if i>1 s keye=keye_" "
 if dir=-1 s t=keye,keye="" for i=32:-1:1 s keye=keye_$P(t," ",i) if i>1 s keye=keye_" "
 s t="",j=1,n=$O(@dt@(""),-1),k=0 k:0 @do s @do@(0)="" i $L(n)=0 q
g28147re
 s i=$L(t),t=t_$E(@dt@(k),j,j+7-i),j=j+8-i
 i $L(t)<8 s k=k+1,j=1 i k<(n+1) g g28147re
 i $L(t)=0 q
 i $L(t)<8 s t=t_$Tr($J("",8-$L(t))," ",$C(0)),k=n,n=-1
 s d1=..SECx32bToInt($E(t,1,4)),d2=..SECx32bToInt($E(t,5,8))
 //s d1=$Tr($P(d," ",1,2)," ",""),d1=$Zhex(d1),d2=$Tr($P(d," ",3,4)," ",""),d2=$Zhex(d2)
g28147lp
 //сложение
 s e=d1,e=e+$ZHex($P(keye," ",r+1)),e=$Zboolean(e,$Zhex("FFFFFFFFh"),1) 
 // <<<11
 // s e=($Zboolean(e,$Zhex("001FFFFF"),1)*(2**11))+($Zboolean(e,$Zhex("FFE00000"),1)/(2**21))
 //s e=($Zboolean(e,$Zhex("001FFFFF"),1)*(2048)) +($Zboolean(e,$Zhex("FFE00000"),1)\(2097152))
 //for i=1:1:11 s t=$Zboolean(e,$Zhex("80000000"),1),e=$Zboolean(e,$Zhex("7FFFFFFF"),1),e=e*2 i t>0 s e=e+1
 s e=$Zhex(e),t=$L(e) s:t<8 e=$TR($J("",8-t)," ",0)_e s e=$Zhex($E(e,3,8)_$E(e,1,2)_"h")
 for i=1:1:3 s t=$Zboolean(e,$Zhex("80000000h"),1),e=$Zboolean(e,$Zhex("7FFFFFFFh"),1),e=e*2 i t>0 s e=e+1 
 //S-box
 s e=$Zhex(e),e=$Tr($J("",8-$L(e))," ",0)_e  for i=1:1:8 s t=$Tr($P(sbox," ",2*i-1,2*i)," ",""),$E(e,i)=$E(t,$Zhex($E(e,i)_"h")+1)
 s e=$Zhex(e_"h")
 //e xor d2
 s e=$Zboolean(e,d2,6)
 //перестановка d1 и d2
 s d2=d1,d1=e
 //32 раунада
 s r=r+1 i r<32 g g28147lp
 //перестановка d1 и d2
 s d1=d2,d2=e
 s t=+$O(@do@(""),-1),e=..SECxIntTo32b(d1)_..SECxIntTo32b(d2)
 //i $L(@do@(t)<($L(@dt@(k))-8)) s @do@(t)=@do@(t)_e
 i $L(@do@(t))<32000 s @do@(t)=@do@(t)_e
 e  s @do@(t+1)=e
 q:n=-1  s r=0,t="" g g28147re
]]></Implementation>
</Method>

<Method name="SECx32bToInt">
<Internal/>
<FormalSpec>e:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ q ((256**3)*$A($E(e,1)))+((256**2)*$A($E(e,2)))+((256)*$A($E(e,3)))+$A($E(e,4))
]]></Implementation>
</Method>

<Method name="SECxBsToHs">
<Internal/>
<FormalSpec>d:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n i,e s e="" f i=1:1:$L(d) s e=e_$Tr($J($Zhex($A($E(d,i))),2)," ",0)
 q e
]]></Implementation>
</Method>

<Method name="SECxInsSpace">
<Internal/>
<FormalSpec>d:%Library.String,k:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n i,n,e s n=$L(d),e="" f i=1:k:n s e=e_$E(d,i,i+k-1) i i<(n-k) s e=e_" "
 q e
]]></Implementation>
</Method>

<Method name="SECxIntTo32b">
<Internal/>
<FormalSpec>d:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n t,i,e s d=$TR($J($Zhex(d),8)," ",0),e=""
 f i=1:2:8 s e=e_$C($Zhex($E(d,i,i+1)))
 q e
]]></Implementation>
</Method>

<Method name="SECxshiftL">
<Internal/>
<FormalSpec>e:%Library.String,n:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n t,i
 for i=1:1:n s t=$Zboolean(e,$Zhex("80000000h"),1),e=$Zboolean(e,$Zhex("7FFFFFFFh"),1),e=e*2 i t>0 s e=e+1
 q e
]]></Implementation>
</Method>

<Method name="SQLini">
<Description>
Заполнение Vt(qqnump,"sql") для отображения с типом объекта 7 (SQL-таблицы)</Description>
<Internal/>
<FormalSpec>ConName:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqo,qqw,qqz,qqzz,qqi,qqop,z,error,q753,qq,err K Vt(qqnump,"sql")
 n numa,list,atrn,atr,table,A,tip,ATable,AF,str,ch,nach,qqwR
 I $G(ConName)="" S ConName=$G(^Q(1,"XBase",0,"XSQLcon")) ;I ConName="" Q:$Q "Не задано соединение (Проводник/База XSQLcon)" Q
 s:$g(ConName)="" ConName="???"
 I $L(ConName," ")>1 S ConName=$P(ConName," ",$G(qqConList,1)) I ConName="" Q:$Q "В списке соединений отсутствует №"_$G(qqConList) Q
 S qqo=-1 F  S qqo=$O(Vo(qqnump,qqo)) Q:qqo=""  D:$G(Vo(qqnump,qqo,2))=7  Q:$G(error)'=""
 .S qqop=$P($$$ObjRef(qqo),",",$L($$$ObjRef(qqo),",")-1) ;предыдущий объект
 .;необходимые параметры объекта (кроме обязательно загружаемых)
 .F z="X533","X522" D  ;необходимые параметры объекта (кроме обязательно загружаемых)
 ..I $D(^Q(1,"XView",Vo(qqnump),"CxObj",qqo,z)) S Vo(qqnump,qqo,$E(z,3,10))=^(z) Q
 ..I $D(^Q(1,"CxObj",qqo,z)) S Vo(qqnump,qqo,$E(z,3,10))=^(z) Q  ;наследование из объектов
 .S (Vt(qqnump,"sql",qqo,"qqw"),qqz)=$G(^Q(1,"XView",Vo(qqnump),"CxObj",qqo,"xWoc")) ;список понятий
 .S z=$S(qqop="":"",1:$P($G(Vt(qqnump,529,qqo,qqop)),";")) ;список внешних ключей для связи с родителем
 .;формирование списка забираемых из таблицы реквизитов
 .S qqzz="" F qqi=1:1:$L(qqz," ") S qqw=$P(qqz," ",qqi) D:qqw'=""
 ..S (q753,Vt(qqnump,"sql",qqo,"qqw",qqw))=qARM.GetPar("X753",,qqo,qqw)
 ..S:$P(q753," ")'="" qqzz=qqzz_","_$P(q753," ")
 ..S qq=qARM.GetPar("x710",,qqo,qqw) S:qq'="" Vt(qqnump,"sql",qqo,"qqw",qqw,10)=qq ;дата
 ..S qq=qARM.GetPar("X741",,qqo,qqw) S:qq'="" Vt(qqnump,"sql",qqo,"qqw",qqw,41)=qq ;одно слово
 ..S qq=qARM.GetPar("x742",,qqo,qqw) S:qq'="" Vt(qqnump,"sql",qqo,"qqw",qqw,42)=qq ;преобразование регистра
 .F qqi=1:1:$L(z," ") S qqw=$E($P(z," ",qqi),2,2000) I qqw'="",qqzz_","'[(","_qqw_",") S qqzz=qqzz_","_qqw,Vt(qqnump,"sql",qqo,"qqw")=Vt(qqnump,"sql",qqo,"qqw")_" p"_qqw ;дополним внешними ключами, отсутствующими в списке ("p"_ надо срочно убрать
 .S Vt(qqnump,"sql",qqo,"qqwR")=$E(qqzz,2,32000) ;,Vt(qqnump,"sql",qqo,"qqwKE")=z
 .;S Vt(qqnump,"sql",qqo,"qqwK")=$G(Vo(qqnump,qqo,22)) ;список ключевых (их текущие значения нужно будет держать для связи с потомком в Vt(qqnump,"sql",qqo,"qqwK",qqw) )
 .S z=$G(Vo(qqnump,qqo,33))
 .S Vt(qqnump,"sql",qqo,"tab")=""_$S(z[":":$P(z,":",2),1:z) I Vt(qqnump,"sql",qqo,"tab")="dbo." S error="Нет таблицы для объекта "_qqo Q  ;dbo.
 .S Vt(qqnump,"sql",qqo,"con")=$S(z[":":$P(z,":",1),1:ConName)
 i $g(%qGWcon)'=1 d qW.SQLConTcp()
 d:$L($g(sqlcon(qqnump))) qW.SQLClose(sqlcon(qqnump)) d  ;i $g(sqlcon(qqnump))="" d 
 .n dsn,user,psw
 .s dsn=$S($G(^Q(1,"XBase",0,"XSQLdsn"))'="":$G(^Q(1,"XBase",0,"XSQLdsn")),1:$G(^Q(1,"XView",Vo(qqnump),"XSQLdsn"))) ;S dsn=$G(^Q(1,"XBase",0,"XSQLdsn"))
 .s user=$S($G(^Q(1,"XBase",0,"XSQLuser"))'="":$G(^Q(1,"XBase",0,"XSQLuser")),1:$G(^Q(1,"XView",Vo(qqnump),"XSQLuser"))) ;S d=$G(^Q(1,"XBase",0,"XSQLduser"))
 .s psw=$S($G(^Q(1,"XBase",0,"XSQLpsw"))'="":$G(^Q(1,"XBase",0,"XSQLpsw")),1:$G(^Q(1,"XView",Vo(qqnump),"XSQLpsw")))  ;S dsn=$G(^Q(1,"XBase",0,"XSQLdsn"))
 .;i %SQLCODE'=0 s error=" Ошибка GateWay!! " q:error
 .s sqlcon(qqnump)=qW.SQLCon(dsn,user,psw)
 .i %SQLCODE<0 s error="Ошибка DSN " ;d qW.SQLClose(sqlcon(qqnump),1) ;d qW.SQLConTcp()
 I (+$G(^Q(1,"XView",Vo(qqnump),"XSQLNoVer")))&&($g(error)="") D ..SQLref() Q:$Q "" Q  ;I +$G(^Q(1,"XBase",0,"XSQLNoVer")) D ..SQLref() Q:$Q "" Q  ;@dol 23.03.04


 i $g(error)=""
 { 
 ;Получение списка таблиц и удаление лишних из Vt
 k ^AVtOld
 m ^AVtOld=Vt

 ; n use
 i $g(ConName)'="???"
 {
 s use=qW.SQLExec(sqlcon(qqnump),"use "_ConName) 
 i (%SQLCODE<0)&&(%SQLCODE'=-100)
 {
 s error="Нет базы "_ConName  d:0 qW.SQLClose(use,0) Q error
 }
 d:0 qW.SQLClose(use,0)  
 }


 k ^AVov s ^AVov=1
 d qW.SQLGetT(sqlcon(qqnump))
 s ^AVov=2

 k ATable
 f z=1:1:$o(%qGWT(sqlcon(qqnump),""),-1) s ATable(%qGWT(sqlcon(qqnump),z))=""

 s qqo=""
 f  {
 s qqo=$o(Vt(qqnump,"sql",qqo))
 q:qqo=""
 s table=$s(Vt(qqnump,"sql",qqo,"tab")'="":Vt(qqnump,"sql",qqo,"tab"),1:"????")
 ;d qARM.Message(qqnump)
 ;d qARM.Message(qqo)
 ;d qARM.Message(table)
 k:'$d(ATable(table)) Vt(qqnump,"sql",qqo),Vt(qqnump,111,1,qqo)
 }
 ;k ^AVtNew  
 ;m ^AVtNew=Vt              

 ;Получение аттрибутов таблиц и удаление лишних из Vt
 ;Обход таблиц отображения
 s qqo="" k AF
 f  {
 s qqo=$o(Vt(qqnump,"sql",qqo))
 q:qqo=""

 s table=$s(Vt(qqnump,"sql",qqo,"tab")'="":Vt(qqnump,"sql",qqo,"tab"),1:"????") ;;qq_$S($G(qsor)'="":" ORDER BY "_qsor,1:"")) i (%SQLCODE<0) s error="Ошибка Exec "_qq Q
 d qW.SQLGetF(sqlcon(qqnump),$S($G(^Q(1,"XView",Vo(qqnump),"XShema"))'="":^Q(1,"XView",Vo(qqnump),"XShema")_".",1:"")_table)

 f z=1:1:$o(%qGWF(sqlcon(qqnump),""),-1) s AF(%qGWF(sqlcon(qqnump),z))=""        

 ;Удаление лишних понятий из Vt для таблицЫ qqo список понятий qqwR

 s (pole,qqwR)=""
 f pole=1:1:$l(Vt(qqnump,"sql",qqo,"qqwR"),",") {

 s atr=$p(Vt(qqnump,"sql",qqo,"qqwR"),",",pole)
 i $d(AF(atr)) s qqwR=$g(qqwR)_atr_","

 }
 s $e(qqwR,$l(qqwR))="" ;убрать последнюю запятую

 s Vt(qqnump,"sql",qqo,"qqwR")=qqwR

 k ^AVtNew  
 m ^AVtNew=Vt

 }

 }  ;i $g(error)=""

 D:'$d(error) ..SQLref()

 Q:$Q $G(error) Q
]]></Implementation>
</Method>

<Method name="SQLref">
<Description>
Создание списка соответствия SQL-таблиц (и их реквизитов, если Arg1=1) 
Массив
Vt(qqnump,"sqlref",tab)=qqo
Vt(qqnump,"sqlrefw",rek)=qqw</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N tab,rek,qqo,qqw,view,x,y
 K Vt(qqnump,"sqlref"),Vt(qqnump,"sqlrefw")
 S qqo="" F  S qqo=$O(^Q(1,"CxObj",qqo)) Q:qqo=""  I $G(^Q(1,"CxObj",qqo,"x52"))=7||$S($G(^Q(1,"CxObj",qqo,"x52"))=6:0,1:$G(^Q(1,"CxObj",qqo,"X533"))'="") D  ;@dol 4.8.03 сложность - обявлен хранимым
 .S tab=$G(^Q(1,"CxObj",qqo,"X533"),"???")
 .S Vt(qqnump,"sqlref",tab)=qqo
 I '$G(Arg1) Q:$Q "" Q
 S qqw="" F  S qqw=$O(^Q(1,"CxWoc",qqw)) Q:qqw=""  S rek=$G(^Q(1,"CxWoc",qqw,"X753")) D:rek'=""
 .S:$P(rek," ")'="" Vt(qqnump,"sqlrefw",$P(rek," "))=qqw
 S view="" F  S view=$O(^Q(1,"XView",view)) Q:view=""  D:view["virt"
 .S qqo=-1 F  S qqo=$O(^Q(1,"XView",view,"CxObj",qqo)) Q:qqo=""  D
 ..S y="" F  S y=$O(^Q(1,"XView",view,"CxObj",qqo,"Xy",y)) Q:y=""  D
 ...S x="" F  S x=$O(^Q(1,"XView",view,"CxObj",qqo,"Xy",y,"Xx",x)) Q:x=""  S rek=$P($G(^(x,"X753"))," ") D:rek'=""
 ....S qqw=$G(^("X71")),Vt(qqnump,"sqlrefw",$P(rek," "))=qqw
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="SaveMas">
<Description>
Сохранить список массивов (через запятую) в файл программой ^%GOF.
Возвращает пусто или сообщение об ошибке.</Description>
<Internal/>
<FormalSpec>Masli:%Library.String,file:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 N names,IO,IOT,IOPAR,descript,external,%gofmsg,flag
 S:$G(Masli)="" Masli="Q,QT,QRes,Qa,QNaz"
 S IO=$G(file) S:IO="" IO=$ZU(5)_".gsa"
 S external=1,IOT="RMS",IOPAR="(""UNW"")",descript="qWORD-XML Base "_$ZU(5)
 K ^UTILITY($J) F names=1:1:$L(Masli,",") S ^UTILITY($J,$TR($P(Masli,",",names),"^"))=""
 D top^%GOF Q $S('$G(flag):$P(flag,"#",2,255),1:%gofmsg)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="SetVs">
<Description>
Установка массива состояний Vs(qqnump,Arg1,qqo)=qqz или Vs(qqnump,Arg1,qqo,qqw)=qqz.
Если qqz не задан, то qqz=1.
Для зачеркивания (Arg1) учтен спец вариант зачеркивания понятий. Возможна динамическое зачеркивание (в этом случае необходим qARM.wcre).
Необходим перевывод дерева объектов для отображения результата переустановки qARM.wcro, если дерево объектов видно.</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,qqo:%Library.String,qqw:%Library.String,qqz:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I Arg1=1 D  Q:$Q "" Q  ;спец. обработка зачеркивания понятий
 .I $G(qqw)="" D  Q  ;весь объект
 ..I $G(qqz)=0 K Vs(qqnump,1,qqo) Q
 ..S Vs(qqnump,1,qqo)=1
 .I qqw?1"Zs"1.n1"c"1.n S Vs(qqnump,Arg1,qqo,+$P(qqw,"Zs",2),$P(qqw,"c",2))=1 Q  ;@dol 6.11.03 выражения
 .N q1,q2 I qqw["*" S q1=$G(Vo(qqnump,qqo,11,$P(qqw,"*"))) Q:q1=""  S Vs(qqnump,Arg1,qqo,+q1)=$S('$D(qqz):1,1:qqz) Q  ;@dol 27.03.03 - зачеркнуть строку с понятием
 .S q1=$G(Vo(qqnump,qqo,11,qqw)) Q:q1=""
 .K Vt(qqnump,9,qqo_" "_$P(q1," ")),Vt(qqnump,9,"-1 "_qqo_" "_$P(q1," ")) ;уберем образцы
 .S q2=$P(q1," ",2) I q2 D  I 1 ;@dol 26.03.03  ;связанная константа
 ..S q2=$O(Vo(qqnump,qqo,0,+q1,q2),-1) Q:q2=""
 ..I $E($G(Vo(qqnump,qqo,0,+q1,q2)))'=0 S q2="" Q
 .E  S q2="" 
 .I $G(qqz)'=0 S Vs(qqnump,1,qqo,qqw)=1,Vs(qqnump,1,qqo,+q1,$P(q1," ",2))=1 S:q2'="" Vs(qqnump,1,qqo,+q1,q2)=1 Q  ;зачеркнули
 .K Vs(qqnump,1,qqo,qqw),Vs(qqnump,1,qqo,+q1,$P(q1," ",2)) K:q2'="" Vs(qqnump,1,qqo,+q1,q2) I '$G(Vs(qqnump,1,qqo)),$D(Vs(qqnump,1,qqo))<10 K Vs(qqnump,1,qqo) ;восстановили
 S Vs(qqnump,Arg1,qqo,qqw)=$S('$D(qqz):1,1:qqz)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="SetVsLst">
<Description>
Получение массива вида
Vs(qqnump,ind,qqo,qqw)=значение   (значение по умолчанию 1)
из списка (через пробел)  вида :
list=qqo1[=значение]:qqw1[=значение],qqw2[=значение]... qqo2[=значение]:qqw[=значение]...
Значение может пропускаться (list=qqo:qqw1,qqw2... )</Description>
<Internal/>
<FormalSpec>qqnump:%Library.String,ind:%Library.String,list:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqo,qqw,qqoi,qqwi,qst,z F qqoi=1:1:$L(list," ") S qqo=$P(list," ",qqoi) D:qqo'=""
 .S qst=$P(qqo,":",2),qqo=$P(qqo,":",1),z=$P(qqo,"=",2),qqo=$P(qqo,"=",1)
 .I qst="" S:z="" z=1 S Vs(qqnump,ind,qqo)=z Q
 .S:z'="" Vs(qqnump,ind,qqo)=z
 .F qqwi=1:1:$L(qst,",") S qqw=$P(qst,",",qqwi) I qqw'="" S z=$P(qqw,"=",2),qqw=$P(qqw,"=",1) S:z="" z=1 S Vs(qqnump,ind,qqo,qqw)=z
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="SetX119">
<Description>
Переопределить вариант выделения</Description>
<Internal/>
<FormalSpec>x119:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ D:$G(Vo(qqnump,-1,19))=4 qARM.wM(qwin_".T2","SetCellRect",-1,-1,"SB") S Vo(qqnump,-1,19)=x119 D qARM.wP(qwin_".T2","SelectStyle",2*(x119=2||(x119=4))+1) Q
]]></Implementation>
</Method>

<Method name="Setx52">
<Description>
Присваивание типа объекта (x52) всем объектам текущего отображения.
Arg1 - код типа (0 - хранимый...6-массив
Arg2 - условие присваиваиния относительно qqo. Если задано, будет проверятся при каждом присваивании.
Arg3 - код отображения (не задан - текущее из Vo(qqnump)</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(Arg3)="" Arg3=Vo(qqnump)
 N qqo S qqo=-1 F  S qqo=$O(^Q(1,"XView",Arg3,"CxObj",qqo)) Q:qqo=""  D
 .I $G(Arg2)="" D Setx52S Q
 .I @Arg2 D Setx52S Q
 Q:$Q "" Q
Setx52S I $G(Arg1)="" K ^Q(1,"XView",Arg3,"CxObj",qqo,"x52") Q  ;сброс в умолчание
 S ^Q(1,"XView",Arg3,"CxObj",qqo,"x52")=+Arg1 Q
]]></Implementation>
</Method>

<Method name="SortTree">
<Description>
Включение внутренней сортировки дерева по нажатию кнопок заголовка колонок
Добавляется как действие (X73) в описании заголовков колонок (строка 0 объекта -1)

Arg1=-1 (по умолчанию) - сортировка по верхнему уровню
Arg1="" - по уровню текущей строки
Arg1= чиссло - по уровю строки Arg1 (имеется ввиду qqy - реальный номер строки в дереве)</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 D qARM.wM(qwin_".T2","SortDependents",$G(Arg1,-1),but*qqx,0,0) S qqend=1
 S Vs(qqnump,"NoSortD")=1 ;блокировка уточнения выбора
 d:$D(Vt(qqnump,9,"FCBUT")) qARM.wwwwFCBUT(1) ;qARM.wM(qwin,"Vol_ArrayElementPaint")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="SynJrn">
<Description>
Запуск/Останов (1/0) процессов синхронизации баз (пересылка/прием журнала).
Arg1 - передатчик
Arg2 - приемник
Возвращает сообщение.</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 //14082002
 s smtpserver=$G(^Q(1,"XBase",0,"Xsmtpadr"))
 s from=$G(^Q(1,"XBase",0,"Xsmtpfrom"))
 s to=$G(^Q(1,"XBase",0,"Xsmtpto"))
 s period=$g(^Q(1,"XBase",0,"Xperiodsmtp"))
 i ($G(Arg1))&((smtpserver="")!(from="")!(to="")!(period="")) s:$g(qqw)="XFSendJrn" W(qqw)=0 q "Нет данных "_$s(smtpserver="":"о smtpserver",from="":"об отправителе",to="":"о получателе",period="":" о периоде отправки журнала",1:"")

 s popserver=$G(^Q(1,"XBase",0,"Xpopadr"))
 s login=$P($G(^Q(1,"XBase",0,"Xpopuser"))," ")
 s password=$P($G(^Q(1,"XBase",0,"Xpopuser"))," ",2)
 i ($G(Arg2))&((popserver="")!(login="")!(password="")) s:$g(qqw)="XFResivJrn" W(qqw)=0 q "Нет данных "_$s(popserver="":"о popserver",login="":"о логине",password="":"о пароле",1:"")


 s:$G(Arg1)'="" ^Q(1,"XBase",0,"XFSendJrn")=$s($G(Arg1):1,1:0)
 s:$G(Arg2)'="" ^Q(1,"XBase",0,"XFResivJrn")=$s($G(Arg2):1,1:0)
 //sasha 20080806 не работало в каше версий с 5
 //закомментировано @misuno 20080911
 ;i $G(Arg1) d
 ;.i ($zv'["Cache")||($p($p($zv,") ",2)," ",1)'>5) j ASMTPfon^%ooLibrary.qSYS.2(0,smtpserver,from,to) q
 ;.j zASMTPfon^%ooLibrary.qSYS.1(0,smtpserver,from,to) 
 
 //@misuno 20080911
 ;;sas 20090409
 i $G(Arg1),$zv["Cache" j Job^%GMan00x7("qSYS.ASMTPfon",$lb(0,smtpserver,from,to))
 ;i $G(Arg1),$zv["Cache" j Job^%GMan00x6("qSYS.ASMTPfon",$lb(0,smtpserver,from,to))

 //закомментировано @misuno 20080911
 ;i $G(Arg2) d 
 ;.i ($zv'["Cache")||($p($p($zv,") ",2)," ",1)'>5) j APOPfon^%ooLibrary.qSYS.1(0,popserver,login,password)
 ;.j zAPOPfon^%ooLibrary.qSYS.1(0,popserver,login,password)
 
 //@misuno 20080911
 ;;sas 20090409
 i $G(Arg2),$zv["Cache" j Job^%GMan00x7("qSYS.APOPfon",$lb(0,popserver,login,password))
 ;i $G(Arg2),$zv["Cache" j Job^%GMan00x6("qSYS.APOPfon",$lb(0,popserver,login,password))
 q:$zv'["Cache"
 
 Q "Синхронизация:"_$S($G(Arg1)'="":" Передача "_$S(Arg1:"Запущена",1:"Остановлена"),1:"")_$S($G(Arg2)'="":" Прием "_$S(Arg2:"Запущен",1:"Остановлен"),1:"")
]]></Implementation>
</Method>

<Method name="TBF">
<Description>
Автоматический подбор картинки фона панели инструментов</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N Pic I $G(qARM("ClientThemes")) D  Q Pic ;Win XP
 .I $G(qARM("ClientWinColor"))=14933984 S Pic="R,377" Q  ;серебристая
 .I $G(qARM("ClientWinColor"))=14215660 S Pic="R,376" Q  ;стандартная (голубая)
 .I $G(qARM("ClientWinColor"))=14215660 S Pic="R,376" Q  ;оливковая
 .S Pic="R,376"
 D  Q Pic ;Win 2000 Классический стиль
 .I $G(qARM("ClientWinColor"))=13160660 S Pic="R,379" Q  ;Стандартная
 .I $G(qARM("ClientWinColor"))=12632256 S Pic="R,380" Q  ;Классическая
 .I $G(qARM("ClientWinColor"))=9476264 S Pic="R,376" Q  ;слива
 .S Pic="R,377"
]]></Implementation>
</Method>

<Method name="TLTBcreate">
<Description>
Создание тулбаров в отображении
idTB - идентификатор совокупности</Description>
<Internal/>
<FormalSpec>idTB:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 q:$g(idTB)=""
 ;Находим нужную совокупность
 n qqcTBid s qqcTBid=qW.FastKey("TBid","sysidTB",,,idTB)
 i qqcTBid="" d qARM.Message("Не найдена совокупность тулбаров "_idTB_"!") q ""


 d ..TLcreateimlist() n ImageIndex

 ;Обход тулбаров совокупности
 n visTBbut,enTBbut,onTBbut,cupTBbut,hintTBbut,showhTBbut,nm,nameTBbut,downTBbut
 n qqcTB,nameTB,qqcTBbut,qqcPictB s qqcTB=""
 f  {
 s qqcTB=qW.UserOrd(1,"TB",qqcTB,qqcTBid)
 q:(qqcTB="")!($e(qqcTB,1,$l(qqcTBid))'=qqcTBid)
 ;Создание тулбара
 s nameTB=qwin_"."_qW.GG("TB","sysnameTB",qqcTB)
 d qARM.wC("TToolBar",nameTB)
 ;Вызов метода по нажатию на кнопку
 D qARM.wP(,"OnClickMethod","qSYS.TLonToolButtonClick")

 d qARM.wP(nameTB,"Align",$s(qW.GG("TB","sysalignTB",qqcTB)="Низ":2,1:1))
 d qARM.wP(nameTB,"Flat",$s(qW.GG("TB","sysflatTB",qqcTB)="Плоский":1,1:0))
 ;Высота тулбара
 i qW.GG("TB","sysheightTB",qqcTB)'?.N D qARM.wP(,"AutoSize",1)
 i qW.GG("TB","sysheightTB",qqcTB)?.N d qARM.wP(nameTB,"Height",$s(qW.GG("TB","sysheightTB",qqcTB)="":40,1:qW.GG("TB","sysheightTB",qqcTB))) ;d:qW.GG("TB","heightTB",qqcTB)="" qARM.Message("Не задана высота тулбара "_nameTB_"!")
 ;Бордюр тулбара
 D:qW.GG("TB","sysbt",qqcTB)'=1 qARM.wP(nameTB,"EdgeBorders.-",1)
 D:qW.GG("TB","sysbl",qqcTB)=1 qARM.wP(nameTB,"EdgeBorders.+",0) 
 D:qW.GG("TB","sysbt",qqcTB)=1 qARM.wP(nameTB,"EdgeBorders.+",1) 
 D:qW.GG("TB","sysbr",qqcTB)=1 qARM.wP(nameTB,"EdgeBorders.+",2) 
 D:qW.GG("TB","sysbb",qqcTB)=1 qARM.wP(nameTB,"EdgeBorders.+",3)

 i qW.GG("TB","syscapTBbut",qqcTB)="Нет"
 {
 d qARM.wP(nameTB,"ButtonHeight",$s(qW.GG("TB","sysheightTBbut",qqcTB)="":35,1:qW.GG("TB","sysheightTBbut",qqcTB))) ;d:qW.GG("TB","heightTBbut",qqcTB)="" qARM.Message("Не задана высота кнопок тулбара "_nameTB_"!")
 d qARM.wP(nameTB,"ButtonWidth",$s(qW.GG("TB","syswidthTBbut",qqcTB)="":35,1:qW.GG("TB","syswidthTBbut",qqcTB))) ;d:qW.GG("TB","widthTBbut",qqcTB)="" qARM.Message("Не задана ширина кнопок тулбара "_nameTB_"!")
 }

 d qARM.wP(nameTB,"ShowCaptions",$s(qW.GG("TB","syscapTBbut",qqcTB)="Нет":0,1:1))
 D:qW.GG("TB","syscapTBbut",qqcTB)'="Нет" qARM.wP(nameTB,"List",$s(qW.GG("TB","syscapTBbut",qqcTB)="Справа":1,1:0))

 d qARM.wP(nameTB,"Images","Pict"_qW.GG("TB","sysnameTB",qqcTB)),qARM.wP(nameTB,"HotImages","PictHot"_qW.GG("TB","sysnameTB",qqcTB))
 ;d qARM.wP(nameTB,"Images","PictList"),qARM.wP(nameTB,"HotImages","PictListHot")

 ;Создание кнопок
 ;Обход кнопок
 n stTBbut
 s qqcTBbut=""
 f  {
NextBut       s qqcTBbut=qW.UserOrd(-1,"TBbut",qqcTBbut,qqcTB)
 q:qqcTBbut=""
 s stTBbut=qW.GG("TBbut","sysstTBbut",qqcTBbut)
 g:stTBbut="" NextBut

 i stTBbut["Кнопка"
 {
 s ImageIndex=-1
 ;Обходим картинки кнопки и подставляем нужный ImageIndex
 s qqcPictB=""
 f  {
NextP            s qqcPictB=qW.UserOrd(1,"PictB",qqcPictB,qqcTBbut)
 q:qqcPictB=""
 i qW.GG("PictB","syssee",qqcPictB)="" s ImageIndex=$$$tmpGl($j,"ImageIndex",qW.GG("TB","sysnameTB",qqcTB),qqcPictB) g NextP
 i @qW.GG("PictB","syssee",qqcPictB) s ImageIndex=$$$tmpGl($j,"ImageIndex",qW.GG("TB","sysnameTB",qqcTB),qqcPictB)
 }
 ;Создаем кнопку
 s @("visTBbut="_$s(qW.GG("TBbut","sysvisTBbut",qqcTBbut)="":1,1:qW.GG("TBbut","sysvisTBbut",qqcTBbut)))
 s @("enTBbut="_$s(qW.GG("TBbut","sysenTBbut",qqcTBbut)="":1,1:qW.GG("TBbut","sysenTBbut",qqcTBbut)))
 s @("onTBbut="_$s(qW.GG("TBbut","sysonTBbut",qqcTBbut)="":1,1:qW.GG("TBbut","sysonTBbut",qqcTBbut)))
 s @("showhTBbut="_$s(qW.GG("TBbut","sysshowhTBbut",qqcTBbut)="":1,1:qW.GG("TBbut","sysshowhTBbut",qqcTBbut)))
 s cupTBbut=qW.GG("TBbut","syscupTBbut",qqcTBbut)
 s hintTBbut=qW.GG("TBbut","syshintTBbut",qqcTBbut)
 s nameTBbut=qW.GG("TBbut","sysnameTBbut",qqcTBbut)

 d qARM.ToolbarCreateButton(nameTB,nameTBbut,cupTBbut,visTBbut,enTBbut,onTBbut,ImageIndex,hintTBbut,showhTBbut,$s(stTBbut="Кнопка":0,stTBbut["Check":1,1:2))
 
 ;Сойство "нажатости"
 s @("downTBbut="_$s(qW.GG("TBbut","sysdownTBbut",qqcTBbut)="":0,1:qW.GG("TBbut","sysdownTBbut",qqcTBbut)))
 d qARM.wP(nameTB_"."_nameTBbut,"Down",downTBbut)

 ;Создаем меню для кнопки если есть идентификатор
 s DmenuId=qW.GG("TBbut","sysDmenuId",qqcTBbut)
 i DmenuId'=""
 {
 s nm="XU"_nameTBbut
 I '$D(qwin(qwin,nm)) d qARM.wC("TPopupMenu",qwin_"."_nm) S qwin(qwin,nm)=""
 D qARM.MenuWoc(nm,..TLgetMenu(DmenuId),,,,,,1,-1)
 d qARM.wP(nameTB_"."_nameTBbut,"DropdownMenu",nm)
 }

 }

 i stTBbut'["Кнопка"
 {
 d qARM.ToolbarCreateButton(nameTB,qW.GG("TBbut","sysnameTBbut",qqcTBbut),,1,,,,,,$s(stTBbut="Промежуток":3,1:4),$s(qW.GG("TBbut","syswidthTBbut",qqcTBbut)'="":qW.GG("TBbut","syswidthTBbut",qqcTBbut),1:10))
 }  

 }
 }


 q ""
]]></Implementation>
</Method>

<Method name="TLcreateimlist">
<Description>
создание имлистов</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
    n ListNormal,ListHot,ImageIndex
    i $g(ImageIndexTB)="Yes" q ""
    ; обходим все кнопки тулбара и создаем листы
    n qqcTBAll s qqcTBAll=$$$UserOrd(1,"TBAll","","") q:qqcTBAll="" ""
    n qqcTB,qqcPictB,imL,nameTB,refTmpGl
    s qqcTB=""
    f  {
        s qqcTB=$$$UserOrd(1,"TB",qqcTB,qqcTBAll) q:qqcTB=""
        s ListNormal="",ListHot="",ImageIndex=0
        s nameTB=qW.GG("TB","sysnameTB",qqcTB)
        s refTmpGl=$na($$$tmpGl($j,"ImageIndex",nameTB))
        i $g(@refTmpGl)="Yes" d qARM.wM("Pict"_nameTB,"Clear"),qARM.wM("PictHot"_nameTB,"Clear") ;15.12.2008 Kokarev
        ; формируем листы с картинками
        s qqcPictB=""
        f  {
            s qqcPictB=$$$UserOrd(1,"PictB",qqcPictB,qqcTB) q:qqcPictB=""
            s imL=qW.GG("PictB","sysnumpic",qqcPictB)_"~"_qW.GG("PictB","sysnumpicHOT",qqcPictB)
            d forim(imL)
            ; записываем номер пары в имеджлисте
            s @refTmpGl@(qqcPictB)=($i(ImageIndex)-1)
        }
        i $g(@refTmpGl)'="Yes" {
            d qARM.wC("TCustomImageList","Pict"_nameTB)
            d qARM.wC("TCustomImageList","PictHot"_nameTB)
            d qARM.wP("Pict"_nameTB,"Width",32),qARM.wP(,"Height",32)
            d qARM.wP("PictHot"_nameTB,"Width",32),qARM.wP(,"Height",32)
            d qARM.wM("Pict"_nameTB,"Fill",ListNormal)
            d qARM.wM("PictHot"_nameTB,"Fill",ListHot)
        }
    }
    s ImageIndexTB="Yes"
    q ""
    ; список картинок
forim(Pict) ;
    n qqcPic s qqcPic=$P(Pict,"~") ;картинка
    s ListNormal=ListNormal_..TLwpic(qqcPic)_$C(13)
    s qqcPic=$p(Pict,"~",2) ;картинка под мышкой
    s ListHot=ListHot_..TLwpic(qqcPic)_$C(13)
    q
]]></Implementation>
</Method>

<Method name="TLgetMenu">
<Description>
Метод используется для получения ссылки на внешнее меню отображения.
Возвращает строку меню в виде "userMenu0::"_код_экземпляра_userMenu0_",;userMenu1:;userMenu2:;userMenu3:;"
Код_экземпляра_userMenu0 - подходящий экземпляр userMenu0 в зависимости от параметров.
Если код_экземпляра_userMenu0 не найден, то возвращаем "".

Параметры:
idSys - системный идентификатор меню - определяет набор меню для отображения
Значение ОБЯЗАТЕЛЬНО. Если равен "", то выход.
Поиск идет на полное соответствие понятию DmenuIdSys.
Если меню с заданным idSys не существует, то возвращаем "".
idUser - пользовательский идентификатор меню - определяет меню для конкретного пользователя.
Проверяется на вхождение в значение понятие DmenuIdUser ((" "_значение_DmenuIdUser_" ")[(" "_idUser_" "))
Если нет набора меню с таким idUser, то возвращается меню по умолчанию (DmenuIdUser="") или "", если меню по умолчанию отсутствует)
idRule - ролевой идентификатор меню - определяет меню определенного набора ролей
Если равен "", то ищется меню, где роль равна "" (с учетом idSys и idUser)
Проверяется на вхождение.
Возвращается ПЕРВЫЙ экземляр userMenu0, если все условия по идентификаторам выполняются.
Иначе - ПОСЛЕДНИЙ подходяший ,но выбор идет в следующем порядке (для всех, совпадающих с IdSys):
- если есть совпадение по роли
- если есть совпадение по пользователю и значение реквизита menuIdRule=""
- если значение понятий DmenuUser и menuIdRule равны ""</Description>
<Internal/>
<FormalSpec>idSys:%Library.String,idUser:%Library.String,ipRule:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 Q:$G(idSys)="" "" ;если не задан системный идентификатор меню, то выход
 S idRule=$G(idRule) ;идентификатор роли
 S idUser=$S($G(idUser)'="":" "_idUser_" ",1:"")
 N q0,qr,qu,qt,qo,val,val1
 ;s qt=qW.UserOrd()
 S qo="sysuserMenu0",(q0,qr,qu,qt)="" F  S qt=$O(^Q(1,"sysDmenuId",idSys,qo,qt)) Q:qt=""  D  Q:(qr'=""&&(qr=q0)&&(qr=qu))||(idUser=""&&(qr'=""))||(idRule=""&&(qu'=""))||(idRule=""&&(idUser="")&&(q0'=""))
 .S val=$G(^Q(1,qo,qt,"menuIdRule")),val=$S(val="":"",idRule'="":$D(^Q(1,"menuIdRule",idRule,qo,qt)),1:0) Q:val="0"
 .S val1=$G(^Q(1,qo,qt,"DmenuIdUser")),val1=$S(val1="":"",idUser'="":(" "_val1_" ")[idUser,1:0) Q:val="0"
 .I val,val1 S (qr,qu,q0)=qt Q
 .S:val qr=qt S:val1 qu=qt S:'val&&'val1 q0=qt
 Q $S(qr'=""||(q0'="")||(qu'=""):qo_"::"_$S(qr'="":qr,qu'="":qu,1:q0)_",;sysuserMenu1:;sysuserMenu2:;sysuserMenu3:;",1:"")
]]></Implementation>
</Method>

<Method name="TLinvis">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 s (Vs(qqnump,1,qqo,"syswidthTBbut"))=$s(qW.G("sysstTBbut")["Кнопка":1,1:0) 

 s (Vs(qqnump,1,qqo,"sysDmenuId"),Vs(qqnump,1,qqo,"sysdoTBbut"),Vs(qqnump,1,qqo,"syscupTBbut"),Vs(qqnump,1,qqo,"sysenTBbut"),Vs(qqnump,1,qqo,"sysonTBbut"),Vs(qqnump,1,qqo,"sysimTBbut"),Vs(qqnump,1,qqo,"syshintTBbut"),Vs(qqnump,1,qqo,"sysshowhTBbut"),Vs(qqnump,1,qqo,"sysvisTBbut"))=$s(qW.G("sysstTBbut")["Кнопка":0,1:1)
 
 s Vs(qqnump,1,qqo,"sysdownTBbut")=$s(qW.G("sysstTBbut")["Check":0,1:1) 

 s:qqo="TB" (Vs(qqnump,1,qqo,"sysheightTBbut"),Vs(qqnump,1,qqo,"syswidthTBbut"))=$s(qW.G("syscapTBbut")="Нет":0,1:1)


 q ""
]]></Implementation>
</Method>

<Method name="TLnameTB">
<Description>
Формирует имя тулбара</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
    ; обход всех тулбаров под данной совокупностью
    n qqcTB
    s qqcTB=""
    f  {
        s qqcTB=$$$UserOrd(1,"TB",qqcTB,qqc) q:qqcTB=""
        s W("sysnameTB")="CTB_"_Z_"_"_qqcTB d qW.rCor("TB",qqcTB,"sysnameTB",,0) k $$$tmpGl($j,"ImageIndex") ; 15.12.2008 Kokarev
    }
    q 1
]]></Implementation>
</Method>

<Method name="TLnameTBbut">
<Description>
Формирует имя кнопки</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 ;Имя кнопки начиная с 1000
 ;Обход существующих кнопок и поиск свободного номера
 n qqcTBbut,nameTBbut,CountTB,ret s qqcTBbut=""
 f  {
 s qqcTBbut=qW.UserOrd(1,"TBbut",qqcTBbut,"")
 q:qqcTBbut=""
 s nameTBbut=$e(qW.GG("TBbut","sysnameTBbut",qqcTBbut),2,$l(qW.GG("TBbut","sysnameTBbut",qqcTBbut)))
 s:nameTBbut'="" CountTB(nameTBbut)=""
 }
 ;Если не было ни одной кнопки определено
 i '$d(CountTB) q 1000

 ;Обход CountTB и поиск свободного номера
 s nameTBbut="",ret=""
 f  {
 s nameTBbut=$o(CountTB(nameTBbut))
 q:nameTBbut=""
 i ((nameTBbut+1)'=$o(CountTB(nameTBbut)))&($o(CountTB(nameTBbut))'="") s ret=(nameTBbut+1) q
 }

 q $s(ret'="":ret,1:($o(CountTB(nameTBbut),-1)+1))
]]></Implementation>
</Method>

<Method name="TLnumPic">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 n qqcTBAll s qqcTBAll=qW.UserOrd(1,"TBAll","","") q:qqcTBAll="" ""
 ;Присвоение номера кнопки
 ;Обход существующих картинок и поиск свободного номера
 n qqcPict,count,CountP s qqcPict=""
 f  {
 s qqcPict=qW.UserOrd(1,"Pict",qqcPict,qqcTBAll)
 q:qqcPict=""
 s count=qW.GG("Pict","sysnumpic",qqcPict)
 s:count'="" CountP(count)=""
 }
 ;Если не было ни одной картинки определено
 i '$d(CountP) q 1

 ;Обход CountP и поиск свободного номера
 s count="",ret=""
 f  {
 s count=$o(CountP(count))
 q:count=""
 i ((count+1)'=$o(CountP(count)))&($o(CountP(count))'="") s ret=(count+1) q
 }

 q $s(ret'="":ret,1:($o(CountP(count),-1)+1))
]]></Implementation>
</Method>

<Method name="TLonToolButtonClick">
<Internal/>
<FormalSpec>Sender:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $P(Sender,".")'=("Q"_$G(qqnump))!$G(W("ZredB")),qARM.ChgWin() Q "" ;Обработка смены окна (смена локальной среды)
 n nameB s nameB=$p(Sender,".",3)
 ;d qARM.Message(Sender)

 ;Поиск кнопки с данным именем
 n qqcTB s qqcTB=$p($p(Sender,".",2),"_",3)
 n qqcTBAll s qqcTBAll=qW.UserOrd(1,"TBAll","","") q:qqcTBAll="" ""

 n qqcTBid s qqcTBbut=qW.FastKey("TBbut","sysnameTBbut",qqcTB,,nameB,qqcTBAll)
 q:qqcTBbut="" ""
 X qW.GG("TBbut","sysdoTBbut",qqcTBbut)
 ;d qARM.wM(qwin_".XU"_"100","Popup")


 q ""
]]></Implementation>
</Method>

<Method name="TLwpic">
<Description>
Возвращает выражение для ресурса ячейки из объекта Картинка
nump - номер картинки</Description>
<Internal/>
<FormalSpec>nump:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 q:$g(nump)="" ""
 n qqcPicture
 s qqcPicture=qW.FastKey("Pict","sysnumpic",,,nump)
 q:qqcPicture="" "" 

 q "M,^Q(1,""Pict"","""_qqcPicture_""",""Ypic""),0"
]]></Implementation>
</Method>

<Method name="TMenuObj">
<Description>
             Отработка выборов меню редактирования объектов.</Description>
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 G @("m"_$TR(Arg1,"_","p"))
 ;свойства
m90 D qSYS.CallDef(Vo(qqnump),$S('W("Zpos",1,"y")&('W("Zpos",1,"x")):"",1:$P(W("Zpos",1,"d")," ")),$S('$P(W("Zpos",1,"d")," ",2)&('W("Zpos",1,"x")):"",1:$P(W("Zpos",1,"d")," ",2)),$S('W("Zpos",1,"x"):"",1:W("Zpos",1,"x")-1)) Q ""
 ;Вставить
m91p1   D ..Redview(1) Q "" ;Строку
m91p2   D ..Redview(3) Q "" ;ячейку
m91p5   D ..Redview(30) Q "" ;Колонку
m91p3p1 S W("Zcrea")="" D ..Redview(6) Q "" ;Объект_текущего_уровня
m91p3p2 S W("Zcrea")="1 0" D ..Redview(6) Q ""
m91p3p3 S W("Zcrea")="0 0" D ..Redview(6) Q ""
m91p3p4 S W("Zcrea")="1 1" D ..Redview(6) Q ""
m91p3p5 S W("Zcrea")="0 1" D ..Redview(6) Q ""
m91p4p1  S W("Zcrea")="" D ..Redview(5) Q "" ;Объект_нижнего_уровня
m91p4p2 S W("Zcrea")="1 0" D ..Redview(5) Q ""
m91p4p3 S W("Zcrea")="0 0" D ..Redview(5) Q ""
m91p4p4 S W("Zcrea")="1 1" D ..Redview(5) Q ""
m91p4p5 S W("Zcrea")="0 1" D ..Redview(5) Q ""
m92     ;Удалить
m92p1   D ..Redview(2) Q "" ;Строку
m92p2   Q:'$G(W("Zpos",1,"x")) "" D ..Redview(4) Q "" ;Ячейку
m92p5   Q:'$G(W("Zpos",1,"x")) "" D ..Redview(40) Q "" ;колонку
m92p3   Q:'$G(W("Zpos",1,"y")) "" D ..Redview(7) Q "" ;Объект
 ;копировать
m96p1   D ..Redview("ResObj",0) Q "" ;Объект
m96p2   D ..Redview("ResObj",1) Q "" ;Поддерево
m96p3   D ..Redview("ResView") Q "" ;Отображение
m96p4   D ..Redview("ResCell") Q ""      ;Ячейка                //sasha 20080717
m93     ;Отображение
m93p1   D ..Redview("SavBuf") Q "" ;Сохранить
m93p2   D ..Redview("RestBuf") Q ""
m93p3    ;печать
m93p3p1 ;структура с пояснениями
 D qARM.SaveView(1,"","syssysV"_Vo(qqnump))
 D qARM.MenuWoc("x320","x320",qARM.GetPar("x320"),1,"D qWEB.Print($J,,$E(qqchoice,7))") Q ""
m93p3p2 ;описание отображения
 D qARM.OpenWindow(,,,Vo(qqnump)_" XView   XView",,"XXXXNVstr")
 Q ""
 ;перетаскивание
m94p1
m94p2
m94p3
 S Vt(qqnump,"Zmenu94")=$P(Arg1,"_",2)
 D qARM.wcrm("94_1",1,"Перетаскивать ячейку",","_(Vt(qqnump,"Zmenu94")=1))
 D qARM.wcrm("94_2",1,"Копировать параметры",","_(Vt(qqnump,"Zmenu94")=2))
 //D qARM.wcrm("94_3",1,"Копировать ячейку",","_(Vt(qqnump,"Zmenu94")=3))
 D qARM.wcrm("94_3",1,"Копировать ячейку",","_(Vt(qqnump,"Zmenu94")=3)),qSYS.Redview("SavCell")  //sasha 20080717
 Q ""
 ;Описания
m95p1 ;отображения
 D qARM.OpenWindow("","","",Vo(qqnump)_" XView  ^Q(1)","","XXXXView") Q ""
m95p2 ;объекты
 D qARM.OpenWindow("","","",$P(W("Zpos",1,"d")," ")_" CxObj","","XXXCxObj") Q ""
m95p3 ;Понятия
 N qqw S qqw=$P($G(Vo(qqnump,$P(W("Zpos",1,"d")," "),0,$P(W("Zpos",1,"d")," ",2),W("Zpos",1,"x")-1)),$C(13,10)),qqw=$S('qqw:"","234"[$E(qqw):$E($P(qqw," "),2,20),1:"")
 D qARM.OpenWindow("","","",qqw_" CxWoc","","XXXCxWoc") Q ""
m98p1 D qARM.OpenText($G(qqRUN),"S %1=qARM.Value(Text,""X"") D:%1'="""""""" qARM.Message(%1)","Выполнить (XQend возвращается в виде сообщения)",400) Q ""
 ;заменить
m98p2 N qqq S qqq=Vo(qqnump,$P(W("Zpos",1,"d")," "),0,$P(W("Zpos",1,"d")," ",2),W("Zpos",1,"x")-1,2) D qARM.OpenText(qqq_">>"_qqq,"D qSYS.Redview(13,Text)","Заменить параметры ячеек (...>>...)",400) Q ""
m98p3p1
m98p3p2
m98p3p4 S W("Zoom")=$P(Arg1,"_",3) D qARM.wcro()
 D qARM.wcrm("98_3_1",1,"*1",","_($G(W("Zoom"),1)=1))
 D qARM.wcrm("98_3_2",1,"*2",","_($G(W("Zoom"),1)=2))
 D qARM.wcrm("98_3_4",1,"*4",","_($G(W("Zoom"),1)=4))
 Q ""
 ;заголовки
m98p4 D qSYS.Redview(14) Q ""
 ;колонки
m98p5 D qARM.OpenText("27,3,,5","D qSYS.Redview(16)","Колонки: Кол-во,Размер,Гор.выравнивание,Многострочность",400) Q ""
 ;переход на объект
m98p6 D qARM.OpenWindow("","","",,"","XXXPassObj") Q ""
m99 D qARM.OpenDHelp("11") Q ""
]]></Implementation>
</Method>

<Method name="TMenuServ">
<Description>
Отработка выборов меню сервиса</Description>
<Internal/>
<FormalSpec>qqchoice:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
    //sas 20090324 исправлены диалоги выбора файлов для сохранения данных, а также dat заменено на dat.gz
 G m63:$E(qqchoice,1,3)="63_",@("m"_$TR(qqchoice,"_","p"))
 ; Сохранить_в_поток;;;;;;
 ;перечень релевантных
m61p1p2
 I '$$$RelNum D qARM.Message("Нет перечня релевантных") Q ""
 ;I '$$$ReFind D qARM.Message("Не режим уточнения") Q ""
 D qARM.Question("Сохранить по перечню релевантных поддеревья для "_qARM.RecObj($$$CurObj),1,"","D qW.StreemExp(""^QS(1)"","""_$$$CurObj_""","""_qqc_""",1,1),qARM.wcrm(""61_4"",1,"""",$D(^QS(1))>1)") Q ""
 ;поддерево текущего объекта
m61p1p1
 D qARM.Question("Сохранить поддерево для "_qARM.RecObj($$$CurObj),1,"","D qW.StreemExp(""^QS(1)"","""_$$$CurObj_""","""_qqc_""",0,1),qARM.wcrm(""61_4"",1,"""",$D(^QS(1))>1)") Q ""
m61p1p3
 D qARM.Question("Сохранить "_$S($G($$$ReFind):"релевантные",1:"все")_" экземпляры объектов (и описанных понятий) отображения",1,"","D qW.StreemExp(""^QS(1)"","""","""_Vo(qqnump)_""","_$S($G($$$ReFind):2,1:0)_",1),qARM.wcrm(""61_4"",1,"""",$D(^QS(1))>1)") Q ""
 Q ""
 ; Восстановить_из_потока;;;;;;
m61p5 D qARM.OpenText("^QS(1)","D qW.rStreem(Text)","Массив потока") Q ""
m61p2p1 D qARM.Wait("D qW.StreemImp(""^QS(1)"",0),qARM.wcrm(""61_4"",1,"""",$D(^QS(1))>1),qARM.Message(""Ввод потока завершен"")") Q ""
m61p2p2 D qARM.Wait("D qW.StreemImp(""^QS(1)"",1),qARM.wcre(),qARM.wcrm(""61_4"",1,"""",$D(^QS(1))>1),qARM.Message(""Ввод потока завершен"")") Q ""
m61p3 I $D(^QS(1))<10 D qARM.Message("Нет потока") Q ""
 D qARM.OpenWindow(,,,"   ^QS(1)",,"XXXsysS") Q ""
m61p4 K ^QS(1) D qARM.wcrm("61_4",1,"",$D(^QS(1))>1) Q ""
 ;@Sveta 13.04.04
 ;поддерево текущего объекта в файл ; 15.12.2008 Kokarev
m61p5p1 
 N parsav2,parsav3,parsav5,savdat ;;;D setm61p5
 n nameG s nameG=$na($$$tmpGl)_"("""_$j_","_$r(999)_","_$zts_""")"  ;@Pav 20090324
 D qARM.Question("Сохранить поддерево для "_qARM.RecObj($$$CurObj),1,"","k "_nameG_" D qW.StreemExp("""_qSYS.dblqw(nameG)_""","""_$$$CurObj_""","""_qqc_""",0,1) D qARM.OpenWinDialog(""D qSYS.zwrk1("""""_qSYS.dblqw(qSYS.dblqw(nameG))_""""")"",""File of data(*.dat.gz)|*.dat.gz|File of data(*.dat)|*.dat|"","""_qWEB.ClientPath()_""","".dat.gz"",""updateQS.dat.gz"",1)") Q ""
 ;D qARM.Question("Сохранить поддерево для "_qARM.RecObj($$$CurObj),1,"","D qW.StreemExp("""_$na($$$tmpGl)_"("""""_qARM("ComputerName")_""""")"","""_$$$CurObj_""","""_qqc_""",0,1) D qARM.OpenWinDialog(""D qSYS.zwrk1()"",""File of data(*.dat.gz)|*.dat.gz|;"","""_qWEB.ClientPath()_""","".dat.gz"",""updateQS.dat.gz"",1)") Q ""
 ;;;D qARM.Question("Сохранить поддерево для "_qARM.RecObj($$$CurObj),1,"","D qW.StreemExp(""^QF"_qARM("ComputerName")_"(1)"","""_$$$CurObj_""","""_qqc_""",0,1) D qARM.OpenWinDialog(""D qSYS.savedat(qARM(""""qpars"""",0),"_savdat_""",""File of data(*.dat)|*.dat|;"","""_qWEB.ClientPath()_""","".dat"",""updateQS.dat"")") Q ""
 ;перечень релевантных в файл ; 15.12.2008 Kokarev
m61p5p2 
 N parsav2,parsav3,parsav5,savdat ;;;D setm61p5
 n nameG s nameG=$na($$$tmpGl)_"("""_$j_","_$r(999)_","_$zts_""")"  ;@Pav 20090324
 I '$$$RelNum D qARM.Message("Нет перечня релевантных") Q ""
 D qARM.Question("Сохранить по перечню релевантных поддеревья для "_qARM.RecObj($$$CurObj),1,"","k "_nameG_" D qW.StreemExp("""_qSYS.dblqw(nameG)_""","""_$$$CurObj_""","""_qqc_""",1,1) D qARM.OpenWinDialog(""D qSYS.zwrk1("""""_qSYS.dblqw(qSYS.dblqw(nameG))_""""")"",""File of data(*.dat.gz)|*.dat.gz|File of data(*.dat)|*.dat|"","""_qWEB.ClientPath()_""","".dat.gz"",""updateQS.dat.gz"",1)") Q ""
 ;D qARM.Question("Сохранить по перечню релевантных поддеревья для "_qARM.RecObj($$$CurObj),1,"","D qW.StreemExp("""_$na($$$tmpGl)_"("""""_qARM("ComputerName")_""""")"","""_$$$CurObj_""","""_qqc_""",1,1) D qARM.OpenWinDialog(""D qSYS.zwrk1()"",""File of data(*.dat.gz)|*.dat.gz|;"","""_qWEB.ClientPath()_""","".dat.gz"",""updateQS.dat.gz"",1)") Q ""
 ; 15.12.2008 Kokarev
m61p5p3
 N parsav2,parsav3,parsav5,savdat ;;;D setm61p5
 n nameG s nameG=$na($$$tmpGl)_"("""_$j_","_$r(999)_","_$zts_""")"  ;@Pav 20090324
 D qARM.Question("Сохранить "_$S($G($$$ReFind):"релевантные",1:"все")_" экземпляры объектов (и описанных понятий) отображения",1,"","k "_nameG_" D qW.StreemExp("""_qSYS.dblqw(nameG)_""","""","""_Vo(qqnump)_""","_$S($G($$$ReFind):2,1:0)_",1) D qARM.OpenWinDialog(""D qSYS.zwrk1("""""_qSYS.dblqw(qSYS.dblqw(nameG))_""""")"",""File of data(*.dat.gz)|*.dat.gz|File of data(*.dat)|*.dat|"","""_qWEB.ClientPath()_""","".dat.gz"",""updateQS.dat.gz"",1)") Q ""
 ;;;D qARM.Question("Сохранить "_$S($G($$$ReFind):"релевантные",1:"все")_" экземпляры объектов (и описанных понятий) отображения",1,"","D qW.StreemExp(""^QF"_qARM("ComputerName")_"(1)"","""","""_Vo(qqnump)_""","_$S($G($$$ReFind):2,1:0)_",1) D qARM.OpenWinDialog(""D qSYS.savedat(qARM(""""qpars"""",0),"_savdat_""",""File of data(*.dat)|*.dat|;"","""_qWEB.ClientPath()_""","".dat"",""updateQS.dat"")") Q ""
 ; восстановить поток из файла
 ;без включения в релевантные
m61p6p1 
 D qARM.OpenWinDialog("D qARM.wM(""-qARM"",""ModalExec"",qARM(""ClientPath"")_""GManager.exe -S""_qARM(""SectionIni"")_"" -C -R -F""_$TR(qARM(""qpars"",0),"" "",""*"")_"" -H"")","File of data(*.dat.gz)|*.dat.gz|File of data(*.dat)|*.dat|",qWEB.ClientPath(),".dat.gz","updateQS.dat.gz") Q ""
 ;с включением в релевантные ; 15.12.2008 Kokarev
m61p6p2 
 S $$$tmpGl("StreemImpRel")=1 D qARM.OpenWinDialog("D qARM.wM(""-qARM"",""ModalExec"",qARM(""ClientPath"")_""GManager.exe -S""_qARM(""SectionIni"")_"" -C -R -F""_$TR(qARM(""qpars"",0),"" "",""*"")_"" -H"") M ^Q("""_$$$Relind_qview_""")=^Q("""_$$$Relind_"XXXStreemImp"") S Vs(qqnump,""RelNum"")=1 K ^Q("""_$$$Relind_"XXXStreemImp""),"_$na($$$tmpGl)_"(""StreemImpRel"") D qARM.wcre()","File of data(*.dat.gz)|*.dat.gz|;",qWEB.ClientPath(),".dat.gz","updateQS.dat.gz") Q ""
 D qARM.OpenWinDialog("D qARM.wM(""-qARM"",""ModalExec"",qARM(""ClientPath"")_""GManager.exe -S""_qARM(""SectionIni"")_"" -C -R -F""_$TR(qARM(""qpars"",0),"" "",""*"")_"" -H"")","File of data(*.dat.gz)|*.dat.gz|File of data(*.dat)|*.dat|",qWEB.ClientPath(),".dat.gz","updateQS.dat.gz") Q ""
 ;;;;;;;;;;;;
setm61p5
 S qARM("ComputerName")=qW.zsymbol(qARM("ComputerName"))
 S parsav2="""K ^QF"_qARM("ComputerName")_""""
 ;s qARM(""""""""ClientIP"""""""")=""""""""1.1.1.4"""""""",qARM(""""""""Password"""""""")=""""""""drowq"""""""",qARM(""""""""ClientPath"""""""")=""""""""D:\"""""""", qARM(""""""""CntStr"""""""")=""""""""cn_iptcp:127.0.0.1[1972]:test"""""""",qARM(""""""""ComputerName"""""""")=""""""""O"""""""", qARM(""""""""Screen"""""""",""""""""Height"""""""")=600,qARM(""""""""Screen"""""""",""""""""Width"""""""")=800, qARM(""""""""SectionIni"""""""")=""""""""test"""""""" s qa=##class(%TqARM).%New() d qa.Create()
 S parsav3="""s qARM(""""""""ClientIP"""""""")=""""""""1.1.1.4"""""""",qARM(""""""""Password"""""""")=""""""""drowq"""""""",qARM(""""""""ClientPath"""""""")=""""""""D:\"""""""", qARM(""""""""CntStr"""""""")=""""""""cn_iptcp:127.0.0.1[1972]:test"""""""",qARM(""""""""ComputerName"""""""")=""""""""O"""""""", qARM(""""""""Screen"""""""",""""""""Height"""""""")=600,qARM(""""""""Screen"""""""",""""""""Width"""""""")=800, qARM(""""""""SectionIni"""""""")=""""""""test"""""""" s qa=##class(%TqARM).%New() d qa.Create() D qW.StreemImp(""""""""^QF"_qARM("ComputerName")_"(1)"""""""") K ^QLog(""""""""drowq""""""""),^QF"_qARM("ComputerName")_""""
 ;S parsav3="""D qW.StreemImp(""""""""^CacheTemp"_qARM("ComputerName")_"(1)"""""""")"""
 S parsav5="""^QF"_qARM("ComputerName")_""""
 S savdat=""""_parsav2_""","""_parsav3_""","""""""","""_parsav5_""",1) D:0 qARM.Wait(""""K ^QF"_qARM("ComputerName")_""""")"
 Q
 ;сохранение GM
m61p7p1 ; текущее поддерево
 D qARM.OpenWinDialog("d qSYS.CallGM(""m61p7p1"")","File of data(*.dat.gz)|*.dat.gz|;",qWEB.ClientPath(),".dat.gz","AAA.dat.gz",1) Q ""
 s %GMVirt="d qW.GMFileExp("""_$$$CurObj_""","""_qqc_""",0)"  s %GMInit="s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()" d qARM.wM("-qARM","ClipboardSet")
 ;D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni"))
 D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -FABC.dat.gz -C -S -H -M -D")
 q ""
m61p7p2 ; поддеревья релевантных
 D qARM.OpenWinDialog("d qSYS.CallGM(""m61p7p2"")","File of data(*.dat.gz)|*.dat.gz|;",qWEB.ClientPath(),".dat.gz","AAA.dat.gz",1) Q ""
m61p7p3 ; отображение с учетом релевантных
 D qARM.OpenWinDialog("d qSYS.CallGM(""m61p7p3"")","File of data(*.dat.gz)|*.dat.gz|;",qWEB.ClientPath(),".dat.gz","AAA.dat.gz",1) Q ""
 ;      
m61p8 ; восстановление
 D qARM.OpenWinDialog("d qSYS.CallGM(""m61p8"")","File of data(*.dat.gz)|*.dat.gz|;",qWEB.ClientPath(),".dat.gz","AAA.dat.gz") Q ""
 s %GMVirt="S BB=$I(BB),^BB(BB)=%gNd_%gVl d:0 qW.GMFileImp()"  s %GMInit="s qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New(),qW=##class(%qWORD).%New(),qWEB=##class(%qWEB).%New()" d qARM.wM("-qARM","ClipboardSet")
 D qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -FABC.dat.gz -C -R -H -M")
 q ""

 ;XML
m71p1 ;сохранить в файл
 D qARM.OpenWindow(,,,,,"XXXXExport") Q ""
m63 ; Удаление_перечня_релевантных
 D qARM.RecDelRel() Q ""
 ;S length=$P(qqchoice,"_",2)*1000 ;было управление протоколом
 ;D qARM.wcrm("63_1",1,"1000",","_(length=1000))
 ;D qARM.wcrm("63_2",1,"2000",","_(length=2000))
 ;D qARM.wcrm("63_5",1,"5000",","_(length=5000))
 ;D qARM.wcrm("63_10",1,"10000",","_(length=10000))
 ;D qARM.wcrm("63_20",1,"20000",","_(length=20000))
 ;D qARM.wcrm("63_30",1,"30000",","_(length=30000))
 ;Q ""
 ;пересчет всех объектов
m65     S %1=qW.qObjNum($$$CurObj) Q ""
 ;преобразование текущего объекта
m69p1 I $G(Vo(qqnump,$$$CurObj,2))>1 D qARM.OpenText($$$CurObj_" "_$$$CurObj,"D qW.qObjConv($P(Text,"" "",1),$P(Text,"" "",2))","Преобразовать виртуальный объект в хранимый",400) Q ""
 I $D(Vs(qqnump,12,$$$CurObj))<10 D qARM.Message("Нет выражений преобразований для текущего объекта") Q ""
 D qARM.Question($S('$$$ReFind:"По всей базе!!!"_$C(13,10),1:"")_"Преобразовать выражениями аналитик экземпляры объекта "_$$$CurObj,1,"","D qARM.Wait(""D qW.qObjConv()"")") Q ""
m69p2 I $D(Vt(qqnump,111)) D qARM.Question("Преобразовать все виртуальные объекты в хранимые"_$S(qW.GG("XBase","XFSQLcon",0):" (по списку соединений)",1:""),0,"","D qW.qObjConv(,,1)") Q ""
 I $D(Vs(qqnump,12))<10 D qARM.Message("Нет выражений преобразований") Q ""
 D qARM.Question($S('$$$ReFind:"По всей базе!!!"_$C(13,10),1:"")_"Преобразовать выражениями аналитик экземпляры всех объектов отображения",1,"","D qARM.Wait(""D qW.qObjConv(,,1)"")") Q ""
m69p3 I '$D(Vt(qqnump,111)) D qARM.Message("Только для преобразования виртуальных в хранимые") Q ""
 D qARM.Question("Последовательно преобразовать все виртуальные объекты в хранимые"_$S(qW.GG("XBase","XFSQLcon",0):" (по списку соединений)",1:""),0,"","D qW.qObjConv(,,2)") Q ""
 ;
m66 ; закачка файла
 D qARM.OpenWinDialog("D qSYS.LoadQRes()") Q ""
 ;Выполнить
m67 D qARM.OpenText($G(qqRUN),"N qqTime S qqRUN=Text,qqTime=$P($H,"","",2),%1=qARM.Value(Text,""X""),qqTime=$P($H,"","",2)-qqTime,qqTime=qqTime\60_"":""_(qqTime#60) D:%1'="""""""" qARM.Message(%1,""dt=""_qqTime)","Выполнить (XQend возвращается в виде сообщения)",400) Q ""
 ;Проводник
 ;D qARM.SaveView(1)
 ;D qARM.OpenWindow(,,,,,"XXXX") Q ""
m68 S Vt(qqnump,"Zcordtu")='$G(Vt(qqnump,"Zcordtu")) D qARM.wcrm("P668",1,"",","_Vt(qqnump,"Zcordtu")) D ..CreZcordtu(Vt(qqnump,"Zcordtu")) Q ""
m70 D qARM.OpenDHelp("2,4") Q ""
 ;состояние отображения
m62p1 D ..ViewStat()
 S Vo("par",-1,23)="S W(""Zdomod"")=1"
 S Vo("par",-1,22)="D qARM.WrWin("""",0,"""",""qSYS.ViewStat(0,1),qARM.wcro(),qARM.MenuAn(""""FAD"""")"") S qqend=1" 
 D qARM.OpenWindow(,,,"XViewStat "_$TR(qview," ","_")_"  ^Q(1,""XViewStat"","""_$TR(qview," ","_")_""") XViewStat",,"XXXXViewStat") Q ""
m62p2 D qARM.SaveView(1) Q ""
m62p3 K Vs(qqnump) M Vs(qqnump)=^Q("V"_qview,"XObjStat") ;пока так ???XViewStat
 D qARM.wcro(),qARM.MenuAn("AFD"),qARM.wcre() Q ""
 ;сохранение состояний меню
m62p4 N q,i S q="" F i=0:1:3 D  ;поиск
 .I 'i S $P(q,",",i+1)=$G(Vs(qqnump,99,"Find")) Q
 .S $P(q,",",i+1)=$G(Vs(qqnump,99,"Find",i))
 S $P(Vo(qqnump,-1,70)," ",2)=q
 S q="" F i=1:1:6 D  ;аналитика
 .I i=2 S $P(q,",",i)=$G(Vs(qqnump,99,"Anal")) Q
 .S $P(q,",",i)=$G(Vs(qqnump,99,"Anal",$S(i=1:0,1:i-2)))
 S $P(Vo(qqnump,-1,70)," ",3)=q
 N qq S qq="P,M,S,X,R",q="" F i=1:1:5 D  ;диаграмма
 .S $P(q,",",i)=$G(Vs(qqnump,13,$P(qq,",",i)))
 S $P(Vo(qqnump,-1,70)," ",4)=$TR(q," ","_")
 S ^Q(1,"XView",Vo(qqnump),"X170")=Vo(qqnump,-1,70) Q ""
 ;сохранение размеров окна
m62p5 D qARM.wG(qwin,"Width"),qARM.wG(qwin,"Height"),qARM.wG(qwin,"SplitterMove",-1),qARM.wG(qwin,"ShowTrees",-1)
 S ^Q(1,"XView",Vo(qqnump),"X162")=0 ;сброс авторазмеров окна
 Q ""
 ;сохранение размеров граф дерева объектов
m62p6 N i F i=0:1:9 D qARM.wG(qwin_".T1","ColumnWidth",i)
 Q ""
 ;сохранение размеров граф дерева экземпляров
m62p7 N i F i=0:1:$G(Vo(qqnump,-1,9),0) D qARM.wG(qwin_".T2","ColumnWidth",i)
 Q ""
 ;m72 S OlegFind='$g(OlegFind) D qARM.wcrm(0,1,"Тестирование нового варианта поиска",","_(''$g(OlegFind))) Q "" ;@Oleg тестирование нового поиска
m72 S qqGERROR='$g(qqGERROR) D qARM.wcrm(0,1,"Выводить ошибки в обобщениях",","_(''$g(qqGERROR))) Q "" ;@Dol 24.08.09
 Q
]]></Implementation>
</Method>

<Method name="TTab">
<Internal/>
<FormalSpec>file:%Library.String,mas:%Library.String,raz:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 O file I '$T Q:$Q 0 Q
 K @mas S:$G(raz)="" raz="|"
 N I,str,i,j,k,s,ss
 S k=0,p=0
 U file F I=1:1 R str Q:$ZEOF=-1  D
 .I str'[raz Q
 .I $TR(str," "_raz)="" D  Q
 ..;I $G(@mas@(p,0,1))'="",p S p=p+1,k=0 Q
 ..S k=k+1 Q
 .F i=1:1:$L(str,raz) S s=$ZSTRIP($P(str,raz,i),"<>W") D
 ..I i=1,s'="",$G(@mas@(p,k,i))="" S p=p+1,k=0
 ..S ss=$G(@mas@(p,k,i)) I s'="" S ss=$S(ss="":ss_s,$E(ss,$L(ss))'="-":ss_" "_s,$E(ss,$L(ss)-1)'=" ":$E(ss,1,$L(ss)-1)_s,1:ss_" "_s)
 ..S:ss'="" @mas@(p,k,i)=ss
 c file Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="TextHelpRTF">
<Internal/>
<FormalSpec>qqv:%Library.String,qqpar2:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; вывод пояснения компоненты
 N comp,cod,qqo,adm,X52w,X52o
 S adm=$G(W("Zadm")),adm=$S($E(Vo(qqnump),1,3)="XXX":1,1:adm)
 S cod=$E(qqpar2,2,255) S:$E(qqpar2)="W" qqo=$P(cod,"_",2),cod=$P(cod,"_")
 S comp=$S($E(qqpar2)="W":"CxWoc",$E(qqpar2)="O":"CxObj",$E(qqpar2)="V":"XView",1:"")
 I comp="" Q:$Q "" Q
 I $D(Vo(qqnump,"CxWoc")),$G(Vo(qqnump,"CxWoc",2))>1 S X52w=Vo(qqnump,"CxWoc",2),Vo(qqnump,"CxWoc",2)=0 ;@Dol 23.0.07 
 N help S help="{\rtf1\ansi\ansicpg0\uc1\deff0\deflang1024\deflangfe1024{\fonttbl{\f0\fnil\fcharset1 Times New Roman;}{\f1\fnil\fcharset1 Arial;}{\f2\fnil\fcharset1 Verdana;}{\f3\fnil\fcharset204 uTimes New Roman;}{\f4\fnil\fcharset1 MS Sans Serif;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red255\green64\blue64;\red51\green51\blue153;}{\stylesheet{\s0\fi0\li0\ql\ri0\sb0\sa0 Paragraph Style;}{\s1\fi0\li0\qc\ri0\sb0\sa0 Centered;}{\*\cs2\f0\fs24 Normal text;}{\*\cs3\f1\b\fs28 Heading;}{\*\cs4\f2\b\i\fs24 Subheading;}{\*\cs5\f2\i\fs24\cf13 Keywords;}{\*\cs6\f0\ul\fs24\cf11 Jump 1;}{\*\cs7\f0\ul\fs24\cf11 Jump 2;}{\*\cs8\f3\b\lang1049\fs40 Font Style;}{\*\cs9\f4\fs16 Font Style;}{\*\cs10\f4\fs16\cf17 Font Style;}{\*\cs11\f4\fs16\cf18 Font Style;}}"
 ;S help="{\rtf1\ansi\ansicpg0\uc1\deff0\deflang1024\deflangfe1024{\fonttbl{\f0\fnil\fcharset1 Times New Roman;}{\f1\fnil\fcharset1 Arial;}{\f2\fnil\fcharset1 Verdana;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\s0\fi0\li0\ql\ri0\sb0\sa0 Paragraph Style;}{\s1\fi0\li0\qc\ri0\sb0\sa0 Centered;}{\*\cs2\f0\fs24 Normal text;}{\*\cs3\f1\b\fs28 Heading;}{\*\cs4\f2\b\i\fs24 Subheading;}{\*\cs5\f2\i\fs24\cf13 Keywords;}{\*\cs6\f0\ul\fs24\cf11 Jump 1;}{\*\cs7\f0\ul\fs24\cf11 Jump 2;}}"
 S help=help_"\uc1\pard\lang1033\f0\fs20\cf18"_"ПОЯСНЕНИЯ для "_$S($E(qqpar2)="W":$S($E(qqpar2,2,3)="Zs":"Ячейки",1:"Понятия"),$E(qqpar2)="O":"Объекта",$E(qqpar2)="V":"Отображения",1:"")   ;_" }"
 S help=help_"\pard\lang1033\f0\fs22\cf0\par"
 S help=help_"\par"
 ;
 I $E(qqpar2,1,3)="WZs" D  I cod="" S help=help_" }" S:$D(X52w) Vo(qqnump,"CxWoc",2)=X52w $$$oQuit(1,help)     ;D ..CreVoAdd() Q:$Q "" Q  ;пояснения по ячейки
 .S %1=$G(Vo(qqnump,qqo,0,$P($E(cod,3,5),"c"),$P(cod,"c",2))) ;тип ячейки
 .I $E(%1)'=0,$E(%1)'=5 S cod=$E(%1,2,255) D
 ..S:adm help=help_"\pard\lang1033\b\f0\cf17"_cod_"   " S help=help_"\pard\lang1033\b\f0\cf18"_$S($G(Vs("par","Name"))'="":Vs("par","Name"),$E(qqpar2)="V":qW.GG(comp,"X11",cod),1:qW.GetWoc(comp,cod))
 ..K Vs("par","Name") S help=help_"\par"
 ..S:adm help=help_"\pard\lang1033\b\f0\cf0"_qW.GG(comp,"XRef",cod) S help=help_"\pard\lang1033\i\b0\f0\cf0 "_$S($G(Vs("par","Thlp"))'="":qW.zReplace(qW.zReplace(qW.zReplace(qW.zReplace(Vs("par","Thlp"),"\","\\"),"{","\{"),"}","\}"),$C(13,10),"\par"),1:qW.zReplace(qW.zReplace(qW.zReplace(qW.zReplace(qW.GT(comp,"Thlp",cod),"\","\\"),"{","\{"),"}","\}"),$C(13,10),"\par ")) ;@dima 20100526 последний "\par" -> "\par "
 ..K Vs("par","Thlp")
 ;
 S:$e(qqpar2)'="V" help=help_"\par\pard\lang1033\f0\cf17"
 I $E(qqpar2,1,3)="WZs" D  I cod="" S help=help_" }" S:$D(X52w) Vo(qqnump,"CxWoc",2)=X52w $$$oQuit(1,help)     ;D ..CreVoAdd() Q:$Q "" Q  ;пояснения по ячейки
 .I $E(%1)'=0,$E(%1)'=5 S cod=$E(%1,2,255) Q
 .S help=help_"\pard\lang1033\b\f0\fs30\cf17"_$S($E(%1)=5:"Выражение",1:"Константа")    ;_" }" 
 .;S ^Vo(qqnump,-1,0,1,1)=$S($E(%1)=5:"5""Выражение""",1:"5""Константа""")
 .S:adm help=help_"\pard\lang1033\f0\fs30\cf10"_"   "_$E(%1,2,10000)
 .I $G(Vs("par","Thlp"))'="" S help=help_"\par\pard\lang1033\f0\fs30\cf10 "_qW.zReplace(qW.zReplace(qW.zReplace(qW.zReplace(Vs("par","Thlp"),"\","\\"),"{","\{"),"}","\}"),$C(13,10),"\par") K Vs("par","Thlp")
 .N qqwt
 .D
 ..S qqwt=qARM.GetPar("X731",,qqo,$P($E(cod,3,5),"c"),$P(cod,"c",2))
 .S:qqwt'="" help=help_"\par\pard\lang1033\b\f0\fs20\cf0"_qW.GetWoc("Cx731",+qqwt)
 .D
 ..S qqwt=qARM.GetPar("x730",,qqo,$P($E(cod,3,5),"c"),$P(cod,"c",2))
 .S:qqwt'="" help=help_"\pard\lang1033\b\f0\fs20\cf0"_"  Разв.: "_qW.GetWoc("Cx730",qqwt)
 .S cod=""
 I $E(qqpar2)="V" D  S help=help_" }" S:$D(X52w) Vo(qqnump,"CxWoc",2)=X52w $$$oQuit(1,help)     ;по отображению
 .;S:adm Vo(qqnump,-1,0,1,0)="0База" S Vo(qqnump,-1,0,1,1)=5_"qW.GG(""XBase"",""XBName"",0)",Vo(qqnump,-1,0,1,3)="5qW.GT(""XBase"",""Thlp"",0)"
 .S help=help_"\pard\lang1033\f0\b\cf18   База  \b"_qW.GG("XBase","XBName",0)_"\par\i\cf0 "_qW.GT("XBase","Thlp",0)
 .;S:adm Vo(qqnump,-1,0,2,0)="5"""_cod_"""" S Vo(qqnump,-1,0,2,1)=5_"qW.GG("""_comp_""",""X11"","""_cod_""")" S:adm Vo(qqnump,-1,0,2,2)="5qW.GG("""_comp_""",""XRef"","""_cod_""")" S Vo(qqnump,-1,0,2,3)="5qW.GT("""_comp_""",""Thlp"","""_cod_""")"   
 .S:adm help=help_"\pard\lang1033\f0\i0\cf17"_cod_"    " S help=help_"\pard\cf18"_qW.GG(comp,"X11",cod) S:adm help=help_"  "_qW.GG(comp,"XRef",cod)
 .S help=help_"\par\pard\lang1033\f0"
 .S help=help_"\par\i\b0\cf0"_qW.zReplace(qW.zReplace(qW.zReplace(qW.zReplace(qW.GT(comp,"Thlp",cod),"\","\\"),"{","\{"),"}","\}"),$C(13,10),"\par")
 I $E(qqpar2)="O" D  S help=help_" }" S:$D(X52w) Vo(qqnump,"CxWoc",2)=X52w $$$oQuit(1,help) 
 .S:adm help=help_"\pard\lang1033\f0\fs22\cf17 "_cod_"    " S help=help_"\pard\b\cf18"_$S($G(Vs("par","Name"))'="":Vs("par","Name"),$E(qqpar2)="V":qW.GG(comp,"X11",cod),1:qW.GetWoc(comp,cod))
 .S:adm help=help_"\fs22"_ qW.GG(comp,"XRef",cod) S help=help_"\par\i\b0\fs22\cf0"_$S($G(Vs("par","Thlp"))'="":qW.zReplace(qW.zReplace(qW.zReplace(qW.zReplace(Vs("par","Thlp"),"\","\\"),"{","\{"),"}","\}"),$C(13,10),"\par"),1:qW.zReplace(qW.zReplace(qW.zReplace(qW.zReplace(qW.GT(comp,"Thlp",cod),"\","\\"),"{","\{"),"}","\}"),$C(13,10),"\par"))
 .K Vs("par","Name"),Vs("par","Thlp")
 ;
 I $E(qqpar2)'="W" S help=help_" }" S:$D(X52w) Vo(qqnump,"CxWoc",2)=X52w $$$oQuit(1,help)    ;D ..CreVoAdd() Q:$Q "" Q
 N qqw,qqwt,qi,qqwpar S qi=3,qqw=cod D  S help=help_" }" S:$D(X52w) Vo(qqnump,"CxWoc",2)=X52w $$$oQuit(1,help)  ;D ..CreVoAdd() Q:$Q "" Q
 .D
 ..S qqwt=qARM.GetPar("X731",,qqo,qqw),qqwpar=qARM.GetPar("X73",,qqo,qqw)
 .;I $S(qqwt'="":1,1:$E(qqw)'="@") S Vo(qqnump,-1,0,qi,1)="0"_qW.GetWoc("Cx731",+qqwt),Vo(qqnump,-1,0,qi,1,2)=",,,,1,,,255"
 .I $S(qqwt'="":1,1:$E(qqw)'="@") S help=help_"\par\pard\lang1033\f0\fs20\i0\cf0  Вариант редактирования:   \pard\i "_qW.GetWoc("Cx731",+qqwt) ; @dima 20100526 добавлен пробел после "\pard\i"
 .D
 ..S qqwt=qARM.GetPar("x730",,qqo,qqw)
 .S:qqwt'="" help=help_"\pard\lang1033\i0\f0\fs20\cf0     Развертка:   \pard\i "_qW.GetWoc("Cx730",qqwt)
 .S qi=qi+1
 .;Q:"@XLTM"[$E(qqw)
 .;S help=help_"\par\pard\lang1033\f0\fs20\cf0"
 .;S help=help_"\par\pard\lang1033\f0\fs20\cf0"
 .D
 ..S qqwt=qARM.GetPar("x77",,qqo,qqw) I qqwt="",$E(qqw)="x" S qqwt=1 ;@Dol 5.02.06
 .Q:qqwt=0  I "@XLTM"[$E(qqw) Q:'qqwt  Q:$P(qqwpar," ")=""  N qqw S qqw=$P(qqwpar," ")
 .S qqo=-1 S:'qqwt qqwt=4  ;нужны значения?
 .;;S:'(qqwt#2) help=help_"\par\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap0 {\trowd\trgaph45\trleft0\itap1\trpaddl15\trpaddt15\trpaddr15\trpaddb15\trpaddfl3\trpaddft3\trpaddfr3\trpaddfb3\trspdl15\trspdr15\trspdfl3\trspdfr3\trspdt15\trspdb15\trspdft3\trspdfb3\trftsWidth1\richviewtbw0\trbrdrl\brdrs\brdrw15\brdrcf0\trbrdrt\brdrs\brdrw15\brdrcf0\trbrdrr\brdrs\brdrw15\brdrcf0\trbrdrb\brdrs\brdrw15\brdrcf0\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx1900\cellx4400\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx7565\pard\intbl\itap1" 
 .;;S:qqwt#2&($E(qqw)'="D") help=help_"\par\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap0 {\trowd\trgaph45\trleft0\itap1\trpaddl15\trpaddt15\trpaddr15\trpaddb15\trpaddfl3\trpaddft3\trpaddfr3\trpaddfb3\trspdl15\trspdr15\trspdfl3\trspdfr3\trspdt15\trspdb15\trspdft3\trspdfb3\trftsWidth1\richviewtbw0\trbrdrl\brdrs\brdrw15\brdrcf0\trbrdrt\brdrs\brdrw15\brdrcf0\trbrdrr\brdrs\brdrw15\brdrcf0\trbrdrb\brdrs\brdrw15\brdrcf0\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx975\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx3200\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx5400\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx7595\pard\intbl\itap1"
 .;;S:qqwt#2&($E(qqw)="D") help=help_"\par\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap0 {\trowd\trgaph45\trleft0\itap1\trpaddl15\trpaddt15\trpaddr15\trpaddb15\trpaddfl3\trpaddft3\trpaddfr3\trpaddfb3\trspdl15\trspdr15\trspdfl3\trspdfr3\trspdt15\trspdb15\trspdft3\trspdfb3\trftsWidth1\richviewtbw0\trbrdrl\brdrs\brdrw15\brdrcf0\trbrdrt\brdrs\brdrw15\brdrcf0\trbrdrr\brdrs\brdrw15\brdrcf0\trbrdrb\brdrs\brdrw15\brdrcf0\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx2200\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx4300\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx7565\pard\intbl\itap1"
 .;S qqo=-1 S:'qqwt qqwt=4  ;нужны значения?
 .;;;S help=help_"{{\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\b0\f0\fs22   "_$S(qqwt#2&($E(qqw)'="D"):"Код",1:"Значение")_"\cell}{"
 .;;;S:qqwt#2&($E(qqw)'="D") help=help_"\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0    Значение  \cell}{"
 .;;;S help=help_"\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0    Характеристика  \cell}{"
 .;;;S help=help_"\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0   Пояснения  \cell}}\pard\intbl\itap1\row"
 .S help=help_"\par\b0"
 .;;;;S help=help_"\par\pard\lang1033\f0\fs20\i0\cf0   (1) "_$S(qqwt#2&($E(qqw)'="D"):"Код     ",1:"Значение         ")
 .;;;;S:qqwt#2&($E(qqw)'="D") help=help_"\pard         (2) Значение     "
 .;;;;S help=help_"\pard\lang1033\i0\f0\fs20\cf0        "_$S(qqwt#2&($E(qqw)'="D"):"(3)",1:"(2)")_" Характеристика   "
 .;;;;S help=help_"\pard\lang1033\i0\f0\fs20\cf0          "_$S(qqwt#2&($E(qqw)'="D"):"(4)",1:"(3)")_" Пояснения"    
 .;;;;S help=help_"\par\pard\lang1033\f0\fs20\cf0"
 .I qqwt#2 S qqwc="" F ii=1:1 S qqwc=$O(^Q(qqlang,$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),qqwc)) Q:$S(qqwc="":1,qqwt=3:ii>5,1:0)  D
 ..S qi=qi+1
 ..S help=help_"\par\pard\lang1033\f0\fs20\cf0    "_qqwc
 ..S help=help_"\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0\cf18\b\fs20    "_$G(^Q(qqlang,$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),qqwc))
 ..S help=help_"\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0\fs20 "_qW.GG($S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),"XRef",qqwc)
 ..S help=help_"\par\pard\lang1033\f0\fs20\cf0" 
 ..S help=help_"\par\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0\fs20\i\cf0 "_qW.zReplace(qW.zReplace(qW.zReplace(qW.zReplace(qW.GT($S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),"Thlp",qqwc),"\","\\"),"{","\{"),"}","\}"),$C(13,10),"\par\pard")
 ..S help=help_"\par\pard"
 .I '(qqwt#2) S qqwc="" F ii=1:1 S qqwc=$O(^Q(qqlang,qqw,qqwc)) Q:$S(qqwc="":1,qqwt=4:ii>15,1:0)  D
 ..S qi=qi+1
 ..S help=help_"\par\pard\lang1033\f0\fs20\cf0"
 ..S help=help_"\par\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0\fs20    "_qqwc
 ..S help=help_"\pard\tab\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0   "_qW.GG($S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),"XRef",$S("CD"[$E(qqw):qqwc,1:^Q(qqlang,qqw,qqwc)))
 ..I qW.GT($S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),"Thlp",$S("CD"[$E(qqw):qqwc,1:^Q(qqlang,qqw,qqwc)))'="" D
 ...S help=help_"\par\pard\lang1033\f0\fs20\cf0"    
 ...S help=help_"\par\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0\i  Пояснения "_qW.zReplace(qW.zReplace(qW.zReplace(qW.zReplace(qW.GT($S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),"Thlp",$S("CD"[$E(qqw):qqwc,1:^Q(qqlang,qqw,qqwc))),"\","\\"),"{","\{"),"}","\}"),$C(13,10),"\par\pard")
 .;S help=help_" }"
]]></Implementation>
</Method>

<Method name="TextHelpRTF0">
<Internal/>
<FormalSpec>qqv:%Library.String,qqpar2:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; вывод пояснения компоненты
 N comp,cod,qqo,adm

 S adm=$G(W("Zadm")),adm=$S($E(Vo(qqnump),1,3)="XXX":1,1:adm)
 S cod=$E(qqpar2,2,255) S:$E(qqpar2)="W" qqo=$P(cod,"_",2),cod=$P(cod,"_")
 S comp=$S($E(qqpar2)="W":"CxWoc",$E(qqpar2)="O":"CxObj",$E(qqpar2)="V":"XView",1:"")
 I comp="" Q:$Q "" Q
 N help S help="{\rtf1\ansi\ansicpg0\uc1\deff0\deflang1024\deflangfe1024{\fonttbl{\f0\fnil\fcharset1 Times New Roman;}{\f1\fnil\fcharset1 Arial;}{\f2\fnil\fcharset1 Verdana;}{\f3\fnil\fcharset204 uTimes New Roman;}{\f4\fnil\fcharset1 MS Sans Serif;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red255\green64\blue64;\red51\green51\blue153;}{\stylesheet{\s0\fi0\li0\ql\ri0\sb0\sa0 Paragraph Style;}{\s1\fi0\li0\qc\ri0\sb0\sa0 Centered;}{\*\cs2\f0\fs24 Normal text;}{\*\cs3\f1\b\fs28 Heading;}{\*\cs4\f2\b\i\fs24 Subheading;}{\*\cs5\f2\i\fs24\cf13 Keywords;}{\*\cs6\f0\ul\fs24\cf11 Jump 1;}{\*\cs7\f0\ul\fs24\cf11 Jump 2;}{\*\cs8\f3\b\lang1049\fs40 Font Style;}{\*\cs9\f4\fs16 Font Style;}{\*\cs10\f4\fs16\cf17 Font Style;}{\*\cs11\f4\fs16\cf18 Font Style;}}"
 ;S help="{\rtf1\ansi\ansicpg0\uc1\deff0\deflang1024\deflangfe1024{\fonttbl{\f0\fnil\fcharset1 Times New Roman;}{\f1\fnil\fcharset1 Arial;}{\f2\fnil\fcharset1 Verdana;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\s0\fi0\li0\ql\ri0\sb0\sa0 Paragraph Style;}{\s1\fi0\li0\qc\ri0\sb0\sa0 Centered;}{\*\cs2\f0\fs24 Normal text;}{\*\cs3\f1\b\fs28 Heading;}{\*\cs4\f2\b\i\fs24 Subheading;}{\*\cs5\f2\i\fs24\cf13 Keywords;}{\*\cs6\f0\ul\fs24\cf11 Jump 1;}{\*\cs7\f0\ul\fs24\cf11 Jump 2;}}"
 S help=help_"\uc1\pard\lang1033\f0\fs20\cf18"_"ПОЯСНЕНИЯ для "_$S($E(qqpar2)="W":$S($E(qqpar2,2,3)="Zs":"Ячейки",1:"Понятия"),$E(qqpar2)="O":"Объекта",$E(qqpar2)="V":"Отображения",1:"")   ;_" }"
 S help=help_"\pard\lang1033\f0\fs22\cf0\par"
 S help=help_"\par"
 ;
 I $E(qqpar2,1,3)="WZs" D  I cod="" S help=help_" }" $$$oQuit(1,help)     ;D ..CreVoAdd() Q:$Q "" Q  ;пояснения по ячейки
 .S %1=$G(Vo(qqnump,qqo,0,$P($E(cod,3,5),"c"),$P(cod,"c",2))) ;тип ячейки
 .I $E(%1)'=0,$E(%1)'=5 S cod=$E(%1,2,255) D
 ..S:adm help=help_"\pard\lang1033\b\f0\cf17"_cod_"   " S help=help_"\pard\lang1033\b\f0\cf18"_$S($G(Vs("par","Name"))'="":Vs("par","Name"),$E(qqpar2)="V":qW.GG(comp,"X11",cod),1:qW.GetWoc(comp,cod))
 ..K Vs("par","Name") S help=help_"\par"
 ..S:adm help=help_"\pard\lang1033\b\f0\cf0"_qW.GG(comp,"XRef",cod) S help=help_"\pard\lang1033\i\b0\f0\cf0 "_$S($G(Vs("par","Thlp"))'="":qW.zReplace(Vs("par","Thlp"),$C(13,10),"\par"),1:qW.zReplace(qW.GT(comp,"Thlp",cod),$C(13,10),"\par"))
 ..K Vs("par","Thlp")
 ;
 S:$e(qqpar2)'="V" help=help_"\par\pard\lang1033\f0\cf17"
 I $E(qqpar2,1,3)="WZs" D  I cod="" S help=help_" }" $$$oQuit(1,help)     ;D ..CreVoAdd() Q:$Q "" Q  ;пояснения по ячейки
 .I $E(%1)'=0,$E(%1)'=5 S cod=$E(%1,2,255) Q
 .S help=help_"\pard\lang1033\b\f0\fs30\cf17"_$S($E(%1)=5:"Выражение",1:"Константа")    ;_" }" 
 .;S ^Vo(qqnump,-1,0,1,1)=$S($E(%1)=5:"5""Выражение""",1:"5""Константа""")
 .S:adm help=help_"\pard\lang1033\f0\fs30\cf10"_"   "_$E(%1,2,10000)
 .I $G(Vs("par","Thlp"))'="" S help=help_"\par\pard\lang1033\f0\fs30\cf10 "_qW.zReplace(Vs("par","Thlp"),$C(13,10),"\par") K Vs("par","Thlp")
 .N qqwt
 .D
 ..S qqwt=qARM.GetPar("X731",,qqo,$P($E(cod,3,5),"c"),$P(cod,"c",2))
 .S:qqwt'="" help=help_"\par\pard\lang1033\b\f0\fs20\cf0"_qW.GetWoc("Cx731",+qqwt)
 .D
 ..S qqwt=qARM.GetPar("x730",,qqo,$P($E(cod,3,5),"c"),$P(cod,"c",2))
 .S:qqwt'="" help=help_"\pard\lang1033\b\f0\fs20\cf0"_"  Разв.: "_qW.GetWoc("Cx730",qqwt)
 .S cod=""
 I $E(qqpar2)="V" D  S help=help_" }" $$$oQuit(1,help)     ;по отображению
 .;S:adm Vo(qqnump,-1,0,1,0)="0База" S Vo(qqnump,-1,0,1,1)=5_"qW.GG(""XBase"",""XBName"",0)",Vo(qqnump,-1,0,1,3)="5qW.GT(""XBase"",""Thlp"",0)"
 .S help=help_"\pard\lang1033\f0\b\cf18   База  \b"_qW.GG("XBase","XBName",0)_"\par\i\cf0 "_qW.GT("XBase","Thlp",0)
 .;S:adm Vo(qqnump,-1,0,2,0)="5"""_cod_"""" S Vo(qqnump,-1,0,2,1)=5_"qW.GG("""_comp_""",""X11"","""_cod_""")" S:adm Vo(qqnump,-1,0,2,2)="5qW.GG("""_comp_""",""XRef"","""_cod_""")" S Vo(qqnump,-1,0,2,3)="5qW.GT("""_comp_""",""Thlp"","""_cod_""")"   
 .S:adm help=help_"\pard\lang1033\f0\i0\cf17"_cod_"    " S help=help_"\pard\cf18"_qW.GG(comp,"X11",cod) S:adm help=help_"  "_qW.GG(comp,"XRef",cod)
 .S help=help_"\par\pard\lang1033\f0"
 .S help=help_"\par\i\b0\cf0"_qW.zReplace(qW.GT(comp,"Thlp",cod),$C(13,10),"\par")
 I $E(qqpar2)="O" D  S help=help_" }" $$$oQuit(1,help) 
 .S:adm help=help_"\pard\lang1033\f0\fs22\cf17 "_cod_"    " S help=help_"\pard\b\cf18"_$S($G(Vs("par","Name"))'="":Vs("par","Name"),$E(qqpar2)="V":qW.GG(comp,"X11",cod),1:qW.GetWoc(comp,cod))
 .S:adm help=help_"\fs22"_ qW.GG(comp,"XRef",cod) S help=help_"\par\i\b0\fs22\cf0"_$S($G(Vs("par","Thlp"))'="":qW.zReplace(Vs("par","Thlp"),$C(13,10),"\par"),1:qW.zReplace(qW.GT(comp,"Thlp",cod),$C(13,10),"\par"))
 .K Vs("par","Name"),Vs("par","Thlp")
 ;
 I $E(qqpar2)'="W" S help=help_" }" $$$oQuit(1,help)    ;D ..CreVoAdd() Q:$Q "" Q
 N qqw,qqwt,qi,qqwpar S qi=3,qqw=cod D  S help=help_" }" $$$oQuit(1,help)  ;D ..CreVoAdd() Q:$Q "" Q
 .D
 ..S qqwt=qARM.GetPar("X731",,qqo,qqw),qqwpar=qARM.GetPar("X73",,qqo,qqw)
 .;I $S(qqwt'="":1,1:$E(qqw)'="@") S Vo(qqnump,-1,0,qi,1)="0"_qW.GetWoc("Cx731",+qqwt),Vo(qqnump,-1,0,qi,1,2)=",,,,1,,,255"
 .I $S(qqwt'="":1,1:$E(qqw)'="@") S help=help_"\par\pard\lang1033\f0\fs22\i0\cf0  Вариант редактирования:   \pard\i"_qW.GetWoc("Cx731",+qqwt)
 .D
 ..S qqwt=qARM.GetPar("x730",,qqo,qqw)
 .S:qqwt'="" help=help_"\pard\lang1033\i0\f0\fs22\cf0"_"    Развертка:   \pard\i"_qW.GetWoc("Cx730",qqwt)
 .S qi=qi+1
 .;Q:"@XLTM"[$E(qqw)
 .S help=help_"\par\pard\lang1033\f0\fs20\cf0"
 .S help=help_"\par\pard\lang1033\f0\fs20\cf0"
 .D
 ..S qqwt=qARM.GetPar("x77",,qqo,qqw)
 .Q:qqwt=0  I "@XLTM"[$E(qqw) Q:'qqwt  Q:$P(qqwpar," ")=""  N qqw S qqw=$P(qqwpar," ")
 .S qqo=-1 S:'qqwt qqwt=4  ;нужны значения?
 .S:'(qqwt#2) help=help_"\par\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap0 {\trowd\trgaph45\trleft0\itap1\trpaddl15\trpaddt15\trpaddr15\trpaddb15\trpaddfl3\trpaddft3\trpaddfr3\trpaddfb3\trspdl15\trspdr15\trspdfl3\trspdfr3\trspdt15\trspdb15\trspdft3\trspdfb3\trftsWidth1\richviewtbw0\trbrdrl\brdrs\brdrw15\brdrcf0\trbrdrt\brdrs\brdrw15\brdrcf0\trbrdrr\brdrs\brdrw15\brdrcf0\trbrdrb\brdrs\brdrw15\brdrcf0\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx1900\cellx4400\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx7565\pard\intbl\itap1" 
 .S:qqwt#2&($E(qqw)'="D") help=help_"\par\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap0 {\trowd\trgaph45\trleft0\itap1\trpaddl15\trpaddt15\trpaddr15\trpaddb15\trpaddfl3\trpaddft3\trpaddfr3\trpaddfb3\trspdl15\trspdr15\trspdfl3\trspdfr3\trspdt15\trspdb15\trspdft3\trspdfb3\trftsWidth1\richviewtbw0\trbrdrl\brdrs\brdrw15\brdrcf0\trbrdrt\brdrs\brdrw15\brdrcf0\trbrdrr\brdrs\brdrw15\brdrcf0\trbrdrb\brdrs\brdrw15\brdrcf0\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx975\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx3200\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx5400\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx7595\pard\intbl\itap1"
 .S:qqwt#2&($E(qqw)="D") help=help_"\par\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap0 {\trowd\trgaph45\trleft0\itap1\trpaddl15\trpaddt15\trpaddr15\trpaddb15\trpaddfl3\trpaddft3\trpaddfr3\trpaddfb3\trspdl15\trspdr15\trspdfl3\trspdfr3\trspdt15\trspdb15\trspdft3\trspdfb3\trftsWidth1\richviewtbw0\trbrdrl\brdrs\brdrw15\brdrcf0\trbrdrt\brdrs\brdrw15\brdrcf0\trbrdrr\brdrs\brdrw15\brdrcf0\trbrdrb\brdrs\brdrw15\brdrcf0\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx2200\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx4300\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx7565\pard\intbl\itap1"
 .;S qqo=-1 S:'qqwt qqwt=4  ;нужны значения?
 .S help=help_"{{\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\b0\f0\fs22   "_$S(qqwt#2&($E(qqw)'="D"):"Код",1:"Значение")_"\cell}{"
 .S:qqwt#2&($E(qqw)'="D") help=help_"\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0    Значение  \cell}{"
 .S help=help_"\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0    Характеристика  \cell}{"
 .S help=help_"\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0   Пояснения  \cell}}\pard\intbl\itap1\row"
 .I qqwt#2 S qqwc="" F ii=1:1 S qqwc=$O(^Q(qqlang,$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),qqwc)) Q:$S(qqwc="":1,qqwt=3:ii>5,1:0)  D
 ..S qi=qi+1
 ..;S:$E(qqw)'="D" help=help_"\par\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap0 {\trowd\trgaph45\trleft0\itap1\trpaddl15\trpaddt15\trpaddr15\trpaddb15\trpaddfl3\trpaddft3\trpaddfr3\trpaddfb3\trspdl15\trspdr15\trspdfl3\trspdfr3\trspdt15\trspdb15\trspdft3\trspdfb3\trftsWidth1\richviewtbw0\trbrdrl\brdrs\brdrw15\brdrcf0\trbrdrt\brdrs\brdrw15\brdrcf0\trbrdrr\brdrs\brdrw15\brdrcf0\trbrdrb\brdrs\brdrw15\brdrcf0\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx975\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx3200\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx5400\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx7595\pard\intbl\itap1"
 ..;S:$E(qqw)="D" help=help_"\par\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap0 {\trowd\trgaph45\trleft0\itap1\trpaddl15\trpaddt15\trpaddr15\trpaddb15\trpaddfl3\trpaddft3\trpaddfr3\trpaddfb3\trspdl15\trspdr15\trspdfl3\trspdfr3\trspdt15\trspdb15\trspdft3\trspdfb3\trftsWidth1\richviewtbw0\trbrdrl\brdrs\brdrw15\brdrcf0\trbrdrt\brdrs\brdrw15\brdrcf0\trbrdrr\brdrs\brdrw15\brdrcf0\trbrdrb\brdrs\brdrw15\brdrcf0\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx2200\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx4300\clwWidth0\richviewcbw320\richviewcbh0\clbrdrl\brdrs\brdrw15\brdrcf0\clbrdrt\brdrs\brdrw15\brdrcf0\clbrdrr\brdrs\brdrw15\brdrcf0\clbrdrb\brdrs\brdrw15\brdrcf0\cellx7565\pard\intbl\itap1"
 ..S help=help_"{{\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0 "_qqwc_"\cell}{"
 ..S:$E(qqw)'="D" help=help_"\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0"_$G(^Q(qqlang,$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),qqwc))_"\cell}{"
 ..;S Vo(qqnump,qqo,0,qi,0)="5"""_qqwc_""""
 ..;S:$E(qqw)'="D" Vo(qqnump,qqo,0,qi,1)="5"""_$G(^(qqwc))_""""
 ..S help=help_"\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0\fs20 "_qW.GG($S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),"XRef",qqwc)_"\cell}{"
 ..S help=help_"\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0\fs20 "_qW.zReplace(qW.GT($S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),"Thlp",qqwc),$C(13,10),"\par")_"\cell}}\pard\intbl\itap1\row"
 ..;S:adm Vo(qqnump,qqo,0,qi,2)="5qW.GG("""_$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw)_""",""XRef"","""_qqwc_""")"
 ..;S Vo(qqnump,qqo,0,qi,3)="5qW.GT("""_$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw)_""",""Thlp"","""_qqwc_""")",Vo(qqnump,qqo,0,qi,3,10)=3
 .;I qqwt#2 S help=help_" }"
 .I '(qqwt#2) S qqwc="" F ii=1:1 S qqwc=$O(^Q(qqlang,qqw,qqwc)) Q:$S(qqwc="":1,qqwt=4:ii>15,1:0)  D
 ..S qi=qi+1
 ..S help=help_"{{\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0\fs20  "_qqwc_"\cell}{"
 ..;S:adm help=help_"\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0\fs20"_qqwc_"\cell}{"
 ..S help=help_"\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0 "_qW.GG($S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),"XRef",$S("CD"[$E(qqw):qqwc,1:^Q(qqlang,qqw,qqwc)))_"\cell}{"
 ..S help=help_"\pard\s0\fi0\li0\ql\ri0\sb0\sa0\itap1\intbl \plain \s2\f0 "_qW.zReplace(qW.GT($S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),"Thlp",$S("CD"[$E(qqw):qqwc,1:^Q(qqlang,qqw,qqwc))),$C(13,10),"\par")_"\cell}}\pard\intbl\itap1\row"
 .S help=help_" }"
 ;;;S help=help_" }"
 ;;;Q help
]]></Implementation>
</Method>

<Method name="TransfLocal">
<Description>
@pav преобразование по справочнику локализации по разделителю divider в закладках</Description>
<Internal/>
<FormalSpec>str,divider</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    n ii,strLoc
    f ii=1:1:$l(str,divider) {
        s strLoc=$g(strLoc)_divider_qSYS.getLocal($p(str,divider,ii),5)
    }
    s $e(strLoc,1,$l(divider))=""
    q $g(strLoc)
]]></Implementation>
</Method>

<Method name="UpdFiles">
<Description>
Проверка обновления при запуске (+ ^mtempupdflag=1)
upd: dima 20110420</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    i $G(Arg1)=1 g UpdFilesQue
    i $G(qARM("NoUpdateAtStart")) s qARM("FUpdLog",$I(qARM("FUpdLog")))="флаг NoUpdate=1 или GlobalNoUpdate=1 в qARM.ini - нет обновления" q  
    i '$D(qARM("Ver","qARMProj1.ocx")) s qARM("FUpdLog",$I(qARM("FUpdLog")))="Gmanager или версия <2005 г. - нет обновления" q
    n qf,baseflag,adm,network,old s qf="^%qFiles"
    s network=$G(qARM("NetworkDrive")) s:network="" network=($A($E($G(qARM("ClientPath"))))>$A("G")) ;первый вариант работает с 11.04.08
    s qARM("FUpdLog",$I(qARM("FUpdLog")))="Сетевой диск: "_$S(network:"да",1:"нет")
    s old='qARM.ProjVerNotOlder(3,8,3,22)
    s qARM("FUpdLog",$I(qARM("FUpdLog")))="Версия более старая, чем 3.8.3.22: "_$S(old:"да",1:"нет")
    i '$D(@qf) s qARM("FUpdLog",$I(qARM("FUpdLog")))="Образы файлов в базе отсутствуют" q  
    s baseflag=$G(qqXBupdate) 
    s qARM("FUpdLog",$I(qARM("FUpdLog")))="%База / Обновление системных файлов при старте: "_$S(baseflag:"да",1:"нет")
    s adm=($G(qARM("Password"))'="")&($G(^Q(1,"XUser",qARM("Password"),"Xsys"))=1) 
    s qARM("FUpdLog",$I(qARM("FUpdLog")))="Администратор: "_$S(adm:"да",1:"нет")_". Пользователь есть в XUser: "_$S($D(^Q(1,"XUser",qARM("Password"))):"да",1:"нет")
    i old,'baseflag,'adm D qARM.wM("-qARM","MessageBox","Системные файлы qARM должны быть обновлены. Обратитесь к системному администратору.","Сообщение",0) q  ; старые файлы, не администратор и не установлен "%База/Обновление системных файлов при старте"
    i 'old g UpdFilesNew 
    
    ;версия qARMProj1.ocx НЕ поддерживает новый метод обновления файлов
    s qqnump=10,qwin="Q10" d qARM.wC("TForm",qwin),qARM.wP(,"Width",200),qARM.wP(,"Height",200),qARM.wP(,"Left",(qARM("Screen","Width")-200)\2),qARM.wP(,"Top",(qARM("Screen","Height")-200)\2) ; для работы qARM.Question в старых версиях
    s qARM("FUpdLog",$I(qARM("FUpdLog")))="Старая версия: диалог"
    d qARM.Question("Файлы в директории "_qARM("ClientPath")_" должны быть обновлены."_$C(13)_$S(network:$C(13)_"Файлы находятся на сетевом диске. Их должен обновить администратор, имеющий права записи на диск, убедившись, что файлы qARM не заняты другими компьютерами в сети."_$C(13),1:"")_$C(13)_"После завершения обновления запустите программу вновь."_$C(13)_"Выполнить процедуру обновления",1,"s qARM(""NoUpdateAtStart"")=1,updfExitFlag=0 d qARM.wM(""Q10"",""Destroy"") d qARM.Create()","d qSYS.UpdFiles(1)",3,0)
    s updfExitFlag=1 ; флаг немедленного выхода
    q
    
UpdFilesQue ; Действие при ответе "Да" на qARM.Question
    n i,fn,qf s i="",qf="^%qFiles"
    k ^mtempUPD($J) m ^mtempUPD($J)=@qf s qf=$NA(^mtempUPD($J)) ; старый FileFastSave портит верхний узел - работа с копией глобала
    f  s i=$O(@qf@(i)) q:i=""  s fn=$E(i,3,1024),@qf@(i)=0 d qARM.wM("-qARM","FileFastSave",$NA(@qf@(i)),fn_$S(fn="QUPDATER.EXE":"",1:".UPD"))
    s qARM("FUpdLog",$I(qARM("FUpdLog")))="Старая версия: обновление."
    //d qARM.wM("-qARM","WinExec",qARM("ClientPath")_"QUPDATER.EXE",1)
    D qARM.wM("-qARM","ShellExecute",0,"open",qARM("ClientPath")_"QUPDATER.EXE","",$E(qARM("ClientPath"),1,$L(qARM("ClientPath"))-1),1)
    d qARM.wM("-qARM","Terminate")
    s updfExitFlag=1 ; флаг немедленного выхода
    q
    
UpdFilesNew ;версия qARMProj1.ocx поддерживает новый метод обновления файлов
    //i ('network)||adm D qARM.wM("-qARM","CheckUpdateIncomplete")
    ; Обновление только при установленном флаге "%База/Обновление системных файлов при старте".
    ; Для обновления сетевого диска пользователь должен быть администратором
    ; ^afteres(2)=1 - обновлять независимо от флага "%База/Обновление системных файлов при старте", без запроса (если не включен в ini)
    i ('network)||adm d  ; @dima 20080603
    .i $G(^mtempupdflag) s qARM("FUpdLog",$I(qARM("FUpdLog")))="Проверка обновления" d qARM.wM("-qARM","RestoreDirTree",qARM("ClientPath"),"^%qFiles",0,10,$G(qARM("AskUpdate")),0) s ^mtempupdflag=0 ; параметр: выдавать диалог, если AskUpdate=1 или GlobalAskUpdate=1 (в ini)
    .e  i baseflag s qARM("FUpdLog",$I(qARM("FUpdLog")))="Проверка обновления" d qARM.wM("-qARM","RestoreDirTree",qARM("ClientPath"),"^%qFiles",0,10,adm||$G(qqXBAllDlgUpd)||$G(qARM("AskUpdate")),0) ; параметр: выдавать диалог, если администратор ИЛИ флаг "%База/Диалог при обновлении" ИЛИ AskUpdate=1 или GlobalAskUpdate=1 (в ini)
    q
]]></Implementation>
</Method>

<Method name="VerBase">
<Internal/>
<FormalSpec>cor:%Library.String=0</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 N qqo,qqw,qqq,Job,qq,i S Job=$J K $$$tmpGl("Error",Job) ;15.12.2008 Kokarev
 S qqq="" F  S qqq=$O(^Q(1,qqq)) Q:qqq=""  I "Xx"'[$E(qqq),$E(qqq,1,2)'="Cx" D
 .I $D(^Q(1,qqq))<10 K ^Q(1,qqq) D ..VerErr(qqq_" - нет потомков."_$S('cor:"",1:" Удален")) Q:cor  ; '$D(^Q(1,"CxObj",qqq)),'$D(^Q(1,"CxWoc",qqq))
 .I qqq?1.N Q:$D(^Q(1,"CxObj",qqq))  D ..VerErr($$VerBaseCre(0,qqq)) Q
 .I $E(qqq)="D" Q:$D(^Q(1,"CxObj",qqq))||($D(^Q(1,"CxWoc",qqq)))  D ..VerErr($$VerBaseCre(1,qqq)) Q
 .I $E(qqq)="C" D:'$D(^Q(1,"CxWoc",$E(qqq,2,255))) ..VerErr($$VerBaseCre(1,$E(qqq,2,255))) D:'$D(^Q(1,$E(qqq,2,255))) ..VerErr(qqq_" - для понятия нет прямого словаря") Q
 .Q:$D(^Q(1,"CxObj",qqq))  I $D(^Q(1,"CxWoc",qqq)) D:'$D(^Q(1,"C"_qqq)) ..VerErr(qqq_" - для понятия нет обратного словаря") Q
 .D:'$D(^Q(1,"C"_qqq)) ..VerErr($$VerBaseCre($D(^Q(1,"C"_qqq)),qqq))
 Q:$Q "" Q
VerBaseCre(a,qqq)   D:cor
 .S qq=$S('a:"Объект_",1:"Понятие_")_qqq F i=1:1 Q:'$D(^Q(1,$S('a:"xObj",1:"xWoc"),qq))  S qq=$S(i=1:qq,1:$P(qq,"|"))_"|"_i
 .S ^Q(1,$S('a:"xObj",1:"xWoc"),qq)=qqq,^Q(1,$S('a:"CxObj",1:"CxWoc"),qqq)=qq I $I(^Q(1,$S('a:"CxObj",1:"CxWoc")))
 Q qqq_" - отсутствует описание "_$S('a:"Объекта.",1:"Понятия.")_$S('cor:"",1:"Создан"_$S('a:"",1:"о")_" "_qq)
]]></Implementation>
</Method>

<Method name="VerCall">
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    /*
    01.08.2008 Kokarev - изменен вызов фонового процесса для одновременной работы в cache_4 и cache_5_и_старше
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
    n J
    i $s('Arg1:$g(W("CxObj"))="",1:$g(W("CxWoc"))="") q "Не определены "_$s('Arg1:"Объекты",1:"Понятия")
    d  q:Arg1=99 "Ошибка запуска в фон"
    .i $g(^rOBJ("%GMan00x7"))'=""  d  q
    ..i 'Arg1 s J=$j j Xec^%GMan00x7("s qARM=##class(%TqARM).%New() d qARM.Create(),qSYS.AAVerObj",$LB(J,$G(W("CxObj")),$G(W("ZVercor")),$G(W("ZVerNoDef")),$G(W("ZVerNoX")),$G(W("ZVerWoc")),$G(W("ZVerNoGr")))) I '$T S Arg1=99 Q   ;;sasha 20080512
    ..i Arg1=1 s J=$j j Xec^%GMan00x7("s qARM=##class(%TqARM).%New() d qARM.Create(),qSYS.AAVerObj",$LB(J,$G(W("CxWoc")),$G(W("ZVercor")),$G(W("ZVerNoGr")))) I '$T S Arg1=99 Q    ;;sasha 20080512
    .;
    .n operation ;для cache < 5 вызываем AAVerObj как метку в %ooLibrary.qSYS.1; для cache >= 5 вызываем AAVerObj как метод класса %qSYS
    .s operation=$s($$$IsV2007=1:"##class(%qSYS).AAVerObj",1:"AAVerObj^%ooLibrary.qSYS.1")
    .i 'Arg1 s operation=operation_"($j,$g(W(""CxObj"")),$g(W(""ZVercor"")),$g(W(""ZVerNoDef"")),$g(W(""ZVerNoX"")),$g(W(""ZVerWoc"")),$g(W(""ZVerNoGr"")))"
    .e  s operation=operation_"($j,$g(W(""CxWoc"")),$g(W(""ZVercor"")),$g(W(""ZVerNoGr"")))"
    .i 1 j @operation i '$t s Arg1=99 ;используем условие "i 1" для того, чтобы переменная $TEST перед запуском процесса была установлена в 1
    ; 15.12.2008 Kokarev
    i ($g(^rOBJ("%GMan00x7"))'="")&&($g(Arg2)='1) H 2 d:$G(J)'="" qARM.Wait("d qARM.RepeatedTimer(,2000,""s kol=$O("_$na($$$tmpGl)_"(""""Error"""","""""_J_""""",""""""""),-1) d:kol="""""""" qARM.wP("""""_qwin_".Timer"""",""""Enabled"""",0) q:kol=""""""""  D:$G("_$na($$$tmpGl)_"(""""Error"""","""""_J_""""",kol))[""""*** Проверка """" qARM.wP("""""_qwin_".Timer"""",""""Enabled"""",0),qARM.OpenWindow(,,,,,""""XXXError"""") k:$G("_$na($$$tmpGl)_"(""""Error"""","""""_J_""""",kol))[""""*** Проверка """" kol "")") Q:$L($G($$$tmpGl("Error"))," ")=1 "Проверка запущена в фон" Q ""     ;;sasha 20080512
    i ($g(^rOBJ("%GMan00x7"))'="")&&($g(Arg2)=1) H 2 d:$G(J)'="" qARM.Wait("d qARM.WrWin("""_qqnumpOLD1_""","""","""",""d qARM.wcre()""),qARM.RepeatedTimer(,2000,""s kol=$O("_$na($$$tmpGl)_"(""""Error"""","""""_J_""""",""""""""),-1) d:kol="""""""" qARM.wP("""""_qwin_".Timer"""",""""Enabled"""",0),qARM.Message(""""Сброс результатов проверки запрещен во время Проверки!""_$C(13,10)_""Автоматический вывод результатов проверки прекращен!""_$C(13,10)_""Вывод результатов проверки по кнопке Обновить!"""") q:kol=""""""""  D:$G("_$na($$$tmpGl)_"(""""Error"""","""""_J_""""",kol))[""""*** Проверка """" qARM.wP("""""_qwin_".Timer"""",""""Enabled"""",0),qARM.WrWin("""""_qqnumpOLD1_""""","""""""","""""""",""""d qARM.wcre()"""") k:$G("_$na($$$tmpGl)_"(""""Error"""","""""_J_""""",kol))[""""*** Проверка """" kol "")") Q:$L($G($$$tmpGl("Error"))," ")=1 "Проверка запущена в фон" Q ""  ;;sasha 20080512
    ; 15.12.2008 Kokarev
    i $g(Arg2)='1 H 2 D qARM.OpenWindow(,,,,,"XXXError") Q:$L($G($$$tmpGl("Error"))," ")=1 "Проверка запущена в фон" Q ""
    i $g(Arg2)=1 H 2 D qARM.WrWin(qqnumpOLD1,"","","d qARM.wcre()") Q:$L($G($$$tmpGl("Error"))," ")=1 "Проверка запущена в фон" Q "" // 01.03.06 Nina (для совместимости с навой версией проверки базы)
    q ""
]]></Implementation>
</Method>

<Method name="VerErr">
<Internal/>
<FormalSpec>sss:%Library.String,Job:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
    S:$G(Job)="" Job=$J S $$$tmpGl("Error",Job,$I($$$tmpGl("Error",Job)))=sss Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="VerObj">
<Description>
Проверка экземпляров объектов
cor=1 - исправлять ошибки
NoDef=1 выводить экземпляры с отсутствующими в описании понятиями (cor=1 - удалять эти понятия)
NoX=1 не проверять понятия X и Xc - даты время коррекции, создания
Y-понятия не проверяются.</Description>
<Internal/>
<FormalSpec>qqolist:%Library.String,cor:%Library.String=0,NoDef:%Library.String=0,NoX:%Library.String=0,VerWoc:%Library.String=1,NoGr:%Library.String=0,Job:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - (1) явное имя ^CacheTemp заменено на макрос $$$tmpGl
                         (2) проверка типа "объект и потомки" (qqolist=объект_"*") не учитывала режим проверки всех объектов (qqolist="*")
    */
 N qqo,qqob,qqolisti,Lqqc,err,qqg,dcor,qqw,qqwlist,qqwlistno,qqwlistyes,qqc,qqwi,qqwrez,qqwd,qqon,qqz,qqzz,qqzzz,$ET S qqwrez="",$ET="S $EC="""" D VerObjErr($ZE) Q:$Q $ZE Q  "
 S (qqwlistno,qqwlistyes)="" S:$G(Job)="" Job=$J
 K $$$tmpGl("Error",Job,1,0) ;список проверенных понятий для режима VerWoc ; 15.12.2008 Kokarev (1)
 I $E($G(qqolist))="#" D  Q:$Q "" Q  ;по объектам отображения
 .S qqo=-1 F  S qqo=$O(^Q(1,"XView",$E($P(qqolist," "),2,255),"CxObj",qqo)) Q:qqo=""  D VerObj1
 I $g(qqolist)'="*",$E($G(qqolist),$L(qqolist))="*" D VerObj0($P(qqolist,"*")) Q:$Q "" Q  ;объект и его потомки ; 15.12.2008 Kokarev (2)
 I $G(qqolist)'="",$G(qqolist)'="*" D  Q:$Q "" Q
 .F qqolisti=1:1:$L(qqolist," ") S qqo=$P(qqolist," ",qqolisti) D:qqo'="" VerObj1
 S qqo="" F  S qqo=$O(^Q(1,"CxObj",qqo)) Q:qqo=""  D VerObj1
 Q:$Q "" Q
VerObj0(qqolist)    N qqolisti F qqolisti=1:1:$L(qqolist," ") S qqo=$P(qqolist," ",qqolisti) I qqo'="" D VerObj1 S qqo=$G(^Q(1,"CxObj",qqo,"xObj")) D:qqo'="" VerObj0(qqo)
 Q
 ;
VerObj1 Q:"vX"[$E(qqo)  Q:$G(^Q(1,"CxWoc",qqo,"Xsys"))
 S qqg=$G(^Q(1,"CxObj",qqo,"xWoc")),qqwlist="" F qqwi=1:1:$L(qqg," ") S qqw=$P(qqg," ",qqwi) I qqw'="","@C"'[$E(qqw) S qqwlist=qqwlist_" "_qqw
 S qqwlist=qqwlist_" " ;список хранимых понятий по описанию
 S dcor=+$G(^Q(1,"CxObj",qqo,"xWoc")) S:'NoX qqwlist=qqwlist_$S('dcor:"X ",dcor=1:"Xc ",dcor=2:"X Xc ",1:"") ;дата время коррекции (X) создания (Xc)
 S Lqqc=+$G(^Q(1,"CxObj",qqo,"X50")) S:Lqqc=255 Lqqc=0
 S qqob=$G(^Q(1,"CxObj",qqo,"XORef")) D  ;список родителей (в qqob - их кол-во)
 .I $L(qqob,",")<2 S qqob=0 Q
 .F qqwi=$L(qqob,",")-1:-1:1 S qqob(qqwi)=$P(qqob,",",qqwi),Lqqc($P(qqob,",",qqwi))=$G(^Q(1,"CxObj",$P(qqob,",",qqwi),"X50"))
 .S qqob=$L(qqob,",")-1
 D VerObjErr("     Объект "_qqo_" "_$G(^Q(1,"CxObj",qqo)))
 S qqc="",qqwd=0 F qqon=0:1 S qqc=$O(^Q(1,qqo,qqc)) Q:qqc=""  D
 .I Lqqc,$L(qqc)'=Lqqc D VerObjErr(qqc_" - ошибка длины кода: "_$L(qqc)_" вместо "_Lqqc_$S(cor:" ***удалено",1:""),qqc) I cor K ^Q(1,qqo,qqc)  S qqon=qqon-1 Q  ;D qW.rCor(qqo,qqc,"",,0) S qqon=qqon-1 Q
 .I qqob F qqwi=qqob:-1:1 S qqw=qqob(qqwi) I '$D(^Q(1,qqw,$E(qqc,1,Lqqc(qqw)))) D VerObjErr(qqc_" - нет объекта-родителя  "_qqw_" c qqc="_$E(qqc,1,Lqqc(qqw))_$S(cor:" ***создан",1:""),qqc) S:cor ^Q(1,qqw,$E(qqc,1,Lqqc(qqw)))=""
 .S qqw="" F  S qqw=$O(^Q(1,qqo,qqc,qqw)) Q:qqw=""  I $E(qqw)'="Y",$S('NoX:1,qqw="X":0,qqw="Xc":0,1:1) S qqz=$G(^(qqw)) D
 ..I "@C"[$E(qqw)||($E(qqw)'?1a)||($A(qqw)>128) D VerObjErr(qqc_" qqw="_qqw_" - недопустимый код понятия"_$S(cor:" ***удалено",1:""),qqc,qqw) K:cor ^Q(1,qqo,qqc,qqw) Q
 ..I qqwlist'[(" "_qqw_" ") D:NoDef  S:qqwlistno_" "'[(" "_qqw_" ")&&("@C"'[$E(qqw)) qqwlistno=qqwlistno_" "_qqw I 1 ;список отсутствующих понятий
 ...D VerObjErr(qqc_" qqw="_qqw_" - нет в описании"_$S(cor:" ***удалено",1:""),qqc,qqw) K W(qqw) D:cor qW.rCor(qqo,qqc,qqw,,0)
 ..I qqwlistyes_" "'[(" "_qqw_" ") S qqwlistyes=qqwlistyes_" "_qqw ;список присутствующих понятий
 ..Q:"TY"[$E(qqw)
 ..I $TR(qqz," ")="",qqw'="X" D VerObjErr(qqc_" qqw="_qqw_" - пустое значение"_$S(cor:" ***удалено",1:""),qqc,qqw) K:cor ^Q(1,qqo,qqc,qqw) Q  ;X="" - при создании нового экземпляра
 ..Q:"MLX"[$E(qqw)
 ..N qqwR I $E(qqw)="R" S qqwR=qqw N qqw S qqw=$E(qqwR,3,255) ;@Dol 22.12.04
 ..F qqwi=$L(qqz," "):-1:1 S qqzz=$P(qqz," ",qqwi) D  I cor,qqz="" K ^Q(1,qqo,qqc,qqw)  ;@dol 14.01.03 I cor,qqz="" - довыкидывались до пустого значения
 ...I qqzz="" D VerObjErr(qqc_" qqw="_qqw_" qqz="_qqz_" - "_qqwi_" пустое слово значения"_$S(cor:" ***удалено из значения",1:""),qqc,qqw) D:cor VerObjDel Q
 ...I $E(qqw)="D" D  Q
 ....I '$D(^Q(1,qqw,qqzz)) D VerObjErr(qqc_" qqw="_qqw_" qqz="_qqz_" - в словаре нет слова: "_qqzz_$S(cor:" ***удалено из значения",1:""),qqc,qqw) D:cor VerObjDel Q
 ....;@oleg 21.09.05 добавлена проверка на организацию словаря
 ....I qW.rWocx711(qqw,qqo) Q:$d(^Q(1,qqw,qqzz,qqo))  D VerObjErr(qqc_" qqw="_qqw_" qqz="_qqz_" - в словаре нет ссылки на объект для: "_qqzz_$S(cor:" ***создана",1:""),qqc,qqw) S:cor ^Q(1,qqw,qqzz,qqo)="" Q
 ....I '$D(^Q(1,qqw,qqzz,qqo,qqc)) D VerObjErr(qqc_" qqw="_$E($G(qqwR),1,2)_qqw_" qqz="_qqz_" - в словаре нет ссылки для: "_qqzz_$S(cor:" ***создана",1:""),qqc,qqw) D:cor  Q
 .....I $G(qqwR)="" S ^Q(1,qqw,qqzz,qqo,qqc)=(qqwi-1) Q
 .....S ^Q(1,qqw,qqzz,qqo,qqc,$E(qqwR,2))=(qqwi-1)
 ....;S qqg=+$G(^Q(1,qqw,qqzz,qqo,qqc)) I qqg'=(qqwi-1),$P(qqz," ",qqg+1)'=qqzz D VerObjErr(qqc_" qqw="_qqw_" qqz="_qqz_" - в словаре неверен номер слова в ссылке для: "_qqzz_". "_qqg_" вместо "_(qqwi-1)_$S(cor:" ***исправлено",1:""),qqc,qqw) S:cor ^Q(1,qqw,qqzz,qqo,qqc)=(qqwi-1) Q
 ...I '$D(^Q(1,"C"_qqw,qqzz)) D VerObjErr(qqc_" qqw="_qqw_" qqz="_qqz_" - в словаре нет кода: "_qqzz_$S(cor:" ***удален из значения",1:""),qqc,qqw) D:cor VerObjDel Q
 ...S qqzzz=$G(^Q(1,"C"_qqw,qqzz)) I $TR(qqzzz," ")="" D VerObjErr(qqc_" qqw="_qqw_" qqz="_qqz_" - в словаре нет слова для кода: "_qqzz_$S(cor:" ***удалено из значения и из словаря",1:""),qqc,qqw) D:cor VerObjDel K:cor ^Q(1,"C"_qqw,qqzz) Q
 ...;@oleg 21.09.05 добавлена проверка на организацию словаря
 ...I qW.rWocx711(qqw,qqo) Q:$d(^Q(1,qqw,qqzzz,qqo))  D VerObjErr(qqc_" qqw="_qqw_" qqz="_qqz_" - в словаре нет ссылки на объект для: "_qqzzz_$S(cor:" ***создана",1:""),qqc,qqw) S:cor ^Q(1,qqw,qqzzz,qqo)="" Q
 ...I '$D(^Q(1,qqw,qqzzz,qqo,qqc)) D VerObjErr(qqc_" qqw="_$E($G(qqwR),1,2)_qqw_" qqz="_qqz_" - в словаре нет ссылки для: "_qqzzz_" (код:"_qqzz_")"_$S(cor:" ***создана",1:""),qqc,qqw) D:cor  Q
 ....I $G(qqwR)="" S ^Q(1,qqw,qqzzz,qqo,qqc)=(qqwi-1) Q
 ....S ^Q(1,qqw,qqzzz,qqo,qqc,$E(qqwR,2))=(qqwi-1)
 ...;S qqg=+$G(^Q(1,qqw,qqzzz,qqo,qqc)) I qqg'=(qqwi-1),$P(qqz," ",qqg+1)'=qqzz D VerObjErr(qqc_" qqw="_qqw_" qqz="_qqz_" - в словаре неверен номер слова в ссылке для: "_qqzzz_" (код:"_qqzz_"). "_qqg_" вместо "_(qqwi-1)_$S(cor:" ***исправлено",1:""),qqc,qqw) S:cor ^Q(1,qqw,qqzzz,qqo,qqc)=(qqwi-1) Q
 .;????I cor,'$D(^Q(1,qqo,qqc)) S qqon=qqon-1
 I +$G(^Q(1,qqo))'=qqon D VerObjErr("Всего экземпляров: "_qqon_" счетчик: "_+$G(^Q(1,qqo))_$S(cor:" ***исправлено",1:""))  S:cor ^Q(1,qqo)=qqon ;коррекция счетчика
 I 'qqon D VerObjErr("Нет экземпляров") Q
 I qqwlistno'=""||($L(qqwlistyes," ")+1'=$L(qqwlist," ")) D
 .D VerObjErr(qqwlist_" - список понятий из описания объекта"_$S(qqwlist[" X "||(qqwlist[" Xc "):" (X Xc - даты коррекции и создания)",1:""))
 .I qqwlistno'="" D VerObjErr(qqwlistno_" - список понятий отсутствующих в описании объекта")
 .I $L(qqwlistyes," ")+1'=$L(qqwlist," ") D
 ..S qqwlistno="" F qqwi=2:1:$L(qqwlist," ")-1 S qqw=$P(qqwlist," ",qqwi) I "@CZ"'[$E(qqw),$E(qqw,1,2)="TB" S:qqwlistyes_" "'[(" "_qqw_" ") qqwlistno=qqwlistno_" "_qqw
 ..D:qqwlistno'="" VerObjErr(qqwlistno_" - список понятий отсутствующих в экземплярах объекта")
 I VerWoc D
 .F qqwi=1:1:$L(qqwlistyes," ") S qqw=$P(qqwlist," ",qqwi) I qqw'="",'$D($$$tmpGl("Error",Job,1,0,qqw)) D ..VerWoc(qqw,cor,NoGr,Job) S $$$tmpGl("Error",Job,1,0,qqw)="" ; 15.12.2008 Kokarev (1)
 I $E($$$tmpGl("Error",Job,$$$tmpGl("Error",Job)),1,5)="    ",$I($$$tmpGl("Error",Job),-1) ; 15.12.2008 Kokarev (1)
 Q
VerObjDel S (^Q(1,qqo,qqc,$E($G(qqwR),1,2)_qqw),qqz)=$S(qqwi=1:$P(qqz," ",2,30000),qqwi=$L(qqz," "):$P(qqz," ",1,qqwi-1),1:$P(qqz," ",1,qqwi-1)_" "_$P(qqz," ",qqwi+1,30000)),qqwi=qqwi-1 Q  ;@Dol 13.10.07
 ;
VerObjErr(sss,qqo,qqw)  S $$$tmpGl("Error",Job,$I($$$tmpGl("Error",Job)))=sss Q  ; 15.12.2008 Kokarev (1)
]]></Implementation>
</Method>

<Method name="VerObjCall">
<Description>
NoMes=1 - не выдавать сообщений</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,cor:%Library.String,NoDef:%Library.String,NoMes:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
    I $D(^Q(1,qqo))<10 D:'$G(NoMes) qARM.Message("Нет Экземпляров") Q:$Q 0 Q
    K $$$tmpGl("Error",$J) D qSYS.VerObj(qqo,+$G(cor),+$G(NoDef)) I $G($$$tmpGl("Error",$J))<2 D:'$G(NoMes) qARM.Message("Нет ошибок") Q:$Q 0 Q  ; 15.12.2008 Kokarev
    D:'$G(NoMes) qARM.OpenWindow(,,,,,"XXXError") ;вывод ошибок
    Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="VerTempor">
<Description>
Производится проверка корректности описания темпоральных объектов во всех отображениях.
Темпоральным объект считается, если X5280="@".
Если ошибок не обнаружено, производится создание понятия YT для объектов-документов (см пояснения к понятию XBTempor).
Выводится признак наличия ошибок и (через пробел) общее кол-во объектов-документов/кол-во исправлений или созданий YT/кол-во экземпляров с неправильной длиной кода
Экземпляры с меньшей длиной кода удаляются и записываются в массив ^Qerr
Message=0 - не выводить сообщение об ошибках в отображениях    
Arg1=1 - только проверка описаний, иначе проверка и экземпляров</Description>
<Internal/>
<FormalSpec>Message:%Library.String=1,Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqnump,err S qqnump="T" K Vo(qqnump),Vs(qqnump),Vt(qqnump)
 N qview,qqo,qqso,qqoc,qqo,qqcP,qqoP,num,numf,numd,temp
 S qview="" F  S qview=$O(^Q(1,"XView",qview)) Q:qview=""  I $E(qview,1,3)'="XXX",$E(qview,4,255)'["zz" D  ;не системные и не отображения аналитик
 .D VerTemOb(-1)
 S qqoP="",qqso="" F  S qqoP=$O(temp(qqoP)) Q:qqoP=""  S qqso=$S(qqso="":"",1:qqso_" ")_qqoP_":"_temp(qqoP)_":",qqo="" F  S qqo=$O(temp(qqoP,qqo)) Q:qqo=""  S qqso=qqso_$S($E(qqso,$L(qqso))=":":"",1:",")_qqo
 S ^Q(1,"XBase",0,"XBTempList")=qqso
 I $D(err) D:$G(Message)  Q:$Q 1 Q
 .S Message="" F err=1:1:err S Message=Message_$C(13,10)_err(err)
 .D qARM.Message(Message,"Ошибки в описании темпоральности")
 I $G(Arg1) D:$G(Message)&(qqso="") qARM.Message("Нет темпоральных групп") Q:$Q 0 Q
 S Vt(qqnump,0)=1,$$$Tree=0,$$$ReFind=0
 S qqoP="" F  S qqoP=$O(temp(qqoP)) Q:qqoP=""  I " "_$TR(qqXBTempor,":"," ")_" "[(" "_qqoP_" ") D
 .S Vo(qqnump,qqoP,2)=0,Vo(qqnump,qqoP,0)=^Q(1,"CxObj",qqoP,"X50"),qqo="" F  S qqo=$O(temp(qqoP,qqo)) Q:qqo=""  S Vo(qqnump,qqo,2)=2,Vo(qqnump,qqo,29)=temp(qqoP),Vo(qqnump,qqo,280)="@",Vo(qqnump,qqo,28)=1,Vo(qqnump,qqo,5)=qqoP_","_qqo
 .S qqcP="" F  S qqcP=$O(^Q(1,qqoP,qqcP)) Q:qqcP=""  D  ;Q:numf>99
 ..I $L(qqcP)'=Vo(qqnump,qqoP,0),$I(numd) D:$L(qqcP)<Vo(qqnump,qqoP,0)  Q  ;одно время была ошибка - создавался лишний экземпляр
 ...M ^Qerr(qqoP,qqcP)=^Q(1,qqoP,qqcP) K ^Q(1,qqoP,qqcP)
 ..S qqo="" F  S qqo=$O(temp(qqoP,qqo)) Q:qqo=""  I qW.gOrder(1,qqo,"",qqcP)
 ..I $I(numf),$G(Vt(qqnump,"ZTmpYT"))'=1,$I(num) K ^Q(1,qqoP,qqcP,"YT") I $D(Vt(qqnump,"ZTmpYT")) S Vt(qqnump,"ZTmpYT")=1 M ^Q(1,qqoP,qqcP,"YT")=Vt(qqnump,"ZTmpYT")
 Q:$Q ''$D(err)_" "_$G(numf)_"/"_$G(num)_"/"_$G(numd) Q
VerTemOb(qqo,qqop)
 N qqso,qqoc,qq,qqq
 I $G(qqop)'="",$G(^Q(1,"XView",qview,"CxObj",qqo,"X5280"))="@" D  Q
 .I $G(^("x52"))'=2 S err($I(err))="view="_qview_" qqo="_qqo_" не ссылочный (x52э=2)"
 .I '$G(^("X528")) S err($I(err))="view="_qview_" qqo="_qqo_" X528 не установлен"
 .S qq=$G(^("X529")) I qq="" S err($I(err))="view="_qview_" qqo="_qqo_" X529 не указан"
 .S qqq=$S($E(qqop)'="v":qqop,1:$E(qqop,3,255))
 .I " "_$TR(qqXBTempor,":"," ")_" "'[(" "_qqq_" "),'$D(temp(qqq)) S err($I(err))="view="_qview_" qqo="_qqq_" нет в списке XBTempor"
 .S temp(qqq,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)))=""
 .I $G(temp(qqq))="" S temp(qqq)=qq Q
 .I temp(qqq)'=qq S err($I(err))="view="_qview_" qqo="_qqo_" X529 не согласован ("_qq_"'="_qqq
 S qqso="" F  S qqso=$O(^Q(1,"XView",qview,"CxObj",qqo,"Xy",qqso)) Q:qqso=""  S qqoc=$G(^(qqso,"X60")) D:qqoc'="" VerTemOb(qqoc,qqo)
 Q
]]></Implementation>
</Method>

<Method name="VerWoc">
<Description>
Проверка словарей</Description>
<Internal/>
<FormalSpec>qqwlist:%Library.String,cor:%Library.String=0,NoGr:%Library.String=0,Job:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 N qqw,qqwlisti,err,qqg,qqo,qqc,qqwi,qqwrez,qqwd,qqwn,qqz,qqzz,qqzzz,qqwiL,qqzzL,$ET,ref,qwreflst,codeEx,iEx,iW,rr S qqwrez="",$ET="S $EC="""" D VerWocErr($ZE) Q:$Q $ZE Q  "
 S:$G(Job)="" Job=$J S ref=$na(^mtempqSYS("tmp",$j,$o(^mtempqSYS("tmp",$j,""),-1)+1)) k @ref
 I $G(qqwlist)'="",$G(qqwlist)'="*" D  Q:$Q "" Q
 .F qqwlisti=1:1:$L(qqwlist," ") S qqw=$P(qqwlist," ",qqwlisti) D:qqw'="" VerWoc1
 S qqw="" 
 F  S qqw=$O(^Q(1,"CxWoc",qqw)) Q:qqw=""  I "@TMLXRCxY"'[$E(qqw) D VerWoc1
 k @ref
 Q:$Q "" Q
 ;
VerWoc1 Q:"@TMLXRCxY"[$E(qqw)
 S qqg=+$G(^Q(1,"CxWoc",qqw,"xGrCol"))
 D VerWocErr("     Понятие "_qqw_" "_$G(^Q(1,"CxWoc",qqw))_" (сборка мусора: "_$G(^Q(1,"CxGrCol",qqg))_")")
 S qqg=$S($G(^Q(1,"CxWoc",qqw,"Xsys")):0,1:qqg'=2) ;разрешена сборка мусора
 S (qqz,qwreflst)="",qqwd=0 F qqwn=0:1 S qqz=$O(^Q(1,qqw,qqz)) Q:qqz=""  D  ;qwreflst - список ссылочных понятий (нужен, если словарь без ссылок)
 .S qqzz=$s($e(qqw)'="D":$G(^(qqz)),1:qqz) I $E(qqw)'="D" D  Q:qqzz=""
 ..I qqzz="" D VerWocErr(qqz_" -нет кода") Q
 ..I '$D(^Q(1,"C"_qqw,qqzz)) D VerWocErr(qqz_" код="_qqzz_" - нет в обратном словаре"_$S(cor:" ***создан",1:"")) S:cor ^Q(1,"C"_qqw,qqzz)=qqz Q
 ..I ^Q(1,"C"_qqw,qqzz)'=qqz S qqzzz=^Q(1,"C"_qqw,qqzz),err=1 D:cor  D VerWocErr(qqz_" код="_qqzz_" - в обратном словаре значение="_qqzzz_$S(cor:" ***исправлено",1:"")) Q  ;исправление дублированных значений
 ...I ^Q(1,qqw,qqzzz)=qqzz M ^Q(1,qqw,qqzzz)=^Q(1,qqw,qqz) K ^Q(1,qqw,qqz) Q
 ...S ^Q(1,"C"_qqw,qqzz)=qqz
 .S qqo="" F  S qqo=$O(^Q(1,qqw,qqz,qqo)) Q:qqo=""  D
 ..;@oleg 21.09.05 добавлена проверка на организацию словаря
 ..;словарь со ссылками
 ..I 'qW.rWocx711(qqw,qqo) D  Q
 ...I $D(^Q(1,qqw,qqz,qqo))<10 D:'$g(@ref@(qqw,qqo))  Q
 ....D VerWocErr("Словарь по объекту "_qqo_" не соответствует свойству ""%Организация словаря"" - нет ссылок на экземпляры объекта"_$S(cor:" ***созданы ссылки на экземпляры объекта",1:""))
 ....D:cor qW.qWocCnv(qqw,qqo) S @ref@(qqw,qqo)=1
 ...S qqc="" F  S qqc=$O(^Q(1,qqw,qqz,qqo,qqc)) Q:qqc=""  D  I err D VerWocErr(qqz_" ссылка qqc="_qqc_" -нет в значении экземпляра qqo="_qqo_$S(cor:" ***ссылка удалена",1:"")) K:cor ^Q(1,qqw,qqz,qqo,qqc)
 ....S err=0 I '$D(^Q(1,qqo,qqc)) D VerWocErr(qqz_" ссылка qqc="_qqc_" -нет экземпляра qqo="_qqo_$S(cor:" ***ссылка удалена",1:"")) K:cor ^Q(1,qqw,qqz,qqo,qqc) Q
 ....I $D(^Q(1,qqw,qqz,qqo,qqc))#10=1 S:" "_$G(^Q(1,qqo,qqc,qqw))_" "'[(" "_qqzz_" ") err=2
 ....Q:$D(^Q(1,qqw,qqz,qqo,qqc))<10
 ....S rr="" F  S rr=$O(^Q(1,qqw,qqz,qqo,qqc,rr)) Q:rr=""  D  ;@Dol 13.10.07 R*-понятия
 .....I " "_$G(^Q(1,qqo,qqc,"R"_rr_qqw))_" "'[(" "_qqzz_" ") D VerWocErr(qqz_" ссылка qqc="_qqc_" -нет в значении экземпляра qqo="_qqo_" для R"_rr_qqw_$S(cor:" ***ссылка удалена",1:"")) K:cor ^Q(1,qqw,qqz,qqo,qqc,rr)
 ..;словарь без ссылок
 ..I $D(^Q(1,qqw,qqz,qqo))>1 D:'$g(@ref@(qqw,qqo))
 ...D VerWocErr("Словарь по объекту "_qqo_" не соответствует свойству ""%Организация словаря"" - есть ссылки на экземпляры объекта"_$S(cor:" ***удалены ссылки на экземпляры объекта",1:""))
 ...D:cor qW.qWocCnv(qqw,qqo) S @ref@(qqw,qqo)=1
 ..s:qwreflst="" qwreflst=qW.rWocRefLst(qqw) d:$d(@ref@(qqw,qqo))<10  q:$d(@ref@(qqw,qqo,qqzz))
 ...s qqc="" f  s qqc=$o(^Q(1,qqo,qqc)) q:qqc=""  f iW=1:1:$l(qwreflst," ") s codeEx=$g(^(qqc,$p(qwreflst," ",iW))) i codeEx'="" f iEx=1:1:$l(codeEx," ") s:$p(codeEx," ",iEx)'="" @ref@(qqw,qqo,$p(codeEx," ",iEx))=""
 ..d VerWocErr(qqz_" не используется в экземплярах объекта "_qqo_$s(cor:" ***удалена ссылка на объект",1:"")) i cor k ^Q(1,qqw,qqz,qqo)
 .I 'NoGr,$D(^Q(1,qqw,qqz))=1,$I(qqwd) D VerWocErr(qqz_" - не используется"_$S(cor&qqg:" ***удалено",1:"")) I qqg,cor  K ^Q(1,qqw,qqz) I $E(qqw)'="D" K ^Q(1,"C"_qqw,qqzz) D:qqllang'="" VerWocL
 ;проход по обратному словарю
 I $E(qqw)'="D" S qqzz="" F qqwn=0:1 S qqzz=$O(^Q(1,"C"_qqw,qqzz)) Q:qqzz=""  D
 .S qqz=$G(^(qqzz)) I qqz="" D VerWocErr(qqzz_" -для кода нет значения"_$S(cor:" ***удалено",1:"")) K:cor ^Q(1,"C"_qqw,qqzz) Q
 .I '$D(^Q(1,qqw,qqz)) D VerWocErr(qqzz_" значение="_qqz_" - нет в обратном словаре"_$S(cor:" ***создан",1:"")) S:cor ^Q(1,qqw,qqz)=qqzz Q
 .I ^Q(1,qqw,qqz)'=qqzz S qqzzz=^Q(1,qqw,qqz),err=1 D:cor  D VerWocErr(qqzz_" значение="_qqz_" - в прямом словаре код="_qqzzz_$S(err&cor:" ***исправлено",1:"")) Q  ;исправление дублированных значений
 ..S err=0  ;вроде нельзя автоматически править
 ..;I ^Q(1,"C"_qqw,qqzzz)=qqz S err=0 Q  ;K ^Q(1,"C"_qqw,qqzz) Q  ;для одного и того же значения - разные коды.Удалять нельзя
 ..;S ^Q(1,qqw,qqz)=qqzz
 I $G(^Q(1,$S($E(qqw)'="D":"C",1:"")_qqw))'=qqwn D VerWocErr("Всего слов: "_qqwn_" счетчик: "_$G(^Q(1,$S($E(qqw)'="D":"C",1:"")_qqw))_$S(cor:" ***исправлено",1:""))  S:cor ^Q(1,$S($E(qqw)'="D":"C",1:"")_qqw)=qqwn ;коррекция счетчика
 I $E($$$tmpGl("Error",Job,$$$tmpGl("Error",Job)),1,5)="     " K $$$tmpGl("Error",Job,$$$tmpGl("Error",Job)) I $I($$$tmpGl("Error",Job),-1) ; 15.12.2008 Kokarev
 Q
VerWocL F qqwiL=1:1:$L(qqllang," ") I $P(qqllang," ",qqwiL)'="",$D(^Q($P(qqllang," ",qqwiL),"C"_qqw,qqzz)) K:^(qqzz)'="" ^Q($P(qqllang," ",qqwiL),qqw,^(qqzz)) K ^Q($P(qqllang," ",qqwiL),"C"_qqw,qqzz)
 Q
VerWocErr(sss)  S $$$tmpGl("Error",Job,$I($$$tmpGl("Error",Job)))=sss Q  ; 15.12.2008 Kokarev
]]></Implementation>
</Method>

<Method name="VerWocCall">
<Internal/>
<FormalSpec>qqw:%Library.String,cor:%Library.String=0,NoGr:%Library.String=0,Nomes:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
    I "@MLXTR"[$E(qqw) D qARM.Message("Нет словаря") Q:$Q 0 Q
    K $$$tmpGl("Error",$J) D qSYS.VerWoc(qqw,+$G(cor),NoGr) I $G($$$tmpGl("Error",$J))<2 D:'$G(Nomes) qARM.Message("Нет ошибок") Q:$Q 0 Q  ; 15.12.2008 Kokarev
    D:'$G(Nomes) qARM.OpenWindow(,,,,,"XXXError") ;вывод ошибок
    Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="VerXMLName">
<Description>
Проверка Arg1 на корректное XML-имя тега
qWORD- расширения
Arg2=1 - код понятия (может начинаться на @)
Arg2=2 - код объекта (может быть целым числом)</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Arg2)=2,Arg1?1.N Q 1 ;числовой код объекта
 I $E(Arg1)'?1A,$S($G(Arg2)="":"%",1:"")_":_"_$S($G(Arg2)=1:"@",1:"")'[$E(Arg1) Q 0
 Q:$ZCVT($E(Arg1,1,3),"U")="XML" 0 Q:$TR($E(Arg1,2,1000),"_-.: ")'?.NA 0 Q 1 ;???$TR($E(Arg1,2,1000)
]]></Implementation>
</Method>

<Method name="Verify">
<Description>
             Проверка схемы базы. Arg1=1 - исправить ошибки (удаляет лишние понятия и объекты).</Description>
<Internal/>
<FormalSpec>Arg1:%String=0</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 K qerr ZA ^QV:10 I '$T S qerr(0)="qWord. Проверка не выполнена. Заблокировано другим пользователем." Q:$Q 2 Q  ;блокирован
 N qview,qqo,qqso,qqoc,qqw,qi,qqo0,qqx,qqwl,qqoll,qqwlst,qqolst,qqoct,qqot,qqw57
 K ^QV,^QVW S qerr=-1 ;^QV - объекты, ^QVW - понятия
 S qview="" F  S qview=$O(^Q(1,"XView",qview)) Q:qview=""  I $E(qview,1,3)'="XXX",$E(qview,4,255)'["zz" D  ;не системные и не отображения аналитик
 .K QVer D VerifyV(qview,-1) ;M ^QQVer=QVer
 .;для вершины
 .S qqso="",qqwlst="",qqolst="" F  S qqso=$O(^Q(1,"XView",qview,"CxObj",-1,"Xy",qqso)) Q:qqso=""  D
 ..S qqoc=$G(^(qqso,"X60")) I qqoc'="" S:qqolst_" "'[(" "_qqoc_" ") qqolst=qqolst_" "_qqoc ;потомки в текущем отображении
 .S ^Q(1,"XView",qview,"CxObj",-1,"xObj")=$E(qqolst,2,32000) ;список потомков текущего объекта
 .;
 .S qqo=-1 F  S qqo=$O(^Q(1,"XView",qview,"CxObj",qqo)) Q:qqo=""  D  ;@dol 19.03.03 ???,qqoct=""
 ..I '$D(QVer(qqo)) S qerr($I(qerr))="qWord. Объект "_qqo_" не используется в отображении "_qview_$S(Arg1!1:" Удален.",1:"") K:Arg1!1 ^Q(1,"XView",qview,"CxObj",qqo) Q
 ..S qqoct="",qqot=QVer(qqo,2) ;;;;qqot=$G(^Q(1,"XView",qview,"CxObj",qqo,"x52")) S:qqot="" qqot=$G(^Q(1,"CxObj",qqo,"x52")) ;@Dol 3.07.05 qqot="" ;Q  ; хранимые объекты, только логическое дерево??? ;qqo?1.N,
 ..S qqwl=$G(^QV(qqo,3)," ") ;список понятий (порядок важен)
 ..S qqol=$G(^QV(qqo,2)," ") ;список объектов (порядок важен)
 ..S qqwlst="",qqso="",qqolst="" F  S qqso=$O(^Q(1,"XView",qview,"CxObj",qqo,"Xy",qqso)) Q:qqso=""  D
 ...S qqoc=$G(^(qqso,"X60")) I $TR(qqoc," ")'="" D  Q
 ....;???I 'qqoct S qqoct=$G(^Q(1,"XView",qview,"CxObj",qqoc,"x52")) S:qqoct="" qqoct=+$G(^Q(1,"CxObj",qqoc,"x52")) ;S:qqoct=9 qqoct=0 ;не виртуальные потомки
 ....S qqoct=QVer(qqoc,2)
 ....S:qqolst_" "'[(" "_qqoc_" ") qqolst=qqolst_" "_qqoc ;потомки в текущем отображении
 ....S:$G(^QV(qqoc,"x52"))'=0 ^("x52")=qqoct
 ....I qqot=1,'qqoct D  Q  ;встроенный объект
 .....N qqot,qqol S qqot=QVer(qqo,0),qqol=$G(^QV(qqot,2)," ") Q:QVer(qqot,2)
 .....S ^QV(qqot,1,qqoc,qview)="" ;потомки
 .....;+@Tat 12.01.2009 !!!@Dol 26.01.09 Вставка от @Tat ОШИБОЧНА. неверно формируется структура
 .....;N qqot,qqol S qqot=QVer(qqo,0) ;Q:QVer(qqot,2)
 .....;I $G(QVer(qqot,2)) D  Q:qqot=""!(qqot=-1) ;нет хранимого предка
 .....;.F  S qqot=$G(QVer(qqot,0)) Q:qqot=""!(qqot=-1)  Q:$G(QVer(qqot,2))=0
 .....;S qqol=$G(^QV(qqot,2)," ")
 .....;-@Tat 12.01.2009
 .....S:qqol'[(" "_qqoc_" ") qqol=qqol_qqoc_" " ;упорядоченный список потомков
 .....I '$D(^QV(qqoc,0,qqot)),$I(^QV(qqoc,0)) ;подсчет числа родителей
 .....S ^QV(qqoc,0,qqot,qview)="" ;родители
 .....S ^QV(qqot,2)=qqol
 ....I 'qqoct D  Q
 .....S ^QV(qqo,1,qqoc,qview)="" ;потомки
 .....S:qqol'[(" "_qqoc_" ") qqol=qqol_qqoc_" " ;упорядоченный список потомков
 .....I '$D(^QV(qqoc,0,qqo)),$I(^QV(qqoc,0)) ;подсчет числа родителей
 .....S ^QV(qqoc,0,qqo,qview)="" ;родители
 ...S qqx="" F  S qqx=$O(^Q(1,"XView",qview,"CxObj",qqo,"Xy",qqso,"Xx",qqx)) Q:qqx=""  S qi=$G(^(qqx,"x70")) D
 ....S:qi="" qi="?" I "0234567"'[qi D  Q
 .....S qerr($I(qerr))="qWord. Объект "_qqo_" (отображение: "_qview_" ) y="_qqso_" x="_qqx_" не определен тип ячейки (x70)."
 .....I qqx<0 K ^Q(1,"XView",qview,"CxObj",qqo,"Xy",qqso,"Xx",qqx)
 ....Q:"0567"[qi  S qqw=$G(^("X71")) I $TR(qqw," ")=""||($TR(qqw," ")'=qqw) S qerr($I(qerr))="qWord. Объект "_qqo_" (отображение: "_qview_" ) y="_qqso_" x="_qqx_" не определено или неправильно определено понятие X71="""_qqw_"""" Q
 ....I $E(qqw)'="@",qqw'="X",qqw'="Xc",qqw'[":" D  ;обобщения не попадают в Схему ???
 .....S:qqwlst_" "'[(" "_qqw_" ") qqwlst=qqwlst_" "_qqw
 .....I qqot=1 D
 ......N qqot,qqwl S qqot=QVer(qqo,0),qqwl=$G(^QV(qqot,3)," ") S:qqwl'[(" "_qqw_" ") qqwl=qqwl_qqw_" " S ^QV(qqot,3)=qqwl
 .....S:qqwl'[(" "_qqw_" ") qqwl=qqwl_qqw_" "
 ..S qqw57=$G(^Q(1,"XView",qview,"CxObj",qqo,"X57")) D:qqw57'=""  ;@dol 5.09.04 дополнительные понятия
 ...F qqx=1:1:$L(qqw57," ") S qqw=$P(qqw57," ",qqx) I $TR(qqw," ")'="",$E(qqw)'="@",qqw'="X",qqw'="Xc",qqw'[":" D
 ....S:qqwlst_" "'[(" "_qqw_" ") qqwlst=qqwlst_" "_qqw
 ....I qqot=1 D
 .....N qqot,qqwl S qqot=QVer(qqo,0),qqwl=$G(^QV(qqot,3)," ") S:qqwl'[(" "_qqw_" ") qqwl=qqwl_qqw_" " S ^QV(qqot,3)=qqwl
 ....S:qqwl'[(" "_qqw_" ") qqwl=qqwl_qqw_" "
 ..S ^QV(qqo,3)=qqwl,^QV(qqo,2)=qqol
 ..S ^Q(1,"XView",qview,"CxObj",qqo,"xWoc")=$E(qqwlst,2,32000) ;список понятий текущего объекта
 ..S ^Q(1,"XView",qview,"CxObj",qqo,"xObj")=$E(qqolst,2,32000) ;список потомков текущего объекта
 ;Q "" ;Поиск вершин
 S qqo="" F  S qqo=$O(^QV(qqo)) Q:qqo=""  I '$G(^QV(qqo,0)),'$G(^QV(qqo,"x52")),'$G(^Q(1,"CxObj",qqo,"Xsys")) S ^QV(-1,qqo)=""
 ;Обход поддеревьев
 S qqo0="",qqol="" F  S qqo0=$O(^QV(-1,qqo0)) Q:qqo0=""  S ^QV(qqo0)=qqo0,qqol=qqol_" "_qqo0,^Q(1,"CxObj",qqo0,"XORef")="" D VerifyT(qqo0,qqo0) ;@Dol 01.03.05 ^Q(1,"CxObj",qqo0,"XORef")="" для вершин
 S ^Q(1,"XBase",0,"xObj")=$E(qqol,2,32000) ;главные объекты ; tdv 20100912 было ограничение 1000, заменено на 32000
 ;Лишние объекты
 S qqo="" F  S qqo=$O(^Q(1,"CxObj",qqo)) Q:qqo=""  I "AX"'[$E(qqo),'$G(^Q(1,"CxObj",qqo,"Xsys")) D:'$D(^QV(qqo))
 .Q:$E(qqo)="#"  S qerr($I(qerr))="qWord. Объект "_qqo_" не используется в схеме базы."_$S(Arg1:" Удален.",1:"") I Arg1 S qtmp=$G(^Q(1,"CxObj",qqo)) K ^Q(1,"CxObj",qqo),^Q(1,qqo) K:qtmp'="" ^Q(1,"xObj",qtmp)
 ;Лишние понятия
 S qqw="" F  S qqw=$O(^Q(1,"CxWoc",qqw)) Q:qqw=""  I "CXx@"'[$E(qqw),'$G(^Q(1,"CxWoc",qqw,"Xsys")),'$D(^QVW(qqw))
 .S qerr($I(qerr))="qWord. Понятие "_qqw_" не используется в схеме базы."_$S(Arg1:" Удалено.",1:"") I Arg1 S qtmp=$G(^Q(1,"CxWoc",qqw)) K ^Q(1,"CxWoc",qqw),^Q(1,qqw),^Q(1,"C"_qqw) K:qtmp'="" ^Q(1,"xWoc",qtmp)
 L -^QV#"I" I $D(qerr)>1 Q:$Q 1 Q
 S qerr(0)="qWord. Ошибок в структуре нет." Q:$Q 0 Q
 ;
VerifyT(qqo0,qqoref) ;обход потомков
 N qqo,qi,qqol S qqo="",qqol="" F  S qqo=$O(^QV(qqo0,1,qqo)) Q:qqo=""  S qi=$G(^QV(qqo,0)) D
 .I qi>1 D  Q:'q
 ..S qqoc="" F  S qqoc=$O(^QV(qqo,0,qqoc)) Q:qqoc=""  S q=","_qqoref_","[(","_qqoc_",") Q:'q  K:qqoc'=qqo0 ^QV(qqoc,1,qqo),^QV(qqo,0,qqoc) ;все предки принадлежат поддереву 
 .I $G(^QV(qqo))'="" D  K ^QV(qqo,0),^QV(qqo0,1,qqo) Q
 ..S qview="",q="" F  S qview=$O(^QV(qqo0,1,qqo,qview)) Q:qview=""  D  ;@dol 28.07.04 лишние сообщения о ссылочных
 ...N qqoct S qqoct=$G(^Q(1,"XView",qview,"CxObj",qqo,"x52")) S:qqoct="" qqoct=+$G(^Q(1,"CxObj",qqo,"x52")) Q:qqoct
 ...S q=q_" "_qview
 ..S:q'="" qerr($I(qerr))="qWord. Объект "_qqo_" (отображения: "_q_" ) не соответствует схеме базы."
 .S (^QV(qqo),^Q(1,"CxObj",qqo,"XORef"))=qqoref_","_qqo,qqol=qqol_" "_qqo K ^QV(qqo,0),^QV(qqo0,1,qqo) D VerifyT(qqo,qqoref_","_qqo)
 ;необработанные ссылки
 S qqo="" F  S qqo=$O(^QV(qqo0,1,qqo)) Q:qqo=""  D
 .S (^QV(qqo),^Q(1,"CxObj",qqo,"XORef"))=qqoref_","_qqo,qqol=qqol_" "_qqo K ^QV(qqo,0,qqo0),^QV(qqo0,1,qqo)
 .S qqoc="" F  S qqoc=$O(^QV(qqo,0,qqoc)) Q:qqoc=""  D
 ..S qview="",q="" F  S qview=$O(^QV(qqo,0,qqoc,qview)) Q:qview=""  D  ;@dol 28.07.04 лишние сообщения о ссылочных
 ...N qqoct S qqoct=$G(^Q(1,"XView",qview,"CxObj",qqoc,"x52")) S:qqoct="" qqoct=+$G(^Q(1,"CxObj",qqoc,"x52")) Q:qqoct
 ...S q=q_" "_qview
 ..S:q'="" qerr($I(qerr))="qWord. Объект "_qqoc_" (отображения: "_q_" ) не соответствует схеме базы."
 .D VerifyT(qqo,qqoref_","_qqo)
 ;переупорядочивание списка объектов-потомков в порядке их следования в описании
 I qqol="" K ^Q(1,"CxObj",qqo0,"xObj")
 E  D
 .S qqol=qqol_" ",qqwl=^QV(qqo0,2),qqwl=$E(qqwl,2,$L(qqwl)-1),qqoc=""
 .F qi=1:1:$L(qqwl," ") S qqw=$P(qqwl," ",qi) S:qqol[(" "_qqw_" ") qqoc=qqoc_" "_qqw
 .S qqoc=$S($L(qqoc," ")+1'=$L(qqol," "):$E(qqol,2,$L(qqol)-1),1:$E(qqoc,2,10000)) ;вдруг что-то потеряли
 .;S ^QV(qqo0,5)=qqoc
 .S ^Q(1,"CxObj",qqo0,"xObj")=qqoc ;список потомков
 S qqwl=$G(^QV(qqo0,3)),qqwl=$E(qqwl,2,$L(qqwl)-1) ;список понятий
 I qqwl'="" F qi=1:1:$L(qqwl," ") S qqw=$P(qqwl," ",qi) I "@HZ"'[$E(qqw),qqw'[":"  ;@Dol 05.04.06 '[":' ;@Dol 23.08.02 только хранимые
 .D:'$D(^Q(1,"CxWoc",qqw))
 ..S qerr($I(qerr))="qWord. Объект "_qqo0_" понятие "_qqw_" отсутствует в CxWoc. Создано ""Понятие_"_qqw_"""."
 ..S ^Q(1,"CxWoc",qqw)="Понятие_"_qqw,^Q(1,"xWoc","Понятие_"_qqw)=qqw
 .S qqoc=$G(^Q(1,"CxWoc",qqw)) S:qqoc="" qqoc="Понятие_"_qqw,^Q(1,"xWoc",qqoc)=qqw ;имя понятия
 .I '$D(^QVW(qqw)) K ^Q(1,"xWoc",qqoc,"CxObj") S ^QVW(qqw)="" ;уберем ссылки
 .S ^Q(1,"xWoc",qqoc,"CxObj",qqo0)=qi-1 ;сделаем ссылку
 I qqwl'="" S ^Q(1,"CxObj",qqo0,"xWoc")=qqwl
 E  K ^Q(1,"CxObj",qqo0,"xWoc")
 Q
VerifyV(qview,qqo,qqop) ;Заполнение массива объектов отображения
 I qqo'=-1 S QVer(qqo)=0 N qqoct S qqoct=$G(^Q(1,"XView",qview,"CxObj",qqo,"x52")) S:qqoct="" qqoct=+$G(^Q(1,"CxObj",qqo,"x52")) S QVer(qqo,2)=+qqoct,QVer(qqo,0)=qqop ;предка впишем
 N qqso S qqso="" F  S qqso=$O(^Q(1,"XView",qview,"CxObj",qqo,"Xy",qqso)) Q:qqso=""  S qi=$G(^(qqso,"X60")) D:qi'="" VerifyV(qview,qi,qqo)
 Q
]]></Implementation>
</Method>

<Method name="VerqUSER">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 N qList,qviewt,qqot,qqw,x,y,qqot1,qqot2,qqot3,qqot4 K $$$tmpGl("qUSER",$J) ; 15.12.2008 Kokarev
 S qviewt="" F  S qviewt=$O(^Q(1,"XView",qviewt)) Q:qviewt=""  D
 .D VerqUw("X122 X123 X167 X169 X172 X185 X186 X182 X120 X130 XMod",qviewt)
 .;обобщение заголовка
 .S qqw=$G(^Q(1,"XView",qviewt,"X164")) I qqw'="",$E(qqw,1,3)'="@XH" D
 ..I $E(qqw,1,2)="@@" D VerqUws("X164",qqw,"X164 Выражение заголовка") Q
 ..;I '$D(^Q(1,"CxWoc",qqw)) S ^CacheTemp("qUSER",$J,$P("o"_$E(qqw,2,255),"."),$I(^CacheTemp("qUSER",$J,$P("o"_$E(qqw,2,255),"."))))="Обобщение не определено в CxWoc qqw="_qqw
 ..S $$$tmpGl("qUSER",$J,$P("o"_$E(qqw,2,255),"."),$I($$$tmpGl("qUSER",$J,$P("o"_$E(qqw,2,255),"."))))="X164 Обобщение заголовка view="_qviewt_" qqw="_qqw ;15.12.2008 Kokarev
 .;параметры печати
 .S y="" F  S y=$O(^Q(1,"XView",qviewt,"XPrint",y)) Q:y=""  D VerqUw("X324 X325",qviewt,"XPrint набор",y)
 .;Действия
 .S y="" F  S y=$O(^Q(1,"XView",qviewt,"XQuest",y)) Q:y=""  D VerqUw("X21",qviewt,"XQuest действие",y)
 .;Меню отображений
 .S qqot="" F  S qqot=$O(^Q(1,"XView",qviewt,"XMenu",qqot)) Q:qqot=""  D
 ..D VerqUws("XMenuDo",$G(^(qqot,"XMenuDo")),"XMenu п."_qqot_" меню отображения "_qviewt)
 ..D VerqUws("XMenuAct",$G(^Q(1,"XView",qviewt,"XMenu",qqot,"XMenuAct")),"XMenu п."_qqot_" меню отображения "_qviewt)
 ..S qqot1="" F  S qqot1=$O(^Q(1,"XView",qviewt,"XMenu",qqot,"XMenu1",qqot1)) Q:qqot1=""  D
 ...D VerqUws("XMenuDo",$G(^(qqot1,"XMenuDo")),"XMenu1 п."_qqot_","_qqot1_" меню отображенийя "_qviewt)
 ...D VerqUws("XMenuAct",$G(^Q(1,"XView",qviewt,"XMenu",qqot,"XMenu1",qqot1,"XMenuAct")),"XMenu1 п."_qqot_","_qqot1_" меню отображения "_qviewt)
 ...S qqot2="" F  S qqot2=$O(^Q(1,"XView",qviewt,"XMenu",qqot,"XMenu1",qqot1,"XMenu2",qqot2)) Q:qqot2=""  D
 ....D VerqUws("XMenuDo",$G(^(qqot2,"XMenuDo")),"XMenu2 п."_qqot_","_qqot1_","_qqot2_" меню отображения "_qviewt)
 ....D VerqUws("XMenuAct",$G(^Q(1,"XView",qviewt,"XMenu",qqot,"XMenu1",qqot1,"XMenu2",qqot2,"XMenuAct")),"XMenu2 п."_qqot_","_qqot1_","_qqot2_" меню отображения "_qviewt)
 ....S qqot3="" F  S qqot3=$O(^Q(1,"XView",qviewt,"XMenu",qqot,"XMenu1",qqot1,"XMenu2",qqot2,"XMenu3",qqot3)) Q:qqot3=""  D
 .....D VerqUws("XMenuDo",$G(^(qqot3,"XMenuDo")),"XMenu3 п."_qqot_","_qqot1_","_qqot2_","_qqot3_" меню отображения "_qviewt)
 .....D VerqUws("XMenuAct",$G(^Q(1,"XView",qviewt,"XMenu",qqot,"XMenu1",qqot1,"XMenu2",qqot2,"XMenu3",qqot3,"XMenuAct")),"XMenu3 п."_qqot_","_qqot1_","_qqot2_","_qqot3_" меню отображения "_qviewt)
 .;Объекты
 .S qqot="" F  S qqot=$O(^Q(1,"XView",qviewt,"CxObj",qqot)) Q:qqot=""  D
 ..D VerqUw("X524 X525 X527 X535 X539 X529 X54 X530 X5240 X587 X536 X537 X531 XMod",qviewt,qqot)
 ..D VerqUw("XRef",,qqot)
 ..S y="" F  S y=$O(^Q(1,"XView",qviewt,"CxObj",qqot,"Xy",y)) Q:y=""  S x="" F  S x=$O(^Q(1,"XView",qviewt,"CxObj",qqot,"Xy",y,"Xx",x)) Q:x=""  D
 ...S qqwt=+$G(^(x,"x70")),qqw=$S("234"[qqwt:$G(^("X71")),1:"")
 ...D VerqUw($S(qqwt=5:"X71 ",1:"")_"X73 X74 X75 X753 X78 X731 X753 X76 X720",qviewt,qqot,y,x,qqw)
 ;объекты
 N qqo,qqc S qqot="X524 X525 X527 X535 X539 X529 X54 X530 X5240 X587 X536 X537 X531",qqot4="XMenuAct XMenuDo XMenuCond"
 S qqo="" F  S qqo=$O(^Q(1,"CxObj",qqo)) Q:qqo=""  I $E(qqo)'="X",'$G(^(qqo,"Xsys"))  D
 .F qqot1=1:1:$L(qqot," ") S qqot2=$P(qqot," ",qqot1) D VerqUws(qqot2,$G(^Q(1,"CxObj",qqo,qqot2)),qqot2_" Описание объекта qqo="_qqo)
 .I $G(^Q(1,"CxObj",qqo,"xWoc"))["XMenuDo" S qqc="" F  S qqc=$O(^Q(1,qqo,qqc)) Q:qqc=""  D  ;объект-меню
 ..F qqot1=1:1:$L(qqot4," ") S qqot2=$P(qqot4," ",qqot1) D VerqUws(qqot2,$G(^Q(1,qqo,qqc,qqot2)),qqot2_" Объект-меню qqo="_qqo_" qqc="_qqc)
 ;понятия
 S qqot="X73 X74 X75 X753 X78 X731 X753 X76 X720",qqw="" F  S qqw=$O(^Q(1,"CxWoc",qqw)) Q:qqw=""  I "xX"'[$E(qqw),'$G(^(qqw,"Xsys")) D
 .I $E(qqw)="@"  D  Q  ;обобщения
 ..I $E(qqw,1,2)="@Z",$E(qqw,1,3)'="@ZX" Q  ;@dol 4.8.03 учет @ZX*
 ..I $E(qqw,1,3)'="@XH",$E(qqw,1,3)'="@ZX" S $$$tmpGl("qUSER",$J,$P("o"_$E(qqw,2,255),"."),$I($$$tmpGl("qUSER",$J,$P("o"_$E(qqw,2,255),"."))))="Обобщение qqw="_qqw Q  ;15.12.2008 Kokarev
 ..D VerqUw("XRef",,,,,qqw)
 .F qqot1=1:1:$L(qqot," ") S qqot2=$P(qqot," ",qqot1) D VerqUws(qqot2,$G(^Q(1,"CxWoc",qqw,qqot2)),qqot2_" Описание Понятия qqw="_qqw)
 ;Запросы
 S qqw="" F  S qqw=$O(^Q(1,"XQuery",qqw)) Q:qqw=""  D VerqUw("XQDoBeg XQDoEnd",qqw,"Запрос")
 ;Роли
 S qqot="" F  S qqot=$O(^Q(1,"XRuls",qqot)) Q:qqot=""  D
 .S qqot1=$O(^Q(1,"XRuls",qqot,"XViewStat",qqot1)) Q:qqot1=""  D
 ..D VerqUws("Ref4",$G(^Q(1,"XRuls",qqot,"XViewStat",qqot1,"Ref4")),"Роль "_qqot_" view="_qqot1_" Действие по входу")
 ..D VerqUws("Ref1",$G(^Q(1,"XRuls",qqot,"XViewStat",qqot1,"Ref1")),"Роль "_qqot_" view="_qqot1_" Запрет ввода/удаления")
 ..D VerqUws("Ref2",$G(^Q(1,"XRuls",qqot,"XViewStat",qqot1,"Ref2")),"Роль "_qqot_" view="_qqot1_" Запрет коррекции")
 ..D VerqUws("Ref5",$G(^Q(1,"XRuls",qqot,"XViewStat",qqot1,"Ref5")),"Роль "_qqot_" view="_qqot1_" Постоянные условия")
 ..S qqot2=$O(^Q(1,"XRuls",qqot,"XViewStat",qqot1,"CxObj",qqot2)) Q:qqot2=""  D
 ...D VerqUws("Ref1",$G(^Q(1,"XRuls",qqot,"XViewStat",qqot1,"CxObj",qqot2,"Ref1")),"Роль "_qqot_" view="_qqot1_" qqo="_qqot2_" Запрет ввода/удаления")
 ...D VerqUws("Ref2",$G(^Q(1,"XRuls",qqot,"XViewStat",qqot1,"CxObj",qqot2,"Ref2")),"Роль "_qqot_" view="_qqot1_" qqo="_qqot2_" Запрет коррекции")
 ...D VerqUws("Ref5",$G(^Q(1,"XRuls",qqot,"XViewStat",qqot1,"CxObj",qqot2,"Ref5")),"Роль "_qqot_" view="_qqot1_" qqo="_qqot2_" Постоянные условия")
 ...S qqot3=$O(^Q(1,"XRuls",qqot,"XViewStat",qqot1,"CxObj",qqot2,"CxWoc",qqot3)) Q:qqot3=""  D
 ....D VerqUws("Ref2",$G(^Q(1,"XRuls",qqot,"XViewStat",qqot1,"CxObj",qqot2,"CxWoc",qqot3,"Ref2")),"Роль "_qqot_" view="_qqot1_" qqo="_qqot2_" qqw="_qqot3_" Запрет коррекции")
 ;отсутствующие методы
 S y="" F  S y=$O($$$tmpGl("qUSER",$J,y)) Q:y=""  I '$D(^oddDEF("User.qUSER","method",y)) S $$$tmpGl("qUSER",$J,y,0)="Нет в qUSER" ;15.12.2008 Kokarev
 ;отсутствующие методы
 S y="" F  S y=$O(^oddDEF("User.qUSER","method",y)) Q:y=""  D
 .;поищем, где используется
 .I y="gOrder" S $$$tmpGl("qUSER",$J,y,$I($$$tmpGl("qUSER",$J,y)))="замещение gOrder для виртуальных объектов" ;15.12.2008 Kokarev
 .S x="",p=0 F  S x=$O(^oddDEF("User.qUSER","method",x)) Q:x=""  I $G(^(x,"code"))[(".."_y_"(")||($G(^("code"))[("qUSER."_y_"(")) S $$$tmpGl("qUSER",$J,y,$I($$$tmpGl("qUSER",$J,y)))="Использован в методе "_x,p=1 ;15.12.2008 Kokarev
 .I 'p,'$D($$$tmpGl("qUSER",$J,y)) S $$$tmpGl("qUSER",$J,y,0)="Не используется" ;15.12.2008 Kokarev
 .I $E(y)="o",'$D(^Q(1,"CxWoc","@"_$E(y,2,255))) S $$$tmpGl("qUSER",$J,y,$I($$$tmpGl("qUSER",$J,y)))="Обобщение не определено в CxWoc qqw=@"_$E(y,2,255) ;15.12.2008 Kokarev
 Q:$Q "" Q
VerqUw(liatr,qview,qqo,y,x,qqw)
 N str,st,p,pp,atr F pp=1:1:$L(liatr," ") S atr=$P(liatr," ",pp) D
 .S p=1,st="",str=$S(atr="XRef":$S($G(qqo)'="":$G(^Q(1,"CxObj",qqo)),1:$G(^Q(1,"CxWoc",qqw))),$G(qqo)="Запрос":$G(^Q(1,"XQuery",qview,atr)),$E(atr,2)=1||(atr="XMod"&&($G(qqo)="")):$G(^Q(1,"XView",qview,atr)),$E(atr,2)=2:$G(^Q(1,"XView",qview,"XQuest",y,atr)),$E(atr,2)=3:$G(^Q(1,"XView",qview,"XPrint",y,atr)),$E(atr,2)=5||(atr="XMod"):$G(^Q(1,"XView",qview,"CxObj",qqo,atr)),$E(atr,2)=7:$G(^Q(1,"XView",qview,"CxObj",qqo,"Xy",y,"Xx",x,atr)))
 .F  S p=$F(str,"qUSER.",p) Q:'p  S st=$S(st="":"",1:st_" ")_$P($E(str,p,30000),"(")
 .Q:st=""  F p=1:1:$L(st," ") S $$$tmpGl("qUSER",$J,$P(st," ",p),$I($$$tmpGl("qUSER",$J,$P(st," ",p))))=atr_" "_$G(^Q(1,"CxWoc",atr))_$S($G(qview)="":"",1:" view="_qview)_$S($G(qqo)="":"",1:" qqo="_qqo)_$S($G(y)="":"",1:" y="_y)_$S($G(x)="":"",1:" x="_x)_$S($G(qqw)="":"",1:" qqw="_qqw) ;15.12.2008 Kokarev
 Q
VerqUws(atr,str,txt)
 S p=1,st="" Q:str=""
 F  S p=$F(str,"qUSER.",p) Q:'p  S st=$S(st="":"",1:st_" ")_$P($E(str,p,30000),"(")
 Q:st=""  F p=1:1:$L(st," ") S $$$tmpGl("qUSER",$J,$P(st," ",p),$I($$$tmpGl("qUSER",$J,$P(st," ",p))))=txt ;15.12.2008 Kokarev
 Q
]]></Implementation>
</Method>

<Method name="ViewStat">
<Description>
Сохранение/восстановление состояния отображение в физическое дерево
(Объект XViewStat, отображение XXXXViewStat).
Arg1=0 - текущее отовражение
Arg2=0 - сохранение, 1 - восстанновление</Description>
<Internal/>
<FormalSpec>Arg1:%String=0,Arg2:%String=0</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N masr,masw,nam,qqo,qqw,im,qpar D
 .I 'Arg1 S masr="Vs("""_qqnump_""")",masw=$NA(^Q(1,"XViewStat",$TR(qview," ","_"))) Q  ;состояние текущего отображения
 G:Arg2 ViewStat1
 ;сохранение
 K @masw
 F nam="CurObj","ID","CondFind","RelNum","Relind","ReFind","GloRef" D
 .S @masw@("X"_nam)=$G(@masr@(nam))
 S @masw@("XFix")=$G(@masr@(7)),@masw@("XFixF")=+$G(@masr@(17))
 S @masw@("XPict")=+$G(@masr@(99,"Pic"))
 F nam=1:1:4,7,8,12 D:$D(@masr@(nam))
 .;S @masw@("X"_nam)=$G(@masr@(nam))
 .S qqo="" F  S qqo=$O(@masr@(nam,qqo)) Q:qqo=""  I $G(@masr@(nam,qqo))!(nam>7) S @masw@("X"_nam,qqo,"X59"_nam)=$G(@masr@(nam,qqo)) D:nam>7
 ..S qqw="" F  S qqw=$O(@masr@(nam,qqo,qqw)) Q:qqw=""  D
 ...I nam=8 S @masw@("X"_nam,qqo,"X8W",qqw,"X798")=$G(@masr@(nam,qqo,qqw)) Q
 ...F im=1:1:9 S @masw@("X"_nam,qqo,"X12W",qqw,"X7912"_im)=$G(@masr@(nam,qqo,qqw,im)) I im>4,$G(@masr@(13,0,qqo_" "_qqw_" "_im))'="" S @masw@("X"_nam,qqo,"X12W",qqw,"X79130"_im)="Y"_@masr@(13,0,qqo_" "_qqw_" "_im)
 ;
 S @masw@("X8P",0,"X1980")=+$G(@masr@(99,"Find"))
 S @masw@("X8P",0,"X1981")=+$G(@masr@(99,"Find",1))
 S @masw@("X8P",0,"X1983")=$G(@masr@(99,"Find",2))
 S @masw@("X8P",0,"X1984")=$G(@masr@(99,"Find",3))
 S @masw@("X8P",0,"X1982")=$S('Arg1:$G(Vt(qqnump,0)),1:0)
 ;
 S @masw@("X12P",0,"X19120")=+$G(@masr@(99,"Anal"))
 S @masw@("X12P",0,"X19121")=+$G(@masr@(99,"Anal",0))
 S @masw@("X12P",0,"X19122")=$G(@masr@(99,"Anal",1))
 ;
 S @masw@("X13",0,"X19134")=$G(@masr@(13,"P"))
 S @masw@("X13",0,"X19135")=$G(@masr@(13,"M"))
 S @masw@("X13",0,"X19136")=$G(@masr@(13,"S"))
 S @masw@("X13",0,"X19139")=+$G(@masr@(13,"X"))
 S @masw@("X13",0,"X19137")=$P($G(@masr@(13,"R"))," ")
 S @masw@("X13",0,"X19138")=$P($G(@masr@(13,"R"))," ",2)
 Q:$Q "" Q
ViewStat1 ;восстановление
 K @masr
 F nam="CurObj","ID","CondFind","RelNum","Relind","ReFind","GloRef" D
 .S @masr@(nam)=$G(@masw@("X"_nam))
 S @masr@(7)=$G(@masw@("XFix"))
 S @masr@(17)=+$G(@masw@("XFixF"))
 S @masr@(99,"Pic")=+$G(@masw@("XPict"))
 F nam=1:1:4,7,8,12 D:$D(@masw@("X"_nam))
 .S qqo="" F  S qqo=$O(@masw@("X"_nam,qqo)) Q:qqo=""  I $G(@masw@("X"_nam,qqo,"X59"_nam))!(nam>7) S @masr@(nam,qqo)=$G(@masw@("X"_nam,qqo,"X59"_nam)) D:nam>7
 ..S qqw="" F  S qqw=$O(@masw@("X"_nam,qqo,$S(nam=8:"X8W",1:"X12W"),qqw)) Q:qqw=""  D
 ...I nam=8 S @masr@(nam,qqo,qqw)=$G(@masw@("X"_nam,qqo,"X8W",qqw,"X798")) Q
 ...F im=1:1:9 S qpar=$G(@masw@("X"_nam,qqo,"X12W",qqw,"X7912"_im)) I qpar'="" S @masr@(nam,qqo,qqw,im)=qpar D
 ....I im>4,$G(@masw@("X"_nam,qqo,"X12W",qqw,"X79130"_im))'="" S qpar=$E(@masw@("X"_nam,qqo,"X12W",qqw,"X79130"_im),2,255),@masr@(13,0,qqo_" "_qqw_" "_im)=qpar,@masr@(13,1,qpar)=qqo_" "_qqw_" "_im Q
 ....I im=3 S qpar=$E($G(@masr@(nam,qqo,qqw,im)),2,3) I qpar'="" S:qpar=1 @masr@(12)=qqo_" "_qqw S @masr@(13,2,qqo_" "_qqw)=qpar,@masr@(13,3,qpar)=qqo_" "_qqw
 ;
 S @masr@(99,"Find")=+$G(@masw@("X8P",0,"X1980"))
 S @masr@(99,"Find",1)=+$G(@masw@("X8P",0,"X1981"))
 S @masr@(99,"Find",2)=@masw@("X8P",0,"X1983")
 S @masr@(99,"Find",3)=@masw@("X8P",0,"X1984")
 S:'Arg1 Vt(qqnump,0)=$G(@masw@("X8P",0,"X1982"))
 ;
 S @masr@(99,"Anal")=+$G(@masw@("X12P",0,"X19120"))
 S @masr@(99,"Anal",0)=+$G(@masw@("X12P",0,"X19121"))
 S @masr@(99,"Anal",1)=$G(@masw@("X12P",0,"X19122"))
 ;
 S @masr@(13,"P")=$G(@masw@("X13",0,"X19134"))
 S @masr@(13,"M")=$G(@masw@("X13",0,"X19135"))
 S @masr@(13,"S")=$G(@masw@("X13",0,"X19136"))
 S @masr@(13,"X")=+$G(@masw@("X13",0,"X19139"))
 S $P(@masr@(13,"R")," ")=$G(@masw@("X13",0,"X19137"))
 S $P(@masr@(13,"R")," ",2)=$G(@masw@("X13",0,"X19138"))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Vs8P">
<Description>
Чтение или запись (wrt=1) в поисковый образ окна-родителя.
Используется в качестве правила вывода или проверки отображения сокращенного
задания поискового образа (sysL в методе sysview).</Description>
<Internal/>
<FormalSpec>qqo:%String,qqw:%String,wrt:%String,qqs:%String,load:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $G(wrt) D  Q:$Q "" Q  ;@dol 5.02.03 заменен qqParent на Vt(qqnump,"Zparent")
 .Q:$E(qqw,1,3)="@ZX"  I '$G(qqs) D  Q  ;$E(qqw,1,3)="@ZX" - чтобы можно было включать псевдокнопку с действием
 ..I $TR(Z," ")="" K Vs($P(Vt(qqnump,"Zparent")," ",2),8,qqo,qqw) Q
 ..S Vs($P(Vt(qqnump,"Zparent")," ",2),8,qqo,qqw)=Z Q
 .S:$TR(Z," ")="" Z=""
 .I qqs=1 S Vs($P(Vt(qqnump,"Zparent")," ",2),8,qqo,qqw)=Z_">>"_$P($G(Vs($P(Vt(qqnump,"Zparent")," ",2),8,qqo,qqw)),">>",2) Q
 .I qqs=2 S Vs($P(Vt(qqnump,"Zparent")," ",2),8,qqo,qqw)=$P($G(Vs($P(Vt(qqnump,"Zparent")," ",2),8,qqo,qqw)),">>",1)_">>"_Z Q
 I '$G(qqs) Q $G(Vs($P(qqParent," ",2),8,qqo,qqw)) ;здесь и далее именно qqParent (окно еще не открыто)
 Q $P($G(Vs($P(qqParent," ",2),8,qqo,qqw)),">>",qqs)
]]></Implementation>
</Method>

<Method name="WDXGM1">
<Description>
создание массива для XGM1 объекта sas 20090401</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 i (qqt=1) d
 .n qqcXGM1,qqcXGM,lengthXGM,count
 .s qqcXGM=Vs(qqnump,"Virt","XGM"),lengthXGM=$L(qqcXGM)
 .s qqcXGM1=qW.UserOrd(-1,"XGM1","",qqcXGM)
 .s count=+$E(qqcXGM1,lengthXGM+1,$L(qqcXGM1))
 .s count=count+1
 .s count=$TR($J(count,8)," ",0)
 .s qqcXGM1=qqcXGM_count
 .s ^Q(1,qqo,qqcXGM1)=""
 .s ^Q(1,"XGM1")=($G(^Q(1,"XGM1"))+1)
 .d qARM.wcre()
 .d qARM.wqqotree(qqo,qqcXGM1)
 i qqt=3 K ^Q(1,qqo,qqc) S:+$G(^Q(1,"XGM1"))>0 ^Q(1,"XGM1")=(^Q(1,"XGM1")-1)
 q $S(qqt=1:1_" ",1:"")
]]></Implementation>
</Method>

<Method name="WDXGM2">
<Description>
проверка наличия в глобале ^%qFiles sas 20090401</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 i Z=1 i $G(^%qFiles("F~"_$ZCVT($P($G(^Q(1,"XGM1",qqc,"sysfiles")),"\",$L($G(^Q(1,"XGM1",qqc,"sysfiles")),"\")),"U")))="" d qARM.Message("Узел ^%qFiles("""_"F~"_$ZCVT($P($G(^Q(1,"XGM1",qqc,"sysfiles")),"\",$L($G(^Q(1,"XGM1",qqc,"sysfiles")),"\")),"U")_""") отсутствует!"_$C(13,10)_"Загрузите файл "_$ZCVT($P($G(^Q(1,"XGM1",qqc,"sysfiles")),"\",$L($G(^Q(1,"XGM1",qqc,"sysfiles")),"\")),"U")_"!") q 0
 i Z=1 s ^Q(1,qqo,qqc,"flag")=0 d qARM.wqqotree()
 q 1
]]></Implementation>
</Method>

<Method name="WriteAuditEvent">
<Description>
Запись события в базу аудита Cache.
Details может быть многострочным.
@dima 20100917</Description>
<Internal/>
<FormalSpec>Text:%Library.String,Details:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 d:$p($p($zv,") ",2)," ",1)>5.2 $SYSTEM.Security.Audit("qARM","Event","User event","host="_$ZU(67,12,$J)_"  localuser="_$ZU(67,11,$J)_"  user="_$G(qARM("User"))_$C(13,10,13,10)_$E(qW.zReplace($TR($G(Details),$C(10)),$C(13),$C(13,10)),1,16000),$E(Text,1,128))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="X182">
<Description>
Метод предназначен для вставки в качестве действия по релевантным.
Прозволяет всегда отмечать поддерево текущего экземпляра</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 Q:'$G(Vc(qqnump,qOref,2))  Q:$G(DoRel)  I Arg1'="+",Arg1'="-" Q
 N DoRel,DoRel0 S DoRel=1,DoRel0=$G(Vs(qqnump,99,"Find")),Vs(qqnump,99,"Find")=1 ;временная установка отметки поддерева
 D qARM.RecRel("+",qOref) S Vs(qqnump,99,"Find")=DoRel0 Q
]]></Implementation>
</Method>

<Method name="X720Rel">
<Description>
Динамические параметры для выделения отмеченных релевантных в отображении. Неотмеченные - серые
В действие по релевантным (X182) должен быть вставлен qARM.wwrefr(,,-1,"d") - перевывод дин.пар.
tree=1 - имитация поддерева - ниже отмеченных выводятся своим цветом</Description>
<Internal/>
<FormalSpec>tree</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$G(tree) Q "*"_$S($G(Vc(qqnump,qqci,2)):+$P($G(Vo(qqnump,Vc(qqnump,qqci,0),0,0,0,2)),",",8),1:8421504)
 N Arg1 S Arg1=1 I $D(^Q($$$Relind_qview,Vc(qqnump,$E(qqci,1,2),0)))>1 S Arg1=$G(Vc(qqnump,qqci,2)) I 'Arg1 N qqii,qqii0 D
 .S qqii=qqci,Arg1=0 F  S qqii=$E(qqii,1,$L(qqii)-2) Q:qqii=""  S Arg1=$G(Vc(qqnump,qqii,2)) Q:Arg1
 .Q:'Arg1  S qqii=qqci,Arg1=1 F  S qqii0=qqii,qqii=$E(qqii,1,$L(qqii)-2) Q:qqii=""  Q:$G(Vc(qqnump,qqii0,2))  I '$G(Vc(qqnump,qqii0,2)),$S($G(Vo(qqnump,Vc(qqnump,qqii0,0),2)):$D(^Q($$$Relind_qview,Vc(qqnump,qqii,0),Vc(qqnump,qqii),Vc(qqnump,qqii0,0)))>1,1:$E($O(^Q($$$Relind_qview,Vc(qqnump,qqii0,0),Vc(qqnump,qqii))),1,$L(Vc(qqnump,qqii)))=Vc(qqnump,qqii)) S Arg1=0 Q
 Q "*"_$S('Arg1:8421504,1:+$P($G(Vo(qqnump,Vc(qqnump,qqci,0),0,0,0,2)),",",8))
]]></Implementation>
</Method>

<Method name="XXXCxWocx711">
<Description>
Метод используется для обработки действий в отображении XXXCxWoc_x711.

Параметры:
exec - определеят действие, которое должно быть выполнено.</Description>
<Internal/>
<FormalSpec>exec:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 i $g(exec)="" $$$oQuit(1,"")
 ;
 ;"Действие по входу" в отображение
 i exec="X123" d  $$$oQuit(1,"")
 .n ref s (ref,Vs(qqnump,"UserPar","ref"))=$na(^mtempqSYS($j,qqnump)) k @ref
 .;Vs(qqnump,"UserPar","%qqw") - содержит код понятия, для которого определяем значения x711
 .q:$g(Vs(qqnump,"UserPar","%qqw"))=""  ;если не определен код понятия, то выход
 .;проходим по всем объектам (кроме системных) и, если определено значение x711, то объект добавляем в массив
 .n qo,qw,val s qw=Vs(qqnump,"UserPar","%qqw"),qo=-1 f  s qo=$o(^Q(1,"CxObj",qo)) q:qo=""  i '$g(^(qo,"Xsys")) s val=$g(^("CxWoc",qw,"x711")) s:val'="" @ref@(qo,"x711")=val
 ;
 ;"Выражение проверки" для объекта CxОbj6 - выполняется только при удалении (qqt=3) экземпляра массива
 ;  заполняем узел Vs(qqnump,"UserPar","%iddel"), значение которого используем в "%Постдействие"
 i exec="X524" q:qqt'=3 "" s Vs(qqnump,"UserPar","%iddel")=qqc q ""
 ;
 ;"Постдействие" для объекта CxObj6 - выполняется только при коррекции (qqt=2) или удалении (qqt=3) экземпляра массива
 ;  изменяем/удаляем узел ^Q(1,"CxObj",код_объекта,"CxWoc",код_понятия,"x711")
 ;  значение x711 - в массиве @Vs(qqnump,"UserPar","ref")@(код_объекта,"x711")
 ;  если было удаление экземпляра (qqt=3) или значение x711 равно ""(пусто), то узел удаляется
 ;  после выполнения действия - инициализация нового значения x711 для текущего объекта (qW.rWocx711)
 i exec="X5240" d  $$$oQuit(1,"")
 .n qw,qo,qt s qw=$g(Vs(qqnump,"UserPar","%qqw")) q:qw=""  s qo=$s(qqt=3:$g(Vs(qqnump,"UserPar","%iddel")),1:$g(qqc)) q:qo=""
 .i qqt=3 k ^Q(1,"CxObj",qo,"CxWoc",qw,"x711")
 .e  s qt=$g(@Vs(qqnump,"UserPar","ref")@(qo,"x711")) k:qt="" ^Q(1,"CxObj",qo,"CxWoc",qw,"x711") s:qt'="" ^Q(1,"CxObj",qo,"CxWoc",qw,"x711")=qt
 .d qW.rWocx711(qw,qo,1)
 $$$oQuit(1,"")
]]></Implementation>
</Method>

<Method name="aPOP">
<Description>
Получение файла журнала qj.xml и его восстановление в базу </Description>
<Internal/>
<FormalSpec>server:%Library.String,username:%Library.String,password:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    030602
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 ;#include %occOptions
 ;#include %occStatus
 ;
 n qvnumb,k,sender,mnum,getmail,getnum,execute,count


 I $G(server)="" S server=$G(^Q(1,"XBase",0,"Xsmtppopadr")) S:server="" server=$G(^Q(1,"XBase",0,"Xsmtpadr"),"132.32.32.240")
 I $G(username)="" s username=$P($G(^Q(1,"XBase",0,"Xsmtpuser"),"dol dol")," ")
 I $G(password)="" s password=$P($G(^Q(1,"XBase",0,"Xsmtpuser"),"dol dol")," ",2)
 ;D qARM.Message(server_" "_domadr_" "_password)
 ;s server="132.32.32.123"
 ;s domadr="PavelPF@sparm.com"
 ;s password="****"
 //////////////////////////////

 new mailserver,status,from,to,date,subject,messagesize,hdrs,key,mailMsg,qerr,f

 ;s qWEB=##class(%qWEB).%New()
 ;s qWORD=##class(%qWORD).%New()

 set mailserver=##class(%Net.POP3).%New()
 set mailserver.AttachDir=$zu(168)  ; need terminating \
 set mailserver.Debug=0
 set mailserver.StoreAttachToFile=1

 ;;;write !,"Calling Connect"
 set status=mailserver.Connect(server,username,password)
 if $$$ISERR(status) do DecomposeStatus^%occSystem(status,.err) Q err(err)
 ;write !,"Calling FetchMessage"
 d mailserver.GetMailBoxStatus(.num,.byt)
 S qerr="писем - "_num_" объем -"_byt

 ;Если нет сообщений
 i num=0  D mailserver.%Close() q "Нет писем"
 ;Прием и обработка XML если в теме письма есть строка "qWJrnXML"
 s f=0
 f nummail=1:1:num  
 {               
 set status=mailserver.FetchMessage(nummail,.from,.to,.date,.subject,.messagesize,.hdrs,.mailMsg,0)
 if $$$ISERR(status) do DecomposeStatus^%occSystem(status,.err) S qerr=err(err) D mailserver.%Close() quit
 ;write !,"from="_from
 ;write !,"to="_to
 ;write !,"date="_date
 ;write !,"subject="_subject
 ;write !,"messagesize="_messagesize
 i $P(subject,"|")="qWJrnXML"
 {
 s f=f+1
 ;set mailserver.StoreAttachToFile=1
 k $$$tmpGl($j,"1") ;15.12.2008 Kokarev

 i $P(subject,"|",3)=0  k ^getmail($P(subject,"|",2))   ;если первое письмо, то убить закодированное поддерево для данного сендера

 s qin=$Na(^getmail($P(subject,"|",2),$P(subject,"|",3)))
 d ..FileLoad($zu(168)_"qj.xml",qin)        ;запись из файла в массив ^vmail(имя отправителя,номер письма)

 ;s k=$$UEncrLet(qin,"^qout",@qrefSec@("key"),@qrefSec@("sbox"),.vout)
 ;i k<0 q

 ;d qWEB.LoadJrnXML(0,"^qout","^CacheTemp("_$j_",""1"")")
 ;d qW.rJrn("^CacheTemp("_$j_",""1"",""XJrn"")",1)
 ///d qWEB.LoadJrnXML(2,$zu(168)_"qj.xml","^CacheTemp("_$j_",""1"")")
 ///d qWEB.LoadJrnXML(2,$zu(168)_"qj.xml","^CacheTemp("_$j_",""1"")")
 ///d qW.rJrn("^CacheTemp("_$j_",""1"",""XJrn"")",1)
 ;w !,"Процесс - "_$j,!
 D mailserver.DeleteMessage(nummail) ;удалить письмо(пометить)
 }
 D mailMsg.%Close()
 }               
 D mailserver.QuitAndCommit() ;удалить помеченные
 D mailserver.%Close()


 ;Восстановление журнала из массива
 s k="Нет восстановления!"

 s sender="",execute=""  f  {
 s sender=$O(^getmail(sender)) q:sender=""
 ;выявление полученных, отсечение недошедших писем
 s mnum="",getmail=""
 f  {
 s mnum=$O(^getmail(sender,mnum))
 q:mnum=""
 i (mnum=(+$O(^getmail(sender,mnum),-1)+1))!(mnum=0) {s getmail=mnum }
 else {q}
 ;d qARM.Message(mnum_"="_(+$O(^getmail(sender,mnum),-1)+1))
 }

 ;d qARM.Message(getmail) 

 ;определение последнего восстановленного письма
 s getnum=$O(^Security("client",sender,""),-1)
 i getnum="" s getnum=0
 ;s ^pav("getnum")=getnum,^pav("getmail")=getmail
 ;восстановление от последнего восстановленного до последнего вовремя полученного
 s count=0  f mnum=getnum:1:getmail {
 s count=count+1
 s qin=$Na(^getmail(sender,mnum))       
 s qrefSec=$Na(^Security("client",sender,mnum))
 i mnum=0  {
 s @qrefSec@("key")="70D1BC8E ED1F7773 0A7BEF8F E945CC09 69E1B707 9B40B226 EA29A1C0 515244F2"
 s @qrefSec@("sbox")="9F32A807 1C546DEB C3DB1475 09A62EF8 E81536C2 9BA740FD 29C36B87 1A0FED54 816CD9BA 452E3F07 CEB0A89F 2745D361 2A83B09D 46C17F5E 78631D4F E0B2AC95"
 }
 s k=..SECUEncrLet(qin,"^qout",@qrefSec@("key"),@qrefSec@("sbox"),.vout)
 i k<0 q
 s qrefSec=$Na(^Security("client",sender,(mnum+1)))
 s @qrefSec@("key")=vout("key"),@qrefSec@("sbox")=vout("sbox")

 d qWEB.LoadJrnXML(0,"^qout",$na($$$tmpGl($j,"1"))) ;15.12.2008 Kokarev
 d qWEB.LoadJrnXML(0,"^qout",$na($$$tmpGl($j,"1"))) ;15.12.2008 Kokarev
 d qW.rJrn($na($$$tmpGl($j,"1","XJrn")),1) ;15.12.2008 Kokarev
 }
 s execute=+(execute)+count             ;количество обработанных писем
 }

 q:k<0 "BAD ALL  k= "_k
 quit:f'=0 "Получено писем - "_f_" Обработано - "_execute
 q "Нет писем, содержащих журнал."
]]></Implementation>
</Method>

<Method name="aSMTP">
<Description>
Запись журнала ^QJ в файл qj.xml и отправка его по почте</Description>
<Internal/>
<FormalSpec>smtpserver:%Library.String,from:%Library.String,to:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 //030602
 ;#include %occOptions
 ;#include %occStatus 
 N subj,s,m,status
 n k,sb,tmp,qvovka,qvnumb,qin,qrefSec,qout,tmp
 I $g(smtpserver)="" s smtpserver=$G(^Q(1,"XBase",0,"Xsmtpadr"),"132.32.32.240")
 I $g(from)="" s from=$G(^Q(1,"XBase",0,"Xsmtpfrom"),"paffff@sparm.com")
 I $g(to)="" s to=$G(^Q(1,"XBase",0,"Xsmtpto"),"pavelpf@sparm.com")

 ;s from="olgaas@sparm.com"
 ;s to="pavelpf@sparm.com"

 s subj="qWJrnXML|"_from_"|"
 ;s subj="ooo"
 i '$d(^QJ) Q "Нет журнала!"
 s beg=$G(^Q(1,"XBase",0,"Xsmtplast")) S:beg="" beg=($O(^QJ(1,"XJrn",""))-1)
 S end=$O(^QJ(1,"XJrn",""),-1)
 I beg=end||(end<beg)||('$D(^QJ(1,"XJrn",beg))&&beg'=0) Q "Нет записей журнала!"


 set s=##class(%Net.SMTP).%New()
 S s.Debug=1
 set s.smtpserver=smtpserver
 ;set s.timezone="-0400"   
 set m=##class(%Net.MailMessage).%New()
 
 //misuno 20080806
 set auth=##class(%Net.Authenticator).%New() ;use default authentication list
 set login=$P($G(^Q(1,"XBase",0,"Xpopuser"))," ")
 set password=$P($G(^Q(1,"XBase",0,"Xpopuser"))," ",2)
 set auth.UserName=login
 set auth.Password=password
 set auth.MechanismList="LOGIN"
 set s.authenticator=auth
 f i=1:1 s toi=$p(to,",",i) q:toi=""  do m.To.Insert(toi)
 
 set m.From=from
 
 ;misuno 20080806 do m.To.Insert(to) 
 
 ///////////////////////////////////////////////////////////
 ;Кодирование
 s qin="qvovka",qout="out" k @qin,@qout
 d qWEB.GetJrnXML(0,qin,beg,end) ;k ^vol m ^vol=@qin

 s qvnumb=+$O(^Security("server",from,""),-1),qrefSec=$Na(^Security("server",from,qvnumb)) ;номер письма и ссылка на массив где хранятся ключи
 ;если письмо первое задаем начальные ключи
 i qvnumb=0  d
 .s @qrefSec@("key")="70D1BC8E ED1F7773 0A7BEF8F E945CC09 69E1B707 9B40B226 EA29A1C0 515244F2"
 .s @qrefSec@("sbox")="9F32A807 1C546DEB C3DB1475 09A62EF8 E81536C2 9BA740FD 29C36B87 1A0FED54 816CD9BA 452E3F07 CEB0A89F 2745D361 2A83B09D 46C17F5E 78631D4F E0B2AC95"
 set m.Subject=subj_qvnumb                          ;добавление номера письма к теме

 ;кодирование @qin и результат в @qout
 d ..SECEncrLet(qin,qout,@qrefSec@("key"),@qrefSec@("sbox"),m.Subject,qvnumb,.tmp)
 d ..FileSave("qj.xml",qout)  ;запись в файл
 /////////////////////////////////////////////////////////////

 ////set m.Subject=subj
 ////d qWEB.GetJrnXML(2,$zu(168)_"qj.xml",beg,end)    /////Запись текста в файл
 s status=m.AttachFile($zu(168),"qj.xml")
 if $$$ISERR(status) do DecomposeStatus^%occSystem(status,.err) do m.%Close() do s.%Close() q err(err)


 ;w !,"Соединение с сервером и отправка сообщений..." 
 set status=s.Send(m)
 if $$$ISERR(status) do DecomposeStatus^%occSystem(status,.err) do m.%Close() do s.%Close() q err(err)
 S ^Q(1,"XBase",0,"Xsmtplast")=end
 do m.%Close()
 do s.%Close()

 ;Сохранение ключей
 s qvnumb=qvnumb+1,qrefSec=$Na(^Security("server",from,qvnumb)),@qrefSec@("key")=tmp("key"),@qrefSec@("sbox")=tmp("sbox")

 quit "OK!"
]]></Implementation>
</Method>

<Method name="aSMTPretest">
<Description>
Повторная отправка закодиравонного письма №</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 //110702
 ;#include %occOptions
 ;#include %occStatus 

 n smtpserver,from,to,subj,num,s,m,qout,status

 s l=$s($e($lg(^|"%SYS"|%SYS("CSP","Applications","/apps/documatic"),2))="/":1,1:0)
 s dir=$zu(140,9,$zu(168)_$S(l=1:"/",1:"\")_"retest")
 s path=$zu(168)_"retest"_$S(l=1:"/",1:"\")

 s smtpserver=$G(^Q(1,"XBase",0,"Xsmtpadr"))
 s from=$G(^Q(1,"XBase",0,"Xsmtpfrom"))
 s to=$G(^Q(1,"XBase",0,"Xsmtpto"))
 ;s from="olgaas@sparm.com"
 ;s to="pavelpf@sparm.com"


 s num=$g(^Q(1,"XBase",0,"Xsmtpretest"))
 i num="" Q "Нет письма для повторной отправки!"
 s subj="qWJrnXML|"_from_"|"_num


 set s=##class(%Net.SMTP).%New()
 S s.Debug=1
 set s.smtpserver=smtpserver
 ;set s.timezone="-0400"   
 set m=##class(%Net.MailMessage).%New()
 set m.Subject=subj
 set m.From=from
 do m.To.Insert(to)

 ///////////////////////////////////////////////////////////

 i '$d(^QJHistory("Send",from,num,"xmlEncr",0)) Q "Нет истории для письма "_num_"!"
 m qout=^QJHistory("Send",from,num,"xmlEncr")
 d FileSavere(path_"qjfon.xml",$Na(qout))  ;запись в файл
 /////////////////////////////////////////////////////////////

 ////set m.Subject=subj
 ////d qWEB.GetJrnXML(2,$zu(168)_"qj.xml",beg,end)    /////Запись текста в файл
 s status=m.AttachFile(path,"qjfon.xml")
 if $$$ISERR(status) do DecomposeStatus^%occSystem(status,.err) do m.%Close() do s.%Close() q err(err)


 ;w !,"Соединение с сервером и отправка сообщений..." 
 set status=s.Send(m)
 if $$$ISERR(status) do DecomposeStatus^%occSystem(status,.err) do m.%Close() do s.%Close() q err(err)
 do m.%Close()
 do s.%Close()

 quit "OK! Повторно отправлено письмо "_num_"!"

FileSavere(file,e)
 n i o file:"nw" u file for i=0:1:$O(@e@(""),-1) w @e@(i)
 c file q
]]></Implementation>
</Method>

<Method name="autoCodeTableDBF">
<Description>
; автоопределения кодировки символов заданной строки
; На входе:  str - проверяемая строка
; На выходе: если '$G(strdec) возвращаемое значение = "CP1251" - кодировка Windows; "CP866" - DOS; "" (пусто) - кодировку определить не удалось
;            если  $G(strdec) строка, раскодированная с учетом найденной кодировки, иначе - копия строки    </Description>
<Internal/>
<FormalSpec>str:%String,strdec:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    n a,aw,awu,ad,adu,ain,i,flDos,flWin,enc s (flDos,flWin)=0,enc=""
    s a="АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя"  ; алфавит в кодировке по умолчанию
    s aw="" f i=192:1:197,168,198:1:223,224:1:229,184,230:1:255 s aw=aw_$c(i) ; алфавит в кодировке Windows CP1251
    s ad="" f i=128:1:133,240,134:1:165,241,166:1:175,224:1:239 s ad=ad_$c(i) ; алфавит в кодировке DOS CP866
    s awu=$tr(aw,ad)
    s adu=$tr(ad,aw)
    if $tr(adu,str)'=adu s flDos=1,ain=ad
    //if $tr(awu,str)'=awu s flWin=1,ain=aw
    //в случае наличия и dos и win кодировок в строке, кодировка не определялась.
    //теперь если определена дос кодировка, то проверка на win не делается
    if flDos'=1  if $tr(awu,str)'=awu s flWin=1,ain=aw
    if flDos,'flWin s enc="CP866"
    Else  if 'flDos,flWin s enc="CP1251"
    s:$G(strdec) enc=$s(enc'="":$tr(str,ain,a),1:str)
    q enc
]]></Implementation>
</Method>

<Method name="dblqw">
<Description>
Удваивание кавычек в строке qqpar1</Description>
<Internal/>
<FormalSpec>qqpar1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqpos S qqpos=1 F  S qqpos=$F(qqpar1,"""",qqpos) Q:'qqpos  S $E(qqpar1,qqpos-1)="""""",qqpos=qqpos+1
 Q qqpar1
]]></Implementation>
</Method>

<Method name="getLocal">
<Description>
@pav Добыча (и заполнение) значения из словаря локализации
работает если XBLocal=1
если XBfLocal=1 - происходит заполнение словаря локализации
type=1 - константа
2 - понятие
3 - меню
4 - всплывающая подсказка
5 - закладка
6 - заголовок колонки</Description>
<Internal/>
<FormalSpec>cod,type</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    ;q $g(cod)
    s:'$d(type) type=0
    
    q:$g(cod)="" ""
    q:(cod'?.E1.A.E) cod
    
    n codOrig s codOrig=cod
    
    s cod=$tr(cod," ","_")
    ;Длина сущности
    n less
    s less=$l(cod)
    s:less>200 cod=$e(cod,1,200)
    
    ;Если сущность содержит число
    ;????
    
    ;Поиск в словаре локализации
    n qqcqXLocal
    s qqcqXLocal=qW.FastKey("qXLocal","Dessence",,,cod,"")
    i qqcqXLocal="" {
        ;Выход если не включен режим заполнения словаря
        q:'$g(XBfLocal) codOrig
        ;Создаем запись в словаре
        s W("Dessence")=cod,W("Dless")=less
        ;s qqcqXLocal=$P(qW.rNew("qXLocal","")," ")
        ;d qW.rCor("qXLocal",qqcqXLocal,"Dessence Dless",,0)
        s qqcqXLocal=qW.rNewPr("qXLocal","",,,"Dessence Dless","XXXsysO")
    }
    ;Поиск окна
    n qqcqXLwin,win
    s win=$g(Vo(qqnump)) q:win="" codOrig
    s qqcqXLwin=qW.FastKey("qXLwin","DqXwin Desst",,,win_"~"_type,qqcqXLocal)
    i (qqcqXLwin="")&($g(XBfLocal)) {
        s W("DqXwin")=win,W("Desst")=$g(type)
        ;s qqcqXLwin=$P(qW.rNew("qXLwin",qqcqXLocal)," ")
        ;d qW.rCor("qXLwin",qqcqXLwin,"DqXwin Desst",,0)
        s qqcqXLwin=qW.rNewPr("qXLwin",qqcqXLocal,,,"DqXwin Desst","XXXsysO")
    }
    
    ;Выход если длина сущности более 200 (но в словарь локализации записали для анализа!!!)
    q:less>200 codOrig
    
    ;Локаль
    n loc s loc=$g(XLocal) s:loc="" loc="RUS"
    ;Значение сущности по локали
    n ess s ess=qW.GG("qXLocal",("D"_$zcvt(loc,"L")),qqcqXLocal)
    i qqcqXLwin'="" s:qW.GG("qXLwin",("D"_$zcvt(loc,"L")),qqcqXLwin)'="" ess=qW.GG("qXLwin",("D"_$zcvt(loc,"L")),qqcqXLwin)
    s:ess="" ess=cod
    
    q $tr(ess,"_"," ")
]]></Implementation>
</Method>

<Method name="mapSQL">
<Description>
!!!Только для Cache.
Создание маппирющего класса для объкта qWORD.</Description>
<Internal/>
<FormalSpec>obj:%Library.String,f:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; Объекты через пробел в obj
 ; Понятия на Т не маппируются
 Q:$G(obj)=""  ;s obj="3"
 s:$G(f)="" f="mapping.cdl" ;"c:\mapping.cdl"
 o f:"nw":7
 u f

 f i=1:1 
 {
 q:$p(obj," ",i)=""
 s qqo=$p(obj," ",i)
 i $d(^Q(1,"CxObj",qqo))
 {
 w "class User.O"_qqo,!
 w "{",!

 w "sqlrowidprivate;",!
 w "super = %Library.Persistent;",!
 w "persistent = NewStorage1;",!
 w "index qqc { attributes = qqc; extent = 0; idkey; primarykey = 0; unique; }",!


 w "attribute qqc { type = %Library.String(COLLATION=""EXACT""); }",!

 i $d(^Q(1,"CxObj",qqo,"xWoc"))
 {
 f i00=1:1 
 {                        
 s nameproperties=$TR($p(^Q(1,"CxObj",qqo,"xWoc")," ",i00),"@","o")
 q:nameproperties=""
 w:$e(nameproperties)'="T" "attribute q"_nameproperties_" { type = %Library.String; }",!
 }
 }


 w "storage NewStorage1",!
 w "{",!
 w "type = %CacheSQLStorage;",!
 w "sql",!
 w "{",!
 w "map CliMaster",!
 w "{",!
 w "global = ^Q;",!
 w "structure = delimited;",!
 w "type = data;",!
 w "subscript 1 { expression = 1; }",!
 w "subscript 2 { expression = "_qqo_"; }",!
 w "subscript 3 { expression = {qqc}; }",!
 i $d(^Q(1,"CxObj",qqo,"xWoc"))
 {
 f i00=1:1 
 {
 s nameproperties=$TR($p(^Q(1,"CxObj",qqo,"xWoc")," ",i00),"@","o")
 q:nameproperties=""
 i "T"'[$e(nameproperties)
 {
 w "data q"_nameproperties,!
 w "{",!
 w "retrievalcode =",!
 w "[",!
 if "oH"[$e(nameproperties)
 { 
 W "s qqnump=1,qqo="""_qqo_""",qqc={L3},{q"_nameproperties_"}=$$GG^%ooLibrary.qWORD.1("""_$p(^Q(1,"CxObj",qqo,"xWoc")," ",i00)_""","""_qqo_""",{L3})",!
 }
 else
 {
 w "i '$d(^Q(1,"_qqo_",{L3},"""_nameproperties_"""))",! 
 w "{ s {q"_nameproperties_"}="""" q}",!

 i ($e(nameproperties)="D")!($e(nameproperties)="M")
 {
 w "s {q"_nameproperties_"}=^Q(1,"""_qqo_""",{L3},"""_nameproperties_""")",!
 }
 Else 
 {
 w "s str=""""",!
 w "f i=1:1 {",!
 w "s cod=$p(^Q(1,"""_qqo_""",{L3},"""_nameproperties_"""),"" "",i)",!
 w "q:cod=""""",!
 w "s str1=$s('$d(^Q(1,""C"_nameproperties_""",cod)):""!!!"",1:^Q(1,""C"_nameproperties_""",cod))",!
 w "s str=str_"" ""_str1",!
 w "}",!
 w "s $e(str)=""""",!
 w "s {q"_nameproperties_"}=str",!
 }
 }
 w "]",!
 w "}",!
 }
 }                               
 }                
 w "}",!
 ;Построение карты индексов
 i $d(^Q(1,"CxObj",qqo,"xWoc"))
 {          
 f i00=1:1 
 {
 s nameproperties=$p(^Q(1,"CxObj",qqo,"xWoc")," ",i00)
 q:nameproperties=""
 i "TM@"'[$E(nameproperties)
 {      
 w "map Indexq"_nameproperties,!
 w "{",!
 w "structure = delimited;",!
 w "global = ^Q;",!
 w "type = index;",!
 w "subscript 1 { expression = 1; }",!
 w "subscript 2 { expression = """_nameproperties_"""; }",!
 w "subscript 3 { expression = {q"_nameproperties_"}; }",!
 w "subscript 4 { expression = "_qqo_"; }",!
 w "subscript 5 { expression = {qqc}; }",!
 w "}",!
 }    
 }
 }


 w "}",!
 w "}",!

 w "}",! 

 }
 }


 c f
 s status=$System.OBJ.Load("mapping.cdl","c") ;"c:\mapping.cdl","c")
]]></Implementation>
</Method>

<Method name="noJrn">
<Description>
@pav Отключение-включение журнала в базе для версий Cache старше 4
jrn = 0 - выкл (умолч), = 1 - вкл.
database=$zu(12,"")
v - вывод сообщения на экран</Description>
<Internal/>
<FormalSpec>database,jrn,v</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n i,z s i=$F($ZV,")")+1,z=$E($ZV,i,$F($ZV," ",i)-2)
 q:+z<5 ""
 n myNsp,sc
 s myNsp=$zu(5)
 s:$g(database)="" database=$zu(12,"")
 s:$g(jrn)="" jrn=0
 d $zu(5,"%SYS")
 s sc=$$dbnojrn1(database,jrn)
 if $g(v) {
        if sc { d qARM.Message("Для "_database_" журналирование "_$s(jrn:"в",1:"вы")_"ключено") } 
        else { d $system.OBJ.DisplayError(sc) }
 }
 d $zu(5,$g(myNsp))
 q sc
 
dbnojrn1(database,state) ; state = 0 - выкл (умолч), = 1 - вкл.
 n db,%objlasterror s sc=0 s state=$g(state,0)
 s db=##class(SYS.Database).%OpenId(database)
 i $d(%objlasterror) q %objlasterror
 s db.GlobalJournalState=state
 i $d(%objlasterror) q %objlasterror
 q db.%Save()
]]></Implementation>
</Method>

<Method name="q4View">
<Internal/>
<FormalSpec>qqf:%Library.String,qqfadd:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 N qqw,qqwa,qqwl,qqwerr,qqwn,view,x,y,qqo,q,qq,xo,qqy,v4,qqfall
 S qqfall=$G(qqf)=""
q4ViewB I qqfall S qqf=$O(^QF(1,$G(qqf))) Q:qqf="" ""
 ;понятия
 K v4 S qqwl="",qqw="",qqwerr="" F  S qqw=$O(^QF(1,qqf,2,qqw)) Q:qqw=""  D q4Vnew(qqw,qqf)
 S qqwn=$G(^QF(1,qqf),"Фрейм "_qqf),qqwn=$ZCVT($E(qqwn),"U")_$ZCVT($E(qqwn,2,1000),"L") S:'$D(^Q(1,"CxObj","Q"_qqf)) ^Q(1,"CxObj","Q"_qqf)="q4."_qqwn,^Q(1,"xObj",^Q(1,"CxObj","Q"_qqf))="Q"_qqf
 ;список терминальных понятий
 S qqwl=$G(^QF(1,qqf,3))
 F y=1:1:$L(qqwl," ") S qqw=$P(qqwl," ",y),$P(qqwl," ",y)=$$q4Vqqw(qqw) D q4Vnew(qqw,qqf)
 S ^Q(1,"CxObj","Q"_qqf,"xWoc")=qqwl
 S ^Q(1,"CxObj","Q"_qqf,"x52")=4 ;фрейм q4
 ;список переходов (только через одно понятие?)
 S qqw1=""
 S y="" F  S y=$O(^QF(-1,y)) Q:y=""  S q=^(y) I $E(q)'=" ",q[("F="_qqf) D
 .F y=y+1:1 S q=$G(^QF(-1,y)) Q:q=""  Q:$E(q)'=" "  D
 ..I q["==" S qqw=$P($P(q,"T=",2),")"),y=y+1,q=$G(^QF(-1,y)) I q[".." S qqwn=$P($P(q,"F=",2),")"),qqw1=qqw1_" Q"_qqwn_":"_$$q4Vqqw(qqw)
 S y="" F  S y=$O(^QF(-1,y),-1) Q:y=""  S q=^(y) I $E(q)=" ",q[("F="_qqf) D
 .S y=y-1,q=$G(^QF(-1,y)) Q:q'["=="  S qqw=$P($P(q,"T=",2),")")
 .F y=y-1:-1 S q=$G(^QF(-1,y)) Q:q=""  Q:$E(q)'=" "
 .S:q'="" qqwn=$P($P(q,"F=",2),")"),qqw1=qqw1_" Q"_qqwn_":"_$$q4Vqqw(qqw)
 I qqw1'="" S ^Q(1,"CxObj","Q"_qqf,"X529")=$E(qqw1,2,30000) ;список переходов
 ;формирование отображения
 S view="###Q"_qqf
 K ^Q(1,"XView",view)
 S ^Q(1,"XView",view,"X11")="Фрейм "_qqf_"."_^QF(1,qqf),^Q(1,"XView",view,"X165")=1 ;полный вывод
 S ^Q(1,"XView",view,"X127")="-",^Q(1,"XView",view,"X128")="-" ;вызовы, печать
 S ^Q(1,"XView",view,"CxObj",-1,"Xy",1,"X60")="Q"_qqf
 S ^Q(1,"XView",view,"CxObj","Q"_qqf,"x52")=4 ;вирт. объект - фрейм q4
 K v4 S qqw="" F  S qqw=$O(^QF(1,qqf,4,1,qqw)) Q:qqw=""  S q=^(qqw),v4($A(q)-1,$A(q,2))=qqw  ;v4 - массив координат полей
 S y="",qqy=0 F y=1:1:$O(v4(""),-1) D
 .S q=$G(^QF(1,qqf,4,0,y)) I '$D(v4(y)) S qq=$ZSTRIP(q,"<>W") Q:qq=""  D q4Vyx(qqy,0,0,qq) Q:$I(qqy)
 .S qqwn=0,x="",xo=1 F  S x=$O(v4(y,x)) Q:x=""  S qqw=v4(y,x) D  S xo=x
 ..S qq=$ZSTRIP($E(q,xo,x),"<>W") I qq'="" D q4Vyx(qqy,qqwn,0,qq) I $I(qqwn)
 ..D q4Vyx(qqy,qqwn,2,$$q4Vqqw(qqw)) I $I(qqwn)
 .I $I(qqy)
 D q4Vyx(qqy,0,0,"?ВНЕ ЭКРАНА?") I $I(qqy)
 K v4 S qqw="" F  S qqw=$O(^QF(1,qqf,2,qqw)) Q:qqw=""  D
 .I $E(qqw)'="@" Q:$D(^QF(1,qqf,4,1,qqw))  Q:$D(v4(qqw))  S v4(qqw)="" D q4Vnew(qqw,qqf),q4Vyx(qqy,0,0,"@"_$$q4Vqqw(qqw)),q4Vyx(qqy,1,2,$$q4Vqqw(qqw)) Q:$I(qqy)
 .I '$D(^QF(1,qqf,4,1,qqw)),$D(v4(qqw))  S v4(qqw)="" D q4Vnew(qqw,qqf),q4Vyx(qqy,0,0,"@"_$$q4Vqqw(qqw)),q4Vyx(qqy,1,2,$$q4Vqqw(qqw)) I $I(qqy)
 .;подчиненные обобщению понятия
 .S qqwn="" F  S qqwn=$O(^QF(1,qqf,2,qqw,qqwn)) Q:qqwn=""  D
 ..Q:$D(^QF(1,qqf,4,1,qqwn))  Q:$D(v4(qqwn))  S v4(qqwn)="" D q4Vnew(qqwn,qqf),q4Vyx(qqy,0,0,"--> "_$$q4Vqqw(qqw)),q4Vyx(qqy,1,0,"@"_$$q4Vqqw(qqwn)),q4Vyx(qqy,2,2,$$q4Vqqw(qqwn)) I $I(qqy)
 ;список добавляемых из другого фрейма понятий
 D:$G(qqfadd)'=""
 .D q4Vyx(qqy,0,0,"?ДОБАВЛЕНЫ ИЗ ФРЕЙМА "_qqfadd) I $I(qqy)
 .S qqw="",qqwadd="" F  S qqw=$O(^QF(1,qqfadd,2,qqw)) Q:qqw=""  D:'$D(^QF(1,qqf,2,qqw))
 ..S qqwn=$$q4Vqqw(qqw) D q4Vnew(qqw,qqfadd)
 ..S:$E(qqwn)'="@" qqwadd=qqwadd_" "_qqwn
 ..D q4Vyx(qqy,1,0,"@"_qqwn),q4Vyx(qqy,2,2,qqwn) I $I(qqy)
 .I qqwadd'="" S ^Q(1,"CxObj","Q"_qqf,"xWoc")=$G(^Q(1,"CxObj","Q"_qqf,"xWoc"))_qqwadd
 I qqfall G q4ViewB
 Q qqwerr
q4Vqqw(qqw) ;новый код понятия 
 Q $S($E(qqw)="@":"@XH"_$E(qqw,2,20),"ACTDMFXYLxZRH"[$E(qqw):"q4"_qqw,1:qqw) ;вычисляемые обобщения или код совпал со спец.понятиями
q4Vqqwo(q)  ;обработка вычисляемых обобщений
 N j,qw F  S j=$F(q,"$$G(") Q:'j  D
 .I $E(q,j)="""" S qw=$P($E(q,j,30000),"""",2),$E(q,j,j+1+$L(qw))=""""_$$q4Vqqw(qw)_""""
 .S $E(q,j-4,j-1)="qW.G("
 ;I q["$$" S q=";;"_q ;блокировка выполнения
 Q q
q4Vyx(y,x,typ,val)  ;заполнение ячейки
 S ^Q(1,"XView",view,"CxObj","Q"_qqf,"Xy",y,"Xx",x,"x70")=typ
 S ^Q(1,"XView",view,"CxObj","Q"_qqf,"Xy",y,"Xx",x,"X71")=val
 Q
q4Vnew(qqw,qqf) ;новое понятие
 N qqwa,qqwn S qqwa=^QW(1,qqw),qqwn=$$q4Vqqw(qqw)
 I '$D(^Q(1,"CxWoc",qqwn)) D  ;есть понятие
 .S qqwa=$ZCVT($E(qqwa),"U")_$ZCVT($E(qqwa,2,1000),"L") S:$D(^Q(1,"xWoc",qqwa)) qqwa="q4."_qqwa
 .S ^Q(1,"CxWoc",qqwn)=qqwa,^Q(1,"xWoc",qqwa)=qqwn
 I $E(qqwn)="@" S ^Q(1,"CxWoc",qqwn,"XRef")=$$q4Vqqwo($G(^QF(1,qqf,3,qqw)))
 I $E(qqwn)'="@"," "_$ZCVT(qqwa,"U")_" "[" ДАТА " S ^Q(1,"CxWoc",qqwn,"x710")=1 ;тип ДАТА
 Q
]]></Implementation>
</Method>

<Method name="q4imp">
<Description>
Создание объекта Q_qqf из фрейма qqf qWORD4.
Создается CxObj. В CxWoc создаются понятия, входящие в объект.
Возвращается список не перенесенных понятий (уже имеющихся в CxWoc).</Description>
<Internal/>
<FormalSpec>qqf:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qqw,qqwa,qqwl,qqwerr,qqwn
 S qqwl="",qqwa="",qqwerr="" F  S qqwa=$O(^QW(0,qqwa)) Q:qqwa=""  D:$D(^QW(0,qqwa,qqf))
 .S qqw=^QW(0,qqwa) I "ACTDMFXYLxZRH"[$E(qqw) S qqw="q4"_qqw ;код совпал со спец.понятиями
 .S:$E(qqw)'="@" qqwl=qqwl_" "_qqw
 .I $D(^Q(1,"CxWoc",qqw)) S qqwerr=qqwerr_" "_qqw Q  ;есть понятие
 .S qqwn=$ZCVT($E(qqwa),"U")_$ZCVT($E(qqwa,2,1000),"L") S:$D(^Q(1,"xWoc",qqwa)) qqwn="q4."_qqwa
 .S ^Q(1,"CxWoc",qqw)=qqwn,^Q(1,"xWoc",qqwn)=qqw
 S qqwn=$G(^QF(1,qqf),"Фрейм "_qqf),qqwn=$ZCVT($E(qqwn),"U")_$ZCVT($E(qqwn,2,1000),"L"),^Q(1,"CxObj","Q"_qqf)="q4."_qqwn,^Q(1,"xObj",^Q(1,"CxObj","Q"_qqf))="Q"_qqf
 S ^Q(1,"CxObj","Q"_qqf,"xWoc")=$E(qqwl,2,32000) ;,^("x52")=4
 Q:$Q qqwerr Q
]]></Implementation>
</Method>

<Method name="qmView">
<Internal/>
<FormalSpec>qqf:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqw,qqwa,qqwl,qqwerr,qqwn,view,x,y,qqo,q,qq,xo,qqy,v4,qqfall,qqfc,qqfn,qqwc,qqwcol
 S qqfall=$G(qqf)=""
qmViewB I qqfall S qqf=$O(^mdd(1,$G(qqf))) Q:qqf=""  Q:qqf'?.N
 ;Объект
 S qqwn=$G(^mdd(1,qqf,1)),qqwn=$P(qqwn,$C(1),2),qqfc=$TR($P($P($P(qqwn,"(",2),")"),",")," "),qqfn=$TR($ZSTRIP($P(qqwn,"("),"<>W")," ","_") S:'$D(^Q(1,"CxObj","m"_qqfc)) ^Q(1,"CxObj","m"_qqfc)="qm."_qqfn,^Q(1,"xObj",^Q(1,"CxObj","m"_qqfc))="m"_qqfc
 ;формирование отображения
 S view="###m"_qqfc
 K ^Q(1,"XView",view)
 S ^Q(1,"XView",view,"X11")="Таблица "_qqfc_"."_qqfn,^Q(1,"XView",view,"X165")=1 ;полный вывод
 S ^Q(1,"XView",view,"X127")="-",^Q(1,"XView",view,"X128")="-" ;вызовы, печать
 S ^Q(1,"XView",view,"CxObj",-1,"Xy",1,"X60")="m"_qqfc
 S ^Q(1,"XView",view,"CxObj","m"_qqfc,"x52")=5 ;вирт. объект - mt
 D qmVyx(0,0,0,"@")
 ;понятия
 K v4 S qqwl="",qqwc="",qqwerr="" F qqy=1:1 S qqwc=$O(^mdd(1,qqf,2,qqwc)) Q:qqwc=""  D
 .S qqwa=^mdd(1,qqf,2,qqwc,1),qqwcol=$P(qqwa,$C(1),3),qqw=$$qmVqqw($P($P(qqwa,$C(1)),"_",2,255)),qqwa=$P(qqwa,$C(1),2),qqwa=$TR($S($P(qqwa," ")=qqfc:$P(qqwa," ",2,255),1:qqwa)," ","_")
 .I '$D(^Q(1,"CxWoc",qqw)) D  ;есть понятие
 ..S:$D(^Q(1,"xWoc",qqwa)) qqwa="qm."_qqwa
 ..S ^Q(1,"CxWoc",qqw)=qqwa,^Q(1,"xWoc",qqwa)=qqw
 .S qqwl=qqwl_" "_qqw
 .D qmVyx(qqy,0,0,"@"_qqw),qmVyx(qqy,1,2,qqw)
 .S ^Q(1,"XView",view,"CxObj","m"_qqfc,"Xy",qqy,"Xx",1,"X79")=qqwcol ;маппирование
 ;список терминальных понятий
 ;S qqwl=$G(^QF(1,qqf,3))
 ;F y=1:1:$L(qqwl," ") S qqw=$P(qqwl," ",y),$P(qqwl," ",y)=$$qmVqqw(qqw) D qmVnew(qqw,qqf)
 S ^Q(1,"CxObj","m"_qqfc,"xWoc")=$E(qqwl,2,30000)
 S ^Q(1,"CxObj","m"_qqfc,"x52")=5 ;таблица mt
 ;список переходов (только через одно понятие?)
 ;I qqw1'="" S ^Q(1,"CxObj","Q"_qqf,"X529")=$E(qqw1,2,30000) ;список переходов
 I qqfall G qmViewB
 Q:$Q qqwerr Q
qmVqqw(qqw) ;новый код понятия 
 Q "m"_qqw
 Q $S($E(qqw)="@":"@XH"_$E(qqw,2,20),"ACTDMFXYLxZRH"[$E(qqw):"q4"_qqw,1:qqw) ;вычисляемые обобщения или код совпал со спец.понятиями
qmVqqwo(q)  ;обработка вычисляемых обобщений
 N j,qw F  S j=$F(q,"$$G(") Q:'j  D
 .I $E(q,j)="""" S qw=$P($E(q,j,30000),"""",2),$E(q,j,j+1+$L(qw))=""""_$$qmVqqw(qw)_""""
 .S $E(q,j-4,j-1)="qW.G("
 ;I q["$$" S q=";;"_q ;блокировка выполнения
 Q q
qmVyx(y,x,typ,val)  ;заполнение ячейки
 S ^Q(1,"XView",view,"CxObj","m"_qqfc,"Xy",y,"Xx",x,"x70")=typ
 S ^Q(1,"XView",view,"CxObj","m"_qqfc,"Xy",y,"Xx",x,"X71")=val
 Q
qmVnew(qqw,qqf) ;новое понятие
 N qqwa,qqwn,qqwcol S qqwa=^mdd(1,qqf,2,qqw,1),qqwcol=$P(qqwa,$C(1),3),qqwn=$$qmVqqw($P($P(qqwa,$C(1)),"_",2,255)),qqwa=$TR($P($P(qqwa,$C(1),2)," ",2,255)," ","_")
 I '$D(^Q(1,"CxWoc",qqwn)) D  ;есть понятие
 .S:$D(^Q(1,"xWoc",qqwa)) qqwa="qm."_qqwa
 .S ^Q(1,"CxWoc",qqwn)=qqwa,^Q(1,"xWoc",qqwa)=qqwn
 ;I $E(qqwn)="@" S ^Q(1,"CxWoc",qqwn,"XRef")=$$qmVqqwo($G(^QF(1,qqf,3,qqw)))
 ;I $E(qqwn)'="@"," "_$ZCVT(qqwa,"U")_" "[" ДАТА " S ^Q(1,"CxWoc",qqwn,"x710")=1 ;тип ДАТА
 Q qqwn
]]></Implementation>
</Method>

<Method name="qqlang">
<Description>
ввод альтернативного словаря в правиле проверки для системного отображения вывода словаря</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Obj:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ Q:Z="" "???" S ^Q(Arg1,Obj,qqc)=Z,^Q(Arg1,$E(Obj,2,30),Z)=qqc Q ""
]]></Implementation>
</Method>

<Method name="qqnumpT">
<Description>
возвращает qqnump связанного (не текущего) окна (когда в закладке вызывается несколько окон)
Arg1 - код отображения желаемого окна (не указан - первое не текущее)
Tabs - код группы закладок (по умолчанию - 0)</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Tabs:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqnumpT,qqnumpt S:$G(Tabs)="" Tabs=0 S qqnumpT=$G(qwin(qwin,"child")) Q:qqnumpT="" 999 S qqnumpt=Vs(qqnumpT,"Tabs",Tabs,Vs(qqnumpT,"Tabs",Tabs),0) I $G(Arg1)'="" N qqnumpV S qqnumpV=Vs(qqnumpT,"Tabs",Tabs,Vs(qqnumpT,"Tabs",Tabs),7) ;список окон текущей закладки (и отображений)
 F qqnumpT=1:1:$L(qqnumpt," ") I $P(qqnumpt," ",qqnumpT)'=qqnump Q:$G(Arg1)=""  Q:Arg1=$P(qqnumpV," ",qqnumpT)
 Q $P(qqnumpt," ",qqnumpT)  ;окно вывода
]]></Implementation>
</Method>

<Method name="savedat">
<Description>
Создание файла обновлений.

Если задан только fname, то используются сохраненные в XUpg описания с кодом обновления fname

del - список глобалов через запятую, которые нужно удалить после формирования файла. 
del=1 - все сохраянемы глобалы+^upqview  и ^afteres</Description>
<Internal/>
<FormalSpec>fname:%Library.String,bef:%Library.String,aft:%Library.String,sys:%Library.String,globlist:%Library.String,del:%Library.String="",namesysfiles:%Library.String,flagsysfiles:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$D(bef),'$D(aft),'$D(sys),'$D(globlist),'$D(flagsysfiles) D  ;@dol 4.12.03 взять сохраненное описание (отображение XXXUpg)
 .X:qW.GG("XUpg","XRef2",fname)'="" qW.GG("XUpg","XRef2",fname)
 .S bef=qW.GG("XUpg","XUDoBeg",fname),aft=qW.GG("XUpg","XUDoEnd",fname),sys=qW.GG("XUpg","Xsys",fname),globlist=qW.GG("XUpg","XRef4",fname),fname=qW.GG("XUpg","XRes",fname),namesysfiles=qW.GG("XUpg","Xsysfiles",fname),flagsysfiles=qW.GG("XUpg","XGMsysfiles",fname)
 .I globlist'="" N qq,i F i=1:1:$L(globlist,",") S qq=$P(globlist,",",i) I qq'["[" S $P(globlist,",",i)=qq_"["_$TR($P(qARM("CntStr"),":",2,4),"[:]","**")_"]"
 i fname="" d qARM.Message("Не задано имя файла!") Q:$Q "" Q

 k ^upqview,^afteres
 n conect,%1,i,glob,rconect, delList,exec,err,classL,file
 s file=$tr(fname," ","*")
 s %1=$tr($p(qARM("CntStr"),":",2),"[","*"),conect=$e(%1,1,$l(%1)-1)_"*"_$p(qARM("CntStr"),":",3) //%1 - параметры соединения
 s ^afteres(0)=$g(bef),^afteres(1)=$g(aft)  // действия перед и после восстановления глобалов

 //системные файлы
 //правка sasha 20080324
 d sysfilesold
 
 // список через запятую глобалов, которые нужно удалить после формирования файла : del=1 - все глобалы, которые сохраняли; del=список глобалов - указанные в del глобалы; кроме того удаляем ^afteres
 s delList(0)=$s($g(del)=1:$g(globlist),$l($g(del))>1:del,1:"") s delList(0)=delList(0)_$s(delList(0)'="":",",1:"")_"^afteres"  
 s:sys=1 delList(0)=delList(0)_",^upqview" // если сохраняются системные описания, то после формирования файла удаляеся и ^upqview
 //delList(1) - список через запятую глобалов, которые нужно удалить в текущей области; delList(2) - список через запятую глобалов из других областей: глобал[server*port*namеspase]
 n str s (str,glob)="" f i=1:1:$l(delList(0),",") d
 .s str=$p(delList(0),",",i) s:$f(str,"[")=0 delList(1)=$g(delList(1))_","_str s:$f(str,"[")>0 delList(2)=$g(delList(2))_","_str
 s exec="k "_$e(delList(1),2,$l(delList(1)))
 //если сохраняются системные описания
 i sys=1 d
 .s ^afteres(0)=^afteres(0)_" k ^%QView"
 //сохраняется в файл глобал с действиями перед и после восстановления
 //правка sas 20081212
 i ($g(flagsysfiles)'=1)!($g(namesysfiles)="") d qARM.wM("-qARM","ModalExec","""GManager.exe"" -C -S -D -F"_file_" -T"_conect_" -A^afteres -H -t"_(''$F($ZV,"GT.M")))
 e  d qARM.wM("-qARM","ModalExec","""GManager.exe"" -C -S -F"_file_" -T"_conect_" -A^afteres -H -t"_(''$F($ZV,"GT.M")))
 //Если сохраняются системные описания, то сохраняем в файл глобал ^%QView, в переменную classL "%TqARM,%qWORD,%qSYS,%qWEB,%qARM" - список сохраняемых классов
 if sys=1 m ^upqview=^|"%SYS"|%QView d qARM.wM("-qARM","ModalExec","""GManager.exe"" -C -S -F"_file_" -T"_conect_" -G^%QView -H -t"_(''$F($ZV,"GT.M"))) s classL="%TqARM,%qWORD,%qSYS,%qWEB,%qARM,%qPrint"
 //сохраняются в файл глобал из списка globlist
 s i=1,globlist=$tr(globlist," ","")
 f i=1:1:$l(globlist,",") d
 .s glob=$p(globlist,",",i)
 .s rconect=$p(glob,"[",2) s:rconect'="" rconect=$e(rconect,1,$l(rconect)-1),glob=$e(glob,1,$f(glob,"[")-2)
 .d qARM.wM("-qARM","ModalExec","""GManager.exe"" -C -S -F"_file_" -T"_$s(rconect="":conect,1:rconect)_" -G"_glob_" -H -t"_(''$F($ZV,"GT.M")))
 .//если выгружается ^QUser (он НЕ ДОЛЖЕН содержать узла  ^QUser("User.qUSER")), то отдельно сохраняется класс User.qUSER - в список сохраняемых классов classL добавляется qUSER
 .Q:glob'="^QUser"  S:'$D(^QUser("User.qUSER")) classL=$g(classL)_$s($g(classL)'="":",",1:"")_"qUSER"
 .;@Dol 3.07.05 остальные пользовательские классы
 .N qclass S qclass="" F  S qclass=$O(^Q(1,"XUClass",qclass)) Q:qclass=""  D:qclass'="qUSER"
 ..S:'$D(^QUser("User."_qclass)) classL=$g(classL)_$s($g(classL)'="":",",1:"")_$G(^Q(1,"XUClass",qclass))
 d:$g(classL)'="" qARM.wM("-qARM","ModalExec","""GManager.exe"" -C -S -F"_file_" -T"_conect_" -K"_classL_" -H -t"_(''$F($ZV,"GT.M")))


 //Удалене глобалов
 d:exec'="" qARM.Wait(exec)   // удаление глобалов из текуей области
 //в цикле удаление глобалов по списку из delList(2) - в других областях
 f i=1:1:$l($g(delList(2)),",") s glob=$p($g(delList(2)),",",i) d:glob'=""
 .//для этого формируем временный файл, содержащий только глобал с действиями перед восстановлением, в действии - удаление нужного глобала
 .s rconect=$p(glob,"[",2) s:rconect'="" rconect=$e(rconect,1,$l(rconect)-1),glob=$e(glob,1,$f(glob,"[")-2) 
 .s ^|$p(rconect,"*",3)|a(0)="k ^|"""_$p(rconect,"*",3)_"""|a,^|"""_$p(rconect,"*",3)_"""|"_$e(glob,2,$l(glob)),file=qARM("ClientPath")_"tmpforKILL.dat"
 .d qARM.wM("-qARM","ModalExec","""GManager.exe"" -C -D -S -F"_$tr(file," ","*")_" -T"_rconect_" -A^a -H -t"_(''$F($ZV,"GT.M")))
 .//восстаналвиваем в соответствующей области временный файл - сответсвенно выполняется действие перед восстановлением.
 .d qARM.wM("-qARM","ModalExec","""GManager.exe"" -C -R -X -F"_$tr(file," ","*")_" -T"_rconect_" -H -t"_(''$F($ZV,"GT.M")))
 Q:$Q "" Q

sysfilesold
 q:$g(flagsysfiles)'=1
 ///sas 20081212
 i $g(namesysfiles)="" s globlist=$S($G(globlist)'="":globlist_",",1:"")_"^%qFiles" q
 ///q:$g(namesysfiles)=""
 n i,globalL
 k ^%qFiles
 f i=1:1:$L(namesysfiles,"*") d
 .D qARM.wM("-qARM","ReadDirTree","","^%qFiles",""_$P(namesysfiles,"*",i)_"",0,0)
 s globalL=$S($G(globalL)'="":globalL_",",1:"")_"^%qFiles"
 s ^afteres(0)=$S($ZCVT($E(^afteres(0)),"U")="K":"k ^%qFiles,"_$E(^afteres(0),3,$L(^afteres(0))),1:"k ^%qFiles "_^afteres(0))
 d qARM.wM("-qARM","ModalExec","""GManager.exe"" -C -S -F"_file_" -T"_conect_" -G^%QView -H -t"_(''$F($ZV,"GT.M")))
 d qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -C -S -D -F"_fname_" -H "_$S($G(globalL)'="":"-G"_$G(globalL)_" ",1:"")_"-A^afteres "_$S($g(classL)'="":" -K"_classL,1:"")_$S($G(visible)="":"",1:" -h"))
]]></Implementation>
</Method>

<Method name="savedatnew">
<Description>
новое сохранение
если только file, то это код обновления</Description>
<Internal/>
<FormalSpec>file:%Library.String,globals:%Library.String,classes:%Library.String,classsys:%Library.String,sys:%Library.String,classuser:%Library.String,user:%Library.String,userop:%Library.String,bef:%Library.String,aft:%Library.String,closeaction:%Library.String,visible:%Library.String,namesysfiles:%Library.String,flagsysfiles:%Library.String,flagsysfilesnoq:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 l +^afteres
 I '$D(bef),'$D(aft),'$D(classsys),'$D(sys),'$D(classuser),'$D(user),'$D(globals),'$D(classes),'$D(closeaction),'$D(flagsysfiles) D  ;(отображение XXXGM)
 .X:qW.GG("XGM","XRef1",file)'="" qW.GG("XGM","XRef1",file)
 .S globals=qW.GG("XGM","XGMglobals",file),classes=qW.GG("XGM","XGMclasses",file),classsys=qW.GG("XGM","XGMclasssys",file),sys=qW.GG("XGM","XGMsys",file),classuser=qW.GG("XGM","XGMclassuser",file),user=qW.GG("XGM","XGMuser",file),userop=qW.GG("XGM","XGMclassuserop",file),bef=qW.GG("XGM","XGMbef",file),aft=qW.GG("XGM","XGMaft",file),closeaction=qW.GG("XGM","XRef2",file),visible=qW.GG("XGM","XRef3",file),namesysfiles=qW.GG("XGM","Xsysfiles",file),flagsysfiles=qW.GG("XGM","XGMsysfiles",file),flagsysfilesnoq=qW.GG("XGM","XGMsysfilesnoq",file),file=qW.GG("XGM","XGMfile",file)
 
 
 i file="" d qARM.Message("Не задано имя файла!") l -^afteres Q:$Q "" Q
 k ^afteres,afteres
 
 s file=$tr(file," ","*")
 //преддействие
 s afteres(0)=$g(bef)
 //постдействие
 ;@pav 17.11.2010
 i $G(classsys)=1 n dosys s dosys="K ^Q(1,""XSClass"") M ^Q(1,""XSClass"")=^%QView(""XSClass"") "
 s afteres(1)=$S(($g(aft)'="")!$G(user)=1:"S qARM(""Password"")=""XXXX drowq"",qARM(""Pars"",9)=""S qqend=1"" "_$g(dosys)_"s qa=##class(%TqARM).%New() d qa.Create() S qqnump=0",1:"")_$S($G(userop)=1:" M ^Q(1)=^QUser(1)",1:"")_$S($G(user)=1:" D qSYS.QUser(,,1),qARM.UserClass()",1:"")_$S($g(aft)'="":" "_$g(aft),1:"")
 ;s afteres(1)=$S(($g(aft)'="")!$G(user)=1:"S qARM(""Password"")=""XXXX drowq"",qARM(""Pars"",9)=""S qqend=1"" s qa=##class(%TqARM).%New() d qa.Create() S qqnump=0",1:"")_$S($G(userop)=1:" M ^Q(1)=^QUser(1)",1:"")_$S($G(user)=1:" D qSYS.QUser(,,1),qARM.UserClass()",1:"")_$S($g(aft)'="":" "_$g(aft),1:"")
 s:0 afteres(1)=$g(aft)
 n exec,classL,globalL
 //системные файлы
 d sysfiles
 
 //удаляем ^afteres 
 s exec="k ^afteres"
 
 //флаг сохранения системных классов
 ;i $G(classsys)=1 s classL="%TqARM,%qWORD,%qSYS,%qWEB,%qARM"
 ;@pav 17.11.2010
 i $G(classsys)=1 {
	 n id s id=""
	 f  {
		s id=$o(^Q(1,"XSClass",id))
		q:id=""
		s classL=$g(classL)_","_^Q(1,"XSClass",id)
	}
	s $e(classL)=""
 }
 //если указаны сохраняемые классы
 i $G(classes)'="" s classL=$S($G(classL)'="":classL_",",1:"")_classes
 //флаг сохранения пользовательских классов
 n quserc //переменная для проверки наличия класса quser
 i $G(classuser)=1 d 
 .N qclass S qclass="" F  S qclass=$O(^Q(1,"XUClass",qclass)) Q:qclass=""  s:..FindClass(^Q(1,"XUClass",qclass)) classL=$S($G(classL)'="":classL_",",1:"")_^Q(1,"XUClass",qclass) s:^Q(1,"XUClass",qclass)="qUSER" quserc=1   
 .i $G(quserc)=1 q
 .s classL=$S($G(classL)'="":classL_",",1:"")_"qUSER"
 //сохранять глобалы и системные описания
 i $G(sys)=1 d
 .s afteres(0)=$S($ZCVT($E(afteres(0)),"U")="K":"k ^%QView,"_$E(afteres(0),3,$L(afteres(0))),1:"k ^%QView "_afteres(0))
 .//s afteres(0)="k ^%QView "_afteres(0)
 .//^%QView выгружается только из глобала ^Q
 .d qSYS.QView(1)
 .s globalL=$S($G(globalL)'="":globalL_",",1:"")_"^%QView"
 //сохранить глобалы
 i $G(globals)'="" d
 .s globalL=$S($G(globalL)'="":globalL_",",1:"")_globals
 //сохранить глобалы и пользовательские описания
 n globalsus,globalsus1
 i $G(user)=1 d
 .s afteres(0)=$S($ZCVT($E(afteres(0)),"U")="K":"k ^QUser,"_$E(afteres(0),3,$L(afteres(0))),1:"k ^QUser "_afteres(0)) d qSYS.QUser(1,,1) s globalL=$S($G(globalL)'="":globalL_",",1:"")_"^QUser"
 m ^afteres=afteres
 
 ;20100405 @sas+dima par3 в ModalExec: действие после GManager
 d qARM.wM("-qARM","ModalExec","""GManager.exe"" -S"_qARM("SectionIni")_" -C -S -D -F"_file_" -H "_$S($G(globalL)'="":"-G"_$G(globalL)_" ",1:"")_"-A^afteres "_$S($g(classL)'="":" -K"_classL,1:"")_$S($G(visible)=1:" -h",1:""),"",$G(closeaction))
 //d:$G(closeaction)'="" qARM.wM("-qARM","Xecute",closeaction) так делать нельзя
 d qARM.wM("-qARM","Xecute","l -^afteres")

 Q:$Q "" Q

sysfiles
 q:$g(flagsysfiles)'=1
 
 //sasha 20080606 не задавать вопроса при восстановлении файлов системы, 
 //если не установлены флаги в qARM.ini
 
 i $G(flagsysfilesnoq)=1 s afteres(1)="s ^mtempupdflag=1 "_afteres(1) 
 
 i $g(namesysfiles)="" s globalL=$S($G(globalL)'="":globalL_",",1:"")_"^%qFiles" q
 n i
 ;sas 20090408 - теперь при загрузке из файлов K не делается
 ;глобал теперь K сами
 ;k ^%qFiles 
 f i=1:1:$L(namesysfiles,"*") d
 .D qARM.wM("-qARM","ReadDirTree","","^%qFiles",""_$P(namesysfiles,"*",i)_"",0,0)
 s globalL=$S($G(globalL)'="":globalL_",",1:"")_"^%qFiles"
 s afteres(0)=$S($ZCVT($E(afteres(0)),"U")="K":"k ^%qFiles,"_$E(afteres(0),3,$L(afteres(0))),1:"k ^%qFiles "_afteres(0))
 q
]]></Implementation>
</Method>

<Method name="savedatnew0">
<Description>
создание обновлений системы при помощи GManager sas 20090401</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 n XGMglobals,Xsysfiles,GqFiles
 X:qW.G("XRef1")'="" qW.G("XRef1")
 s XGMglobals=qW.G("XGMglobals")
 s:0 Xsysfiles=qW.G("Xsysfiles")_$$fromFiles()
 s Xsysfiles=$$fromFiles()  
 s GqFiles=$$forqFiles()
 s XGMglobals=qW.G("XGMglobals")_$S(qW.G("XGMglobals")'="":","_GqFiles,1:GqFiles) 
 d qSYS.savedatnew(qW.G("XGMfile"),XGMglobals,qW.G("XGMclasses"),qW.G("XGMclasssys"),qW.G("XGMsys"),qW.G("XGMclassuser"),qW.G("XGMuser"),qW.G("XGMclassuserop"),$S(GqFiles'="":"k "_GqFiles_$S($ZCVT($E(qW.G("XGMbef")),"U")="K":",",1:" "),1:"")_$S((GqFiles'="")&&($ZCVT($E(qW.G("XGMbef")),"U")="K"):$E(qW.G("XGMbef"),3,$L(qW.G("XGMbef"))),1:qW.G("XGMbef")),qW.G("XGMaft"),qW.G("XRef2"),qW.G("XRef3"),Xsysfiles,$S(Xsysfiles'="":1,1:0)) 
 q
fromFiles()
 n qqcGM1,files
 s (qqcGM1,files)="" f  s qqcGM1=$O(^Q(1,"XGM1",qqcGM1)) q:qqcGM1=""  i +$G(^Q(1,"XGM1",qqcGM1,"flag"))=1 i qqc=$E(qqcGM1,1,$L(qqc)) s files=files_$S($G(^Q(1,"XGM1",qqcGM1,"sysfiles"))'="":$S(files'="":"*",1:"")_$G(^Q(1,"XGM1",qqcGM1,"sysfiles")),1:"")
 s:qW.G("Xsysfiles")="" files=$ZSTRIP(files,"<>","*")
 q files
forqFiles()
 i Xsysfiles'="" q ""
 n qqcGM1,file,files
 s (qqcGM1,files)="" f  s qqcGM1=$O(^Q(1,"XGM1",qqcGM1)) q:qqcGM1=""  i +$G(^Q(1,"XGM1",qqcGM1,"flag1"))=1 i qqc=$E(qqcGM1,1,$L(qqc)) g:$G(^Q(1,"XGM1",qqcGM1,"sysfiles"))["*" stringfiles s file=$ZCVT("F~"_$P($G(^Q(1,"XGM1",qqcGM1,"sysfiles")),"\",$L($G(^Q(1,"XGM1",qqcGM1,"sysfiles")),"\")),"U") d forqFiles1 
 s files=$ZSTRIP(files,"<>",",")
 q files
forqFiles1 
 n qqcq
 i file="F~" q
 s files=files_$S($G(^%qFiles(file))'="":",^%qFiles("""_file_""")",1:"")
 q
stringfiles
 //@sas 20101229
 n list,str
 s str=$G(^Q(1,"XGM1",qqcGM1,"sysfiles"))
 f list=1:1:$L(str,"*") d
 .s file=$ZCVT("F~"_$P($P(str,"*",list),"\",$L($P(str,"*",list),"\")),"U") 
 .d forqFiles1
 s files=$ZSTRIP(files,"<>",",")
 q files
]]></Implementation>
</Method>

<Method name="slip">
<Description>
НАДО ПЕРЕДЕЛАТЬ {}
Сдвиг кода для дерева с вершиной Arg1.</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n qqcold,qqcnew,codstart,codend,tree,kk,qqotree,lqqotree,qqo   
 s qqo=Arg1                               ;Объект копирования

 s codstart=$g(^Q(1,"CxObj",qqo,"X536")),codend=$g(^Q(1,"CxObj",qqo,"X537"))
 S:$E(codstart)="@" @("codstart="_$E(codstart,2,30000)) S:$E(codend)="@" @("codend="_$E(codend,2,30000)) ;@dol 27.04.03
 i codstart="" d qARM.Message("Не задан 'Новый код. Начало.'")
 i codend="" d qARM.Message("Не задан 'Новый код. Колнец.")
 q:codstart=""!codend=""

 s tree=$g(^Q(1,"CxObj",qqo,"XORef"))               //путь от вершины до объекта
 //Проверка на наличие экземпляров вершины
 i tree'="" { 
 f kk=1:1:($l(tree,",")-1)
 {
 s qqotree=$p(tree,",",kk)
 s lqqotree=$g(^Q(1,"CxObj",qqotree,"X50"))
 i '$D(^Q(1,qqotree,$e(codstart,1,lqqotree))) d qW.rNew(qqotree,$e(codstart,1,lqqotree))  //если нет экземпляра вершины то создать
 }
 }

 ///Обход объекта qqo
 s qqcold=""
 f       {
starttour 
 s qqcold=$$$UserOrd(1,qqo,qqcold,"")
 q:qqcold=""
 i $e(qqcold,1,$l(codstart))=codstart g starttour    //если уже есть код, лежащий в необходимом диапазоне, то пропускаем его
 //копирование  
 s qqcnew=$p(qW.rNew(qqo,codstart)," ")
 d qW.rCopyTree(qqo,qqcnew,,qqcold,,1)
 }
 q
]]></Implementation>
</Method>

<Method name="syn">
<Description>
Синтаксическая проверка строки (val) команд или выражения (v=1).
Возвращает сообщение об ошибке или пусто, если все нормально.</Description>
<Internal/>
<FormalSpec>val:%Library.String,v:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 Q:$ZV["GT.M" "" I $E(val)?1N Q ""
 I $G(v),$E(val)="=" S val=$E(val,2,30000) ;@Dol 1/07/06 для макроподстановок в значениях по умолчанию и правилах проверки (см. qARM.GetPar)
 I '$G(v),$E(val)="@" S v=1 ;косвенное действие как выражение
 S val=$S('$G(v):$ZU(62,1,val),1:$ZU(62,1,"I "_val)) ;$S($E(val)="@":$E(val,2,30000),1:val)))
 Q $S(val="":"",1:"Ошибка в позиции "_val)
]]></Implementation>
</Method>

<Method name="sysR74">
<Description>
Правило проверки для ввода новых значений в развертку.
Используется в отображении sysR. См. метод sysView.</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 Q:Z="" "" K W(qqw) D qARM.wwww(qqw)
 N qqo,qqw S qqo=Vo(qqnump,-1,0,2),qqw=$E(Vo(qqnump,qqo,0,0,0),2,255)
 I qqw="C" Q:$E(qqo)="C" "???" S qqw=qqo,W(qqw)=Z S qqc=W(qqw) Q:+Vo(qqnump,-1,72)=3&('W("Zadm")) -1 D qW.rWoc(1) D qARM.wcre() Q 0
 S W(qqw)=Z I qW.Key(qqo,qqw,"")'="" Q "Значение существует"
 S qqc=Vc(qqnump,"AA") ;@dol 18.03.03 иначе портился словарь ww
 S qqc=$P(qW.rNew(qqo,qqc)," ") D qW.rCor(qqo,qqc,qqw) Q:+Vo(qqnump,-1,72)=3&('W("Zadm")) -1 D qARM.wcre() D:+Vo(qqnump,-1,72)=4 qARM.RecRel("+") Q 0
]]></Implementation>
</Method>

<Method name="sysView">
<Description>
генерация системных отображений.
qqv - имя отображения (sys...).</Description>
<Internal/>
<FormalSpec>qqv:%String,qqpar2:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 G @("gen"_qqv)
 ;Vo(qqnump)=код_отображение ;везде упущено
gensysU D qUSER.sysView(qqpar2),..CreVoAdd() Q:$Q "" Q
gensysA ;отображение вывода текущей аналитики
 D ..CreAr() Q:$Q "" Q
gensysY ;@Dol 13.04.11 отображение вывода приемник-печать
 D ..CreArY() Q:$Q "" Q
gensysT ;Вызов поддерева объекта в виде таблицы
 S $$$Tree=0
 S Vo(qqnump,-1)="Таблица поддерева объекта "_qW.GetWoc("CxObj",qqpar2)
 S Vo(qqnump,-1,0,1)=qqpar2
 D ..CreObj(qqpar2,1,,1,0) D ..CreVoAdd() Q:$Q "" Q
gensysB ;Вызов поддерева объекта в виде бланка
 S $$$Tree=0
 S Vo(qqnump,-1)="Бланк поддерева объекта "_qW.GetWoc("CxObj",qqpar2)
 S Vo(qqnump,-1,0,1)=qqpar2
 D ..CreObj(qqpar2,0,,1,0) D ..CreVoAdd() Q:$Q "" Q
gensysL ;Отображение диалогового ввода параметров запроса
 D ..CresysL() Q:$Q "" Q
gensysQ ;отображение для создания формы ввода значений для списка понятий
 S Vo(qqnump,-1)="-Ввод параметров"
 S Vo(qqnump,-1,61)=1 ;отсутствие сетки
 S Vo(qqnump,-1,62)=1 ;авторазмер
 S Vo(qqnump,-1,74)="X798 X798 X798" ;замещение пояснений на пояснения к поисковому образу
 S Vo(qqnump,-1,52)=",,,,,,,,16777215" ;16776960" ;параметры
 ;S Vo(qqnump,-1,23)="S W(""ZBtred"")=1"
 S Vo(qqnump,-1,23)="S W(""ZBtred"")=1,qqo=-1,Vs(qqnump,""CurObj"")=-1 D qARM.wcre(),qARM.NextEdit("""",1)" ;@dol 17.07.03 чтобы встать на первую ячейку
 S Vo(qqnump,-1,73)=3 ;автоматический невыбор
 S Vo(qqnump,-1,0,0,0,2)="-1,2",Vo(qqnump,-1,0,0,1,2)=15
 S $$$Tree=0
 S Vo(qqnump,-1,0,1,0)="0"
 ;описание (через запятую)
 ;1 -qqw;2 - qqo;3 - заголовок;4 - qqs - стиль. 1 - от-до.;5 - понятие развертки (параметры развертки)
 ;6 - вариант редактирования
 ;7 - тип развертки
 ;8 - размер поля
 ;9 - маска. Если 1 - дата
 N qqw,qqwi,qqo,qqww,qqs,qqt
 S qqpar2=cond F qqwi=2:1:..PQ(qqpar2)+1 S qqww=..PQ(qqpar2,qqwi-1),qqo=$P(qqww,","),qqw=$P(qqww,",",2),qqs=$P(qqww,",",4) D:qqw'=""  ;@dol 2.04.04 qqw'=""
 .I qqs'=1 D  Q
 ..S Vo(qqnump,-1,0,qqwi,0)="0"_$S(..PSYN(qqww,",",3,,,1)="":"@"_qqw,1:$TR(..PSYN(qqww,",",3,,,1),"~"," "))
 ..S Vo(qqnump,-1,0,qqwi,1)="2Z"_(qqwi-1),W("Z"_(qqwi-1))=$P($G(condZ),"~",(qqwi-1))
 ..S Vo(qqnump,-1,0,qqwi,1,30)=$S(..PSYN(qqww,",",7)'="":..PSYN(qqww,",",7),"@MLTX"[$E(qqw):-1,1:0)
 ..S Vo(qqnump,-1,0,qqwi,1,31)=$S(..PSYN(qqww,",",6)'="":..PSYN(qqww,",",6),1:0)
 ..S Vo(qqnump,-1,0,qqwi,1,3)=$S(..PSYN(qqww,",",5,,,1)="":$S($E(qqw)="@":"",1:qqw),1:..PSYN(qqww,",",5,,,1))
 ..S:Vo(qqnump,-1,0,qqwi,1,30)=3!(..PSYN(qqww,",",9,,,1)=1) Vo(qqnump,-1,0,qqwi,1,10)=1 ;явная дата
 ..S:(..PSYN(qqww,",",9,,,1)=6) Vo(qqnump,-1,0,qqwi,1,10)=6 ;явная дата
 ..S:..PSYN(qqww,",",8)'="" Vo(qqnump,-1,0,qqwi,1,2)=..PSYN(qqww,",",8)
 ..I ..PSYN(qqww,",",9,,,1)'="","16"'[..PSYN(qqww,",",9,,,1) S Vo(qqnump,-1,0,qqwi,1,44)=..PSYN(qqww,",",9,,,1)
 .I qqs=1 D  Q  ;вариант от - до
 ..S Vo(qqnump,-1,0,qqwi,0)="0"_$S(..PSYN(qqww,",",3,,,1)="":qW.GetWoc("CxWoc",qqw),1:$TR(..PSYN(qqww,",",3,,,1),"~"," "))_" от:"
 ..S Vo(qqnump,-1,0,qqwi,1)="2Za"_(qqwi-1),W("Za"_(qqwi-1))=$P($P($G(condZ),"~",(qqwi-1)),"-",1)
 ..S qqt=qARM.GetPar("x710",Vo($P(qqParent," ",2)),qqo,qqw) S:$E(qqw,1,3)="dat" qqt=1 I qqt=1!(qqt=6) S (Vo(qqnump,-1,0,qqwi,1,10),Vo(qqnump,-1,0,qqwi,3,10))=qqt ;дата
 ..S Vo(qqnump,-1,0,qqwi,1,30)=$S(..PSYN(qqww,",",7)'="":..PSYN(qqww,",",7),"@MLTX"[$E(qqw):-1,1:0)
 ..S Vo(qqnump,-1,0,qqwi,1,31)=$S(..PSYN(qqww,",",6)'="":..PSYN(qqww,",",6),1:0)
 ..S Vo(qqnump,-1,0,qqwi,1,3)=$S(..PSYN(qqww,",",5,,,1)="":$S($E(qqw)="@":"",1:qqw),1:..PSYN(qqww,",",5,,,1))
 ..S:Vo(qqnump,-1,0,qqwi,1,30)=3!(..PSYN(qqww,",",9,,,1)=1)!(qqt=1) Vo(qqnump,-1,0,qqwi,1,10)=1 ;явная дата
 ..S:(..PSYN(qqww,",",9,,,1)=6)!(qqt=6) Vo(qqnump,-1,0,qqwi,1,10)=6 ;явная дата
 ..S:..PSYN(qqww,",",8)'="" Vo(qqnump,-1,0,qqwi,1,2)=..PSYN(qqww,",",8)
 ..I ..PSYN(qqww,",",9,,,1)'="","16"'[..PSYN(qqww,",",9,,,1) S Vo(qqnump,-1,0,qqwi,1,44)=..PSYN(qqww,",",9,,,1)
 ..S Vo(qqnump,-1,0,qqwi,2)="0 до:",Vo(qqnump,-1,0,qqwi,2,2)=5
 ..S Vo(qqnump,-1,0,qqwi,3)="2Zb"_(qqwi-1),W("Zb"_(qqwi-1))=$P($P($G(condZ),"~",(qqwi-1)),"-",2)
 ..S Vo(qqnump,-1,0,qqwi,3,30)=$S(..PSYN(qqww,",",7)'="":..PSYN(qqww,",",7),"@MLTX"[$E(qqw):-1,1:0) ;qqt=1:1
 ..S Vo(qqnump,-1,0,qqwi,3,31)=$S(..PSYN(qqww,",",6)'="":..PSYN(qqww,",",6),1:0) ;qqt=1:3
 ..S Vo(qqnump,-1,0,qqwi,3,3)=$S(..PSYN(qqww,",",5,,,1)="":$S($E(qqw)="@":"",1:qqw),1:..PSYN(qqww,",",5,,,1))
 ..S:Vo(qqnump,-1,0,qqwi,3,30)=3!(..PSYN(qqww,",",9,,,1)=1)!(qqt=1) Vo(qqnump,-1,0,qqwi,3,10)=1 ;явная дата
 ..S:(..PSYN(qqww,",",9,,,1)=6)!(qqt=6) Vo(qqnump,-1,0,qqwi,3,10)=6 ;явная дата
 ..S:..PSYN(qqww,",",8)'="" Vo(qqnump,-1,0,qqwi,3,2)=..PSYN(qqww,",",8)
 ..I ..PSYN(qqww,",",9,,,1)'="","16"'[..PSYN(qqww,",",9,,,1) S Vo(qqnump,-1,0,qqwi,3,44)=..PSYN(qqww,",",9,,,1)
 ;Сделаем кнопки
 S qqwi=qqwi+1,Vo(qqnump,-1,0,qqwi,0)="0",qqwi=qqwi+1
 S Vo(qqnump,-1,0,qqwi,1)="6@ZXXOK" ;2
 S Vo(qqnump,-1,0,qqwi,1,2)=",1,,,1" ;",,,,4,,,,12632256"
 S Vo(qqnump,-1,0,qqwi,1,31)=1,Vo(qqnump,-1,0,qqwi,1,30)=9
 S Vo(qqnump,-1,0,qqwi,1,3)="S:$D(qwin(""Q0"")) qqend=1 "_$G(condDo)
 ;S Vo(qqnump,-1,0,qqwi,1)="6@ZXXCancel" ;2
 ;S Vo(qqnump,-1,0,qqwi,1,2)=",,,,4,,,,12632256"
 ;S Vo(qqnump,-1,0,qqwi,1,31)=1,S Vo(qqnump,-1,0,qqwi,1,30)=9,Vo(qqnump,-1,0,qqwi,1,3)="S qqend=1"
 ;S Vo(qqnump,-1,75)="O:-1,@ZXXOK" ; C:-1,@ZXXCancel" ;горячие клавиши
 D ..CreVoAdd() Q:$Q "" Q
gensysW ;отображение вывода словаря qqpar2
 S Vo(qqnump,-1)="Словарь"
 S $$$Tree=0
 S Vo(qqnump,-1,23)="S W(""Zdomod"")=3,(Vs(qqnump,""CuRObj""),W(""Zosrt""))="""_qqpar2_""",Vs(qqnump,""CondFind"")=""C""  D qARM.wcre(),qARM.wbut(2,0,1)" ;,qARM.T2ColHButton(0)" ;по входу
 S Vo(qqnump,-1,22)="S qqp4=qqc" ;по выходу
 S Vo(qqnump,-1,86)="I qc=114 S Key=0,qc=0 D qARM.Print(,2)" ;печать по F3
 ;S Vo(qqnump,-1,29)="200,400,0,11,1"
 ;
 S Vo(qqnump,-1,0,1)=qqpar2
 S Vo(qqnump,qqpar2)=qW.GetWoc("CxWoc",qqpar2),$$$ObjLqqc(qqpar2)=255
 S Vo(qqnump,-1,0,0,$E(qqpar2)="C")=0_Vo(qqnump,qqpar2)
 S Vo(qqnump,qqpar2,0,0,0)="2C"
 S Vo(qqnump,qqpar2,0,0,0,2)=20
 S Vo(qqnump,qqpar2,0,0,0,30)=-2
 ;S $$$CondFind="C"
 I $E(qqpar2)="C" D  ;если коды, то выведем и значения
 .S Vo(qqnump,-1,0,0,0)="0Код"
 .S Vo(qqnump,qqpar2,0,0,1)="2CC"
 .S Vo(qqnump,qqpar2,0,0,0,2)=10,Vo(qqnump,qqpar2,0,0,1,2)=20
 .S Vo(qqnump,qqpar2,0,0,1,30)=-2
 .S Vo(qqnump,qqpar2,0,0,2)="2Thlp"
 .S Vo(qqnump,qqpar2,0,0,2,2)=-1
 I $G(Vo("par",-1,22))="D qSYS.CallRel1() S qqend=1" S Vo(qqnump,qqpar2,0,0,1)="2ZTMPN",Vo(qqnump,qqpar2,0,0,1,2)=5 S:$G(OBJ)'="" Vo(qqnump,qqpar2,27)="$D(^Q(1,"""_qqpar2_""",qqc,"""_$G(OBJ)_"""))" ;@Dol 01.03.05 - идиотский вариант условия для набора поискового образа (вызов из qSYS.CallRel - набор при задании поискового образа)
 D ..CreVoAdd() Q:$Q "" Q
gensysR ;отображение вывода словаря qqpar2 для развертки
 S Vo(qqnump,-1)=$S($G(Vo("par",-1))'="":$TR(Vo("par",-1),"_"," "),1:"-Развертка") ;@Dol 05.04.06 заголовок
 S $$$Tree=0
 S Vo(qqnump,-1,73)=3
 S Vo(qqnump,-1,61)=4 ;таблица
 N qqwr S qqwr=$S(qqpar2'[":":"C",1:$P($P(qqpar2,":",2),","))
 S Vo(qqnump,-1,23)="S W(""ZBtred"")=1,$P(Vs(qqnump,""CondFind""),"" "",10,11)=$G(Vs(qqnump,""CondF"")) "_$G(Vo("par",-1,23))_$S('$G(Vo("par",-1,230)):" S (Vs(qqnump,""CuRObj""),W(""Zosrt""))="""_$P(qqpar2,":")_""",$P(Vs(qqnump,""CondFind""),"" "")="""_qqwr_""",qqw="""_qqwr_"""  D qARM.wcre(),qARM.wbut(2,0,1)",1:"") ;_" S:$D(Vc(qqnump))<10 qqend=""Словарь пуст""" ;,qARM.T2ColHButton(0)" ;по входу
 K Vo("par",-1,23),Vo("par",-1,230) ;Vo("par",-1,230)=1 не включать сортировку
 ;
 D:$G(Vo("par",-1,0,1))'=""  ;есть ввод новых значеий
 .S Vo(qqnump,-1,0,1,0)="2Znew"
 .S Vo(qqnump,-1,0,1,0,2)=",,,,,,,,16777215",Vo(qqnump,-1,0,1,0,4)="qSYS.sysR74()",Vo(qqnump,-1,0,1,0,5)="@$P($G(Vs(qqnump,""CondFind"")),"" "",5)"
 .S Vo(qqnump,-1,0,1,0,41)=1 ;режим одного слова
 .M Vo(qqnump,-1,0,1,0)=Vo("par",-1,0,1,0)
 .K Vo("par",-1,0,1)
 ;
 I qqpar2[":" D  G gensysRend
 .N qqo S qqo=$P(qqpar2,":")
 .S Vo(qqnump,-1,0,2)=qqo
 .S Vo(qqnump,qqo)="",$$$ObjLqqc(qqo)=$G(^Q(1,"CxObj",qqo,"X50"),255)
 .S Vo(qqnump,qqo,30)=1
 .N iw,qqw,qqwl S qqwl=$P(qqpar2,":",2)
 .F iw=0:1:$L(qqwl,",")-1 S qqw=$P(qqwl,",",iw+1) D:qqw'=""
 ..;????I 'iw,$G(Vo("par",-1,"x710"))'="",$E(qqw)'="C" S Vo(qqnump,qqo,0,0,iw,10)=Vo("par",-1,"x710") ;@Dol 07.05.08 наследование типа
 ..S Vo(qqnump,qqo,0,0,iw)="2"_qqw
 ..S Vo(qqnump,qqo,0,0,iw,2)=$P($G(Vo("par",qqo,0,0,0,2),"20,20,20,20,20"),",",iw+1)
 ..I 'iw S Vo(qqnump,qqo,0,0,iw,30)=-2 Q
 ..I $E(qqw)'="Z" S Vo(qqnump,qqo,0,0,iw,31)=-1
 .K Vo("par",qqo,0,0,0,2)
 ;
 S Vo(qqnump,-1,0,2)=qqpar2
 S Vo(qqnump,qqpar2)=qW.GetWoc("CxWoc",qqpar2),$$$ObjLqqc(qqpar2)=255
 S Vo(qqnump,qqpar2,30)=1
 S:$G(Vo("par",-1,88))#3'=2 Vo(qqnump,-1,0,0,$E(qqpar2)="C")=0_$S($TR($G(Vo("par",-1,0,0,0))," ")="":Vo(qqnump,qqpar2),1:$E(Vo("par",-1,0,0,0),2,1000)) K Vo("par",-1,0,0,0)
 S Vo(qqnump,qqpar2,0,0,0)="2C"
 S Vo(qqnump,qqpar2,0,0,0,2)=+$G(Vo("par",qqpar2,0,0,0,2),20)
 S Vo(qqnump,qqpar2,0,0,0,30)=-2
 I $G(Vo("par",-1,"x710"))'="",$E(qqpar2)'="C" S Vo(qqnump,qqpar2,0,0,0,10)=Vo("par",-1,"x710") ;@Dol 07.05.08 наследование типа
 ;
 I $E(qqpar2)="C" D  ;если коды, то выведем и значения. Для CxWoc CxObj наследуется режим Администратор
 .I qqpar2="CxWoc",'$G(WS($P(qqParent," ",2),"Zadm")) S Vt(qqnump,0)=1,Vo(qqnump,qqpar2,27)="""xX""'[$E(qqc)&($E(qqc,1,2)'=""Cx"")&($E(qqc,1,4)'=""@ZXX"")&$S('$G(^Q(1,""CxWoc"",qqc,""Xsys"")):1,1:$E(qqc,1,2)'=""TB""&($E(qqc)'=""Z""))!W(""Zadm"")"
 .I qqpar2="CxObj",'$G(WS($P(qqParent," ",2),"Zadm")) S Vt(qqnump,0)=1,Vo(qqnump,qqpar2,27)="'$G(^Q(1,""CxObj"",qqc,""Xsys""))!W(""Zadm"")"
 .S:$G(Vo("par",-1,88))#3'=2 Vo(qqnump,-1,0,0,0)="0Код",Vo(qqnump,-1,0,0,1)="0Значение"
 .S Vo(qqnump,qqpar2,0,0,1)="2CC"
 .S Vo(qqnump,qqpar2,0,0,0,2)=10,Vo(qqnump,qqpar2,0,0,1,2)=20
 .I $G(Vo("par",-1,"x710"))'="" S Vo(qqnump,qqpar2,0,0,1,10)=Vo("par",-1,"x710") ;@Dol 07.05.08 наследование типа
 .S Vo(qqnump,qqpar2,0,0,1,30)=-2
 .S Vo(qqnump,qqpar2,0,0,2)="2Thlp"
 .S Vo(qqnump,qqpar2,0,0,2,2)=-1,Vo(qqnump,qqpar2,0,0,2,31)=-1
gensysRend
 K Vo("par",-1,"x710")
 I $G(Vo("par",-1,88))#3=2 S Vo(qqnump,-1,0,0,0)="0  "
 I $G(Vo("par",-1,231)) K Vo("par",-1,231) D
 .S Vo(qqnump,-1,669)=$P(qqpar2,":") ;@Dol 14.08.06 скролбар перемещений вместо указателя перемещений
 .;N qqo S qqo=$P(qqpar2,":"),qqpar2=$O(Vo(qqnump,qqo,0,0,""),-1)+1,Vo(qqnump,qqo,0,0,qqpar2)="2@ZXXmove",Vo(qqnump,qqo,0,0,qqpar2,2)=2,Vo(qqnump,qqo,0,0,qqpar2,6)=qW.GG("CxWoc","X76","@ZXXmove") I '$P(Vo("par",-1,29),",",11) S Vo(qqnump,-1,0,0,qqpar2)="0 ~Выход",Vo(qqnump,qqo,0,0,qqpar2,2)=3,Vo(qqnump,-1,0,0,qqpar2,6)="R,366",Vo(qqnump,-1,0,0,qqpar2,3)="D qARM.wM(qwin,""EvClose"") S qqend=1" ;кнопка заголовка становится кнопкой выхода, если нет заголовка окна 
 M Vo(qqnump)=Vo("par"),Vs(qqnump)=Vs("par") K Vo("par"),Vs("par")
 S Vo(qqnump,-1,71)=$S($G(Vo(qqnump,-1,60))="":20,1:Vo(qqnump,-1,60)) ;@Dol 10.09.05 кол-во при фиксации такое же как и без
 D ..CreVoAdd() Q:$Q "" Q
gensysC ;отображение вывода пояснения компоненты
 N comp,cod,qqo,adm
 S adm=$P(qqParent," ",2),adm=$S($G(WS(adm,"Zadm")):1,$E(Vo(adm),1,3)="XXX":1,1:0)
 S cod=$E(qqpar2,2,255) S:$E(qqpar2)="W" qqo=$P(cod,"_",2),cod=$P(cod,"_")
 S comp=$S($E(qqpar2)="W":"CxWoc",$E(qqpar2)="O":"CxObj",$E(qqpar2)="V":"XView",1:"")
 I comp="" Q:$Q "" Q
 S Vo(qqnump,-1)="Пояснения для "_$S($E(qqpar2)="W":$S($E(qqpar2,2,3)="Zs":"Ячейки",1:"Понятия"),$E(qqpar2)="O":"Объекта",$E(qqpar2)="V":"Отображения",1:"")
 S Vo(qqnump,-1,60)=10
 S Vo(qqnump,-1,61)=2
 S Vo(qqnump,-1,65)=2
 S Vo(qqnump,-1,63)=10
 S Vo(qqnump,-1,197)=0
 S Vo(qqnump,-1,69)="D qARM.Print(,1) S qqend=1"
 S:$G(Vs(qqnump,"Name"))="" Vs(qqnump,"Name")=$G(Vs("par","Name")) K Vs("par","Name")
 S:$G(Vs(qqnump,"Thlp"))="" Vs(qqnump,"Thlp")=$G(Vs("par","Thlp")) K Vs("par","Thlp")
 ;
 S $$$Tree=0
 S Vo(qqnump,-1,0,0,0,2)="5,2",Vo(qqnump,-1,0,0,1,2)="15,0,5",Vo(qqnump,-1,0,0,2,2)="5,0,5",Vo(qqnump,-1,0,0,3,2)="40,0,5"
 ;
 S Vo(qqnump,-1,0,1,0,2)=",,,,1,,,255",Vo(qqnump,-1,0,1,1,2)=",,,,1,,,16711680"
 I $E(qqpar2,1,3)="WZs" D  I cod="" D ..CreVoAdd() Q:$Q "" Q  ;пояснения по ячейки
 .S %1=$G(Vo($P(qqParent," ",2),qqo,0,$P($E(cod,3,5),"c"),$P(cod,"c",2))) ;тип ячейки
 .I $E(%1)'=0,$E(%1)'=5 S cod=$E(%1,2,255) Q
 .S Vo(qqnump,-1,0,1,1)=$S($E(%1)=5:"5""Выражение""",1:"5""Константа""")
 .S:adm Vo(qqnump,-1,0,1,3)="0"_$E(%1,2,10000)
 .I $G(Vs(qqnump,"Thlp"))'="" S Vo(qqnump,-1,0,2,1)="5Vs(qqnump,""Thlp"")",Vo(qqnump,-1,0,2,1,10)=3 ;@dol 4.03.04
 .N qqwt
 .D
 ..N qqnump S qqnump=$P(qqParent," ",2),qqwt=qARM.GetPar("X731",,qqo,$P($E(cod,3,5),"c"),$P(cod,"c",2))
 .S:qqwt'="" Vo(qqnump,-1,0,3,1)="0"_qW.GetWoc("Cx731",+qqwt),Vo(qqnump,-1,0,3,1,2)=",,,,1,,,255"
 .D
 ..N qqnump S qqnump=$P(qqParent," ",2),qqwt=qARM.GetPar("x730",,qqo,$P($E(cod,3,5),"c"),$P(cod,"c",2))
 .S:qqwt'="" Vo(qqnump,-1,0,4,2)="0Разв.: "_qW.GetWoc("Cx730",qqwt)
 .S cod=""
 I $E(qqpar2)="V" D  D ..CreVoAdd() Q:$Q "" Q  ;по отображению
 .S:adm Vo(qqnump,-1,0,1,0)="0База" S Vo(qqnump,-1,0,1,1)=5_"qW.GG(""XBase"",""XBName"",0)",Vo(qqnump,-1,0,1,3)="5qW.GT(""XBase"",""Thlp"",0)"
 .S:adm Vo(qqnump,-1,0,2,0)="5"""_cod_"""" S Vo(qqnump,-1,0,2,1)=5_"qW.GG("""_comp_""",""X11"","""_cod_""")" S:adm Vo(qqnump,-1,0,2,2)="5qW.GG("""_comp_""",""XRef"","""_cod_""")" S Vo(qqnump,-1,0,2,3)="5qW.GT("""_comp_""",""Thlp"","""_cod_""")"
 .S Vo(qqnump,-1,0,2,0,2)=",,,,1,,,255",Vo(qqnump,-1,0,2,1,2)=",,,,1,,,16711680"
 S:adm Vo(qqnump,-1,0,1,0)="5"""_cod_"""" S Vo(qqnump,-1,0,1,1)=5_$S($G(Vs(qqnump,"Name"))'="":"Vs(qqnump,""Name"")",$E(qqpar2)="V":"qW.GG("""_comp_""",""X11"","""_cod_""")",1:"qW.GetWoc("""_comp_""","""_cod_""")")
 S:adm Vo(qqnump,-1,0,1,3)="5qW.GG("""_comp_""",""XRef"","""_cod_""")" S Vo(qqnump,-1,0,2,1)=5_$S($G(Vs(qqnump,"Thlp"))'="":"Vs(qqnump,""Thlp"")",1:"qW.GT("""_comp_""",""Thlp"","""_cod_""")"),Vo(qqnump,-1,0,2,1,10)=3
 I $E(qqpar2)'="W" D ..CreVoAdd() Q:$Q "" Q
 ;
 N qqw,qqwt,qi,qqwpar S qi=3,qqw=cod D  D ..CreVoAdd() Q:$Q "" Q
 .D
 ..N qqnump S qqnump=$P(qqParent," ",2),qqwt=qARM.GetPar("X731",,qqo,qqw),qqwpar=qARM.GetPar("X73",,qqo,qqw)
 .I $S(qqwt'="":1,1:$E(qqw)'="@") S Vo(qqnump,-1,0,qi,1)="0"_qW.GetWoc("Cx731",+qqwt),Vo(qqnump,-1,0,qi,1,2)=",,,,1,,,255"
 .D
 ..N qqnump S qqnump=$P(qqParent," ",2),qqwt=qARM.GetPar("x730",,qqo,qqw)
 .S:qqwt'="" Vo(qqnump,-1,0,qi,3)="0Разв.: "_qW.GetWoc("Cx730",qqwt)
 .S qi=qi+1
 .;Q:"@XLTM"[$E(qqw)
 .D
 ..N qqnump S qqnump=$P(qqParent," ",2),qqwt=qARM.GetPar("x77",,qqo,qqw)
 .Q:qqwt=0  I "@XLTM"[$E(qqw) Q:'qqwt  Q:$P(qqwpar," ")=""  N qqw S qqw=$P(qqwpar," ")
 .S qqo=-1 S:'qqwt qqwt=4  ;нужны значения?
 .S Vo(qqnump,-1,0,qi,1)="0Значения:" S:adm Vo(qqnump,-1,0,qi,2)="0Хар-ка:"
 .S Vo(qqnump,-1,0,qi,1,2)=",,,,3" S:adm Vo(qqnump,-1,0,qi,2,2)=",,,,3"
 .I qqwt#2 S qqwc="" F ii=1:1 S qqwc=$O(^Q(qqlang,$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),qqwc)) Q:$S(qqwc="":1,qqwt=3:ii>5,1:0)  D
 ..S qi=qi+1
 ..S Vo(qqnump,qqo,0,qi,0)="5"""_qqwc_""""
 ..S:$E(qqw)'="D" Vo(qqnump,qqo,0,qi,1)="5"""_$G(^(qqwc))_""""
 ..S:adm Vo(qqnump,qqo,0,qi,2)="5qW.GG("""_$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw)_""",""XRef"","""_qqwc_""")"
 ..S Vo(qqnump,qqo,0,qi,3)="5qW.GT("""_$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw)_""",""Thlp"","""_qqwc_""")",Vo(qqnump,qqo,0,qi,3,10)=3
 .I '(qqwt#2) S qqwc="" F ii=1:1 S qqwc=$O(^Q(qqlang,qqw,qqwc)) Q:$S(qqwc="":1,qqwt=4:ii>5,1:0)  D
 ..S qi=qi+1
 ..S Vo(qqnump,qqo,0,qi,1)="5"""_qqwc_""""
 ..S:adm Vo(qqnump,qqo,0,qi,2)="5qW.GG("""_$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw)_""",""XRef"","""_$S("CD"[$E(qqw):qqwc,1:^(qqwc))_""")"
 ..S Vo(qqnump,qqo,0,qi,3)="5qW.GT("""_$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw)_""",""Thlp"","""_$S("CD"[$E(qqw):qqwc,1:^(qqwc))_""")",Vo(qqnump,qqo,0,qi,3,10)=3
 ;
gensysP ;отображение вывода полного словаря qqpar2
 N Obj,io S Obj=$S($E(qqpar2)="C":qqpar2,$E(qqpar2)="D":qqpar2,1:"C"_qqpar2)
 S Vo(qqnump,-1)="Таблица значений Словаря "_qW.GetWoc("CxWoc",qqpar2)
 S $$$Tree=0
 S Vo(qqnump,-1,29)="400,500,0"
 S Vo(qqnump,-1,28)="-"
 S Vo(qqnump,-1,27)="-"
 S Vo(qqnump,-1,61)=4 ;таблица
 S Vo(qqnump,-1,0,1)=Obj
 S Vo(qqnump,Obj)=qW.GetWoc("CxWoc",qqpar2),$$$ObjLqqc(Obj)=255
 S Vo(qqnump,-1,0,0,0)="0Код",Vo(qqnump,-1,0,0,1)=0_Vo(qqnump,Obj) ;,Vo(qqnump,-1,0,0,2)="0Ссылка",Vo(qqnump,-1,0,0,3)="0Пояснения"
 S Vo(qqnump,Obj,0,0,0)="2C"
 S Vo(qqnump,Obj,0,0,0,2)=10
 ;
 S Vo(qqnump,Obj,0,0,1)="2CC"
 S Vo(qqnump,Obj,0,0,1,2)=20
 S Vo(qqnump,Obj,0,0,1,4)="$S($E(qqo)'=""C"":"""",$G(^Q(1,$E(qqo,2,255),Z))="""":"""",^Q(1,$E(qqo,2,255),Z)'=qqc:""Существует"",1:"""")"
 S Vo(qqnump,Obj,35)="$S(W(""ZBtred"")&&'W(""Zadm"")&&($E(qqw)=""C""):""Не режим администратора"",1:0)" ;запрет коррекции
 ;
 S io=2 D:$E(qqpar2)'="D"
 .S Vo(qqnump,Obj,0,0,2)="2XRef"
 .S Vo(qqnump,Obj,0,0,2,2)=10
 .;
 .S Vo(qqnump,Obj,0,0,3)="2Thlp"
 .S Vo(qqnump,Obj,0,0,3,2)="40,0,1"
 .S io=4
 .F io=4:1:9 S Vo(qqnump,Obj,0,0,io)="2XRef"_(io-4),Vo(qqnump,Obj,0,0,io,2)=5
 .S io=io+1
 I $L($G(qqllang)," ")>1 D  S io=io+$L(qqllang," ")-1  ;значения для других языков
 .N j,qqlang F j=2:1:$L(qqllang," ") S qqlang=$P(qqllang," ",j),Vo(qqnump,Obj,0,0,io-1+j-1)="5$G(^Q("_qqlang_","""_Obj_""",qqc))",Vo(qqnump,-1,0,0,io-1+j-1)="0"_qW.GetWoc("CxWoc",qqpar2),Vo(qqnump,Obj,0,0,io-1+j-1,4)="qSYS.qqlang("_qqlang_","""_Obj_""")",Vo(qqnump,Obj,0,0,io-1+j-1,31)=0,Vo(qqnump,Obj,0,0,io-1+j-1,40)=1
 ;ссылки на экземпляры объектов
 S Vo(qqnump,Obj,0,0,io)="0Ссылки"
 S Vo(qqnump,Obj,0,0,io,31)=1
 S Vo(qqnump,Obj,0,0,io,30)=9
 S Vo(qqnump,Obj,0,0,io,3)="D qSYS.CallEx()"
 ;
 S Vo(qqnump,Obj,24)="$S(qqt'=3:"""",$D(^Q(1,"""_$S($E(Obj)="C":$E(Obj,2,255)_""",qW.G(""CC"")",1:Obj_""",qqc")_"))>1:""Есть ссылки"",1:"""")" ;правило проверки
 D ..CreVoAdd() Q:$Q "" Q
gensysO ;отображение вывода объекта qqpar2
 ;N Obj S Obj=$S($E(qqpar2)="C":qqpar2,1:"C"_qqpar2)
 S Vo(qqnump,-1)="Таблица экземпляров Объекта "_qW.GetWoc("CxObj",qqpar2)
 S $$$Tree=0
 S Vo(qqnump,-1,29)="400,500,0"
 S Vo(qqnump,-1,0,1)=qqpar2
 S Vo(qqnump,qqpar2)=qW.GetWoc("CxObj",qqpar2)
 S $$$ObjLqqc(qqpar2)=$G(^Q(1,"CxObj",qqpar2,"X50"))
 S Vo(qqnump,qqpar2,0,0,0)="2C"
 S Vo(qqnump,qqpar2,0,0,0,2)=10
 S Vo(qqnump,qqpar2,31)=1 ;@Dol 06.02.09 подтверждение ввода/удаления
 S Vo(qqnump,qqpar2,30)="@$S(W(""Zadm""):0,1:""1Только в режиме Администратор"")" ;@Dol 06.02.09 запрет ввода/удаления
 S Vo(qqnump,qqpar2,35)="$S('W(""ZBtred""):2,W(""Zadm""):0,1:""Только в режиме Администратор"")" ;@Dol 06.02.09 запрет коррекции
 N iw,qqw,qqwl I $D(Vs("par","xWoc")) S qqwl=Vs("par","xWoc") K Vs("par","xWoc") I 1 ;@dol 18.10.04 список выводимых понятий
 E  S qqwl=$G(^Q(1,"CxObj",qqpar2,"xWoc")) 
 F iw=1:1:$L(qqwl," ") S qqw=$P(qqwl," ",iw) I qqw'="","Z@"'[$E(qqw),qqw'="C" D  ;@Dol 10.12.04 qqw'="C" 
 .S Vo(qqnump,qqpar2,0,0,iw)="2"_qqw
 .S:$D(^Q(1,"CxWoc",$S(qqw[":":$P($P(qqw,":",2),"{"),1:qqw),"x710")) Vo(qqnump,qqpar2,0,0,iw,10)=^("x710") ;@Dol 27.10.07
 S Vo(qqnump,-1,28)="-"
 S Vo(qqnump,-1,27)="-"
 S Vo(qqnump,-1,61)=4 ;таблица
 ;ссылки на подчиненные объекты
 S qqwl=$G(^Q(1,"CxObj",qqpar2,"xObj"))
 F iw=1:1:$L(qqwl," ") S qqw=$P(qqwl," ",iw) D:qqw'=""
 .;S $P(Vo(qqnump,-1,27)," ",iw)="XXXsysO"_qqc
 .S Vo(qqnump,-1,2,iw-1,0)=qqw_" "_qW.GetWoc("CxObj",qqw)
 .S Vo(qqnump,-1,2,iw-1,1)="D qARM.OpenWindow(,,,qqc,,""XXXsysO"_qqw_""")"
 S:qqwl="" iw=0
 S Vo(qqnump,-1,2,iw,0)="-----"
 S Vo(qqnump,-1,2,iw+1,0)="Удалить ВСЕ экземпляры"
 S Vo(qqnump,-1,2,iw+1,1)="D:'$G(W(""Zadm"")) qARM.Message(""Только в режиме Администратор"") D:$G(W(""Zadm"")) qARM.Question(""Удалить ВСЕ экземпляры"",0,"""",""D qW.rDelAll(Vs(qqnump,""""CurObj"""")),qARM.wcre()"")"
 S Vo(qqnump,-1,2,iw+2,0)="Удалить ВСЕ экземпляры (включая объекты-потомки)"
 S Vo(qqnump,-1,2,iw+2,1)="D:'$G(W(""Zadm"")) qARM.Message(""Только в режиме Администратор"") D:$G(W(""Zadm"")) qARM.Question(""Удалить ВСЕ экземпляры (включая объекты-потомки)"",0,"""",""D qW.rDelAll(Vs(qqnump,""""CurObj""""),1),qARM.wcre()"")"
 D ..CreVoAdd() Q:$Q "" Q
gensysI ;отображение вывода списка объектов qqpar2
 N qqpar22,iw,qqw,qqwl,io S qqpar22=qqpar2
 S Vo(qqnump,-1)="Таблица экземпляров Объектов"
 S $$$Tree=0
 S Vo(qqnump,-1,29)="400,500,100"
 F io=1:1:$L(qqpar22,",") S qqpar2=$P(qqpar22,",",io) D
 .S Vo(qqnump,-1,0,io)=qqpar2
 .S Vo(qqnump,qqpar2)=qW.GetWoc("CxObj",qqpar2)
 .S $$$ObjLqqc(qqpar2)=$G(^Q(1,"CxObj",qqpar2,"X50"))
 .S Vo(qqnump,qqpar2,io-1,0,0)="2C"
 .S Vo(qqnump,qqpar2,io-1,0,0,2)=10
 .S qqwl=$G(^Q(1,"CxObj",qqpar2,"xWoc"))
 .F iw=1:1:$L(qqwl," ") S qqw=$P(qqwl," ",iw) I qqw'="","Z@"'[$E(qqw) D
 ..S Vo(qqnump,qqpar2,io-1,0,iw)="2"_qqw
 ..S:$D(^Q(1,"CxWoc",$S(qqw[":":$P($P(qqw,":",2),"{"),1:qqw),"x710")) Vo(qqnump,qqpar2,0,0,iw,10)=^("x710") ;@Dol 27.10.07
 D ..CreVoAdd() Q:$Q "" Q
gensysM ;Отображение вывода полной схемы базы (Виртуальное главное отображение)
 N qqol,qqoi
 S qqol=$G(^Q(1,"XBase",0,"xObj")) I qqol="" D qARM.Message("Не построена схема") Q ""
 S Vo(qqnump,-1)="Схема Базы "_$G(^Q(1,"XBase",0,"XBName"))
 S $$$Tree=0
 F qqoi=1:1:$L(qqol," ") S Vo(qqnump,-1,0,qqoi)=$P(qqol," ",qqoi) D ..CreObj($P(qqol," ",qqoi),1,,1)
 D ..CreVoAdd() Q:$Q "" Q
gensysS ;Отображение вывода Потока
 N qqol,qqoi
 S Vo(qqnump,-1)="Массив потока"
 ;S Vo(qqnump,-1,23)="S qql=""A"
 S Vo(qqnump,-1,27)="-",Vo(qqnump,-1,28)="-"
 ;S Vo(qqnump,-1,3,25)="S qql=""A"
 S $$$Tree=1
 S qqol="" F qqoi=1:1 S qqol=$O(^QS(1,qqol)) Q:qqol=""  D
 .S Vo(qqnump,-1,0,qqoi)=qqol
 .;I $E(qqol,1,2)="Cx" D ..CreObjView(qqol,"XXX"_qqol,,,0) Q  ;понятия и объекты
 .I $D(^Q(1,"XView","XXXX","CxObj",qqol)) D ..CreObjView(qqol,"XXXX",,,0) Q  ;есть в проводнике, оттуда и взять
 .I $E(qqol)="C" D  Q  ;словарь
 ..S Vo(qqnump,qqol)=qW.GetWoc("CxWoc",$E(qqol,2,255))
 ..S Vo(qqnump,qqol,0,0,0)="2C"
 ..S Vo(qqnump,qqol,0,0,1)="2CC"
 ..S Vo(qqnump,qqol,0,0,2)="2XRef"
 ..S Vo(qqnump,qqol,0,0,3)="2Thlp"
 .D ..CreObj(qqol,1,,1)
 D ..CreVoAdd() Q:$Q "" Q
gensysV ;отображение описания отображения
 K Vo(qqnump),Vs(qqnump) S $P(qview," ")="syssysV" ;спец.имя отображения
 D
 .I $E(qqpar2,4,6)="sys" D ..sysView($E(qqpar2,4,7),$E(qqpar2,8,30000)) Q
 .D ..CreVo(qqpar2,1)
 N qqo,qqso,qqw,qi,z,qqo0,lev,qii,qqwt,qqwt77,qqw100
 F qi=9,29,30,50,51,52,55,61 K Vo(qqnump,-1,qi) ;уберем на всякий случай
 K Vt(qqnump,0) ;уберем постоянные условия
 S Vo(qqnump,-1,9)=3 ;графы
 ;передвинем ссылки и уберем строки
 S qqo="" F  S qqo=$O(Vo(qqnump,qqo)) Q:qqo=""  D
 .S qqso="" F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""  Q:qqso>999  D
 ..S z=$G(Vo(qqnump,qqo,0,qqso)) K Vo(qqnump,qqo,0,qqso) Q:z=""
 ..I qqo=-1,'$D(qqo0) S qqo0=z
 ..I $D(Vo(qqnump,qqo,0,1000)) S Vo(qqnump,qqo,0,$O(Vo(qqnump,qqo,0,""),-1)+1)=z Q
 ..S Vo(qqnump,qqo,0,1000)=z
 .;;Q:qqo=-1
 .;строка для отображения объекта
 .S lev="" ;$TR($J("",$L($$$ObjRef(qqo),",")-1)," ",".") ;индикатор уровня
 .S qi=0 I qqo=qqo0 D  S qi=1
 ..S Vo(qqnump,qqo,0,0,0)="5"""_qqpar2_"""",Vo(qqnump,qqo,0,0,0,2)=",,,,1,,,8388736,,1" ;,Vo(qqnump,qqo,0,0,0,6)="""F,fldopen.jpg"""
 ..S Vo(qqnump,qqo,0,0,1)=0_Vo(qqnump,-1),Vo(qqnump,qqo,0,0,1,2)=",,,,1,,,8388736,,1"
 ..S Vo(qqnump,qqo,0,0,3)="5qW.GT(""XView"",""Thlp"","""_qqpar2_""")",Vo(qqnump,qqo,0,0,3,2)=",,,,,,,8388736,,1",Vo(qqnump,qqo,0,0,3,10)=3
 ..S Vo(qqnump,qqo,0,0,2)="5qW.GG(""XView"",""XRef"","""_qqpar2_""",0)"
 .D
 ..S Vo(qqnump,qqo,0,qi,0)="5"""_lev_qqo_"""",Vo(qqnump,qqo,0,qi,0,2)=",,,,1",Vo(qqnump,qqo,0,qi,0,6)="""F,fldopen.jpg"""
 ..S Vo(qqnump,qqo,0,qi,1)=$S($G(Vo(qqnump,qqo))'="":0_Vo(qqnump,qqo),1:"0@"),Vo(qqnump,qqo,0,qi,1,2)=",,,,1"
 ..S Vo(qqnump,qqo,0,qi,3)="5qW.GT(""CxObj"",""Thlp"","""_qqo_""")",Vo(qqnump,qqo,0,qi,3,10)=3 ;,Vo(qqnump,qqo,0,0,2,2)=",,,,1"
 ..S Vo(qqnump,qqo,0,qi,2)="5qW.GG(""CxObj"",""XRef"","""_qqo_""",0)"
 .;сформируем строки для отображения понятий
 .F qii=1:1:$G(Vo(qqnump,qqo,10)) S qqw=Vo(qqnump,qqo,10,qii) D
 ..I qi=999 S Vo(qqnump,qqo,0,qi,0)="5""...слишком много строк""" Q
 ..S qi=qi+1
 ..S Vo(qqnump,qqo,0,qi,0)="5""-"_lev_qqw_"""",Vo(qqnump,qqo,0,qi,0,2)=",,,,,,,8388608",Vo(qqnump,qqo,0,qi,0,6)="""F,bollb.jpg"""
 ..S qqw100=qARM.GetPar("X7100",$S($E(qqpar2,4,6)'="sys":qqpar2,1:$G(Vo($P(qqParent," ",2)))),qqo,qqw) ;имя понятия в отображении
 ..S Vo(qqnump,qqo,0,qi,1)=$S(qqw100'="":0_qqw100,1:"0@"_qqw),Vo(qqnump,qqo,0,qi,1,2)=",,,,,,,8388608"
 ..S Vo(qqnump,qqo,0,qi,3)="5qW.GT(""CxWoc"",""Thlp"","""_qqw_""")",Vo(qqnump,qqo,0,qi,3,2)=",,,,,,,8388608",Vo(qqnump,qqo,0,qi,3,10)=3
 ..S Vo(qqnump,qqo,0,qi,2)="5qW.GG(""CxWoc"",""XRef"","""_qqw_""",0)"
 ..;
 ..S qqwt77=qARM.GetPar("x77",$S($E(qqpar2,4,6)'="sys":qqpar2,1:$G(Vo($P(qqParent," ",2)))),qqo,qqw) Q:'qqwt77  ;нужны значения?
 ..S qi=qi+1
 ..S qqwt=qARM.GetPar("X731",$S($E(qqpar2,4,6)'="sys":qqpar2,1:$G(Vo($P(qqParent," ",2)))),qqo,qqw)
 ..S Vo(qqnump,qqo,0,qi,1)=0_qW.GetWoc("Cx731",+qqwt)
 ..S qqwt=qARM.GetPar("x730",$S($E(qqpar2,4,6)'="sys":qqpar2,1:$G(Vo($P(qqParent," ",2)))),qqo,qqw)
 ..S:qqwt'="" Vo(qqnump,qqo,0,qi,3)="0Разв.: "_qW.GetWoc("Cx730",qqwt)
 ..;
 ..Q:"@XLTM"[$E(qqw)  S qqwt=qqwt77
 ..I qqwt#2 S qqwc="" F ii=1:1 S qqwc=$O(^Q(qqlang,$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),qqwc)) Q:$S(qqwc="":1,qqwt=3:ii>5,1:0)  D
 ...S qi=qi+1
 ...S Vo(qqnump,qqo,0,qi,0)="5"""_qqwc_"""",Vo(qqnump,qqo,0,qi,0,2)=",2,,,,,,"
 ...S:$E(qqw)'="D" Vo(qqnump,qqo,0,qi,1)="5"""_$TR($G(^(qqwc)),"_"," ")_""""
 ...S Vo(qqnump,qqo,0,qi,3)="5qW.GT("""_$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw)_""",""Thlp"","""_qqwc_""")",Vo(qqnump,qqo,0,qi,3,10)=3
 ...S Vo(qqnump,qqo,0,qi,2)="5qW.GG("""_$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw)_""",""XRef"","""_qqwc_""",0)"
 ..I '(qqwt#2) S qqwc="" F ii=1:1 S qqwc=$O(^Q(qqlang,qqw,qqwc)) Q:$S(qqwc="":1,qqwt=4:ii>5,1:0)  D
 ...S qi=qi+1
 ...S Vo(qqnump,qqo,0,qi,1)="5"""_$TR(qqwc,"_"," ")_""""
 ...S Vo(qqnump,qqo,0,qi,3)="5qW.GT("""_$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw)_""",""Thlp"","""_$S($E(qqw)="C":qqwc,1:^(qqwc))_""")",Vo(qqnump,qqo,0,qi,3,10)=3
 ...S Vo(qqnump,qqo,0,qi,2)="5qW.GG("""_$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw)_""",""XRef"","""_$S($E(qqw)="C":qqwc,1:^(qqwc))_""",0)"
 K ^Q(0_qview) ;????
 I '$$$Tree D ..CreVoRef(-1,0_qview,"") I 1
 E  D ..CreVoRef(-1,0_qview,$NA(^Q(0_qview)))
 ;S Vo(qqnump,-1,23)="S qql="""_qqpar2_"""" ;действие по входу
 I '$$$Tree S $$$ReFind=1,$$$Relind=0,$$$RelNum=1 I 1
 E  S $$$ReFind=0,$$$Relind=0,$$$RelNum=0
 S Vo(qqnump,-1,60)=10000 ;кол-во выводимых экземпляров
 S Vo(qqnump,-1,0,0,0)="0Объекты/Понятия"
 S Vo(qqnump,-1,0,0,0,2)=25
 S Vo(qqnump,-1,0,0,1,2)="15,,5"
 S Vo(qqnump,-1,0,0,2)="0Хар-ка"
 S Vo(qqnump,-1,0,0,2,2)=5
 S Vo(qqnump,-1,0,0,3)="0Пояснения"
 S Vo(qqnump,-1,0,0,3,2)=40
 S Vo(qqnump,-1,3,64)="A4 0  1cm  1cm"
 S Vo(qqnump,-1,51)=",,5"
 S Vo(qqnump,-1,9,0)=15,Vo(qqnump,-1,9,1)="15,,5",Vo(qqnump,-1,9,2)=5,Vo(qqnump,-1,9,3)=40
 S Vs("par",99,"Pic")=1
 ;S $$$Tree=0 ;
 S (Vo(qqnump,-1,23),Vo(qqnump,-1,3,25))="S Vs(qqnump,99,""Pic"")=1,qqc="""""_$S('$$$Tree:"",1:",qql="""_0_qview_"""")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="tmpGl">
<Description>
Возвращает имя временного глобала</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev
    */
    q $na($$$tmpGl)
]]></Implementation>
</Method>

<Method name="v731">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N v,c,ic,iv,y,x S ic=0,iv=0
 S v="" F  S v=$O(^Q(1,"XView",v)) Q:v=""   D
 .I $D(^(v,"X165")) S ^("x165")=^("X165") K ^("X165")
 .S c="" F  S c=$O(^Q(1,"XView",v,"CxObj",c)) Q:c=""  D  ;I $E(v,1,3)'="XXX"
 ..S y="" F  S y=$O(^Q(1,"XView",v,"CxObj",c,"Xy",y)) Q:y=""  S x="" F  S x=$O(^Q(1,"XView",v,"CxObj",c,"Xy",y,"Xx",x)) Q:x=""  I $D(^(x,"x731")),'$D(^("X731")) S ^("X731")=^("x731") K ^("x731")
 S c="" F  S c=$O(^Q(1,"CxWoc",c)) Q:c=""  I $D(^(c,"x731")),'$D(^("X731")) S ^("X731")=^("x731") K ^("x731") ;I $E(c,1)'="X"
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="vi">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I Arg1=7 Q $S($G(Vs(W("Zqqnump"),7))="":"",1:"Включена"_$S($G(Vs(W("Zqqnump"),17)):" ЖЕСТКАЯ",1:"")_" фиксация на объекте: "_$S($G(WS(W("Zqqnump"),"Zadm"))||$G(Vs(W("Zqqnump"),"Analit")):Vs(W("Zqqnump"),7)_" ",1:"")_qARM.GetName(Vo(W("Zqqnump")),Vs(W("Zqqnump"),7),,W("Zqqnump"))) ;фиксация
 I Arg1=1 Q $S($G(WS(W("Zqqnump"),"Zadm"))||$G(Vs(W("Zqqnump"),"Analit")):W("ZCxObj")_" ",1:"")_qARM.GetName(Vo(W("Zqqnump")),W("ZCxObj"),,W("Zqqnump")) ;имя объекта
 I Arg1=100||(Arg1=200) Q $S($G(WS(W("Zqqnump"),"Zadm"))||$G(Vs(W("Zqqnump"),"Analit")):qqc_" ",1:"")_$S(qqc[(Vo(W("Zqqnump"))_"qq"):"(запрос)"_qW.GG("XQuery","XQName",qqc),1:qW.G("X11")) ;имя Отображения вызова\Печати
 I Arg1=700 Q $S($G(WS(W("Zqqnump"),"Zadm"))||$G(Vs(W("Zqqnump"),"Analit")):qqc_" ",1:"")_qW.G("XQName") ;имя запроса
 I Arg1=10 S Arg1=$$viCN("O") Q $S($TR(Arg1," ")'="":Arg1,1:qW.GT("CxObj","Thlp",W("ZCxObj")))
 I Arg1=2 N qqwt0,str S str="" D  Q str ;$G(Vt(W("Zqqnump"),1,W("ZCxObj"),W("ZXy")))_"."_W("ZXx")_" "_str
 .S qqwt0=Vo(W("Zqqnump"),W("ZCxObj"),0,W("ZXy"),W("ZXx"))
 .I '$E(qqwt0) S str="заголовок """_$S($E(qqwt0,2)'="@":$E(qqwt0,2,30000),1:qARM.GetName(Vo(W("Zqqnump")),W("ZCxObj"),$E(qqwt0,3,30000),W("Zqqnump")))_"""" Q
 .I $E(qqwt0)=5 D  S str="выражение"_$S(str="":"",1:" "_str)_":"_$E(qqwt0,2,30000) Q
 ..S str=qARM.GetPar(7100,,W("ZCxObj"),W("ZXy"),W("ZXx"),W("Zqqnump"))
 .S str=$S($E(qqwt0)=4:"флаг ",$E(W("ZCxWoc"),1,3)="@ZX":"кнопка ",1:"")_$S($G(WS(W("Zqqnump"),"Zadm"))||$G(Vs(W("Zqqnump"),"Analit")):W("ZCxWoc")_" ",1:"")_qARM.GetName(Vo(W("Zqqnump")),W("ZCxObj"),W("ZCxWoc"),W("Zqqnump")) Q  ;имя понятия
 .;S str=$S($E(qqwt0)=3:"список ",$E(qqwt0)=4:"флаг ",1:"")_$S($E(W("ZCxWoc"))'="@":"",$E(W("ZCxWoc"),1,3)="@ZX":"кнопка ",1:"вычисляемое понятие ")_$S($G(WS(W("Zqqnump"),"Zadm"))||$G(Vs(W("Zqqnump"),"Analit")):W("ZCxWoc")_" ",1:"")_qARM.GetName(Vo(W("Zqqnump")),W("ZCxObj"),W("ZCxWoc"),W("Zqqnump")) Q  ;имя понятия
 I Arg1=20 S Arg1=$$viCN("W") Q $S($TR(Arg1," ")'="":Arg1,1:qW.GT("CxWoc","Thlp",W("ZCxWoc")))
 I Arg1=21  N str,qqw,qqo,qqwt,qqwt1,qqwt0,qqwc,qi,ii D  Q str ;стиль редактирования понятия
 .S str="",qqw=W("ZCxWoc"),qqo=W("ZCxObj"),qqwt0=$G(Vo(W("Zqqnump"),W("ZCxObj"),0,W("ZXy"),W("ZXx")))
 .S qqwt1=qARM.GetPar("X731",,W("ZCxObj"),W("ZXy"),W("ZXx"),W("Zqqnump"))
 .S qqwt=qARM.GetPar("x730",,W("ZCxObj"),W("ZXy"),W("ZXx"),W("Zqqnump"))
 .I '$G(WS(W("Zqqnump"),"ZBtred")),"679"'[(+qqwt) Q
 .I qqwt1>-1,qqwt=3 S str="Ввод даты по шаблону" Q
 .I $E(qqwt0)=4 S str="Возможна переустановка ФЛАГА" Q
 .I $S(qqwt1'="":1,1:$E(qqw)'="@") S:qqwt'=9 str=$ZCVT(qW.GetWoc("Cx731",+qqwt1),"U")_" "
 .Q:qqwt1<0
 .S str=str_$S('qqwt1:"Развертка (F9): ",1:"")_$ZCVT(qW.GetWoc("Cx730",+qqwt),"U")
 .Q:"@XLTM"[$E(qqw)
 .S qqwt=qARM.GetPar("x77",,W("ZCxObj"),W("ZXy"),W("ZXx"),W("Zqqnump")) ;вывод словаря
 .Q:'qqwt  ;нужны значения?
 .S str=str_$S(str="":"",1:$C(13,10))_"  ЗНАЧЕНИЯ"_$S(qqwt>2:" (первые 5)",1:"")_":"
 .I qqwt#2 S qqwc="" F ii=1:1 S qqwc=$O(^Q(qqlang,$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw),qqwc)) Q:$S(qqwc="":1,qqwt=3:ii>5,1:0)  D
 ..S str=str_$C(13,10)_$J(qqwc,10)_" "
 ..S:$E(qqw)'="D" str=str_$G(^(qqwc))
 ..;S Vo(qqnump,qqo,0,qi,2)="5qW.GG("""_$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw)_""",""XRef"","""_qqwc_""")"
 ..;S Vo(qqnump,qqo,0,qi,3)="5qW.GT("""_$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw)_""",""Thlp"","""_qqwc_""")"
 .I '(qqwt#2) S qqwc="" F ii=1:1 S qqwc=$O(^Q(qqlang,qqw,qqwc)) Q:$S(qqwc="":1,qqwt=4:ii>5,1:0)  D
 ..S str=str_$C(13,10)_" "_qqwc
 ..;S Vo(qqnump,qqo,0,qi,2)="5qW.GG("""_$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw)_""",""XRef"","""_$S("CD"[$E(qqw):qqwc,1:^(qqwc))_""")"
 ..;S Vo(qqnump,qqo,0,qi,3)="5qW.GT("""_$S($E(qqw)="C":qqw,$E(qqw)="D":qqw,1:"C"_qqw)_""",""Thlp"","""_$S("CD"[$E(qqw):qqwc,1:^(qqwc))_""")"
 I Arg1=173  N str,qqw,qq173,qq172,qqwc,qi,ii S str="" D  Q str ;стиль выхода из формы
 .S qq173=qARM.GetPar("173",,,,,W("Zqqnump")) Q:qq173=""  S qq172=qARM.GetPar("172",,,,,W("Zqqnump"))
 .I 'qq172 S str="Автоматическое закрытие окна при потере фокуса" Q
 .S str=qW.GetWoc("Cx173",+qq173)
 .I +qq172=1 S str=str_" экземпляра объекта" Q
 .;I +qq172=2 S str=str_" и формирование понятий экранной формы вызова: " S qq172=$P(qq172," ",2,255) F ii=1:1:$L(qq172,";") S qi=$P(qq172,";",)
 I Arg1=888 N str,ii D  Q str ;пояснения для действий
 .S ii="",str="" F  S ii=$O(^Q(1,"XView",Vo(W("Zqqnump")),"XQuest",qqc,"Thlp",ii)) Q:ii=""  S str=$S(str="":"",1:str_$C(13,10))_$G(^(ii))
 Q ""
viCN(comp)
 N qqref,qqtr,qqo,qqvv,qqnump,ret S qqnump=W("Zqqnump")
 S qqvv=$G(Vo(qqnump,W("ZCxObj"),889)) S:qqvv="" qqvv=Vo(qqnump) S qqo=$S($E(comp)="O":"CxObj",1:"Xx"),qqtr=+$G($$$Tree),$$$Tree=1,qqref=$S($E(comp)="O":$NA(^Q(1,"XView",qqvv)),1:$NA(^Q(1,"XView",qqvv,"CxObj",W("ZCxObj"),"Xy",W("ZXy"))))
 S ret=$S($E(comp)="O":qW.GT("CxObj","Thlp",W("ZCxObj")),1:qW.GT("Xx","Thlp",W("ZXx"))),$$$Tree=qqtr
 I $E(ret)="@" S Vs("par","Thlp")="Аналог "_$E($P(ret," "),2,255)_" "_$TR(qW.GetWoc($S($E(comp)="O":"CxObj",1:"CxWoc"),$E($P(ret," "),2,255)),"_"," ")_$C(13,10)_qW.GT($S($E(comp)="O":"CxObj",1:"CxWoc"),"Thlp",$E($P(ret," "),2,255))
 Q ret
]]></Implementation>
</Method>

<Method name="zDate">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N hd1,d1,hi S W("ZZdate")="",hd1=$ZDH(1_"/"_W("ZZmonth")_"/"_W("ZZyear"),4),hd1=hd1-(hd1+3#7)-1 ;$H и день недели первого числа
 F hi=1:1:42 S $P(W("ZZdate"),"/",hi)=+$ZD(hd1+hi,4)_$S(+$P($ZD(hd1+hi,4),"/",2)=+W("ZZmonth"):"",1:"~")
 Q ""
]]></Implementation>
</Method>

<Method name="zmList">
<Internal/>
<FormalSpec>qqwlst:%Library.String,qqc0:%Library.String,last:%Library.String,viewf:%Library.String,qqw:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;scloi(qqwlst,qqc0,last)
 S:$G(viewf)="" viewf=$$$Relind_qview
 I $G(qqw)'="" N list
 I qqwlst="" Q:$Q 1 Q
 N qii,qqoo,qqwold,cr,qlist,qlistz,qlisti,qlistzz S qqoo=$P(qqwlst,","),qqwold=$P(qqoo,":",2),qqoo=$P(qqoo,":",1),cr=$P(qqwlst,",",2),qqwlst=$P(qqwlst,",",3,1000) S:cr="" cr=32
 I '$D(qqc0) S qqc0=$E(qqc,1,$$$ObjLqqc(qqoo))
 S qlist=qqc0 F qii=0:1 S:qqc0=""||($G(qqw)="") qlist=$O(^Q(viewf,qqoo,qlist)) Q:qlist=""  Q:$S(qqc0="":0,$G(qqw)'="":qii||'$D(^Q(viewf,qqoo,qlist)),1:$E(qlist,1,$L(qqc0))'=qqc0)  D:'last  I ..zmList(qqwlst,qlist,last,viewf),last D
 .S qlistz="" F qlisti=1:1:$L(qqwold,"~") S qlistzz=$S($E($P(qqwold,"~",qlisti),1,4)'="ZTMP":qW.GG(qqoo,$P(qqwold,"~",qlisti),qlist),1:$G(^Q(viewf,qqoo,qlist,$P(qqwold,"~",qlisti)))) S:qlistzz'="" qlistz=$S(qlistz="":"",1:qlistz_" ")_qlistzz
 .S list=$S('$D(list):"",1:list_$S('qii:" ",cr=33:"!!",cr=13:" "_$C(13,10)_" ",cr=32:" ",1:" "_$C(cr)_" "))_qlistz  ;@dol 8.12.02 cr=33:"!!" - для формирования условий поискового образа
 .I $G(qqw)'="",qqc0="" S W(qqw,qii+1)=list,W(qqw,qii+1,0)=qlist K list
 I $G(qqw)'="" D
 .S qii="",W(qqw)="" F  S qii=$O(W(qqw,qii)) Q:qii=""  D:qqc0'=""   S:$D(W(qqw,qii)) W(qqw)=$S(W(qqw)="":"",1:W(qqw)_$C(13,10))_W(qqw,qii)
 ..Q:$G(W(qqw,qii,0))'=qqc0  I '$D(list) K W(qqw,qii) Q
 ..S W(qqw,qii)=list K list
 .I $D(list),qqc0'="" S qii=$O(W(qqw,""),-1)+1,W(qqw,qii,0)=qqc0,W(qqw,qii)=list,W(qqw)=$S(W(qqw)="":"",1:W(qqw)_$C(13,10))_W(qqw,qii)
 Q:$Q 'qii Q
]]></Implementation>
</Method>

<Method name="zmList1">
<Internal/>
<FormalSpec>qqwlst:%Library.String,qqc0:%Library.String,last:%Library.String,viewf:%Library.String,qqw:%Library.String,ref:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(viewf)="" viewf=$$$Relind_qview
 S:$G(ref)="" ref=$NA(^Q(viewf))
 I qqwlst="" Q:$Q "" Q 
 I $G(qqw)'="" N list,mas I $G(qqc0)'="" S mas=$NA(W("Y"_qqw,qqc0)) K @mas S:$D(^Q(viewf,qqw,qqc0)) @mas=""
 N qii,qqoo,qqwold,cr,qlist,qlistz,qlisti,qlistzz S qqoo=$P(qqwlst,","),qqwold=$P(qqoo,":",2),qqoo=$P(qqoo,":",1),cr=$P(qqwlst,",",2),qqwlst=$P(qqwlst,",",3,1000) S:cr="" cr=32
 I '$D(qqc0) S qqc0=$E(qqc,1,$$$ObjLqqc(qqoo))
 S qlist=qqc0 F qii=0:1 S:qqc0=""||($G(qqw)="")||1 qlist=$O(@ref@(qqoo,qlist)) Q:qlist=""  Q:$S(qqc0="":0,1:$E(qlist,1,$L(qqc0))'=qqc0)  S:$G(mas)'="" @mas@(qqoo,qlist)="" D:'last  I ..zmList1(qqwlst,qlist,last,viewf,,$G(ref)),last D
 .S qlistz="" F qlisti=1:1:$L(qqwold,"~") S qlistzz=$S($E($P(qqwold,"~",qlisti),1,4)'="ZTMP":qW.GG(qqoo,$P(qqwold,"~",qlisti),qlist),1:$G(@ref@(qqoo,qlist,$P(qqwold,"~",qlisti)))) S:qlistzz'="" qlistz=$S(qlistz="":"",1:qlistz_" ")_qlistzz
 .S list=$S('$D(list):"",1:list_$S('qii:" ",cr=33:"!!",cr=13:" "_$C(13,10)_" ",cr=32:" ",1:" "_$C(cr)_" "))_qlistz  ;@dol 8.12.02 cr=33:"!!" - для формирования условий поискового образа
 I $G(qqw)'="" S:$S($G(mas)="":0,1:$D(@mas)) @mas=$G(list) Q:$Q $G(list) Q
 Q:$Q 'qii Q
]]></Implementation>
</Method>

<Method name="zwrk1">
<Internal/>
<FormalSpec>nameG:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
    //sas 20090324 новое сохранение
    n refTmpGl s refTmpGl=$na($$$tmpGl(qARM("ComputerName")))
    s:$g(nameG)'="" refTmpGl=nameG  ;@Pav 20090324
    n actAfter
    ;s actAfter="d qW.StreemImp($na("_refTmpGl_"),$G("_$na($$$tmpGl("StreemImpRel"))_")) k ^QLog(""drowq""),"_refTmpGl
    s actAfter="d qW.StreemImp($na("_refTmpGl_")) k ^QLog(""drowq""),"_refTmpGl
    d ..savedatnew(qARM("qpars",0),refTmpGl,,,,,,,"K "_refTmpGl,actAfter,"k ^afteres") 
    q
    
    
    //старое сохранение
    n refTmpGl s refTmpGl=$na($$$tmpGl(qARM("ComputerName")))
    n actAfter
    s actAfter="s qARM(""ClientIP"")=""1.1.1.4"",qARM(""Password"")=""drowq"",qARM(""ClientPath"")=""D:\"",qARM(""CntStr"")=""cn_iptcp:127.0.0.1[1972]:test"",qARM(""ComputerName"")=""O"",qARM(""Screen"",""Height"")=600,qARM(""Screen"",""Width"")=800,qARM(""SectionIni"")=""test"" "
    s actAfter=actAfter_"s qa=##class(%TqARM).%New() d qa.Create(),qW.StreemImp($na("_refTmpGl_"),$G("_$na($$$tmpGl("StreemImpRel"))_")) k ^QLog(""drowq""),"_refTmpGl
    d ..savedat(qARM("qpars",0),"K "_refTmpGl,actAfter,"",refTmpGl,1) q
]]></Implementation>
</Method>
</Class>


<Class name="%Library.qWEB">
<IncludeCode>%qWORD</IncludeCode>
<Modified>0</Modified>
<ProcedureBlock>0</ProcedureBlock>
<Super>%Library.RegisteredObject,%CSP.Page</Super>
<TimeCreated>66787,41897.206426</TimeCreated>
<Inheritance>right</Inheritance>

<Property name="TestSOAP1">
<Type>%Library.String</Type>
<Internal/>
</Property>

<Property name="vBLOB">
<Type>%Stream</Type>
<Internal/>
</Property>

<Property name="vBLOBCurr">
<Type>%Integer</Type>
<Internal/>
<Private>1</Private>
</Property>

<Property name="vBLOBNode">
<Type>%String</Type>
<Internal/>
<Private>1</Private>
</Property>

<Property name="vBLOBempt">
<Type>%Stream</Type>
<Internal/>
<Private>1</Private>
</Property>

<Property name="vBLOBmk">
<Type>%Integer</Type>
<Internal/>
<Private>1</Private>
</Property>

<Property name="vBLOBvRLen">
<Type>%Integer</Type>
<Internal/>
<InitialExpression>15000</InitialExpression>
</Property>

<Method name="AnyTree">
<Description>
Вывод произвольного глобала в XML</Description>
<Internal/>
<FormalSpec>Root:%Library.String,Type:%Library.Integer,GG2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;GetXMLAnyTree(Root,Type,GG2)
 ; Root - имя узла, поддерево которого выводится
 ; Type - 0/1 - ордер обход/ квери обход
 ; GG2 - имя переменной, куда выводим, если пусто то по команде 'write'
 i $g(GG2)="" s GG2=""
 i GG2'="",$g(ii)="" n ii s ii=-1 ; счетчик ii вкл.при внешнем вызове этой функции
 n Lev,Str,DD,Node,NumInd
 i Type=0 d  q "" ; ордер обход
 .s Lev=0
 .s DD=$d(@Root)
 .i DD=0 s Str="<qw:var qw:name='"_Root_"'/>" q
 .i DD=1 s Str="<qw:var qw:name='"_Root_"' qw:value='"_@Root_"'/>" q
 .i DD=10 s Str="<qw:var qw:name='"_Root_"'>"
 .i DD=11 s Str="<qw:var qw:name='"_Root_"' qw:value='"_@Root_"'>"
 .i GG2="" w Str
 .e  s ii=ii+1,@GG2@(ii)=Str
 .d AnyTree2(Root)
 .i GG2="" w "</qw:var>"
 .e  s @GG2@(ii)=@GG2@(ii)_"</qw:var>"
 i Type=1 d  q "" ; квери обход
 .s DD=$d(@Root)
 .i (DD=1)!(DD=11) d
 ..s Str="<qw:var qw:name='"_Root_"' qw:value='"_@Root_"'/>"
 ..i GG2="" w Str
 ..e  s ii=ii+1,@GG2@(ii)=Str
 .s NumInd=$ql(Root)
 .s Node=Root f  s Node=$q(@Node) q:(Node="")!($na(@Node,NumInd)'=Root)  d
 ..s Str=$c(13,10)_"<qw:var qw:name='"_Node_"' qw:value='"_@Node_"'/>"
 ..i GG2="" w Str
 ..e  s ii=ii+1,@GG2@(ii)=Str
 q ""
AnyTree2(Parent)
 n Form,Ind
 s Lev=Lev+1
 s Form=$c(13,10)_$j("",Lev*2)
 s Ind="" f  s Ind=$o(@Parent@(Ind)) q:Ind=""  d  
 .s Node=$na(@Parent@(Ind))
 .s DD=$d(@Node)
 .i DD=0 s Str=Form_"<qw:index qw:name='"_Ind_"'/>" q
 .i DD=1 s Str=Form_"<qw:index qw:name='"_Ind_"' qw:value='"_@Node_"'/>" q
 .i DD=10 s Str=Form_"<qw:index qw:name='"_Ind_"'>"
 .i DD=11 s Str=Form_"<qw:index qw:name='"_Ind_"' qw:value='"_@Node_"'>"
 .i GG2="" w Str
 .e  s ii=ii+1,@GG2@(ii)=Str
 .d AnyTree2(Node)
 .i GG2="" w "</qw:index>"
 .e  s @GG2@(ii)=@GG2@(ii)_"</qw:index>"
 s Lev=Lev-1
 q
]]></Implementation>
</Method>

<Method name="BrScript">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 D ..write("<SCRIPT><xsl:comment><![CDATA["_$C(13,10))
 D ..write("var frInstHead=parent.frames(""InstHead"").document;")
 D ..write("var ObjTreeXML=parent.frames(""ObjTree"").document.XMLDocument;")
 D ..write("var lostTR,str,listObj;var condResize=0;")
 ;
 D ..write("function load(){style=document.XSLDocument;source=document.XMLDocument;frInstHead.write('<head></head><body style=\'background-color:#D0D0D0;\'><table border=0 cellspacing=0 cellpadding=0 width=100% id=\'head\' style=\'margin:0px;\'><tr><td width=100%>&nbsp</td></tr></table></body>');}")
 ;
 D ..write("function sethead(tr){if(lostTR!=null){lostTR.style.backgroundColor=tr.style.backgroundColor;};tr.style.backgroundColor='#c0c0c0';var id1;var tableInstHead=frInstHead.all('head');var point=tr.className.search('s');")
 D ..write("id1=ObjTreeXML.selectNodes('//Node[name=\''+tr.className.substring(1,point)+'\']/qStruct/qRow[@qNum=\''+tr.className.substring(point+1)+'\']/*');")
 D ..write("tableInstHead.deleteRow(0);tableInstHead.width=table.offsetWidth;var idrow=tableInstHead.insertRow(0);idrow.id=tr.className.substring(0,point);")
 D ..write("var idcell,attrName;var ind=0;for(var item=id1.nextNode();item;item=id1.nextNode())")
 D ..write("{idcell=idrow.insertCell();idcell.width=tr.cells(ind).offsetWidth;++ind;attrName=item.text;if(attrName!=''){attrName=ObjTreeXML.selectSingleNode('//Node[name=\''+attrName+'\']/c0').text;};")
 D ..write("idcell.insertAdjacentHTML('afterBegin','<button onclick=""parent.frames(\'InstTree\').sort(event.srcElement.parentElement)"" style=\'width:100%;cursor:hand;\' title=\''+attrName+'\'>'+attrName+'</button>');idcell.id=item.text;};")
 D ..write("window.event.cancelBubble=true;lostTR=tr;}  ;")
 ;
 D ..write("function sort(pInstHead){if(pInstHead.id==''){return};styleRel=style.cloneNode(true);var temp=template1(pInstHead.parentElement.id,1);styleRel.selectSingleNode('//*[@select=\''+temp+'\']').setAttribute('order-by','./'+((temp==pInstHead.parentElement.id)?'':'/'+pInstHead.parentElement.id+'/')+pInstHead.id);")
 D ..write("listing.innerHTML=source.documentElement.transformNode(styleRel);styleRel=null;lostTR=null;}")
 ;
 D ..write("function doresize(){if(lostTR==null){return};if(condResize){condResize=0;return;};frInstHead.all('head').width=table.offsetWidth;var i=0;for(var length=lostTR.cells.length;i<length;++i){frInstHead.all('head').rows(0).cells(i).width=lostTR.cells(i).offsetWidth;};window.event.cancelBubble=true;condResize=1}")
 ;
 D ..write("function doscroll(){var leftPos=this.document.body.scrollLeft; if(leftPos) {parent.frames('InstHead').scroll(leftPos,0);}}")
 ;
 D ..write("function refreshXSL(key){var temp1;var temp=ObjTreeXML.selectNodes('//Node[p1$ne$\'empty\']');")
 D ..write("for(var i=temp.nextNode;i;i=temp.nextNode){temp1=style.selectNodes('//xsl:template[@match=\'O'+i.selectSingleNode('name').text+'\']//xsl:if[xsl:apply-templates]/@expr');")
 D ..write("for(var item=temp1.nextNode();item;item=temp1.nextNode()){if(i.selectSingleNode('p1').text=='offobj'){item.nodeValue=0;}else{item.nodeValue=1;}}}")
 D ..write("if(key==1){refreshXML();}}")
 ;
 D ..write("function refreshXML(){listing.innerHTML=source.documentElement.transformNode(style);}")
 ;
 D ..write("function template()")
 D ..write("{var cond=ObjTreeXML.selectNodes('//Node[c1$ne$\'\']');if(!cond.length){alert('Не задан поисковый образ');return;};styleRel=style.cloneNode(true);var nameObj,tempObj;listObj='/';")
 D ..write("for(var item=cond.nextNode;item;item=cond.nextNode){tempObj='O'+item.selectSingleNode('qqPar').text;if(str==null){nameObj=tempObj;str='[';}else{if(tempObj!=nameObj){template1(nameObj,0);nameObj=tempObj;str='[';}else{str+='$and$'}};")
 D ..write("str+=convertPattern(item.selectSingleNode('name').text,item.selectSingleNode('c1').text);};template1(nameObj,0);str=null;listing.innerHTML=source.documentElement.transformNode(styleRel);styleRel=null;}")
 ;
 D ..write("function template1(obj,pSort){var test=((listObj!='/')?1:0);")
 D ..write("for(var i=source.selectSingleNode('//'+obj);i.attributes.item(0).nodeValue.length>2;i=i.parentNode)")
 D ..write("{if(!pSort){template2(i.parentNode.nodeName,i.nodeName,test);")
 D ..write("if(listObj.search('/'+i.parentNode.nodeName+'/')==-1){listObj+=i.parentNode.nodeName+'/';};")
 D ..write("if(i.nodeName==obj){template2(i.nodeName,'',test);str='[.//'+obj+str+']';")
 D ..write("if(listObj.search('/'+i.nodeName+'/')==-1){listObj+=i.nodeName+'/'}}}")
 D ..write("else{if(i.parentNode.attributes.item(0).nodeValue.length<=3){return i.nodeName}}}}")
 ;
 D ..write("function template2(objPar,objCurr,test){var temp,temp1;if((!test)||(listObj.search('/'+objPar+'/')==-1))")
 D ..write("{temp=styleRel.selectNodes('//xsl:template[@match=\''+objPar+'\']/xsl:if[xsl:apply-templates]');for(temp1=temp.nextNode;temp1;temp1=temp.nextNode)")
 D ..write("{if(temp1.firstChild.attributes.item(0).nodeValue==objCurr){temp1.attributes.item(0).nodeValue=1;temp1.firstChild.attributes.item(0).nodeValue=objCurr+str+']';}")
 D ..write("else{temp1.attributes.item(0).nodeValue=0}}}")
 D ..write("else{if(objCurr!=''){temp=styleRel.selectSingleNode('//xsl:template[@match=\''+objPar+'\']/xsl:if[xsl:apply-templates/@select=\''+objCurr+'\']');")
 D ..write("if(temp!=null){temp.attributes.item(0).nodeValue=1;temp.firstChild.attributes.item(0).nodeValue=objCurr+str+']';}")
 D ..write("else{temp=styleRel.selectSingleNode('//xsl:template[@match=\''+objPar+'\']/xsl:if[xsl:apply-templates[@select$gt$\''+objCurr+'['+'\'$and$@select$lt$\''+objCurr+'\\\\'+'\']]');")
 D ..write("temp.attributes.item(0).nodeValue=1;temp=temp.firstChild.attributes.item(0);temp.nodeValue=temp.nodeValue.substring(0,temp.nodeValue.length-1)+'$and$'+str.substring(1,str.length)+']';}}}}")
 ;
 D ..write("function convertPattern(attr,patt){if(patt.substring(patt.length-1,patt.length).charCodeAt(0)==42)")
 D ..write("{patt=patt.substring(0,patt.length-1);return '(.//'+attr+'$gt$\''+patt+'\'$and$.//'+attr+'$lt$\''+patt.substring(0,patt.length-1)+String.fromCharCode(patt.substring(patt.length-1,patt.length).charCodeAt(0)+1)+'\')';}")
 D ..write("else{return './/'+attr+'=\''+patt+'\'';}}")
 ;
 D ..write($C(13,10)_"]]]]><![CDATA[></xsl:comment></SCRIPT>")
 Q ""
]]></Implementation>
</Method>

<Method name="Browser">
<Internal/>
<FormalSpec>full:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 ;D ..XMLB(1,full)
 ;D qARM.OpenIE(1,qARM("ClientPath")_"XML\qwordb.xml",0)
 ;
 ;D ..XSL(2,full,"",1)
 ;D qARM.OpenIE(2,qARM("ClientPath")_"XML\qword.xsl",0)
 ;
 D ..XML(3,full,1)
 D qARM.OpenIE(3,qARM("ClientPath")_"XML\qword.xml",0)
 D qARM.OpenIE("",qARM("ClientPath")_"XML\ex_frame.htm",1)
 Q ""
]]></Implementation>
</Method>

<Method name="ClientPath">
<Description>
Метод используется для получения пути, по которому создаются выходные файлы.
    XFuprof (%UserProfile):
    Если флаг установлен, для временных файлов и выходных форм используется папка "qWORD-XML" в
    домашнем каталоге пользователя.
    Если флаг не установлен - подпапка с именем компьютера в папке qARM.
! Имя метода не совсем корректно - это не путь к клиенту.</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[ Q $G(qARM("WorkPath")) ; Dima 20081029
]]></Implementation>
</Method>

<Method name="CloseDev">
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I Arg1'="",Arg1'?1.N C Arg1
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="Diag">
<Description>
Построение диаграммы. 
@Dol 05.03.10 Заменено на формирование массива ^CacheTempDiagXML($J) и отображение для его вывода (через общий алгоритм). Старый вариант в qSYS.Diag
Arg1 =1-VRML, 2 -IE,3-Word, 4-Excel,5- htm -файл
OpenFile - (1 или пусто) - открывать файл, 0 - нет
01.02.2011 @rda @gol для ячеек с итогами добавлен учет цвета фона (берется из настроек запроса понятие XQtc)</Description>
<Internal/>
<FormalSpec>Arg1:%String,view:%String,diagfile:%Library.String,OpenFile:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N Message
 S:'$D(Arg1) Arg1=$G(Vs(qqnump,13,"R")) I Arg1<1 Q "????"
 S:'$D(view) view=qview
 S:$G(diagfile)="" diagfile="qwordD" S diagfile=$P(diagfile,".")
 ;если вывод в IE,Word или Excel, количество аналитик больше 2 и признак XYZ, то выполняем метод DiagWE
 S Vs(qqnump,13,"Xp")=0 I $G(Vs(qqnump,13,"X")),$O(Vs(qqnump,13,3,""),-1)>2||($O(Vs(qqnump,13,1,""),-1)'=1)||$G(Vs(qqnump,99,"Anal",2)) S Vs(qqnump,13,"X")=0 S Vs(qqnump,13,"Xp")=1 ;@Dol 28.11.06 ;;I Arg1>1,Arg1<5,$O(Vs(qqnump,13,3,""),-1)>2,$G(Vs(qqnump,13,"X")) S Message=..DiagWE("A"_view,Arg1-2) Q Message
 S Message=qSYS.CreArDi("A"_view,$S(Arg1>1:100000,1:1000)) Q:'Message $E(Message,2,1000)
 If ( +$G(Vs(qqnump,13,"R")) = 6 ) d ..OpenWebDiag()  Q ""
 ;If ( +$G(Vs(qqnump,13,"R")) = 7 ) d qARM.Message("Диаграмма qWORD")  Q "" //@AKA 08.02.2011
 I Vs(qqnump,13,"Xp") S Vs(qqnump,13,"X")=1
 I $G(qqXBPrttoOOW),$G(Arg1)=3||($G(Arg1)=4) S Arg1=12
 N qqnumpold,xyz S xyz=$G(Vs(qqnump,13,"X"))&'$D(QDiagI),qqnumpold=qqnump D qARM.csav() 
 N par,leg,sum,sumx,sump,sumxp,sumn,qqnump,y,y1,y2,x,x1,xmax,ymax,qqdev,oZVs8,yadd,xstr,ftree,zz,flist,flistP,nP,flist1,xp,Xp,flistN,XQth,XQia,XQtc
 S qqnump="D",ymax=$O(QDiag(""),-1)+xyz,xmax=$O(QDiag(0,""),-1) ;xyz - трехмерная ;Xp
 S ftree=$G(Vs(qqnumpold,99,"Anal",2)) S:xyz ftree=0 ;полное дерево
 I ftree S ftree=ftree_" ",y="" F  S y=$O(Vs(qqnumpold,13,3,y)) Q:y=""  S x=Vs(qqnumpold,13,3,y) I $G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),3,1)) S ftree=ftree_y_" " ;список неподсчитываемых сумм по аналитикам
 S (flist1,flist,flistN)=" ",y="",flistP="" F  S y=$O(Vs(qqnumpold,13,1,y)) Q:y=""  S x=Vs(qqnumpold,13,1,y) S:$G(Vs(qqnumpold,13,0,x,1)) flistN=flistN_y_" " I $P(x," ",3)=6,$G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),4,1)) S flist=flist_y_" " S:$G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),4,1))=1||($G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),4,1))=4) flist1=flist1_y_" " S:$G(Vs(qqnumpold,12,$P(x," "),$P(x," ",2),4,1))=3 flistP=flistP_y_" " ;неподсчитываемые суммы, flist1 - список первых/последних значений, flistP - полные списки;@Dol 22.01.10 4 - последнее;@Dol 22.09.10 flistN - Без сумм
 I flistP'="" S flistP=" "_flistP ;@Dol 1.10.08 полные списки
 I $G(qqoQu)="" N qqoQu,query S qqoQu=99999,query=9999 ;если не запрос
 I $G(query)="" S query=9999 ;@Dol 30.04.09
 ;создание отображения в памяти
 S par=$G(Vs(qqnumpold,13,"R")) ;@Dol 30.04.09 доп.пар. $P(par," ",8)- размер колонки Nп\п, 9 - повтор одинаковых, 10- наследование типа данных аналитик , 11 - наследование параметров аналитик, 12, 13 - агрегатов (12 пока не работает), 14 -Nп.п для A1, 15 - без ИТОГО, 16 - замена пустых (???)
 K Vo(qqnump) S Vo(qqnump)="XXXDiagXML"
 S Vo(qqnump,-1)="Таблица диаграммы"
 S yadd=$L(QDiag(0,0),"~") ;дополнительные колонки (если многомерная диаграмма и не установлено xyz)
 S xp=$G(Vs(qqnumpold,13,"Xp")) I xp D  ;@Dol 10.03.09 раскладка по последнему измерению
 .I $D(QDiagI) M:ftree sum=QDiagI F y1=1:1:ymax I $G(QDiagI(y1))'="" S QDiagI(y1)=0 ;сброс итоговых сумм для пересчета
 .S zz=1 F x=1:1:xmax D
 ..S y=$G(Xp(0,$P(QDiag(0,x),"~",yadd))) I 'y S y=$I(Xp),Xp(0,$P(QDiag(0,x),"~",yadd))=y,Xp(y)=$P(QDiag(0,x),"~",yadd) F y1=1:1:ymax S y2=ymax*(y-1)+y1 S:flist[(" "_y1_" ") flist=flist_y2_" " S:flist1[(" "_y1_" ") flist1=flist1_y2_" " S:flistP[(" "_y1_" ") flistP=flistP_y2_" " S:flistN[(" "_y1_" ") flistN=flistN_y2_" "
 ..I x>1 S zz=$S($P(QDiag(0,x),"~",1,yadd-1)=$P(QDiag(0,zz),"~",1,yadd-1):zz,1:x)
 ..F y1=1:1:ymax D
 ...S y2=ymax*(y-1)+y1 I $G(QDiagI(y1))'="",$I(QDiagI(y2),QDiag(y1,x))!1,ftree,ftree'[(" "_yadd_" "),$I(sumn(zz,y1),QDiag(y1,x))
 ...Q:y=1&&(zz=x)  S QDiag(y2,zz)=QDiag(y1,x),QDiag(y1,x)=""
 ..K:zz'=x QDiag(0,x)
 .I ftree,ftree'[(" "_yadd_" ") S Xp=Xp+1,Xp(Xp)="Всего" D
 ..F x=1:1:xmax I $D(sumn(x))>1 F y1=1:1:ymax I $D(sumn(x,y1)) S QDiag(ymax*(Xp-1)+y1,x)=sumn(x,y1)
 ..F y1=1:1:ymax I $D(sum(y1)) S QDiagI(ymax*(Xp-1)+y1)=sum(y1)
 .K sum,sumn
 .S yadd=yadd-1,xp=ymax,ymax=ymax*Xp
 S Vo(qqnump,-1,9)=ymax+yadd ;+1 для N
 S $$$Tree=0
 S XQth=+$G(^Q(1,qqoQu,query,"XQth")) ;повторяющийся заголовок таблицы  2011/01/28
 S XQia=+$G(^Q(1,qqoQu,query,"XQia")) ;заменять в  промежуточных итогах "**ВСЕГО" на занчение аналитики 2011/01/28
 S XQtc=$S($G(Vs(qqnumpold,99,"Anal",2)):$G(^Q(1,qqoQu,query,"XQtc")),1:"") ;цвет фона для ячеек итогов
 S leg=$G(^Q(1,qqoQu,query,"XQLeg")) ;S:leg="" leg=ymax>5 ;&xyz ;вывести легенду
 D:'leg
 .S Vo(qqnump,-1,0,6)="Xy" ;ссылка на объект Xy (если будут еще строки в объекте -1, заменить 5 на первую свободную
 .F y=0:1:ymax-''xyz D
 ..I y D  Q
 ...S x=$$DiagCol(y,1) I $P(x,",",1)="",$P(par," ",13) S x=$$DiagPar(y,1)
 ...S x1="" I $P(par," ",12) S x1=$$DiagName(y,1)
 ...S y1=y+yadd S:'x Vo(qqnump,-1,0,0,y1,2)=$S($P(x,",")=0:0,1:8) S Vo(qqnump,-1,0,5,y1)="0"_$S(y=ymax&xyz:"ВСЕГО",x1'="":x1,1:$TR($G(QDiag($S($G(xp):$S(y#xp:y#xp,1:xp),1:y),0)),"_"," ")),Vo(qqnump,-1,0,5,y1,2)=",1,5,,1,,,,,2" ;@Dol $S($P(x,",")=0:0,1:8) для зачеркивания  колонок
 ...S:Vo(qqnump,-1,0,5,y1)[";;" Vo(qqnump,-1,0,5,y1)="0"_$P(Vo(qqnump,-1,0,5,y1),";;",2) ;@Dol 20.05.10 для A и D
 ...S Vo(qqnump,"Xy",0,0,y1,64)=1,Vo(qqnump,"Xy",0,0,y1)="5$G(^CacheTempDiagXML($J,qqc,"_y1_"),""~"")" S x1=$$Diag710(y,1) S:x1'="" Vo(qqnump,"Xy",0,0,y1,10)=x1 ;тип данных ;@Dol 23.09.10 было I $P(par," ",12) S x1=
 ...S Vo(qqnump,"Xy",0,0,y1,2)=$S(x'="":x,1:","_$S(flist[(" "_y_" "):",",1:"2,")_",,,,,,,2") 
 ...S:$P(Vo(qqnump,"Xy",0,0,y1,2),",",2)=""&&(flist'[(" "_y_" ")) $P(Vo(qqnump,"Xy",0,0,y1,2),",",2)=2 Q  ;@Dol 29.09.08 flist
 ..F y1=0:1:yadd D
 ...S x=$$DiagCol(y1,3) I $P(x,",",1)="",y1,$P(par," ",11) S x=$$DiagPar(y1,3)
 ...S x1="" I y1,$P(par," ",11) S x1=$$DiagName(y1,3)
 ...S Vo(qqnump,-1,0,0,y1,2)=$S('y1:$S($P(par," ",8)="":2,1:$P(par," ",8)),$P(x,",")'="":$P(x,","),y1=1:20,1:10)
 ...S Vo(qqnump,-1,0,5,y1)="0"_$S('y1:$C(185),x1'="":x1,1:$TR($P(QDiag(y,0),"~",y1),"_"," "))
 ...S:Vo(qqnump,-1,0,5,y1)[";;" Vo(qqnump,-1,0,5,y1)=$P(Vo(qqnump,-1,0,5,y1),";;",1) ;@Dol 20.05.10 для A и D
 ...S Vo(qqnump,-1,0,5,y1,2)=",1,5,,1,,,,,2"_$S(XQth=1:",,,,,,,1",1:""),Vo(qqnump,"Xy",0,0,y1)="5$G(^CacheTempDiagXML($J,qqc,"_y1_"),""~"")"
 ...S:(y1=1)&&(XQtc'="") Vo(qqnump,"Xy",0,0,y1,20)="@$S($G(^CacheTempDiagXML($J,qqc,"""_y1_"x720""))=1:""*0,"_XQtc_",,,1"",1:"""")"
 ...I y1 S x1=$$Diag710(y1,3) S:x1'="" Vo(qqnump,"Xy",0,0,y1,10)=x1 ;тип данных ;@Dol 23.09.10 было I y1,$P(par," ",10)
 ...S Vo(qqnump,"Xy",0,0,y1,64)=1,Vo(qqnump,"Xy",0,0,y1,2)=$S(x'="":x,1:","_$S('y1:$S($P(par," ",8)="":2,1:$P(par," ",8))_",,,1",1:",,,")_",,,,,2") ;c обрамлением ячеек
 .F y1=0:1:$O(Vo(qqnump,"Xy",0,0,""),-1) D DiagParC ;@Dol 20.05.10
 .Q:'xp  S Vo(qqnump,-1,0,4,0)="0"_$TR($P(QDiag(0,0),"~",yadd+1),"_"," ")_": ",Vo(qqnump,-1,0,4,0,2)=",2,,,,,,,,2"_$S(XQth=1:",,,,,,,1",1:""),x=0 F y=yadd+1:xp:ymax+yadd S Vo(qqnump,-1,0,4,y)="0"_Xp($I(x)),Vo(qqnump,-1,0,4,y,2)=",1,,,1,,,,,2"
 D:leg
 .F y=1:1:ymax-''xyz S Vo(qqnump,-1,0,3+y,1)="0"_$J(y,3)_"."_$TR(QDiag($S($G(xp):y#xp+1,1:y),0),"_"," ") ;0->1
 .F y=0:1:ymax D
 ..I y D  Q
 ...S x=$$DiagCol(y,1) I $P(x,",",1)="",$P(par," ",12) S x=$$DiagPar(y,1)
 ...S y1=y+yadd S:'x Vo(qqnump,-1,0,0,y1,2)=$S($P(x,",")=0:0,1:8) S Vo(qqnump,-1,0,3+ymax+1,y1)="0"_$S(y=ymax&xyz:"ВСЕГО:",1:$C(160)_y_$C(160)),Vo(qqnump,-1,0,3+ymax+1,y1,2)=",1,5,,1,,,,,2",Vo(qqnump,"Xy",0,0,y1)="5$G(^CacheTempDiagXML($J,qqc,"_y1_"),""~"")" S Vo(qqnump,"Xy",0,0,y1,2)=$S(x'="":x,1:","_$S(flist[(" "_y_" "):",",1:"2,")_",,,,,,,2") Q  ;c обрамлением ячеек
 ..F y1=0:1:yadd D
 ...S x=$$DiagCol(y1,3) I y1,$P(par," ",11) S x1=$$DiagName(y1,3)
 ...S Vo(qqnump,-1,0,0,y1,2)=$S('y1:$S($P(par," ",8)="":2,1:$P(par," ",8)),$P(x,",")'="":$P(x,","),y1=1:20,1:10),Vo(qqnump,-1,0,3+ymax+1,y1)="0"_$S('y1:$C(185),1:$TR($P(QDiag(y,0),"~",y1),"_"," ")),Vo(qqnump,-1,0,3+ymax+1,y1,2)=",1,5,,1,,,,,2",Vo(qqnump,"Xy",0,0,y1)="5$G(^CacheTempDiagXML($J,qqc,"_y1_"),""~"")" S Vo(qqnump,"Xy",0,0,y1,2)=$S(x'="":x,1:","_$S('y1:$S($P(par," ",8)="":2,1:$P(par," ",8))_",,,1",1:",,,")_",,,,,2") ;c обрамлением ячеек
 .S Vo(qqnump,-1,0,3+ymax+('xyz),0)="0 " ;пустая строка
 .S Vo(qqnump,-1,0,3+ymax+2+('xyz))="Xy"
 S Vo(qqnump,"Xy",2)=6,Vo(qqnump,"Xy",33)="^CacheTempDiagXML($J)",Vo(qqnump,"Xy",27)="qqc"
 S Vo(qqnump,-1,65)=2 ;вывод пустых
 ;
 S Vo(qqnump,-1,3,21)=0 ;вывод в виде бланка
 I $G(^Q(1,qqoQu,query,"XQnp")),'$G(qqXBPrttoOOW) S Vo(qqnump,-1,3,62)="XXXNumPageR",Vo(qqnump,-1,3,620)=0 ;@Dol 05.03.10 колонтитул с номером страницы (пока для OOW нельзя)
 S Vo(qqnump,-1,3,691)=1 ;сохранять размеры колонок
 S Vo(qqnump,-1,3,698)=1 ;учет динамических параметров
 S Vo(qqnump,-1,3,699)=''$G(^Q(1,qqoQu,query,"XQew"))  ; @rda 20110408 учет флага "Не вписывать в ширину страницы" для печати в Excel
 S Vo(qqnump,-1,3,641)="1pt 1pt 1pt 1pt" ;отступы
 S Vo(qqnump,-1,3,64)=$S($G(^Q(1,qqoQu,query,"X364"))'="":^("X364"),1:" "_(ymax+yadd>7)_"  10  10") S:$P(Vo(qqnump,-1,3,64)," ",1)="" $P(Vo(qqnump,-1,3,64)," ",1)="A4" S:'$P(Vo(qqnump,-1,3,64)," ",4) $P(Vo(qqnump,-1,3,64)," ",4)=10 S:'$P(Vo(qqnump,-1,3,64)," ",6) $P(Vo(qqnump,-1,3,64)," ",6)=10 ;параметры страницы ;больше 7 колонок - албом
 S Vo(qqnump,-1,3,55)=$S($G(^Q(1,qqoQu,query,"X355"))'="":^("X355"),1:",9") ;основной фонт
 K ^CacheTempDiagXML($J)
 ;Vs(qqnumpold,120,2) - заголовок аналитики (первая строка - заголовок, затем строки подвала)
 S x=$G(^Q(1,qqoQu,query,"XQTitle")) S:$E(x)="@" @("x="_$E(x,2,30000)) S:x="" x=$P($G(Vs(qqnumpold,120,2)),$C(13,10))
 F x1=0:1:5 Q:$P($G(Vo(qqnump,-1,0,0,x1,2)),",")'=0  ;02.06.09 первая незачеркнутая
 I x="" S Vo(qqnump,-1,0,1,x1)="0"_$S(x'="":x,1:"Таблица распределения """_$TR(QDiag(0,0),"~","/")_$S('xyz:"",1:" ("_$P(QDiag," ",5,255)_")")_""""),Vo(qqnump,-1,0,1,x1,2)=",1,1,10,1" I 1
 E  D  ;@Dol 28.07.10 печать шапки по строкам
 .S Vo(qqnump,-1,0,1)="s"
 .S Vo(qqnump,"s",2)=6,Vo(qqnump,"s",33)="^CacheTempDiagXML($J,""s"")",Vo(qqnump,"s",0,0,x1)="5$G(^CacheTempDiagXML($J,""s"",qqc))",Vo(qqnump,"s",0,0,x1,64)=1
 .;S y1=$F(x,"<") S:y1 y1=$F(x,"</"_$P($E(x,y1,y1+255),">"),y1) ;есть XML-теги
 .I $ZCVT($E(x,1,5),"U")="NOPAR" S x=$E(x,6,32000) I 1 ;без параметров (центр, размер шрифта 10, выделенный)
 .E  S Vo(qqnump,"s",0,0,x1,2)=",1,1,10,1"
 .F y1=1:1:$L(x,$C(13,10)) S ^CacheTempDiagXML($J,"s",y1)=$P(x,$C(13,10),y1)
 ; X3694 - вывод поискового образа,  XQfcond - выражение для его обработки
 s XQfcond=$G(^Q(1,qqoQu,query,"XQfcond")) s:$E(XQfcond)="@" @("XQfcond="_$E(XQfcond,2,30000))  ;@gol 11/02/2011
 S oZVs8=$S($G(^Q(1,qqoQu,query,"X3694"),qqoQu=99999):$s(XQfcond'="":XQfcond,1:qW.oZVs8(qqnumpold,,0)),1:"")
 I oZVs8'="" S Vo(qqnump,-1,0,2,x1)="5$G(^CacheTempDiagXML($J,""Z8""))",Vo(qqnump,-1,0,2,x1,10)=3,Vo(qqnump,-1,0,2,x1,64)=1 do  S ^CacheTempDiagXML($J,"Z8")=oZVs8 ;@Dol 29.03.10 qqoQu=99999 - выводится, если не запрос
 .I $ZCVT($E(oZVs8,1,5),"U")="NOPAR" S oZVs8=$E(oZVs8,6,32000) I 1 ;без параметров ( выделенный)
 .E  s Vo(qqnump,-1,0,2,x1,2)=",1,1"
 S Vo(qqnump,-1,0,3,x1)="0 " ;пустая строка
 S x=$G(^Q(1,qqoQu,query,"XQUnd")) S:$E(x)="@" @("x="_$E(x,2,30000)) S:x="" x=$P($G(Vs(qqnumpold,120,2)),$C(13,10),2,255)
 D:x'=""  ;@Dol 28.07.10 подвал по строкам
 .S y=$O(Vo(qqnump,-1,0,""),-1)+1
 .S Vo(qqnump,-1,0,y,x1)="0 " ;пустая строка
 .;F y1=1:1:$L(x,$C(13,10)) S y=y+1,Vo(qqnump,-1,0,y,x1)="0"_$P(x,$C(13,10),y1),Vo(qqnump,-1,0,y,x1,2)=",,1,,1"
 .S Vo(qqnump,-1,0,y+1)="p"
 .S Vo(qqnump,"p",2)=6,Vo(qqnump,"p",33)="^CacheTempDiagXML($J,""p"")",Vo(qqnump,"p",0,0,x1)="5$G(^CacheTempDiagXML($J,""p"",qqc))",Vo(qqnump,"p",0,0,x1,64)=1
 .I $ZCVT($E(x,1,5),"U")="NOPAR" S x=$E(x,6,32000) I 1 ;без параметров ( выделенный)
 .E  S Vo(qqnump,"p",0,0,x1,2)=",,1,,1"
 .F y1=1:1:$L(x,$C(13,10)) S ^CacheTempDiagXML($J,"p",y1)=$P(x,$C(13,10),y1)
 D qSYS.CreVoAdd()
 ;K ^CacheTempDiagXML($J)
 ;I oZVs8'="" S ^CacheTempDiagXML($J,"Z8")=oZVs8
 S xstr="",sumxp=$G(QDiag(1,1))["%"
 N num1,num0 S:$P(par," ",14) num1=0 S num0=0 ;@Dol 20.01.10 num0 - счетчик строк (вместо x)
 F x=1:1:xmax D:$D(QDiag(0,x))
 .D DiagWr() S sum=0,sump=0,zz=QDiag(0,x) ;"<OXy>"
 .S nP=0 F y=0:1:ymax D
 ..I y,ftree F y1=1:1:yadd-1 I $E(ftree,2,255)'[(" "_y1_" "),$I(sumn($P(zz,"~",1,y1),y)),$I(sum($P(zz,"~",1,y1),y),$G(QDiag(y,x))) ;@Dol 1.12.06 промежуточные суммы
 ..I y,xyz D
 ...S sum=$G(sum)+$G(QDiag(y,x)),sumx(y)=$G(sumx(y))+$S(y=ymax:sum,1:$G(QDiag(y,x))) ;sym - сумма по ряду, symx(y) - по колонке
 ...I $G(sumxp) S sump=$G(sump)+$P($G(QDiag(y,x)),"/",2),sumxp(y)=$G(sumxp(y))+$S(y=ymax:sump,1:$P($G(QDiag(y,x)),"/",2)) ;если %
 ..I y S y1=y+yadd S:$G(QDiag(y,x))["???"&&($TR($P(par," ",16),"?")'="") QDiag(y,x)=qW.zChSym(QDiag(y,x),"???",$P(par," ",16)) D DiagWr(y1,$S(y=ymax&xyz:sum_$S('sumxp:"",1:"%/"_sump),flist'[(" "_y_" "):$S($G(Vo(qqnump,"Xy",0,0,y1,10))'="":qW.GtoExt(Vo(qqnump,"Xy",0,0,y1,10),$P($G(QDiag(y,x))," ")),1:$P($G(QDiag(y,x))," ")),flistP[(" "_y_" "):$TR($P($G(QDiag(y,x))," "),"_"," "),flist1[(" "_y_" "):$TR($G(QDiag(y,x)),"_"," "),1:$G(QDiag(y,x)))) D:flistP[(" "_y_" ")  Q  ;qW.GtoExt(2,QDiag(y,x),,,1)
 ...I nP<$L($G(QDiag(y,x))," ") S nP=$L($G(QDiag(y,x))," ")
 ..I ftree,xstr'="",$P(QDiag(y,x),"~",1,yadd-1)'=$P(xstr,"~",1,yadd-1) F y1=yadd-1:-1:1 I $E(ftree,2,255)'[(" "_y1_" "),$P(QDiag(y,x),"~",1,y1)'=$P(xstr,"~",1,y1),$G(sumn($P(xstr,"~",1,y1),1))>1 D  ;@Dol 1.12.06 промежуточные итоги;23.12.09 Было $G(sumn($P(xstr,"~",1,y1),y1))>1
 ...D DiagWr(0," ") F y2=1:1:y1 D DiagWr(y2,$S(y2<y1&('$P(par," ",9)||'XQia):" ",XQia:"<b>"_$TR($P(xstr,"~",y2),"_"," ")_"</b>",1:"*ВСЕГО:")) ;замена текста ВСЕГО на аналитику (если она есть)  2010/01/28
 ...F y2=1:1:ymax I flist_flistN'[(" "_y2_" ") S x1=$G(sum($P(xstr,"~",1,y1),y2)) S:$G(Vo(qqnump,"Xy",0,0,(y2+yadd),10))'="" x1=qW.GtoExt(Vo(qqnump,"Xy",0,0,(y2+yadd),10),x1) D DiagWr((y2+yadd),"<b>"_x1_"</b>")
 ...D DiagWr()
 ..F y1=0:1:yadd S x1=$S('y1:$S($G(num1)="":$I(num0),($P(QDiag(y,x),"~",1,$P(par," ",14))=$P(xstr,"~",1,$P(par," ",14))):"",1:$I(num1)),xyz:$TR($P(QDiag(y,x),"~",y1),"_"," "),'$P(par," ",9)&&($P(QDiag(y,x),"~",1,y1)=$P(xstr,"~",1,y1)):" ",1:$TR($P(QDiag(y,x),"~",y1),"_"," ")) S:x1["@#@" @("x1="_$P(x1,"@#@",2,255)),x1=$TR(x1,"_"," ") S:x1="???"&&($P(par," ",16)'="") x1=$P(par," ",16) S:x1'=""&&($G(Vo(qqnump,"Xy",0,0,y1,10))'="") x1=qW.GtoExt(Vo(qqnump,"Xy",0,0,y1,10),x1) D DiagWr(y1,x1) ;@Dol 29.06.09 x1["@#@" ;20.01.10 x->$I(num0) ;@Dol 23.07.10 $TR для @#@
 ..S:'xyz xstr=QDiag(y,x)
 .I nP>1 F nP=2:1:nP D DiagWr() D  ;@Dol 1.10.08 строки для полных списков
 ..D DiagWr(0," ") F y=1:1:ymax S y1=y+yadd D DiagWr(y1,$S(y=ymax&xyz:"",flistP[(" "_y_" "):$TR($P($G(QDiag(y,x))," ",nP),"_"," "),1:""))
 .I ftree,x=xmax  F y1=yadd-1:-1:1 I $E(ftree,2,255)'[(" "_y1_" "),$G(sumn($P(xstr,"~",1,y1),1))>1 D  ;23.12.09 Было $G(sumn($P(xstr,"~",1,y1),y1))>1
 ..D DiagWr() D DiagWr(0," ") F y2=1:1:y1 D DiagWr(y2,$S(y2<y1&('$P(par," ",9)||'XQia):" ",XQia:"<b>"_$TR($P(xstr,"~",y2),"_"," ")_"</b>",1:"*ВСЕГО:")) ;замена текста ВСЕГО на аналитику (если она есть)  2010/01/28 ;@Dol 26.09.08
 ..F y2=1:1:ymax I flist_flistN'[(" "_y2_" ") S x1=$G(sum($P(xstr,"~",1,y1),y2)) S:$G(Vo(qqnump,"Xy",0,0,(y2+yadd),10))'="" x1=qW.GtoExt(Vo(qqnump,"Xy",0,0,(y2+yadd),10),x1) D DiagWr(y2+yadd,"<b>"_x1_"</b>")
 ; ОБЩИЕ ИТОГИ
 D:$D(QDiagI)&&'$P(par," ",15)  ;Всего @dol 25.12.02
 .S y="",x=0 F  S y=$O(QDiagI(y)) Q:y=""  I flist_flistN'[(" "_y_" ") S x=$TR($G(QDiagI(y))," ")'="" Q:x  ;@Dol 30.04.09 пустые итоги
 .Q:'x
 .D DiagWr()
 .F y=0:1:ymax D
 ..I y s y1=y+yadd D:flist_flistN'[(" "_y_" ") DiagWr(y1,$S($G(Vo(qqnump,"Xy",0,0,y1,10))'="":qW.GtoExt(Vo(qqnump,"Xy",0,0,y1,10),$G(QDiagI(y))),1:$G(QDiagI(y)))) Q
 ..S x1=0 F y1=0:1:(ymax+yadd) S:'x1 x1=y1&&($P($G(Vo(qqnump,-1,0,0,y1,2)),",")'=0) D DiagWr(y1,$S(x1=1:"ИТОГО:",1:"  ")),DiagWr(y1_"x720","1") S:x1=1 x1=2  ;@rda yadd -> yadd+ymax ?
 D:xyz  ;Всего @dol 25.12.02
 .D DiagWr()
 .F y=0:1:ymax S y1=y+1 D DiagWr(y1,$S('y:"ИТОГО:",y=ymax&sumxp:"100%/"_sumxp(y),1:$G(sumx(y))_$S('sumxp:"",1:"%/"_sumxp(y)))),DiagWr(y1_"x720","1") ;@dol 16.01.02
 ;
 S $$$CurObj=-1,$$$ID="",qqc="",$$$ReFind="",$$$RelNum=0,$$$Relind=0
 S Vo(qqnump,-1,30)=0
 S %1=..Print($J,0,Arg1-2,$G(OpenFile),,10) I %1'="" D qARM.Message(%1) Q:$Q "" Q  ; tdv 20100901 - добавлен OpenFile
 D qARM.crst(,qqnumpold,1) ;@Dol 12.03.10
 Q $E(Message,2,1000)
DiagCol(ycol,y13) ;параметры колонки (y13=1 - D, 3 - A)
 N mc I $G(xp)&&(y13=1) S mc=((ycol-1)\xp)+1=Xp ;@Dol 28.01.11 колонка Всего - параметры $P(,";;",3)
 Q:'ycol "" Q:xyz "" S:$G(xp)&($G(y13)=1) ycol=$S(ycol#xp:ycol#xp,1:xp) S ycol=$G(Vs(qqnumpold,12,$P(Vs(qqnumpold,13,y13,ycol)," "),$P(Vs(qqnumpold,13,y13,ycol)," ",2),17)) Q:ycol="" "" 
 S:ycol[";;" ycol=$S($G(mc)&&($P(ycol,";;",3)'=""):$P(ycol,";;",3),1:$P(ycol,";;",y13=1+1))
 S:$P(ycol,",",10)="" $P(ycol,",",10)="5555" S:$G(mc)&&($P(ycol,",",5)="")&&($G(Vs(qqnumpold,99,"Anal",2))) $P(ycol,",",5)=1 S:$G(mc)&&($P(ycol,",",9)="") $P(ycol,",",9)=XQtc 
 Q ycol
 ;;Q:'ycol "" Q:xyz "" S:$G(xp)&($G(y13)=1) ycol=$S(ycol#xp:ycol#xp,1:xp) S ycol=$G(Vs(qqnumpold,12,$P(Vs(qqnumpold,13,y13,ycol)," "),$P(Vs(qqnumpold,13,y13,ycol)," ",2),17)) Q:ycol="" "" S:ycol[";;" ycol=$P(ycol,";;",y13=1+1) Q:ycol="" "" S:$P(ycol,",",10)="" $P(ycol,",",10)=2 Q ycol
DiagName(ycol,y13) ;название колонки (y13=1 - D, 3 - A)
 S:$G(xp)&($G(y13)=1) ycol=$S(ycol#xp:ycol#xp,1:xp)
 S y13=$P(Vs(qqnumpold,13,y13,ycol)," ",1,2) Q:y13="" "" ;код объекта и понятия
 I $G(Vs(qqnumpold,12,$P(y13," ",1),$P(y13," ",2),1))'="" Q "" ;задано в выражении аналитики
 S ycol=$P(qARM.GetPar("X7103",,$P(y13," ",1),$P(y13," ",2),,qqnumpold),"~") S:ycol="" ycol=qARM.GetName(,$P(y13," ",1),$P(y13," ",2),qqnumpold) Q ycol
DiagPar(ycol,y13) ;параметры колонки (y13=1 - D, 3 - A)
 S:$G(xp)&($G(y13)=1) ycol=$S(ycol#xp:ycol#xp,1:xp)
 S y13=$P($G(Vs(qqnumpold,13,y13,ycol))," ",1,2) Q:y13="" "" ;код объекта и понятия
 S ycol=qARM.GetPar("X72",,$P(y13," ",1),$P(y13," ",2),,qqnumpold)
 I $P(ycol,",")="" S y13=$P($G(Vo(qqnumpold,$P(y13," ",1),11,$P(y13," ",2)))," ",2) S:y13'="" $P(ycol,",",1)=$P($G(Vo(qqnumpold,-1,9,y13)),",") ;размер колонки исходного отображения
 S $P(ycol,",",10)=2 Q ycol
Diag710(ycol,y13) ;тип данных (y13=1 - D, 3 - A)
 N y13o S y13o=y13 S:$G(xp)&($G(y13)=1) ycol=$S(ycol#xp:ycol#xp,1:xp)
 S y13=$P($G(Vs(qqnumpold,13,y13,ycol))," ",1,2) Q:y13="" "" ;код объекта и понятия
 S ycol=$G(Vs(qqnumpold,12,$P(y13," ",1),$P(y13," ",2),18)) I ycol'="" S:ycol[";;" ycol=$P(ycol,";;",y13o=1+1) Q:ycol'="" ycol ;@Dol 23.09.10 тип данных в четвертой строке аналитик
 I y13o=1,'$P(par," ",12) Q ""
 I y13o=3,'$P(par," ",10) Q ""
 S ycol=qARM.GetPar("x710",,$P(y13," ",1),$P(y13," ",2),,qqnumpold)
 Q ycol
DiagParC ;@Dol 20.05.10 Доп. параметры ячеек для заголовков
 S:$P($G(Vo(qqnump,"Xy",0,0,y1,2)),",",19) $P(Vo(qqnump,-1,0,5,y1,2),",",19)=$P(Vo(qqnump,"Xy",0,0,y1,2),",",19),$P(Vo(qqnump,"Xy",0,0,y1,2),",",19)="" ;поворот
 S:$P($G(Vo(qqnump,"Xy",0,0,y1,2)),",",16) $P(Vo(qqnump,-1,0,5,0,2),",",16)=$P(Vo(qqnump,"Xy",0,0,y1,2),",",16),$P(Vo(qqnump,"Xy",0,0,y1,2),",",16)="" ;высота
 Q
DiagWr(xxx,strin)
 I '$D(strin),$I(^CacheTempDiagXML($J)) Q
 S ^CacheTempDiagXML($J,^CacheTempDiagXML($J),xxx)=strin Q  ;D ..write(strin) Q  ;@Dol 26.02.10
]]></Implementation>
</Method>

<Method name="DiagVRML">
<Description>
Создание VRML
Start=1 запуск IE
VID =0 - столбики (квадрат)
1 - столбики (шестигранник)
2 - столбики (бутылка)
3 - круг
4 - линии
5 - точки</Description>
<Internal/>
<FormalSpec>view:%String,file:%String,Start:%String=1,VID:%String=1</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 S:'VID VID=1 ;для красоты
 N Message,qqdev,strcolPic S qqdev=1
 S:'$D(view) view=qview
 I $G(file)="" S file="qword.wrl"
 I file'["." S file=file_".wrl"
 S Message=qSYS.CreArDi("A"_view,500) Q:'Message $E(Message,2,1000)
 D ..OpenDev(qqdev)
 ;
 ;K QDiag,QDiagYL M QDiag=^QDiag,QDiagYL=^QDiagYL
 ;взяли массивы даграмм
 ;QDiag=Min_" "_Max_" "_n1_" "_n2_" "
 ;QDiag(y,x)=значение_" "_норм.знач
 ; - норм.знач=0-100
 ;QDiagYL(0-10) - заголовки оси Y через 10 единиц
 ;
 S ymax=$O(QDiag(""),-1),xmax=$O(QDiag(0,""),-1) ;ПОЛУЧ МАХ РАЗМ МАССИВА
 ;
 ;у=0 - (x=1-xmax - значения по x
 ;0,0 - заголовки по x\y
 ;x=0 -(y=1-ymax - заголовки для рядов 
 ;S file="C:\vrml.wrl"
 ;O file:"WN" ;открытие файла
 ; МАССИВ цветов 
 ; WRML обекта 
 ;
 ;----------создание массива цветов--------------
 S strcolPic(0)=" 0.8 0.01 0.01 " ;красный
 S strcolPic(1)=" 0.8 0.8 0.01 " ;желтый
 S strcolPic(2)=" 0.01 0.8 0.01 " ;зеленый
 S strcolPic(3)=" 0.8 0.01 0.8 " ;сиреневый
 S strcolPic(4)=" 0.01 0.01 0.8 " ;синий
 S strcolPic(5)=" 0.8 0.67 0.2 " ;золото
 S strcolPic(6)=" 0.01 0.8 0.8 " ;голубой
 S strcolPic(7)=" 0.51 0.13 0.13 " ;коричневый
 S strcolPic(8)=" 0.54 0.8 0.15 " ; ж.зелен
 S strcolPic(9)=" 0.8 0.78 0.78 " ; снег
 S strcolPic(10)=" 0.8 0.6 0.01 " ;  pink
 S strcolPic(11)=" 0.4 0.4 0.01 " ; olive
 S strcolPic(12)=" 0.8 0.78 0.01 " ; lemon 
 S strcolPic(13)=" 0.8 0.39 0.25 " ; coral
 S strcolPic(14)=" 0.6 0.6 0.6 " ;серебро 
 S strcolPic(15)=" 0.8 0.51 0.01 " ;оранжевый
 S strcolPic(16)=" 0.23 0.2 0.4 " ; indigo
 ;------------------------------------------------------------  
 S strcolTxt=" 0.2 0.2 0.2 " ;   Цвет Текста
 S strcolBgr=" 0.8 0.8 0.8 " ;   Цвет Фона
 S strcolDig=" 0.1 0.1 0.7 " ;   Цвет Цифр
 S strcolGid=" 0.2 0.8 0.2 " ;   Цвет сетки
 ;S VID=5 ;                       Вид обекта
 S VidG=1 ;                      Кол-во слоев провлочной сетки 
 S HGid=" 0.04 " ;               толшина сетки
 S zazor=0.1 ;   Зазор между обектами в относит единицах(0-1)
 ;
 ;------------куски часто используемых строк в VRML------------
 S strTransf="Transform{ translation " ;     Нач WRML Узла
 S strExtr=" children [DiagPic{SPI[" ;       WRML обект -экструзия
 S strEndE="} ]}" ;                          конец обекта
 ;
 S strTextY=" children[DiagTextX {string[""" ;  ТекстY
 S strTextX="DiagTextX { translation " ;            ТекстX
 S strTextZ="DiagTextZ { translation " ;            ТекстZ
 S strCText=" string["""
 S strTcol="""] color " ;                          Цвет текста
 S strEndT=" }  ]}" ;                                 Конец Текста 
 ;--------------------------------------------------------------
 ;  
 ;параметры для обекта экструзия
 ;куб
 S Cross="1,1,1,-1,-1,-1,-1,1,1,1,end" ;
 S Spine="0,1,end" ;
 S Scale="1 1,1 1" ;
 S RGB=-1 ;индекс Цвет WRML куба
 I VID=1 D  ;Усеченный куб
 .S Cross="0.8,1,1,0.8,1,-0.8,0.8,-1,-0.8,-1,-1,-0.8,-1,-0.8,-1,0.8,-0.8,1,0.8,1,end"
 .S Spine="0,1,end"
 .S Scale="1 1,1 1" ;
 .S RGB=-1 Q  ;индекс Цвет WRML Обекта
 I VID=2 D  ;Бутылка
 .S Cross="0.8,1,1,0.8,1,-0.8,0.8,-1,-0.8,-1,-1,-0.8,-1,-0.8,-1,0.8,-0.8,1,0.8,1,end"
 .S Spine="0,0.1,0.6,0.7,0.88,0.9,1,end" ;
 .S Scale="0.8 0.8,1 1,1 1,0.3 0.3,0.3 0.3,0.5 0.5,0.5 0.5" ;
 .S RGB=14 Q  ;индекс Цвет WRML Обекта
 ;=========================сектор===============================
 I VID=3 D  ;сектор
 .S Cross=" 0 0.5, 2 0.5,2 -0.5,0 -0.5, 0 0.5"
 .S StrSpi="0 0 0," ;
 .S Scale="1 1" ;
 .S CrAng=" 1.5 "
 .S RGB=14   ;индекс Цвет WRML Обекта
 .S nn=1 ;обрабатыв строка при многомерной диаграмме
 .;
 .S SVAL=$$FsumVal("x",xmax,nn),Krad=0 ;пол суммы всех значений
 .S:SVAL'=0 Krad=2*$ZPI/SVAL ;пол коэф-та для радианов
 .Q
 I ((VID=4)!(VID=5)) S Srad=0.3,Hrad=0.054
 ;
 S RGBT=RGB
 ;
 D ..write("#VRML V2.0 utf8") ;    Зап стр wrl файл-заголовка 
 ;
 ;----------------Зап wrl - положен камеры(пользователя)------------>
 ;
 D:VID'=3
 .;----вычеслление положения пользователя от чила и разм эл-тов в диаграмме
 .S len=$L(""_QDiagYL(5)),minus=$FN(len/7,"-",0) ;число столбцов цифр
 .S dlen=1.3*minus ;смещение от числа столбцов
 .S Mlen=$$FmaxTxt("x",xmax)
 .S delta=Mlen*0.22 ;пол приращ из max длины теста
 .S:delta<1 delta=0.8
 .I ((VID=4)!(VID=5)) S:delta<1 Srad=0.2,Hrad=0.036
 .S MaxDX=delta*xmax
 .S VIEWY=delta*8,VIEWZ=delta*17.5
 .I VIEWZ<48 S VIEWZ=48
 .I VIEWY<22 S VIEWY=22
 .I MaxDX<12 S MaxDX=12,delta=MaxDX/xmax,VIEWY=22,VIEWZ=48 ;нoрм длин
 .S Xbeg=-MaxDX/2
 .S Xbmax=Xbeg-dlen,VIEWX=Xbmax+(VIEWZ*0.2) ;смещ VIEW-ра   
 .;----------------------------------------------------------------------
 .D ..write("Transform {children [Viewpoint {position  "_VIEWX_" "_VIEWY_" "_VIEWZ_" orientation 1 0 0 -0.35  fieldOfView  0.35}]}")
 .Q
 ;положение для круговой диаграммы
 D:VID=3 ..write("Transform {children [Viewpoint {position  0 0 10 orientation 0 0 1 0 fieldOfView  0.785398}]}")
 ;
 ;---------------------------------------------------------------------
 ;
 D ..write("Background {skyColor "_strcolBgr_"}") ;Задание цвета фона
 ;
 ;
 ;----------ОПИСАНИЕ ПРОТОТИПА ТЕКСТОВОГО УЗЛА--X--простой----
 ;
 ;
 D ..write("PROTO DiagTextX [ exposedField MFString  string  ""xxxx""")
 D ..write("exposedField SFVec3f translation 0 0 0 exposedField SFColor color 0.6 0.6 0.6] {")
 D ..write("Transform { translation IS translation children")
 D ..write("Shape {appearance Appearance{material Material{ diffuseColor IS color}}")
 D ..write("geometry Text {fontStyle FontStyle{language""ru"" family""SANS"" justify ""MIDDLE"" size 0.8} string IS string} } }")
 D ..write(" }")
 ;
 ;-------------------------------------------------------------------
 ;
 ;----------ОПИСАНИЕ прототипа ТЕКСТОВОГО УЗЛА--Z--цветной------
 ;
 D ..write("PROTO DiagTextZ [ exposedField MFString  string  ""xxxx""")
 D ..write("exposedField SFVec3f translation 0 0 0 exposedField SFColor color 0.6 0.6 0.6 ")
 D ..write("exposedField SFVec3f SB 0 0 0 exposedField SFVec3f ST 0 0 0 ")
 D ..write("field SFVec3f WT 2 1 0.1 field SFVec3f WB 2 1.4 0.1] {")
 D ..write("Transform { translation IS translation children [")
 D ..write("Transform { translation IS SB children [")
 D ..write("Shape { appearance Appearance{material Material{ diffuseColor IS color}} geometry Box{size IS WB} } ")
 D ..write("Transform{ translation  -0.8 0 0.1 children[ ")
 D ..write("Shape { appearance Appearance{material Material{ diffuseColor 0.9 0.9 0.9}}geometry Box{size IS WT } } ")
 D ..write("Transform{ translation IS ST children ")
 D ..write("Shape { appearance Appearance{material Material{ diffuseColor 0.2 0.2 0.2 }}")
 D ..write("geometry Text {fontStyle FontStyle{language""ru"" family""TYPEWRITER"" justify ""MIDDLE"" size 0.8 style ""BOLD""} string IS string} }")
 D ..write("    } ]} ]} ]}")
 D ..write(" }")
 ;-------------------------------------------------------------------   
 I VID'=3 D  
 .;
 .S Xtxt=Xbeg,Ytxt=-1.4,Ztxt=delta/2 ;нач полож текста 
 .S Xdelta=delta,Zdelta=delta ;приращения по X , Z       
 .S:VID=4 Zdelta=1
 .S SXcub=delta-(delta*zazor),SZcub=delta-(delta*zazor) ;размер куба по X ,Z                                                                                  
 .S SXcr=(delta-(delta*zazor))/2,SZcr=(delta-(delta*zazor))/2 ;масштав сечения по X ,Z
 .;
 .;---------------------------------------------------------------------------------            
 .;
 .;----МАСШТАБИРОВАНИЕ Cross по параметрам SXcr ZXcr (зависят от ширины надписей)
 .S NEWX=$P(Cross,",",1)*SXcr,NEWZ=$P(Cross,",",2)*SZcr
 .S Cross1=""_NEWX_" "_NEWZ
 .F I=3:2 Q:$P(Cross,",",I)="end"  D  ; "end"-признак конца параметров
 ..D:$P(Cross,",",I)'="end"  Q   
 ...S NEWX=$P(Cross,",",I)*SXcr,NEWZ=$P(Cross,",",I+1)*SZcr
 ...S Cross1=Cross1_","_NEWX_" "_NEWZ Q 
 .S Cross=Cross1
 .Q
 ;------------------------------------------------------------------------  
 ;
 ;------------------Описание прототипа WRML обекта----------------------------------
 D ..write("PROTO DiagPic [exposedField SFColor color 0.6 0.6 0.6") 
 D:VID'=3 ..write("exposedField SFString string ""xxxx""") ; текстовое поле
 D:VID=3 ..write("exposedField MFString string ""xxxx""") ; текстовое поле
 D:VID=3 ..write("exposedField SFRotation rotation 0 0 1 0") ;поворот поз текста
 D ..write("exposedField SFVec3f translation 0 0 0 ")
 D:'((VID=4)!(VID=5))  ;
 .D ..write("field MFVec2f CRO [ "_Cross_"]") ;Получение кросс-сечения из переменной Cross
 .D ..write("field MFVec3f SPI [0 -1 0,0 1 0]") ;Нач значения spine(верт оси У) обекта
 .D ..write("field MFRotation ORI [0 0 1 0]") ;Нач значения врашения(по оси Z) обекта
 .D ..write("field SFFloat ANG 0") ;Нач значения угла отражения обекта
 .D ..write("field MFVec2f SCL [ "_Scale_"] ] {") ;Получение масштаба spine из Scale
 .Q  ;
 ;---------------Присваивание значений из прототипа обьекту Extrusion---------------
 D:((VID=4)!(VID=5)) ..write("]{")
 D ..write("Transform{ translation IS translation children[")
 D ..write("Shape {appearance Appearance{material Material{ diffuseColor IS color}}")
 D:'((VID=4)!(VID=5))  ;
 .D ..write("geometry Extrusion {")
 .D ..write("crossSection IS CRO")
 .D ..write("spine IS SPI")
 .D ..write("scale IS SCL")
 .D ..write("orientation IS ORI")
 .D ..write("creaseAngle IS ANG")
 .D ..write("} }")
 .D:VID=3
 ..D ..write("Transform{ rotation IS rotation children Transform{translation 3 0 0 children")
 ..D ..write("Billboard {axisOfRotation 0 0 0 children")
 ..D ..write("Shape {appearance Appearance{material Material{ diffuseColor 0.2 0.2 0.2}}")
 ..D ..write("geometry Text {fontStyle FontStyle{language""ru"" family""SANS"" justify ""MIDDLE"" size 0.5} string IS string} } }")
 ..D ..write("}}")
 ..Q
 .Q
 D:((VID=4)!(VID=5)) ..write("geometry Sphere{radius "_Srad_"}}")
 D ..write("]} }")
 ;-----------------------------конец описаня прототипа------------------------------
 D:VID=4  ;
 .D ..write("PROTO DiagPic1 [exposedField SFColor color 0.6 0.6 0.6 field SFFloat Long 2")
 .D ..write("exposedField SFRotation rotation 0 0 1 0 exposedField SFVec3f translation 0 0 0 ]{")
 .D ..write("Transform{ translation IS translation rotation IS rotation children")
 .D ..write("Shape {appearance Appearance{material Material{ diffuseColor IS color }}")
 .D ..write("geometry Cylinder {radius "_Hrad_" height IS Long}}}}")
 .Q
 ;
 ;------------------Описание прототипа линии по оси Z-------------------
 D ..write("PROTO LZ [ exposedField SFColor color"_strcolGid) ;цвет сетки
 D ..write("exposedField SFVec3f Hi 0 1 0 field SFFloat WE 2 ]{") ;Hi- шаг высоты сетки
 D ..write("Transform{  translation IS Hi rotation 1 0 0 1.57 children[ ") ;Пов цил по оси X на 90 град
 D ..write("Shape {appearance Appearance{material Material{ diffuseColor IS color }}")
 D ..write("geometry Cylinder {radius "_HGid_" height IS WE}  }  ] } } ") ;WE -высота цил
 ;
 ;-------------------Описание прототипа линии по оси X----------------------
 D ..write("PROTO LX [ exposedField SFColor color"_strcolGid) ;цвет сетки
 D ..write("exposedField SFVec3f Hi 0 1 0 field SFFloat WE 2 ]{") ;Hi- шаг высоты сетки
 D ..write("Transform{  translation IS Hi rotation 0 0 1 1.57 children[ ") ;Пов цил по оси Z на 90 град
 D ..write("Shape {appearance Appearance{material Material{ diffuseColor IS color }}")
 D ..write("geometry Cylinder {radius "_HGid_" height IS WE}  }  ] } } ") ;WE -высота цил
 ;
 ;
 D ..write("Transform{ rotation 0 1 0 -0 children[") ;BEG MAIN
 ;
 ;
 D:VID'=3 ..DiagVRML0("Pic3D")
 D:VID=3 ..DiagVRML0("Sect")
 ;
 ;
 D ..write(" ]} ")
 D ..write("] }") ; END MAIN
 ;
 D ..write("Group{children[")
 D ..write("DEF WorldProx ProximitySensor {size  10000 10000 10000}")
 D ..write("DEF _1 PlaneSensor {}")
 D ..write("DEF Disp Transform {translation 0 0 0 children[")
 D ..write("DEF _0 Transform{ translation 0 0 0  rotation 1 0 0 0 children[")
 D ..write("DEF ZTZ Group{children[")
 ;---------построение текста для цветных обектов------------------------------
 ;нач полож текста и зн X и Y для поиска текстовых строк
 I VID'=3 S Xtxt=12.6,Ytxt=7,Ztxt=-45,Zhead=-42,x=0 F y=1:1:ymax D ..DiagVRML0("CTXT")
 I VID=3 S Xtxt=12.6,Ytxt=7,Ztxt=-20,Zhead=-18,y=0 F x=1:1:xmax D
 .S RGBT=RGBT+1 I RGBT>16 S RGBT=0
 .S a=$P(QDiag(nn,x)," ",2) Q:a=0  D ..DiagVRML0("CTXT1")
 .Q
 ;S a=QDiag(nn,x) Q:a=0 
 ;-------------------------------------------------------------------------
 D ..write("] }")
 ;
 D ..write("]}")
 S strhead=..RusU8($P(QDiag," ",5,255)_" "_QDiag(0,0))
 ;
 D:VID=3 ..write("DEF Result DiagTextX { translation 1 -6.6 "_Zhead_" color 0.2 0.2 0.2")
 D:VID'=3 ..write("DEF Result DiagTextZ { translation 1 -6.6 "_Zhead_" color 0.7 0.7 0.7")
 D:VID'=3 ..write(" SB 0 0 0 ST 0 -0.2 0.1 WT 29 1 0.1 WB 35 1.4 0.1 ")
 D ..write("  string["""_strhead_"""]}")
 ;
 D ..write("]}]}")
 ;
 D ..write("# Display the results") ;скрипт для перевода SFString > MFString
 D ..write("DEF Collector Script { eventOut   MFString string eventIn SFString fromString")
 D ..write("url ""javascript: ")
 D ..write("function initialize() { string[0] = '"_strhead_"'; }")
 D ..write("function fromString(s) {")
 D ..write("           string[0] = ' '+s+' ';")
 D ..write(" }"" }")
 ;
 D:VID'=3 ..DiagVRML0("Scrpt")  
 ;
 D ..write("")
 D ..write("")
 D ..write("ROUTE _1.translation_changed TO _0.translation")
 D ..write("ROUTE WorldProx.position_changed TO Disp.translation")
 D ..write("ROUTE WorldProx.orientation_changed TO Disp.rotation")
 I VID'=3 D  ;===обход кода для сектора
 .D ..write("ROUTE Touch.touchTime TO POZ.start")
 .D ..write("ROUTE Touch.hitPoint_changed TO POZ.position")
 .D ..write("ROUTE POZ.string TO Collector.fromString")
 .D ..write("ROUTE Collector.string TO Result.string")
 .D ..write("ROUTE POZ.color TO Result.color")
 .D ..write("")
 .Q
 ;
 D ..write("#Программа написана Николаевым Н А 2000 г")
 ;
 D ..CloseDev(qqdev)
 D qARM.OpenIE(qqdev,..ClientPath()_file,Start)
 Q $E(Message,2,1000)
 ;
 ;
 ;-------------Описание функции получения суммы норм значений ----------
 ;1-ый арг строка "x"-поиск по Х "y"-поиск по У; 2-ой арг соотв max значение
 ;3-ий арг номер строки значений
FsumVal(str1,num1,num2) 
 S summa=0 Q:num2=0 summa
 I str1="y" F i=1:1:num1 S summa=summa+$P(QDiag(i,num2)," ",2)
 I str1="x" F i=1:1:num1 S summa=summa+$P(QDiag(num2,i)," ",2)
 Q summa
 ;--------------------------------------------------------------------- 
 ;-------------Описание функции поиска max длины текста---------------
 ;1-ый арг строка "x"-поиск по Х "y"-поиск по У; 2-ой арг соотв max значение
FmaxTxt(str1,num1) 
 S txtLmax=0 
 I str1="y" F i=1:1:num1 S curL=$L(QDiag(i,0)) I txtLmax<curL S txtLmax=curL 
 I str1="x" F i=1:1:num1 S curL=$L(QDiag(0,i)) I txtLmax<curL S txtLmax=curL
 Q txtLmax
 ;--------------------------------------------------------------------- 
 ;Программа написана Николаевым Н А 2000 г
]]></Implementation>
</Method>

<Method name="DiagVRML0">
<Internal/>
<FormalSpec>Label:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;-- подрограммы для метода DiagVRML оформленные как методы-------
 ;
 D @Label Q:$Q "" Q
 ;
 ;--подпрограмма построения цветного текста---------------- 
CTXT S RGBT=RGBT+1 I RGBT>16 S RGBT=0
CTXT1 S a=QDiag(y,x),wght=$L(QDiag(y,x)) ;значения текста для y
 S WB=wght/2+2,WT=WB-2.2,SB=-WB/2,ST=-0.1

 ;-----------------Формирование WRML текста-----------------------
 ;
 D ..write(strTextZ_Xtxt_" "_Ytxt_" "_Ztxt_" ") 
 D ..write(" "_strCText_..RusU8(a)_strTcol_strcolPic(RGBT)_" ")
 D ..write(" SB "_SB_" 0 0 ST "_ST_" -0.2 0.1 WT "_WT_" 1 0.1 WB "_WB_" 1.4 0.1 }")
 ;
 S Ytxt=Ytxt-1.4 
 Q  ;------------------------------------------------------------
 ;  
 ;
Pic3D ;-----построение 3D-диаграммы-----------
 ;построение кубов, сетки, координатной линейки и шкалы
 ;
 ;
 S Zcub1=-Zdelta/2,Xcub1=Xbeg ;нач полож обекта по X Z
 S Zcub=Zcub1-(Zdelta*ymax),Xcub=Xcub1+(Xdelta*xmax)    
 ;
 ;----------------------Построение текста вдоль оси X--------------------------------
 S y=0
 D ..write(strTransf_" 0 -0.7 0.7 children "_"Billboard {axisOfRotation 1 0 0 children[ ")
 D ..write("DEF XTX Group{children[")
 F x=1:1:xmax D 
 .S a=QDiag(y,x) ;значения текста для X
 .S Xtxt=Xtxt+Xdelta ;сдвигание текста по оси X
 .If Ytxt=-1.4 S Ytxt=-0.7
 .Else  S Ytxt=-1.4 
 .;-----------------Формирование WRML текста---------------------------------------
 .D ..write(strTextX_Xtxt_" "_Ytxt_" "_Ztxt_" "_strCText_..RusU8(a)_strTcol_strcolTxt_" }")
 .Q  ;--------------------------------------------------------------------------------
 D ..write("] }")
 D ..write("] } }")
 ;Q
 ;
 D ..write("#построение линейки")
 ;
 ;.-----------------------------------------------------------------------.
 ;|  Постр коорд линейки: геометрия-Швелер (боковины отогнуты) с торцами  | 
 ;|                     загнут на90град на угле                           |
 ;'-----------------------------------------------------------------------'
 D ..write("DEF GG Group{children[") ;описане швелера как IndFaseSet в узле Group
 D ..write(" DEF Gird Shape {geometry IndexedFaceSet {colorPerVertex FALSE coord Coordinate {point [ ")
 ;
 S Xb1=Xbeg+(Xdelta*zazor),Xb2=Xb1+0.2,Xbot1=Xb1 ;опред 1-вых 4-х вешин пов(торец) и зап их
 S Zb1=SZcub/2+0.2,Zb2=Zb1,Zbot2=Zb1 ;          в файл см ниже
 ;
 D ..write(Xb1_" 0 "_Zb2_","_Xb2_" 0.05 "_Zb1_","_Xb2_" 0.95 "_Zb1_","_Xb1_" 1 "_Zb2)
 ;
 S Zb1=Zcub+(Zdelta*zazor),Zb2=Zb1-0.2,Zbot1=Zb2 ;опред 2-ых 4-х вершин пов(угол) и зап их
 ;
 D ..write(Xb1_" 0 "_Zb2_","_Xb2_" 0.05 "_Zb1_","_Xb2_" 0.95 "_Zb1_","_Xb1_" 1 "_Zb2)
 ;
 S Xb1=Xcub+SXcub+0.2,Xb2=Xb1,Xbot2=Xb1 ;опред 1-вых 4-х вешин пов(торец) и зап их
 ;
 D ..write(Xb1_" 0 "_Zb2_","_Xb2_" 0.05 "_Zb1_","_Xb2_" 0.95 "_Zb1_","_Xb1_" 1 "_Zb2)
 ;
 ;опред пов повершинам    1-торец       1-1-бок     1-дно         1-2-бок       2-дно           2-1-бок           2-2-бок       2-торец прав
 D ..write("]}coordIndex [ 0,1,2,3,-1,3,2,6,7,-1,5,6,2,1,-1,4,5,1,0,-1,6,5,9,10,-1,7,6,10,11,-1,8,9,5,4,-1,9,8,11,10,-1]")
 ;опред цвета соотв части пов 1-торец   1-1-бок     1-дно         1-2-бок       2-дно           2-1-бок           2-2-бок       2-торец прав
 D ..write("color Color{color[0.7 0.7 0.7,0.4 0.4 0.4,0.9 0.9 0.9,0.4 0.4 0.4,1 1 1,0.4 0.4 0.4,0.4 0.4 0.4,0.7,0.7,0.7]}}}")
 ;
 ;-----------Повторение коорд линейки 9 раз с шагом в 1.0--------------
 F level=1:1:10 D 
 .D ..write(strTransf_"0 "_level_" 0 children [USE Gird ]}") Q
 D ..write("]}") ;Q
 ;-------------------Конец постр коорд линейки--------------------------
 D:VidG'=0  
 .;----------Построение проволочной сетки из цилиндров-------------------
 .;
 .S dZ=Zdelta*ymax ;      dZ- длина сетки
 .S Xgird=Xbeg+(Xdelta/2) ;Xgird- нач пол сетки
 .S Zgird=-dZ/2
 .S Ygird=0 ;Ygird- нач пол сетки
 .D ..write("Transform{  translation 0 "_Ygird_" 0 children DEF GirdH Group {children[")
 .; 
 .F i=0:1:xmax D  ;построение в цикле GirdZ        
 ..D ..write("LZ{Hi "_Xgird_" 0 "_Zgird_" WE "_dZ_" }")
 ..S Xgird=Xgird+Xdelta Q   ;     по X
 .S Zbeg=-Zdelta/2 ;                     нач полож по оси Z
 .S dX=Xdelta*xmax ;dX- длина сетки-разм надп * на их число 
 .S Zgird=Zbeg+(Zdelta/2) ;Zgird- нач пол сетки
 .S Xgird=(Xdelta/2) ;Xgird- нач пол сетки
 .;
 .F i=0:1:ymax D  ;построение в цикле GirdX
 ..D ..write("LX{Hi "_Xgird_" 0 "_Zgird_" WE "_dX_" }")
 ..S Zgird=Zgird-Zdelta Q  ; по Z
 .D ..write("] } }")
 .;----------------------------------------------------------------------------
 .D:VidG>1
 ..S stepG=10/VidG
 ..F I=2:1:VidG D  ;Так как при VidG=1 сетка уже построена то счет идет с двух
 ...S HiG=stepG*(I-1)
 ...D ..write("Transform{translation 0 "_HiG_" 0 children USE GirdH}") Q
 .Q
 .Q
 ;-----------Построение цифр для шкалы----------------------------------------        
 S Xtxt=Xbeg-dlen,Ytxt=10-0.3,Ztxt=Ztxt+0 ;        положен цифр слева
 D ..write(strTransf_Xtxt_" 0 "_Ztxt_" children "_" DEF DIGIT Billboard {")
 D ..write("axisOfRotation 0 1 0 children[ ")
 F i=10:-1:0  D  ; Нач цикла вывода цифр шкалы
 .S strDig=""_QDiagYL(i) ;Перевод числа в строку
 .D ..write(strTransf_" 0 "_Ytxt_" 0 "_strTextY_strDig_strTcol_strcolDig_strEndT)   
 .S Ytxt=Ytxt-1 Q  ;             //Получение след зн Ytxt и зн Цифры 
 D ..write("] } }")
 ;S Xtxt1=Xb1+1.3,Ztxt1=Zb1+0 ;    положен цифр с права 
 ;D ..write(strTransf_Xtxt1_" 0 "_Ztxt1_" children "_" USE DIGIT }")
 ;----------------------------------------------------------------------------
 ;

 S dx=Xdelta,dz=Zdelta
 S bx=Xbeg+(Xdelta/2),bz=Zcub1+(Zdelta/2)
 D:VID=4  ;-------Построение связывающих цилиндров---------------
 .S RGBH=RGB
 .F y=1:1:ymax D  ;Цикл по Y-------------------------------------
 ..Q:xmax=1  ;выход если только одно значение по X
 ..S RGBH=RGBH+1 I RGB>16 S RGB=0
 ..S Xcub1=bx
 ..S a=$P(QDiag(y,1)," ",2)/10 
 ..F x=2:1:xmax D  ;Цикл по X------------------------------------------------------
 ...S Xcub1=Xcub1+Xdelta ;сдвигание цилиндров по оси X         
 ...S a1=$P(QDiag(y,x)," ",2)/10 ;взять нормализованное значение (0-100)/10
 ...S dy=a1-a,lhe=(dy**2+(Xdelta**2))**.5 ;выч длины цилиндра
 ...S Ang=-($ZARCCOS(dy/lhe)) ;выч угла наклона цилиндра
 ...S dy=a1-(dy/2),a=a1 ;выч положения по у цилиндра
 ...;--------------Формирование WRML обекта----------------------------------------
 ...D ..write("DiagPic1 { translation "_Xcub1_" "_dy_" "_Zcub1_" rotation 0 0 1 "_Ang_" color "_strcolPic(RGBH)_" Long "_lhe_" }")
 ...Q  ;---------------------конец цикла--X----------------------
 ..;
 ..S Zcub1=Zcub1-Zdelta Q  
 .Q
 ;---------------------конец цикла--Y---------------------------------------------

 D ..write("DEF SENS Group{children[ DEF Touch TouchSensor{} ")
 ;
 ;-------------------Построение дна диаграммы как IndFaseSet-------------------
 S Zbot2=SZcub/2+0.2 ;Zbot1=Zbot2-SZcub-1.2
 D ..write("Shape {geometry IndexedFaceSet {colorPerVertex FALSE coord Coordinate {point [ ")
 ;Опред вершин дна
 D ..write(Xbot1_" 0 "_Zbot2_","_Xbot1_" 0 "_Zbot1_","_Xbot2_" 0 "_Zbot1_","_Xbot2_" 0 "_Zbot2)
 D ..write("]}coordIndex [ 3,2,1,0,-1]") ; Соединение вершин дна
 D ..write("color Color{color[0.7 0.7 0.7]}}}") ;  Цвет дна
 ;----------------------------------------------------------------------------
 S:((VID=4)!(VID=5)) Zcub1=-Zdelta/2
 F y=1:1:ymax D  ;Цикл по Y------------------------------------------------------       
 .S RGB=RGB+1 I RGB>16 S RGB=0
 .S Xcub1=Xbeg
 .F x=1:1:xmax D  ;Цикл по X------------------------------------------------------
 ..S Xcub1=Xcub1+Xdelta ;сдвигание кубов по оси X         
 ..I x=0 s a=QDiag(y,x) Q  ;значения для X
 ..S a=$P(QDiag(y,x)," ",2)/10 I VID'=4 Q:a=0  ;взять нормализованное значение (0-100)/10
 ..S a1=$P(QDiag(y,x)," ",1) I VID'=4 Q:a=0  ;взять нормализованное значение (0-100)
 ..;--------------Формирование WRML обекта----------------------------------------
 ..D:'((VID=4)!(VID=5))  ;
 ...D ..write("DiagPic { translation "_Xcub1_" 0 "_Zcub1_" string """_a1_""" SPI [")
 ...S Spine1=""
 ...F I=1:1 Q:$P(Spine,",",I)="end"  D  ; "end"-признак конца параметров
 ....D:$P(Spine,",",I)'="end"  Q           ;масштавирование и присваивание значения
 .....S NEWS=$P(Spine,",",I)*a     ;Spine из строки Spine каждому из обектов
 .....S Spine1=Spine1_"0 "_NEWS_" 0," Q 
 ...D ..write(Spine1_"] color "_strcolPic(RGB)_" }") ;присваивание цвета каждому из обектов
 ...Q
 ..D:((VID=4)!(VID=5)) ..write("DiagPic { translation "_Xcub1_" "_a_" "_Zcub1_" string """_a1_""" color "_strcolPic(RGB)_" }")
 ..Q  ;D ..write(strEndE) Q  ;---------------------конец цикла--X----------------------
 .;
 .S Zcub1=Zcub1-Zdelta Q  
 ;---------------------конец цикла--Y---------------------------------------------
 Q
 ;
Sect ;=====построение VRML обекта сектор============
 D ..write("DEF SECTOR Transform{translation -2 1 0 rotation 1 0 0 -0.75 children[")
 S Xcub1=0,Zcub1=0,y=nn
 S begAng=0,Ang=0 ;нач знач угла
 F x=1:1:xmax D  ;Цикл по X================================================
 .S RGB=RGB+1 I RGB>16 S RGB=0
 .I x=0 S a=QDiag(y,x) Q  ;значения для X
 .S a=$P(QDiag(y,x)," ",2) Q:a=0  ;взять нормализованное значение (0-100)/10
 .S a1=$P(QDiag(y,x)," ",1) Q:a=0  ;взять нормализованное значение (0-100)
 .;
 .;
 .S begAng=begAng+Ang ;вращение секторов по оси Z
 .S strOri="0 0 1 "_begAng,Spine="0 0 0"
 .S Ang=Krad*a,Numang=Ang\0.1,ost=Ang
 .S AngT=begAng+(Ang/2)
 .I Numang'=0 D  
 ..S ost=Ang#(Numang*0.1)
 ..F j=1:1:Numang S strOri=strOri_",0 0 1 "_((j*0.1)+begAng),Spine=Spine_",0 0 0"
 ..Q  
 .S:ost'=0 strOri=strOri_",0 0 1 "_(Ang+begAng),Spine=Spine_",0 0 0"
 .D ..write("DiagPic { translation "_Xcub1_" 0 "_Zcub1_" string """_a1_""" ANG "_CrAng_" ")
 .D ..write("rotation 0 0 1 "_AngT_" SPI [")
 .D ..write(Spine)
 .D ..write("] ORI [")
 .D ..write(strOri)
 .D ..write("] color "_strcolPic(RGB)_" }") ;присваивание цвета каждому из обектов
 .Q  
 Q
 ;========================================================================  
 ;--------Script для 3D диаграммы---------------------------
Scrpt D ..write("DEF POZ Script {")
 D ..write("eventIn SFTime start")
 D ..write("eventIn  SFVec3f position ")
 D ..write("eventOut SFString string ")
 D ..write("eventOut SFColor color ")
 D ..write("field SFNode Gr1 USE SENS")
 D ..write("field MFNode Chi1 [ ]")
 D ..write("field SFNode Gr2 USE XTX")
 D ..write("field MFNode Chi2 [ ]")
 D ..write("field SFNode Gr3 USE ZTZ")
 D ..write("field MFNode Chi3 [ ]")
 D ..write("field SFFloat dx "_dx)
 D ..write("field SFFloat dz "_dz)
 D ..write("field SFFloat bx "_bx)
 D ..write("field SFFloat bz "_bz)
 D ..write("field MFString strX [ ]")
 D ..write("field MFString strZ [ ]")
 D ..write("field SFString strY """_..RusU8("Не попали! переместите курсор на обект и щелкните мышью")_"""")
 D ..write("field SFString strV """_..RusU8(" :")_"""")
 D ..write("directOutput TRUE")
 ;
 D ..write("url ""javascript:")
 D ..write("function initialize( ){n=0;m=0;")
 D ..write("b0=new SFVec3f (0,0,0);b1=new SFVec3f (0,0,0);b2=new SFVec3f (0,0,0);")
 D ..write("c1=new SFColor (0,0,0);c2=new SFColor (0,0,0);c3=new SFColor (1,1,1);")
 D ..write("c4=new SFColor (0.7,0.7,0.7);}")
 D ..write(" function position(value) {")
 D ..write("if((n!=0)&&(m!=0)){b1=value;Chi1= Gr1.children_changed;b2=Chi1[n].translation_changed;")
 D ..write("if(((b1.x>b2.x-(dx/2))&&(b1.x<b2.x+(dx/2))&&(b1.z<b2.z+(dz/2))&&(b1.z>b2.z-(dz/2)))){}")
 D ..write("else{Chi1[n].set_color=c2;color=c4;n=0;string=' "_strhead_" ';}}}")                        
 D ..write("function start(value) {m=0;Chi1= Gr1.children_changed;L1=Chi1.length;b1=Chi1[0].hitPoint_changed;")
 D ..write("if(b1.y>0.3){Chi2= Gr2.children_changed;L2=Chi2.length;Chi3= Gr3.children_changed;L3=Chi3.length;")
 D ..write("//опр индекса обекта")
 D ..write("for(i=2;i<L1;i++){b2=Chi1[i].translation_changed;")
 D ..write("if(((b1.x>b2.x-(dx/2))&&(b1.x<b2.x+(dx/2))&&(b1.z<b2.z+(dz/2))&&(b1.z>b2.z-(dz/2)))){break;};}")
 D ..write("//изменение цвета обекта")
 D ..write("c1=Chi1[i].color_changed;if((c1.r!=c3.r)&&(c1.g!=c3.g)&&(c1.b!=c3.b)){c2.r=c1.r;c2.g=c1.g;c2.b=c1.b;color=c1;};strnum=Chi1[i].string_changed;Chi1[i].set_color=c3;n=i;")
 D ..write("//пол индекса надписи по X")
 D ..write("begX=bx;for(i=0;i<L2;i++){if((b1.x>begX)&&(b1.x<(begX+dx))){break;};begX=begX+dx;}")
 D ..write("strX=Chi2[i].string_changed;")
 D ..write("//пол индекса надписи по Z")
 D ..write("begZ=bz;for(i=0;i<L3;i++){if((b1.z<begZ)&&(b1.z>(begZ-dz))){break;};begZ=begZ-dz;}")
 D ..write("strZ=Chi3[i].string_changed;")
 D ..write("//формирование надписи")
 D ..write("string = strX[0]+'/'+strZ[0]+' '+strV+strnum;}else{string=strY;}")
 D ..write("m=1;}"" }")
 Q
 ;--------------------------------------------------------  
 ;
 ;------конец 3D диаграммы-----------------------------------
]]></Implementation>
</Method>

<Method name="DiagWE">
<Description>
Метод используется для вывода диаграмм в IE,Word или Excel при количестве аналитик больше 2 и при включенном признаке XYZ
Параметры:
- qqrela - слой аналитики</Description>
<Internal/>
<FormalSpec>qqrela:%Library.String,qOutput:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 N viewan S viewan=Vo(qqnump)["zz"||(Vo(qqnump)["sysA")
 I $G(W("Zar"))'="" S qqrela=W("Zar")
 I viewan S qqrela=$S($P(qview," ")'["sysA":$P(qview," "),1:"A"_$P(qview,"sysA",2))
 ;если слой не сформирован или не назначен Y, то выход
 I '$D(^Qa(qqrela)) Q "Не построен аналитический срез "_qqrela
 I $O(Vs(qqnump,13,1,""))="" Q "Не определен Y."
 ;
 N qqdev,i,j,qY,qYt
 ;вывод xsl-файла
 S qqdev=1
 D ..OpenDev(qqdev) D ..write("<?xml version='1.0' encoding='windows-1251'?>")
 // tdv 13.03.2006 - пространства имён перенесены в stylesheet
 d ..write($c(13,10)) D ..write("<xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform' xmlns='http://www.w3.org/TR/REC-html40'"_$S(qOutput?1(1"1",1"2"):" xmlns:v='urn:schemas-microsoft-com:vml' xmlns:o='urn:schemas-microsoft-com:office:office'"_$S(qOutput=1:" xmlns:w='urn:schemas-microsoft-com:office:word'",1:" xmlns:x='urn:schemas-microsoft-com:office:excel'"),1:"")_">")
 d ..write($c(13,10)) D ..write("<xsl:output omit-xml-declaration=""yes""/>")
 ;D ..OpenDev(qqdev),..write("<?xml version='1.0' encoding='windows-1251'?>")
 ;D ..write("<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0' xmlns='http://www.w3.org/TR/REC-html40'>")
 ;описание корневого элемента
 D ..write("<xsl:template match='/'>")
 D ..write("<html>")
 D ..write("<head><meta http-equiv='Content-Type' content='text/html; charset=utf-8'></meta></head>") ;указание кодировки обязательно!!!
 D ..write("<body><div><table border='1' width='100%' cellspacing='0' cellpadding='0'>")
 D ..write("<tr style='vertical-align:middle'>")
 S qY="" F i=1:1:$O(Vs(qqnump,13,3,""),-1) S j=$P(Vs(qqnump,13,3,i)," ",$S('viewan:2,1:1)) S:viewan $E(j)="" D ..write("<td align='center'>"_$TR(qW.GetWoc("CxWoc",j),"_"," ")_"</td>") S qY=qY_"/"_"OA"_$TR($P(j,"{"),"@:{}<>()""=/","ooooooooooo") ;@Dol 04.05.08 $P(,"{")
 F i=1:1:$O(Vs(qqnump,13,1,""),-1) S j=$P(Vs(qqnump,13,1,i)," ",2) S:viewan $E(j,1,2)="" D ..write("<td align='center'>"_$P("Num Sum Min Max Mid"," ",$P(Vs(qqnump,13,1,i)," ",3)-4)_" "_$TR(qW.GetWoc("CxWoc",j),"_"," ")_"</td>")
 D ..write("</tr>")
 D ..write("<xsl:apply-templates select='baseO"_qY_"'/>")
 D ..write("</table></div></body>")
 D ..write("</html>")
 D ..write("</xsl:template>")
 ;
 D ..write("<xsl:template match='"_$P(qY,"/",$L(qY,"/"))_"'>")
 D ..write("<tr style='vertical-align:top'>")
 F i=2:1:$L(qY,"/")-1 S qYt="" D
 .F j=$L(qY,"/")-1:-1:i S qYt=qYt_"parent::"_$P(qY,"/",j)_"/"
 .D ..write("<td align='center'><xsl:value-of select='"_qYt_"C'/></td>")
 D ..write("<td align='center'><xsl:value-of select='C'/></td>")
 F i=1:1:$O(Vs(qqnump,13,1,""),-1) S j=$S('viewan:"LA",1:"")_$P(Vs(qqnump,13,1,i)," ",2) D ..write("<td align='center'><xsl:value-of select='"_$S($E(j)?1N:"O",1:"")_$TR(j,"@:{}<>()/""=","ooooooooooo")_"/"_$P("Num Sum Min Max Mid"," ",$P(Vs(qqnump,13,1,i)," ",3)-4)_"'/></td>")
 D ..write("</tr>")
 D ..write("</xsl:template>")
 D ..write("</xsl:stylesheet>")
 D ..CloseDev(qqdev)
 D qARM.OpenIE(1,..ClientPath()_$G(diagfile)_".xsl",0)
 ;формируем массив qY, удобный для вывода xml-файла
 ;в виде qY(1)=<LA...>,qY(2)=<Num>(Sum,Min,Max,Mid),qY(3)=LA..._" "_№ в списке,qY(4)=</Num>,Y(5)=</LA...> и т.д. для всех Y
 ;используется при обходе слоя аналитики - метод DiagWExml(см. ниже)
 N qYN S (i,qYt,qY)="",j=0 F  S i=$O(Vs(qqnump,13,1,i)) D  Q:i=""
 .S qY=$S(i'="":Vs(qqnump,13,1,i),1:"") S:qY'="" qYN=$P(qY," ",3)-4,qY=$S('viewan:"LA",1:"")_$P(qY," ",2)
 .I qYt'=qY S:qYt'="" qY($I(j))="</"_$S($E(qYt)?1N:"O",1:"")_$TR($P(qYt,"{"),"@:{}<>()""=/","ooooooooooo")_">" S:qY'="" qY($I(j))="<"_$S($E(qY)?1N:"O",1:"")_$TR($P(qY,"{"),"@:{}<>()""=","oooooooooo")_">" S qYt=qY Q:qY=""  ;;@Dol 04.05.08 $P(,"{")
 .S qY($I(j))="<"_$P("Num Sum Min Max Mid"," ",qYN)_">",qY($I(j))=qY_" "_qYN,qY($I(j))="</"_$P("Num Sum Min Max Mid"," ",qYN)_">"
 ;вывод xml-файла
 S qqdev=2
 D ..OpenDev(qqdev)
 D ..write("<?xml version='1.0' encoding='windows-1251'?><?xml-stylesheet type='text/xsl' href='"_$G(diagfile)_".xsl'?>")
 D ..write("<baseO>")
 D DiagWExml($NA(^Qa(qqrela)),$S('viewan:"A",1:"")_$P(Vs(qqnump,13,3,1)," ",$S('viewan:2,1:1)),1)
 D ..write("</baseO>")
 D ..CloseDev(qqdev)
 D ..SendXML(2,Arg1-2,$G(diagfile),,Arg1'=5)
 Q ""
DiagWExml(qref,qqoAn,qA)
 S qA=$O(Vs(qqnump,13,3,qA))
 N value S value="" F  S value=$O(@qref@(qqoAn,value)) Q:value=""  D ..write("<O"_$TR(qqoAn,"@:","oo")_">") D  D ..write("</O"_$TR(qqoAn,"@:","oo")_">")
 .D ..write("<C>"_value_"</C>")
 .I qA'="" D DiagWExml($NA(@qref@(qqoAn,value)),$S('viewan:"A",1:"")_$P(Vs(qqnump,13,3,qA)," ",$S('viewan:2,1:1)),qA) Q
 .N i F i=1:1:$O(qY(""),-1) D
 ..I $E(qY(i))="<" D ..write(qY(i)) Q
 ..D ..write(+$LG($G(@qref@(qqoAn,value,$P(qY(i)," "))),$P(qY(i)," ",2)))
 Q
]]></Implementation>
</Method>

<Method name="GetJrnXML">
<Description>
TargType = 0/1/2 - вывод результата в: перменная/текущ.устр./файл
TargName -  имя файла или переменной, напр."с:\test.xml". Если почтовое сообщение, то ссылка на экземпляр класса, напр для m=##class(%Net.MailMessage).%New() параметр m
qqcBegin - первый узел (не включительно)
qqcEnd - последний узел (включительно)  </Description>
<Internal/>
<FormalSpec>TargType:%Library.String,TargName:%Library.String,qqcBegin:%Library.String,qqcEnd:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n P,T,S,D

 s P("TreeT")=1 ; 0/1 - лог./физ. дерево
 s P("Coll")=1 ; 0/1 - узел/коллекция узлов
 s P("TargT")=$g(TargType,2) ; 0/1/2 - вывод результата в: перменная/текущ.устр./файл
 s P("TargN")=$g(TargName,"c:\test.xml") ; имя файла или переменной
 s P("Title")="<?xml version='1.0' encoding='windows-1251'?>" ; пролог XML-документа
 s P("Title")=P("Title")_$c(13,10)_"<baseO>"
 s P("EndDoc")=$c(13,10)_"</baseO>" ; то, что надо вписать после вывода узлов
 s P("qqoRoot")="XJrn" ; для одного узла и коллекции - qqo корневого элемента
 s P("qqcRoot")="" ; для одного узла - qqc корневого элемента
 s P("qqcBegin")=$S($D(qqcBegin):qqcBegin,1:"") ; для коллекции - первый узел (НЕ включительно)
 s P("qqcEnd")=$S($D(qqcEnd):qqcEnd,1:$O(^QJ(1,"XJrn",""),-1)) ; для коллекции - последний узел (включительно)  
 s P("Pos")=0 ; 0/1 - несч./считать qqc позиц.кодом и по нему сортировать
 s P("CodeN")=1 ; 0/1 - выводить имена/их коды
 s P("CodeV")=1 ; 0/1 - выводить значения/их коды
 s P("GetC")=1 ; 0/1-невыводить/выводить коды узлов qqc
 s P("GetCC")=0 ; 0/1 - невыводить/выводить не пустые значения об. узлов
 s P("DirCh")=1 ; 0/1 - нет/да-список дочерних не искать в опис., а составлять
 s P("Format")=1 ; 0/1 - выводить атрибуты в строку/столбец
 s P("Error")=0 ; запись ошибок
 s P("ListNS")="" ; список префиксов тех NS, которые д.б.декларированы в корне
 s P("GetDTD")=0 ; 0/1-нет/да подать DTD, включающее компоненты и нотации               
 s P("ListEnt")="" ; список компонент, которые д.б.декларированы в DTD
 s P("ListNot")="" ; список нотаций, которые д.б.декларированы в DTD

 s T=1 ; количество выводимых деревьев
 s T(1)="^QJ(1,""XJrn"")"
 
 //misuno 20080806 добавлен анализ
 ;если почему-то не восстановлен журнал
 m:$D(^QJJ) ^QJ=^QJJ 
 k ^QJJ
 n qqcj
 s qqcj=P("qqcBegin")
 f  s qqcj=$O(^QJ(1,"XJrn",qqcj)) q:(qqcj="")!(qqcj]]P("qqcEnd"))  d
 .i '$G(^QJ(1,"XJrn",qqcj)) m ^QJJ(1,"XJrn",qqcj)=^QJ(1,"XJrn",qqcj) k ^QJ(1,"XJrn",qqcj)
 
 s S=1,S(1)="^Q(1)" ; количество используемых схем
 S D=T(1) ;?????
 d ..GetXML(.P,.T,.S,.D)  ; 
 q ""
]]></Implementation>
</Method>

<Method name="GetRelevXML">
<Description>
Метод для вывода логического дерева,
коллекции экземпляров с учетом имеющегося перечня релевантных.
Образец вызова метода находится в программе TestFind в GIRL.
ObjId-qqo
ViewId-код отображения
RelevId-слой для перечня релевантных</Description>
<Internal/>
<FormalSpec>ObjId:%Library.String,ViewId:%Library.String,RelevId:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; образец вызова метода находится в программе TestFind в GIRL
 ;

 n P,T,S,qqoRoot,qqcRoot
 s qqoRoot=""
 s qqcRoot=""
 s P("TreeT")=0 ; 0/1 - лог./физ. дерево
 s P("Coll")=1 ; 0/1 - узел/коллекция узлов
 s P("TargT")=2 ; 0/1/2 - вывод результата в: перменная/текущ.устр./файл
 s P("TargN")="c:\test.xml" ; имя файла или переменной
 s P("Title")="<?xml version='1.0' encoding='windows-1251'?>" ; пролог XML-документа
 s P("EndDoc")="" ; то, что надо вписать после вывода узлов
 s P("qqcBegin")="" ; для коллекции - первый узел (включительно)
 s P("qqcEnd")="" ; для коллекции - последний узел (включительно)   
 s P("Pos")=0 ; 0/1 - несч./считать qqc позиц.кодом и по нему сортировать
 s P("CodeN")=0 ; 0/1 - выводить имена/их коды
 s P("CodeV")=0 ; 0/1 - выводить значения/их коды
 s P("GetC")=1 ; 0/1-невыводить/выводить коды узлов qqc
 s P("GetCC")=0 ; 0/1 - невыводить/выводить не пустые значения об. узлов
 s P("DirCh")=0 ; 0/1 - нет/да-если нет списка дочерних, то выв.их как записано в данных
 s P("Format")=1 ; 0/1 - выводить атрибуты в строку/столбец
 s P("Error")=0 ; запись ошибок

 i $g(ViewId)="" s ViewId="###a"
 i $g(ObjId)="" s ObjId="3"
 i $g(RelevId)="" s RelevId="0###a "_$J


 s T=2
 s T(1)="^Q("""_RelevId_""","""_ObjId_""")"
 s T(2)="^Q(1,"""_ObjId_""")"

 s S=2
 s S(1)="^Q(1,""XView"","""_ViewId_""")"
 s S(2)="^Q(1)"
 s S(2,"X51")="CC"
 s S(2,"X7100")="CC"
 d ..GetXML(.P,.T,.S,,)  ; (P,T,S,qqoRoot,qqcRoot)
 q ""
]]></Implementation>
</Method>

<Method name="GetViewXML">
<Description>
Выводит описание отображения в виде XML</Description>
<Internal/>
<FormalSpec>ViewId:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n P,T,S,qqoRoot,qqcRoot

 s qqoRoot=""
 s qqcRoot=""
 s P("TreeT")=1 ; 0/1 - лог./физ. дерево
 s P("Coll")=0 ; 0/1 - узел/коллекция узлов
 s P("TargT")=2 ; 0/1/2 - вывод результата в: перменная/текущ.устр./файл
 s P("TargN")="c:\test.xml" ; имя файла или переменной
 s P("Title")="<?xml version='1.0' encoding='windows-1251'?>" ; пролог XML-документа
 s P("EndDoc")="" ; то, что надо вписать после вывода узлов
 s P("qqcBegin")="" ; для коллекции - первый узел (включительно)
 s P("qqcEnd")="" ; для коллекции - последний узел (включительно)   
 s P("Pos")=0 ; 0/1 - несч./считать qqc позиц.кодом и по нему сортировать
 s P("CodeN")=0 ; 0/1 - выводить имена/их коды
 s P("CodeV")=0 ; 0/1 - выводить значения/их коды
 s P("GetC")=1 ; 0/1-невыводить/выводить коды узлов qqc
 s P("GetCC")=1 ; 0/1 - невыводить/выводить не пустые значения об. узлов
 s P("DirCh")=0 ; 0/1 - нет/да-если нет списка дочерних, то выв.их как записано в данных
 s P("Format")=1 ; 0/1 - выводить атрибуты в строку/столбец
 s P("Error")=0 ; запись ошибок

 i $g(ViewId)="" s ViewId="####"

 s T=2 ; количество выводимых деревьев
 s T(1)="^Q(1,""XView"","""_ViewId_""")"
 s T(2)="^Q(1)"
 s T(2,"X51")="CC"  ; переопределения кодов
 s T(2,"X7100")="CC"
 s T(2,"CC")=""

 s S=2 ; количество используемых схем
 s S(1)="^Q(1,""XView"",""XXXXView"")"
 s S(2)="^Q(1)"
 s S(2,"X51")="CC"
 s S(2,"X7100")="CC"

 d ..GetXML(.P,.T,.S,,)  ; (P,T,S,qqoRoot,qqcRoot)
 q ""
]]></Implementation>
</Method>

<Method name="GetXML">
<Description>
Универсальная функция для вывода в XML, вызывается из других методов</Description>
<Internal/>
<FormalSpec><![CDATA[&P:%Library.String,&T:%Library.String,&S:%Library.String,&D:%Library.String]]></FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;////////// Это заготовка, которая д.б.вставлена в метод, вызывающий 'GetXML'
 ;
 ;n P,T,S,D
 ;s T=1,T(1)="^QJJ(1,""*1"",""AAB"")"
 ;s D="^QJJ(3)"  ; ==добавлено
 ;s S=1,S(1)="^QJJ(2)"

 ;s P("TreeT")=0 ; 0/1 - лог./физ. дерево
 ;s P("Coll")=0 ; 0/1 - один узел/коллекция узлов
 ;s P("TargT")=2 ; 0/1/2 - вывод результата в: перменная/текущ.устр./файл
 ;s P("TargN")="d:\test0.xml" ; имя файла или переменной
 ;s P("Title")="<?xml version='1.0' encoding='windows-1251'?>" ; пролог XML-документа
 ;s P("EndDoc")="" ; то, что надо вписать после вывода узлов
 ;s P("qqoRoot")="*1" ; для одного узла и коллекции - qqo корневого элемента
 ;s P("qqcRoot")="AAB" ; для одного узла - qqc корневого элемента
 ;s P("qqcBegin")="" ; для коллекции - первый узел (НЕ включительно)
 ;s P("qqcEnd")="" ; для коллекции - последний узел (включительно)       
 ;s P("Pos")=0 ; 0/1 - несч./считать qqc позиц.кодом и по нему сортировать
 ;s P("CodeN")=0 ; 0/1/2 - выводить имена/их коды/и то и другое
 ;s P("CodeV")=0 ; 0/1 - выводить значения/их коды
 ;s P("GetC")=0 ; 0/1-невыводить/выводить коды узлов qqc
 ;s P("GetCC")=0 ; 0/1 - невыводить/выводить не пустые значения об. узлов
 ;s P("DirCh")=0 ; 0/1 - нет/да-список дочерних не искать в опис., а составлять
 ;s P("Format")=1 ; 0/1 - выводить атрибуты в строку/столбец
 ;s P("Error")=0 ; запись ошибок
 ;s P("ListNS")="qq" ; список префиксов тех NS, которые д.б.декларированы в корне
 ;s P("GetDTD")=1 ; 0/1-нет/да подать DTD, включающее компоненты и нотации               
 ;s P("ListEnt")="" ; список компонент, которые д.б.декларированы в DTD
 ;s P("ListNot")="" ; список нотаций, которые д.б.декларированы в DTD
 ;s P("AttAsElem")=0 ; 0/1-нет/да выводить атрибуты как элементы

 ;d ..GetXML(.P,.T,.S,.D)
 ;q
 ;
 ;////////// Конец заготовки. Далее текст самого метода 'GetXML'.

 ; переменые кот.не надо запоминать при рекурсивном вызове 'GetOneObj':
 n qqoRoot,qqcRoot
 n WocList,ObjList,Sort2,n,tt,x,y,qqw,item,value,Tret,L,qqo1,qqc1,qqoPar,ss
 n GG,ii
 ; обработка входных параметров
 i $g(T)="" s P("Error")=1 q ""
 i $g(S)="" s S=0
 i P("TargT")=2 o P("TargN"):"WN" u P("TargN") ; открытие файла на запись
 i P("TargT")=0 s GG=P("TargN"),ii=-1  ; запись в перем. GG с индексом ii
 s L=-1 ; уровень иерархии для форматирования вывода

 i P("ListNS")'="" f n=$L(P("ListNS")," "):-1:1 d
 .s item=$p(P("ListNS")," ",n)
 .f ss=1:1:S s value=$g(@S(ss)@("CxNSp",item),"@") q:value'="@"
 .i (item="%")!(item="qq") s Sort2(-n,"xmlns:qq")=value q
 .i item="@" s Sort2(-n,"xmlns")=value q
 .s Sort2(-n,"xmlns:"_item)=value q
 i P("TargT") w P("Title")
 e  s ii=ii+1,@GG@(ii)=P("Title")
 i P("Coll")=1 d  i 1 ; для вывода коллекции
 .s qqoRoot=$g(P("qqoRoot"),$qs(T(1),$ql(T(1))))
 .i P("GetDTD")=1 d
 ..i P("TargT") d GetXMLGetDTDWriteTag i 1
 ..e  d GetXMLGetDTDWriteVariable
 .s qqcRoot=P("qqcBegin")
 .f  s qqcRoot=$o(@T(1)@(qqcRoot)) q:(qqcRoot="")!(qqcRoot]]P("qqcEnd"))  d
 ..f tt=1:1:T s T(tt)=$na(@T(tt)@(qqcRoot))
 ..d GetXMLOneObj(qqoRoot,qqcRoot)
 ..f tt=1:1:T s T(tt)=$na(@T(tt),$ql(T(tt))-1)
 e  d  ; для вывода одного узла
 .s qqoRoot=$g(P("qqoRoot"),$qs(T(1),$ql(T(1))-1))
 .i P("GetDTD")=1 d
 ..i P("TargT") d GetXMLGetDTDWriteTag i 1
 ..e  d GetXMLGetDTDWriteVariable
 .s qqcRoot=$g(P("qqcRoot"),$qs(T(1),$ql(T(1))))
 .d GetXMLOneObj(qqoRoot,qqcRoot)

 i P("TargT") w P("EndDoc")
 e  s ii=ii+1,@GG@(ii)=P("EndDoc")
 i P("TargT")=2 c P("TargN")
 q ""

GetXMLOneObj(qqo,qqc)   
 ; перед вызовом д.б. определены и заданы массивы 'P,T,S,D',
 n CloserTag,Sort1 ; эти перем., а также 'qqo,qqc' и 'child' сохраняем при рекурс. вызове
 s CloserTag="",L=L+1
 i $e(qqo)="#" s Sort2=$$GetXMLNodeValue()  ; ==добавлено
 i P("DirCh") s WocList=$$GetXMLMakeList(2) i 1
 e  d
 .f ss=1:1:S s WocList=$g(@S(ss)@("CxObj",qqo,"xWoc"),"@") q:WocList'="@"
 .i WocList="@" s WocList="" ; трактуем отсутствие значения как отсут.атрибутов
 i P("GetCC") d  ; добавляем 'C' и 'CC'к списку атрибутов
 .i WocList="" s WocList="CC" q
 .f n=1:1:$L(WocList," ") i $p(WocList," ",n)="CC" q
 .i '$T s WocList="CC "_WocList
 i P("GetC") d
 .i WocList="" s WocList="C" q
 .f n=1:1:$L(WocList," ") i $p(WocList," ",n)="C" q
 .i '$T s WocList="C "_WocList
 i WocList'="" d  ; заполняем массив 'Sort2'
 .f n=1:1:$L(WocList," ") d
 ..s qqw=$p(WocList," ",n)
 ..s value=$$GetXMLAttValue()
 ..i value'="@" s Sort2(n,qqw)=value
 i P("DirCh") s ObjList=$$GetXMLMakeList(1) i 1
 e  d
 .f ss=1:1:S s ObjList=$g(@S(ss)@("CxObj",qqo,"xObj"),"@") q:ObjList'="@"
 .i ObjList="@" s ObjList=""
 i 'P("TreeT") f tt=1:1:T s T(tt)=$na(@T(tt),$ql(T(tt))-2) ; обрезаем 'qqo,qqc' для лог.дер.
 i ObjList'="" d  ; заполняем массив 'Sort1'
 .f n=1:1:$L(ObjList," ") d
 ..s item=$p(ObjList," ",n) d GetXMLMakeSort1
 i P("TargT") d GetXMLWriteTag i 1 ; записываем откр.тег с атрибутами
 e  d GetXMLWriteVariable
 k Sort2
 i $d(Sort1)>1 d GetXMLChildObj ; внутри рекурс. вызов 'GetOneObj'
 i 'P("TreeT") f tt=1:1:T s T(tt)=$na(@T(tt)@(qqo,qqc)) ; добавл.'qqo,qqc' для лог.дер.
 i CloserTag'="" d
 .i P("TargT") w CloserTag ; записываем закр.тег если он есть
 .e  s @GG@(ii)=@GG@(ii)_CloserTag
 s L=L-1
 q

GetXMLChildObj     
 ; до вызова д.б. определены 'y,tt,qqo1,qqc1' 
 ; определены и заданы 'qqo,qqc' и массивы 'P,T,D,Sort1'
 n child ; сохраняем при рекурс. вызове
 s child="Sort1" f  s child=$q(@child) q:child=""  d
 .i P("Pos") s qqc1=$qs(child,1) 
 .e  s qqc1=$qs(child,2)
 .s qqo1=@child,qqoPar=qqo
 .f tt=1:1:T s T(tt)=$na(@T(tt)@(qqo1,qqc1)) ; добавл.'qqo1,qqc1'для лог.дерева
 .d GetXMLOneObj(qqo1,qqc1) ; T(tt) - это курсоры обходимых деревьев
 .f tt=1:1:T s T(tt)=$na(@T(tt),$ql(T(tt))-2) ; обрезаем 'qqo1,qqc1'для лог.дерева
 q


GetXMLMakeList(type)     ; ==добавлено 29.01.02
 ; до вызова д.б. определены и заданы массивы 'P,T,Tret'
 ; type - 1/2 - объект/атрибут
 n List,item,y,tt,n
 s List=""
 f tt=1:1:T d
 .s item="" f  s item=$o(@T(tt)@(item)) q:item=""  d
 ..i type=1,$d(@T(tt)@(item))<10 q
 ..i type=2,$d(@T(tt)@(item))>1 q
 ..s y=$g(Tret(tt,item),item)
 ..i List="" s List=y q
 ..f n=1:1:$L(List," ") i $p(List," ",n)=y q
 ..i '$T s List=List_" "_y
 q List




GetXMLGetDTDWriteVariable        
 n Nm,Val,Form1,Form2
 f ss=1:1:S s Nm=$g(@S(ss)@("CxObj",qqoRoot),"@") q:Nm'="@"
 i Nm="@" s Nm=$$GetXMLFiltrCode(qqoRoot) i 1
 e  s Nm=$$GetXMLFiltrName(Nm)
 f ss=1:1:S s Val=$g(@S(ss)@("XDoc",qqoRoot),"@") q:Val'="@"
 i P("ListEnt")="",P("ListNot")="" s Form1="",Form2=">"
 e  s Form1="[",Form2="]>"
 s ii=ii+1,@GG@(ii)="<!DOCTYPE "_Nm_" "_Val_Form1
 i P("ListEnt")'="" f n=1:1:$L(P("ListEnt")," ") d
 .s Nm=$p(P("ListEnt")," ",n)
 .f ss=1:1:S s Val=$g(@S(ss)@("XDoc",qqoRoot,"XEnt",Nm),"@") q:Val'="@"
 .s ii=ii+1,@GG@(ii)="  <!ENTITY "_Nm_" "_Val_">"
 i P("ListNot")'="" f n=1:1:$L(P("ListNot")," ") d
 .s Nm=$p(P("ListNot")," ",n)
 .f ss=1:1:S s Val=$g(@S(ss)@("XDoc",qqoRoot,"XNot",Nm),"@") q:Val'="@"
 .s ii=ii+1,@GG@(ii)="  <!NOTATION "_Nm_" "_Val_">"
 s @GG@(ii)=@GG@(ii)_Form2
 q
GetXMLGetDTDWriteTag        
 n Nm,Val,Form1,Form2
 f ss=1:1:S s Nm=$g(@S(ss)@("CxObj",qqoRoot),"@") q:Nm'="@"
 i Nm="@" s Nm=$$GetXMLFiltrCode(qqoRoot) i 1
 e  s Nm=$$GetXMLFiltrName(Nm)
 f ss=1:1:S s Val=$g(@S(ss)@("XDoc",qqoRoot),"@") q:Val'="@"
 i P("ListEnt")="",P("ListNot")="" s Form1="",Form2=">"
 e  s Form1="[",Form2="]>"
 w $c(13,10)_"<!DOCTYPE "_Nm_" "_Val_Form1
 i P("ListEnt")'="" f n=1:1:$L(P("ListEnt")," ") d
 .s Nm=$p(P("ListEnt")," ",n)
 .f ss=1:1:S s Val=$g(@S(ss)@("XDoc",qqoRoot,"XEnt",Nm),"@") q:Val'="@"
 .w $c(13,10)_"  <!ENTITY "_Nm_" "_Val_">"
 i P("ListNot")'="" f n=1:1:$L(P("ListNot")," ") d
 .s Nm=$p(P("ListNot")," ",n)
 .f ss=1:1:S s Val=$g(@S(ss)@("XDoc",qqoRoot,"XNot",Nm),"@") q:Val'="@"
 .w $c(13,10)_"  <!NOTATION "_Nm_" "_Val_">"
 w Form2
 q
GetXMLWriteVariable   
 ; до вызова д.б. определены и заданы 'qqo,L' и массивы 'P,Sort1,Sort2'
 n qqw,Nm,y,Form
 s Form=$j("",L*2)
 i $g(Sort2,"@")'="@" d  q
 .i qqo="#text" s Sort2=$$GetXMLFiltrValue(Sort2) s ii=ii+1,@GG@(ii)=Form_Sort2 q
 .i qqo="#cdata" s ii=ii+1,@GG@(ii)=Form_"<![CDATA["_Sort2_"]]]]><![CDATA[>" q
 .i qqo="#comment" s Sort2=$$GetXMLFiltrValue(Sort2) s ii=ii+1,@GG@(ii)=Form_"<!--"_Sort2_"-->" q
 i P("CodeN")=1 s Nm=$$GetXMLFiltrCode(qqo)
 i P("CodeN")=0 d
 .f ss=1:1:S s Nm=$g(@S(ss)@("CxObj",qqo),"@") q:Nm'="@"
 .i Nm="@" s Nm=$$GetXMLFiltrCode(qqo) i 1
 .e  s Nm=$$GetXMLFiltrName(Nm)
 i P("CodeN")=2 d
 .;f ss=1:1:S s Nm=$g(@S(ss)@("CxObj",qqo),"@") q:Nm'="@"
 .s Nm=$$GetXMLFiltrName(^Q(1,"CxObj",qqo)) ;Nm)
 .s Nm=Nm_".."_$$GetXMLFiltrCode(qqo)
 i $d(Sort1)>1 s CloserTag="</"_Nm_">"
 s ii=ii+1,@GG@(ii)=Form_"<"_Nm
 i $d(Sort2)>1 s y="Sort2" f  s y=$q(@y) q:y=""  d
 .s qqw=$qs(y,2)
 .i P("CodeN")=1 s Nm=$$GetXMLFiltrCode(qqw) i 1
 .i P("CodeN")=0 d
 ..f ss=1:1:S s Nm=$g(@S(ss)@("CxWoc",qqw),"@") q:Nm'="@"
 ..i Nm="@" s Nm=$$GetXMLFiltrCode(qqw) i 1
 ..e  s Nm=$$GetXMLFiltrName(Nm)
 .i P("CodeN")=2 d
 ..f ss=1:1:S s Nm=$g(@S(ss)@("CxWoc",qqw),"@") q:Nm'="@"
 ..s Nm=$$GetXMLFiltrName(Nm)
 ..s Nm=Nm_".."_$$GetXMLFiltrCode(qqw)
 .I $E(qqw,1,3)="xml" S Nm=qqw
 .i P("Format") s ii=ii+1,@GG@(ii)=$c(9,9)
 .e  s @GG@(ii)=@GG@(ii)_" "
 .i @y="" s @GG@(ii)=@GG@(ii)_Nm_"=''"
 .e  s @y=$$GetXMLFiltrValue(@y) s @GG@(ii)=@GG@(ii)_Nm_"='"_@y_"'"
 i $d(Sort1)>1 s @GG@(ii)=@GG@(ii)_">"
 e  s @GG@(ii)=@GG@(ii)_"/>"
 q
GetXMLWriteTag        
 ; до вызова д.б. определены и заданы 'qqo,L' и массивы 'P,Sort1,Sort2'
 n qqw,Nm,y,Form
 s Form=$c(13,10)_$j("",L*2)
 i $g(Sort2,"@")'="@" d  q
 .i qqo="#text" s Sort2=$$GetXMLFiltrValue(Sort2) w Form_Sort2 q
 .i qqo="#cdata" w Form_"<![CDATA["_Sort2_"]]]]><![CDATA[>" q
 .i qqo="#comment" s Sort2=$$GetXMLFiltrValue(Sort2) w Form_"<!--"_Sort2_"-->" q
 i P("CodeN")=1 s Nm=$$GetXMLFiltrCode(qqo) i 1
 i P("CodeN")=0  d
 .f ss=1:1:S s Nm=$g(@S(ss)@("CxObj",qqo),"@") q:Nm'="@"
 .i Nm="@" s Nm=$$GetXMLFiltrCode(qqo) i 1
 .e  s Nm=$$GetXMLFiltrName(Nm)
 i P("CodeN")=2  d
 .;?????f ss=1:1:S s Nm=$g(@S(ss)@("CxObj",qqo),"@") q:Nm'="@"
 .s Nm=$$GetXMLFiltrName(^Q(1,"CxObj",qqo)) ;)Nm)
 .s Nm=Nm_".."_$$GetXMLFiltrCode(qqo)
 i $d(Sort1)>1 s CloserTag="</"_Nm_">"
 i P("AttAsElem")=1,$d(Sort2)>1 s CloserTag="</"_Nm_">"
 w Form_"<"_Nm
 i P("AttAsElem")=1 d
 .i '($d(Sort1)>1),'($d(Sort2)>1) w "/>"
 .e  w ">"
 i $d(Sort2)>1 s y="Sort2" f  s y=$q(@y) q:y=""  d
 .s qqw=$qs(y,2)
 .i P("CodeN")=1 s Nm=$$GetXMLFiltrCode(qqw)
 .i P("CodeN")=0  d
 ..f ss=1:1:S s Nm=$g(@S(ss)@("CxWoc",qqw),"@") q:Nm'="@"
 ..i Nm="@" s Nm=$$GetXMLFiltrCode(qqw) i 1
 ..e  s Nm=$$GetXMLFiltrName(Nm)
 .i P("CodeN")=2  d
 ..f ss=1:1:S s Nm=$g(@S(ss)@("CxWoc",qqw),"@") q:Nm'="@"
 ..s Nm=$$GetXMLFiltrName(Nm)
 ..i Nm="@" s Nm=$$GetXMLFiltrCode(qqw) i 1
 ..s Nm=Nm_".."_$$GetXMLFiltrCode(qqw)
 .I $E(qqw,1,3)="xml" S Nm=qqw
 .i P("Format") w $c(13,10,9,9)
 .e  w " "
 .i P("AttAsElem")=0 d  i 1
 ..i @y="" w Nm_"=''"
 ..e  s @y=$$GetXMLFiltrValue(@y) w Nm_"='"_@y_"'"
 .e  d
 ..i @y="" w "<"_Nm_"/>"
 ..e  s @y=$$GetXMLFiltrValue(@y) w "<"_Nm_">"_@y_"</"_Nm_">"
 i P("AttAsElem")=0 d
 .i $d(Sort1)>1 w ">"
 .e  w "/>"
 q
GetXMLMakeSort1       
 ; до вызова д.б. определены и заданы 'item,n,qqc' и массивы 'P,T,Sort1'
 n Flag,tt,x
 s Flag=0 f tt=1:1:T d  q:Flag
 .i $d(@T(tt)@(item))=0 s Flag=1 q
 .i $d(@T(tt)@(item))=1 q
 .s Flag=1
 .i P("TreeT") s x="" f  s x=$o(@T(tt)@(item,x)) q:x=""  d  ;для физ.дер.
 ..i P("Pos") s Sort1(x,n)=item
 ..e  s Sort1(n,x)=item
 .i 'P("TreeT") s x=qqc f  s x=$o(@T(tt)@(item,x)) q:x'[qqc  d  ;для лог.дер.
 ..i P("Pos") s Sort1(x,n)=item
 ..e  s Sort1(n,x)=item
 q

GetXMLAttValue()    
 ; до вызова д.б. определены и заданы 'qqc,qqw' и массивы 'P,T'
 n n,tt,qqz,Str,FSim,Num,Para,Val
 s FSim=$e(qqw)
 i FSim="C" d  q Val
 .i $e(qqw,2)="C" f tt=1:1:T s Val=$g(@T(tt),"@") q:Val'="@"
 .e  s Val=qqc
 i FSim="Y" d  q ""   ;@dol
 .f tt=1:1:T i $d(@T(tt)@(qqw))>0,$g(@T(tt)@(qqw))'="@" q
 .i P("TargT") d GetXMLAnyTree($na(@T(tt)@(qqw))) i 1
 .e  d GetXMLAnyTree($na(@T(tt)@(qqw)),0,GG)
 f tt=1:1:T s Val=$g(@T(tt)@(qqw),"@") q:Val'="@"
 i Val="@" q Val ; (здесь надо будет сделать умолчания для выв. XSL-ных атрибутов)
 i Val="",FSim'="T" q Val
 i P("CodeV") q Val
 i FSim="M" q Val
 i FSim="X" q Val
 i FSim="D" q Val
 i FSim="T" d  q Para
 .s Num=0,Para=$g(@T(tt)@(qqw,Num)) f  s Num=$o(@T(tt)@(qqw,Num)) q:Num=""  d
 ..s Para=Para_$c(13,10)_@T(tt)@(qqw,Num)
 s Str="" d  q Str  ; для понятий типа "*"
 .f n=1:1:$L(Val," ") d
 ..s qqz=$p(Val," ",n) i qqz="" q
 ..s qqz=$g(@D@("C"_qqw,qqz),qqz)
 ..s Str=$s(Str="":qqz,1:Str_" "_qqz)
 q Val
GetXMLNodeValue()
 n n,tt,qqz,Str,FSim,Num,Para,Val
 f tt=1:1:T s Val=$g(@T(tt),"@") q:Val'="@"
 i Val="@" q Val ; (здесь надо будет сделать умолчания для выв. XSL-ных атрибутов)
 ;i Val="" q Val
 i P("CodeV") q Val
 i qqo="#cdata" q Val
 i qqo="#comment" d  q Para
 .s Num=0,Para=@T(tt)@(Num) f  s Num=$o(@T(tt)@(Num)) q:Num=""  d
 ..s Para=Para_$c(13,10)_@T(tt)@(Num)
 i qqo="#text" s FSim=$e(qqoPar)
 e  q Val
 i FSim="M" q Val
 i FSim="X" q Val
 i FSim="D" q Val
 i FSim="T" d  q Para
 .s Num=0,Para=@T(tt)@(Num) f  s Num=$o(@T(tt)@(Num)) q:Num=""  d
 ..s Para=Para_$c(13,10)_@T(tt)@(Num)
 s Str="" d  q Str  ; для текстовых узлов типа "*"
 .f n=1:1:$L(Val," ") d
 ..s qqz=$p(Val," ",n) i qqz="" q
 ..s qqz=$g(@D@("C"_qqo,qqz),qqz)
 ..s Str=$s(Str="":qqz,1:Str_" "_qqz)
 q Val

GetXMLFiltrCode(Nm) 
 i +Nm s Nm="_"_Nm
 q Nm

GetXMLFiltrName(Nm)
 n bb,Str s Str=""
 i $e(Nm)="%" s Nm="qq:"_$e(Nm,2,1000)
 f n=1:1:$L(Nm) s bb=$e(Nm,n) d  s Str=Str_bb  ; 
 .i bb="&" s bb="_" q
 .i bb="/" s bb="_" q
 .i bb="\" s bb="_" q
 .i bb="'" s bb="_" q
 .i bb="""" s bb="_" q
 .i bb=" " s bb="_" q
 .i bb="%" s bb="процент" q
 .i $a(bb)<32 s bb="_" q
 q Str
GetXMLFiltrValue(Val)
 n bb,Str s Str=""
 f n=1:1:$L(Val) s bb=$e(Val,n) d  s Str=Str_bb  ; 
 .i bb="&" s bb="&amp;" q
 .i bb="<" s bb="&lt;" q
 .i bb=">" s bb="&gt;" q
 .i bb="'" s bb="&apos;" q
 .i bb="""" s bb="&quot;" q
 .i $a(bb)=13 q
 .i $a(bb)=10 q
 .i $a(bb)=9 q
 .i $a(bb)=0 s bb="&" q
 .i $a(bb)<32 s bb="&#"_$a(bb)_";" q
 q Str
GetXMLAnyTree(Root,Type,GG2)
 ; Root - имя узла, поддерево которого выводится
 ; Type - 0/1 - ордер обход/ квери обход
 ; GG2 - имя переменной, куда выводим, если пусто то по команде 'write'
 i $g(GG2)="" s GG2=""
 i GG2'="",$g(ii)="" n ii s ii=-1 ; счетчик ii вкл.при внешнем вызове этой функции
 n Lev,Str,DD,Node,NumInd
 i Type=0 d  q  ; ордер обход
 .s Lev=0
 .s DD=$d(@Root)
 .i DD=0 s Str="<qw:var qw:name='"_Root_"'/>" q
 .i DD=1 s Str="<qw:var qw:name='"_Root_"' qw:value='"_@Root_"'/>" q
 .i DD=10 s Str="<qw:var qw:name='"_Root_"'>"
 .i DD=11 s Str="<qw:var qw:name='"_Root_"' qw:value='"_@Root_"'>"
 .i GG2="" w Str
 .e  s ii=ii+1,@GG2@(ii)=Str
 .d GetXMLAnyTree2(Root)
 .i GG2="" w "</qw:var>"
 .e  s @GG2@(ii)=@GG2@(ii)_"</qw:var>"
 i Type=1 d  q  ; квери обход
 .s DD=$d(@Root)
 .i (DD=1)!(DD=11) d
 ..s Str="<qw:var qw:name='"_Root_"' qw:value='"_@Root_"'/>"
 ..i GG2="" w Str
 ..e  s ii=ii+1,@GG2@(ii)=Str
 .s NumInd=$ql(Root)
 .s Node=Root f  s Node=$q(@Node) q:(Node="")!($na(@Node,NumInd)'=Root)  d
 ..s Str=$c(13,10)_"<qw:var qw:name='"_Node_"' qw:value='"_@Node_"'/>"
 ..i GG2="" w Str
 ..e  s ii=ii+1,@GG2@(ii)=Str
 q
GetXMLAnyTree2(Parent)
 n Form,Ind
 s Lev=Lev+1
 s Form=$c(13,10)_$j("",Lev*2)
 s Ind="" f  s Ind=$o(@Parent@(Ind)) q:Ind=""  d  
 .s Node=$na(@Parent@(Ind))
 .s DD=$d(@Node)
 .i DD=0 s Str=Form_"<qw:index qw:name='"_Ind_"'/>" q
 .i DD=1 s Str=Form_"<qw:index qw:name='"_Ind_"' qw:value='"_@Node_"'/>" q
 .i DD=10 s Str=Form_"<qw:index qw:name='"_Ind_"'>"
 .i DD=11 s Str=Form_"<qw:index qw:name='"_Ind_"' qw:value='"_@Node_"'>"
 .i GG2="" w Str
 .e  s ii=ii+1,@GG2@(ii)=Str
 .d GetXMLAnyTree2(Node)
 .i GG2="" w "</qw:index>"
 .e  s @GG2@(ii)=@GG2@(ii)_"</qw:index>"
 s Lev=Lev-1
 q
]]></Implementation>
</Method>

<Method name="Init">
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String,qqpar3:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 K WS,W,qwin,qprotstr,qqCEKey S qwin=""
 S length=5000
 D qSYS.BaseIni()
 I $G(qqpar3)'="" S qqP1=qqpar3
 I '$D(qARM("CntStr")) S qARM("CntStr")="cn_iptcp:127.0.0.1[1972]:GIRL" ;@dol tmp
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="LoadJrnXML">
<Description>
Восстановление XML журнала в заданный массив Tw
SourT -тип  источника XML 0/1/2 - перменная/текущ.устр./файл
SourN - источник XML. Если mail то  mailMsg из FetchMessage</Description>
<Internal/>
<FormalSpec>SourT:%Library.String,SourN:%Library.String,Tree:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n P,Tw,Sw,S,Dw,Rw
 s P("TreeT")=1 ; 0/1/2 - разбирать XML в: лог.дер./физ.дер./лог.дер.XORef
 s P("SourT")=$g(SourT,2) ; 0/1/2 - источник XML: перменная/текущ.устр./файл
 s P("SourN")=$g(SourN,"c:\test.xml") ; имя файла, переменной == или почты(?)
 s P("RootDelete")=2 ; 0/1/2 - записать все/отбросить Root-узлы неэлементы/и элементы тоже
 s P("CodeN")=1 ; 0/1 -нет/да - имена узлов это qW-коды (qqw,qqo), а вовсе не имена
 s P("CodeV")=1 ; 0/1 -нет/да - значения узлов это qW-коды (qqz)
 s P("qqcBegin")="" ; первый qqc НЕ вкл.(если сначала для лог.дер., то ='qqcParent'_"AAA")
 s P("qqcEnd")="" ; запись последнего qqc вкл., для справки
 s P("qqoParent")="#base" ; qqo род., только для модиф. его описаний в 'Sw' и для P("qqcFind")=1
 s P("qqcParent")="" ; qqc родителя для лог.дер.
 s P("QQBegin")=0  ; последний исп. номер для 'qqo' 'qqw' при их автоматич.создании 
 s P("NSBegin")=1  ; последний использованный номер для префикса намспейса
 s P("qqcFind")=0 ; 0/1-нет/да-qqcBegin должно быть найдено как посл.из имеющихся (только для P("Pos")=1)
 s P("Error")=0 ; запись ошибок
 s P("AttVDef")="*" ; "M","X","*","D","T" - тип хранения атрибутов по умолчанию
 s P("TxtVDef")="*" ; "M","X","*","D","T" - тип хранения влож. в элемент текст.узлов по умолчанию
 s P("Pos")=0 ; 0/1 - несч./считать qqc позиц.кодом и соотв.образом его генерировать

 s Tw=$g(Tree,"^QJJ(1)") ; узел, под который записываем узлы XML
 s Sw="^TempXML" ; узел, куда запис.метаданные, кот.не нашли в 'S'
 s Dw="^TempXML" ; узел, откуда читается и куда записывается словарь
 s Rw="^TempXML" ; узел, куда записывается обратная ссылка
 s S=1 ; схемы, общее количество
 s S(1)="^Q(1)" ; схемы, откуда берем описания

 d ..LoadXML(.P,.Tw,.Sw,.S,.Dw,.Rw)
 q ""
]]></Implementation>
</Method>

<Method name="LoadXML">
<Internal/>
<FormalSpec><![CDATA[&P:%Library.String,&Tw:%Library.String,&Sw:%Library.String,&S:%Library.String,&Dw:%Library.String,&Rw:%Library.String]]></FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;LoadXML(P,Tw,Sw,S,Dw,Rw)        
 ;////////// Это заготовка, которая д.б.вставлена в метод, вызывающий 'LoadXML'
 ;
 ;n P,Tw,Sw,S,Dw,Rw
 ;s P("TreeT")=0 ; 0/1/2 - разбирать XML в: лог.дер./физ.дер./лог.дер.XORef
 ;s P("SourT")=2 ; 0/1/2 - источник XML: перменная/текущ.устр./файл
 ;s P("SourN")="c:\test1.xml" ; имя файла, переменной == или почты(?)
 ;s P("RootDelete")=0 ; 0/1/2 - записать все/отбросить Root-узлы неэлементы/и элементы тоже
 ;s P("CodeN")=0 ; 0/1 -нет/да - имена узлов это qW-коды (qqw,qqo), а вовсе не имена
 ;s P("CodeV")=0 ; 0/1 -нет/да - значения узлов это qW-коды (qqz)
 ;s P("qqcBegin")="" ; первый qqc НЕ вкл.(если сначала для лог.дер., то ='qqcParent'_"AAA")
 ;s P("qqcEnd")="" ; запись последнего qqc вкл., для справки
 ;s P("qqoParent")="#base" ; qqo род., только для модиф. его описаний в 'Sw' и для P("qqcFind")=1
 ;s P("qqcParent")="" ; qqc родителя для лог.дер.
 ;s P("QQBegin")=0  ; последний исп. номер для 'qqo' 'qqw' при их автоматич.создании 
 ;s P("NSBegin")=1  ; последний использованный номер для префикса намспейса
 ;s P("qqcFind")=0 ; 0/1-нет/да-qqcBegin должно быть найдено как посл.из имеющихся (только для P("Pos")=1)
 ;s P("Error")=0 ; запись ошибок
 ;s P("AttVDef")="*" ; "M","X","*","D","T" - тип хранения атрибутов по умолчанию
 ;s P("TxtVDef")="*" ; "M","X","*","D","T" - тип хранения влож. в элемент текст.узлов по умолчанию
 ;s P("Pos")=0 ; 0/1 - несч./считать qqc позиц.кодом и соотв.образом его генерировать

 ;s Tw="^QJJ(1)" ; узел, под который записываем узлы XML
 ;s Sw="^QJJ(2)" ; узел, куда запис.метаданные, кот.не нашли в 'S'
 ;s Dw="^QJJ(3)" ; узел, откуда читается и куда записывается словарь
 ;s Rw="^QJJ(4)" ; узел, куда записывается обратная ссылка
 ;s S=1 ; схемы, общее количество
 ;s S(1)="^Q(1)" ; схемы, откуда берем описания
 ;d ..LoadXML(.P,.Tw,.Sw,.S,.Dw,.Rw)
 ;q
 ;
 ;////////// Конец заготовки. Далее текст самого метода 'LoadXML'.

 n aa,paa,ppaa  ;текущий символ,предыдущий и предпредыдущий
 n T,N,L,X
 n QQC  ;
 n Glb,n,nn,ss,Nd
 n XORef
 n Err,StrXML,NumSim,FlagExit
 n ReplPr,Pr,qPr,NSp,FlagSysAtt,FlagSpace
 n att,FSim,Label,AttQQC
 ; ниже определены массивы для промежуточной обраб.данных
 ; att,elm,txt,node,meta - 5 типовых групп узлов
 ; ( C,P,N,V,S,VC - соответственно - Code,Prefics,Name,Value,Storage,ValueCode
 ;  т.е.- код, префикс, имя, значение, способ хранения, код значения)
 n attC,attP,attN,attV,attS,attVC ;
 n elmC,elmP,elmN,elmS  ;  ,elmV,elmVC
 n txtC,txtN,txtV,txtVC  ;  ,txtP,txtS
 n nodeC,nodeN,nodeV,nodeS,nodeVC  ;  ,nodeP
 n meta,metaC,metaN,metaV  ;  ,metaP,metaS,metaVC

 ; обработка входных параметров
 i P("qqcFind")=1 d LoadXMLFindQQC
 ;i $g(P("qqcBegin"))="" d
 ;.i P("TreeT")=1 s P("qqcBegin")=0
 ;.e  s P("qqcBegin")=$g(P("qqcParent"))_"AAA" q
 i $g(S)="" s S=0

 s T="?",N="",FlagSpace=1 ;
 s att=0
 s FlagSysAtt=0
 i P("RootDelete")=1 s FlagExit=1
 e  s FlagExit=0
 i P("RootDelete")=2 s L=0
 e  s L=1
 s Err=0
 s elmC(0)=P("qqoParent")
 s QQC(1)=P("qqcBegin"),QQC(0)=P("qqcParent")

 ;////////ВКЛЮЧЕНИЕ ВЫВОДА В ЛИНЕЙНУЮ МОДЕЛЬ (ОТЛАДКА РАЗБОРЩИКА СИМВ.ПОТОКА)
 n NumLinMod s NumLinMod=0 k ^Qdebug   ;индекс для линейной модели
 ;////////

 i P("SourT")=0 d LoadXMLSourGlobal
 i P("SourT")=1 d LoadXMLSourStream
 i P("SourT")=2 d LoadXMLSourFile
 s P("qqcEnd")=QQC(1)
 q ""
LoadXMLSourFile       
 ;построчный разбор файла
 i $zu(68,40,1) Open P("SourN"):("RF":2500):0
 e  s Err=100 q
 f  Use P("SourN") Read StrXML q:$zeof<0  d LoadXMLStringStream q:Err
 Close P("SourN")
 q
LoadXMLSourStream               
 f  d  q:StrXML=""
 .s StrXML=%request.Content.Read(1000)
 .d LoadXMLStringStream(StrXML)
 q
LoadXMLSourGlobal               
 ;поузельный разбор глобала от заданного узла до последнего дочернего
 i $d(@P("SourN"))=0 s Err="NoSource" q Err
 i $d(@P("SourN"))=10 s P("SourN")=$q(@P("SourN"))
 f  s StrXML=@P("SourN") d LoadXMLStringStream q:Err  s P("SourN")=$q(@P("SourN")) q:P("SourN")=""
 q


LoadXMLStringStream                       
 ; StrXML принятая строка символов из файла или глобала
 f NumSim=1:1:$l(StrXML) d  q:Err
 .s aa=$e(StrXML,NumSim)
 .i FlagSpace=0 s aa=$s($a(aa)<32:" ",1:aa)  ; если FlagSpace=1,то $c(9,10,13) сохраняются
 .d LoadXMLSimbolStream
 q

LoadXMLSimbolStream                       
 ; aa-принятый очередной символ
 ; Перед каждым вызовом 'LoadXMLGo1' имеем:
 ; T-тип получаемого фрагмента узла
 ; N-имя или значение узла
 ; L-уровань иерархии
 ; X-доп.признак, в каком месте читаем узел
 ;---------------------------------------
 i T="?" d  q  ; находимся вне тегов
 .i aa=" " q  ; отрезаем ведущие пробелы и пр.
 .i aa=$c(13) q  ;
 .i aa=$c(10) q  ;
 .i aa="<" s T="<",N="",FlagSpace=0 q
 .e  s T=3,N="#text" d LoadXMLGo1 s T="s3",N=aa q
 i T="s3" d  q  ; текст
 .i aa="<" d LoadXMLGo1 s T=-3,N="" d LoadXMLGo1 s T="<",N="",FlagSpace=0 q
 .e  s N=N_aa q

 i T="<" d  q  ; вошли в тег, либо: закрыв.тег, PI, коментарий, CDATA, DTD, откр.тег
 .i aa=" " q
 .i aa="/" s L=L-1,T=-1,N="" q
 .i aa="?" s T=7,X="N",N="" q
 .i aa="!" s T="!",N="" q
 .e  s T=1,X="N",N=aa q
 i T=-1 d  q  ; закрыв.тег (или закрытие пустого тега, тогда N="")
 .i aa=" " q
 .i aa=">" d LoadXMLGo1 s T="?",N="",FlagSpace=1 q  ;
 .e  s N=N_aa q
 i T=1,X="N" d  q  ; откр.тег или пустой тег
 .i aa=">" d LoadXMLGo1 s T=0,N="" d LoadXMLGo1 s L=L+1,T="?",N="",FlagSpace=1 q
 .i aa="/" d LoadXMLGo1 s T=0,N="" d LoadXMLGo1 s T=-1 q
 .i aa=" " d LoadXMLGo1 s T=1,X="?" q
 .e  s N=N_aa q
 i T=1,X="?" d  q  ; внутри откр.тега возможно есть атрибуты, а возм.нет
 .i aa=" " q
 .i aa=">" s T=0,N="" d LoadXMLGo1 s L=L+1,T="?",N="",FlagSpace=1 q
 .i aa="/" s T=0,N="" d LoadXMLGo1 s T=-1 q
 .e  s L=L+1,T=2,X="N",N=aa q

 i T=2,X="N" d  q  ; атрибут со значением, а возможно без
 .i aa=" " d LoadXMLGo1 s T=-2,N="" d LoadXMLGo1 s L=L-1,T=1,X="?" q
 .i aa="/" d LoadXMLGo1 s T=-2,N="" d LoadXMLGo1 s L=L-1,T=0,N="" d LoadXMLGo1 s T=-1 q
 .i aa=">" d LoadXMLGo1 s T=-2,N="" d LoadXMLGo1 s L=L-1,T=0,N="" d LoadXMLGo1 s L=L+1,T="?",N="",FlagSpace=1 q
 .i aa="=" d LoadXMLGo1 s T=2,X="?" q
 .e  s N=N_aa q
 i T=2,X="?" d  q  ; атрибут с неизвестной кавычкой у значения
 .i aa=" " q
 .i aa="""" s T="s2",X="q",N="",FlagSpace=1 q
 .i aa="'" s T="s2",X="a",N="",FlagSpace=1 q
 .e  q
 i T="s2",X="q" d  q  ;атрибут с кавычкой, вошли внутрь значения
 .i aa="""" d  q
 ..d LoadXMLGo1
 ..s T=-2,N="" d LoadXMLGo1 s L=L-1,T=1,X="?",N="",FlagSpace=0
 .e  s N=N_aa q
 i T="s2",X="a" d  q  ; атрибут с апострофом, вошли внутрь значения
 .i aa="'" d  q
 ..d LoadXMLGo1
 ..s T=-2,N="" d LoadXMLGo1 s L=L-1,T=1,X="?",N="",FlagSpace=0
 .e  s N=N_aa q

 i T=7,X="N" d  q  ; PI
 .i aa=" " d LoadXMLGo1 s T="s7",X=7,N="",paa="" q
 .e  s N=N_aa q
 i T="s7",X=7 d  q  ; PI
 .i aa=">",paa="?" d LoadXMLGo1 s T=-7,N="" d LoadXMLGo1 s T="?",N="",FlagSpace=1 q
 .e  s N=N_paa,paa=aa q
 i T="!" d  q  ; либо: коментарий, CDATA, DTD
 .i aa=" " d  q
 ..i N="DOCTYPE" s T=10,N="" q
 ..i N="ENTITY" s T=6,N="" q
 ..i N="NOTATION" s T=12,N="" q
 .i aa="-" s T="-" q
 .i aa="[" s T=4,X="N",N="" q
 .e  s N=N_aa q

 i T=10 d  q
 .i aa=" ",N="" q
 .i aa=" " d LoadXMLGo1 s T="s10",N="" q
 .e  s N=N_aa q
 i T="s10" d  q
 .i aa="[" d LoadXMLGo1 s L=L+1,T="?",N="" q
 .i aa=">" d LoadXMLGo1 s T=-10,N="" d LoadXMLGo1 s T="?",N="",FlagSpace=1 q
 .e  s N=N_aa q
 i T=6 d  q
 .i aa=" ",N="" q
 .i aa=" " d LoadXMLGo1 s T="s6",N="",FlagSpace=1 q
 .e  s N=N_aa q
 i T="s6" d  q
 .i aa=">" d LoadXMLGo1 s T=-6,N="" d LoadXMLGo1 s T="?D",N="",FlagSpace=0 q
 .e  s N=N_aa q
 i T=12 d  q
 .i aa=" ",N="" q
 .i aa=" " d LoadXMLGo1 s T="s12",N="" q
 .e  s N=N_aa q
 i T="s12" d  q
 .i aa=">" d LoadXMLGo1 s T=-12,N="" d LoadXMLGo1 s T="?D" q
 .e  s N=N_aa q
 i T="?D" d  q
 .i aa="<" s T="<",N="" q
 .i aa="]" s L=L-1,T=-10,N="" q
 i T=-10 d  q
 .i aa=">" d LoadXMLGo1 s T="?",N="",FlagSpace=1 q

 i T="-" d  q  ; либо: коментарий, ошибка     
 .i aa="-" s T=8,X="N",N="#comment" d LoadXMLGo1 s T="s8",X=8,N="",paa="",ppaa="",FlagSpace=1 q
 .e  s Err=1 q
 i T="s8",X=8 d  q  ; коментарий
 .i aa=">",paa="-",ppaa="-" d LoadXMLGo1 s T=-8,N="" d LoadXMLGo1 s T="?",N="",FlagSpace=1 q
 .e  s N=N_ppaa,ppaa=paa,paa=aa q
 i T=4,X="N" d  q  ; CDATA
 .i aa="[" s N="#cdata" d LoadXMLGo1 s T="s4",X=4,N="",paa="",ppaa="",FlagSpace=1 q
 .e  s N=N_aa q
 i T="s4",X=4 d  q  ; CDATA
 .i aa=">",paa="]",ppaa="]" d LoadXMLGo1 s T=-4,N="" d LoadXMLGo1 s T="?",N="",FlagSpace=1 q
 .e  s N=N_ppaa,ppaa=paa,paa=aa q
 q

LoadXMLGo1              
 ;  'LoadXMLGo1' вызывается когда установлен какой-либо фрагмент узла;
 ;  его содержимое (имя или значение) находится в 'N'
 ;  'T' -тип узла согласно номерам типов MS DOM с дополнениями, 'X'-неважно
 ;  'FlagSpace' -если =1, то символы $c(9,10,13) пропускаются, =0, то замен.на пробелы
 ;T=1 -открывающий тег элемента. 
 ;T=0 -закрытие открывающего тега, пустого или нет.
 ;T=-1 -закрывающий тег(N'="") или закрытие пуст.тега(N="") элемента.
 ;T=2,T=-2 - "открытие" и "закрытие" атрибута.
 ;T=3,T=-3 - ...текстового узла.
 ;T=4,T=-4 - ...неразбираемых данных (CDATA).
 ;T=7,T=-7 - ...инструкций процессору (PI).
 ;T=8,T=-8 - ...коментария.
 ;T=10,T=-10 - ...опр.типа документа (DTD).
 ;T=12,T=-12 - ...нотации.
 ;T=6,T=-6 - ...компонент .
 ;
 ;T="s2",T="s3",T="s7",T="s8",T="s4",T="s10",T="s12",T="s6"
 ; -строка значения узлов типа 2,3,7,8,4,10,12,6
 ;i (T=9)!(T=11) q  ; не обрабатываем


 i L=0 q  ; отсекание Root-ов
 i L=1 i (T=2)!(T=-2)!(T="s2") q
 i L=1,P("RootDelete")=1 d
 .i T=1 s FlagExit=0 q
 .i T=-1 s FlagExit=1 q
 i FlagExit q

 ;////ВКЛЮЧЕНИЕ ВЫВОДА В ЛИНЕЙНУЮ МОДЕЛЬ (ОТЛАДКА)
 d LoadXMLLinearModel
 ;////

 ; обработка системных xml-атрибутов:
 ; намспейсов,         
 ;------------------------------------------------------------
 ;
 i T=2 d  q  ; атрибут
 .i $e(N,1,3)="xml" s FlagSysAtt=1 d  q
 ..i $p(N,":",1)="xmlns" s Pr=$p(N,":",2) i Pr="" s Pr="@" q  ; обр. нового намспейса
 .s att=att+1 ; счетчик количества атрибутов
 .i P("CodeN")=1 s attC(att)=N q  ; если не имена, а коды
 .i $L(N,":")=1 s attP(att)="@",attN(att)=N
 .e  s attP(att)=$p(N,":",1),attN(att)=$p(N,":",2)
 i T="s2" d  q
 .i FlagSysAtt d  q
 ..i $g(Pr)'="" s NSp=N q  ; обр. нового намспейса
 .s attV(att)=N ; 
 i T=-2 d  q
 .i FlagSysAtt s FlagSysAtt=0 d  q
 ..i $g(Pr)'="" d  q  ; обр. нового намспейса
 ...s qPr=$g(@Sw@("xNSp",NSp)) i qPr="" d LoadXMLSetNSpace  ; проверка наличия и создание описаний в Sw
 ...s ReplPr(Pr)=qPr k Pr,qPr,NSp

 i T=1 d  q  ; элемент
 .i P("CodeN")=1 s elmC(L)=N q  ; если не имена, а коды
 .i $L(N,":")=1 s elmP(L)="@",elmN(L)=N
 .e  s elmP(L)=$p(N,":",1),elmN(L)=$p(N,":",2)
 i T=0 d  q
 .s Label="elm" d LoadXMLGo2
 .k attC,attP,attN,attV,attS,attVC s att=0
 i T=-1 d  q
 .i L=1,$g(meta,"@")'="@" d  ; запись узлов 'meta' в момент закрытия корневого элемента
 ..i $L(metaN(1),":")=2 s metaN(1)=ReplPr($p(metaN(1),":",1))_":"_$p(metaN(1),":",2)
 ..e  i $g(ReplPr("@"))'="" s metaN(1)=ReplPr("@")_":"_metaN(1)
 ..s metaC(1)=@Sw@("xObj",metaN(1))
 ..Merge @Sw@("XDoc",metaC(1))=meta
 .k elmC(L),elmP(L),elmN(L),elmV(L),elmS(L),elmVC(L)

 i T=3 s txtN=N q  ;  узел text
 i T="s3" s txtV=N q
 i T=-3 d  q
 .s Label="txt" d LoadXMLGo2 
 .k txtC,txtN,txtV,txtVC q

 i (T=4)!(T=8) s nodeN=N q  ; узлы CDATA, коментарий
 i (T="s4")!(T="s8") s nodeV=N q
 i (T=-4)!(T=-8) d  q
 .s Label="node" d LoadXMLGo2
 .k nodeC,nodeN,nodeV,nodeS,nodeVC


 i (T=6)!(T=7)!(T=10)!(T=12) s metaN(L)=N q  ; узлы PI,DTD,сущность,нотация
 i (T="s6")!(T="s7")!(T="s10")!(T="s12") s metaV(L)=N q
 i (T=-6)!(T=-7)!(T=-10)!(T=-12) d  q
 .s Label="meta" d LoadXMLGo2
 .i L'=1 k metaN(L),metaV(L)

 k N
 q
 ;

LoadXMLGo2      
 ; устанавл. qW-префиксы, qW-коды, заполнение описаний, 
 ; -----------------------------------------------------
 i P("CodeN")=1 d  d LoadXMLGo3 q
 i Label="txt" d  d LoadXMLGo3 q
 .s txtC="#text" s elmC(L)=txtC d LoadXMLSetObj q
 i Label="node" d  d LoadXMLGo3 q
 .i T=-4 s nodeC="#cdata" s elmC(L)=nodeC d LoadXMLSetObj q  ; CDATA
 .i T=-8 s nodeC="#comment" s elmC(L)=nodeC d LoadXMLSetObj q  ; коментарий
 i Label="meta" d  q  ; выход!! для этих узлов запись после закрытия документа
 .i T=-6 s meta("XEnt",metaN(L))=metaV(L) q  ; сущность
 .i T=-7 s meta("XPI",metaN(L))=metaV(L) q  ; PI
 .i T=-10 s meta=metaV(L) q  ; DTD
 .i T=-12 s meta("XNot",metaN(L))=metaV(L) q  ; нотация
 i Label="elm" d  d LoadXMLGo3 q
 .d  ; для элемента
 ..i P("CodeN")=1 s elmC(L)=elmN(L) q
 ..s qPr=$g(ReplPr(elmP(L)),"@") ; если qPr="@" то либо намспейса нет вообще, либо это qW-овский
 ..i qPr="%" s elmN(L)=qPr_elmN(L)
 ..e  i qPr'="@" s elmN(L)=qPr_":"_elmN(L)
 ..s elmC(L)=$g(@Sw@("xObj",elmN(L))) i elmC(L)="" d LoadXMLCreateObj ; проверка наличия и создание опис.в Sw
 ..d LoadXMLSetObj ; дополнение описаний в Sw
 .f n=1:1:att d  ; для атрибутов элемента
 ..i P("CodeN")=1 s attC(n)=attN(n) q
 ..s qPr=$g(ReplPr(attP(n)),"@") ; 
 ..i qPr="%" s attN(n)=qPr_attN(n)
 ..e  i qPr'="@" s attN(n)=qPr_":"_attN(n)
 ..s attC(n)=$g(@Sw@("xWoc",attN(n))) i attC(n)="" d LoadXMLCreateWoc ; проверка наличия и создание опис.в Sw
 ..d LoadXMLSetWoc ; дополнение описаний в Sw
 d LoadXMLGo3 q

LoadXMLGo3      
 ;  qW-способы хранения
 ; -----------------------------------------------------
 i Label="elm" d  d LoadXMLGo4 q
 .d  ; для текстового содержимого элемента
 ..s FSim=$e(elmC(L))
 ..s elmS(L)=$S(FSim="M":"M",FSim="X":"X",FSim="D":"D",FSim="T":"T",1:"*") ; способ хранения
 .f n=1:1:att d  ; для значений атрибутов
 ..s FSim=$e(attC(n))
 ..s attS(n)=$S(FSim="C":"C",FSim="M":"M",FSim="X":"X",FSim="D":"D",FSim="T":"T",1:"*") ; способ хранения
 ..i FSim="C",$e(attC(n),2)="C" s attS(n)="CC"
 i Label="node" d  d LoadXMLGo4 q
 .i T=-4 s nodeS="M" q  ; CDATA
 .i T=-8 s nodeS="T" q  ; коментарий
 d LoadXMLGo4 q

LoadXMLGo4      
 ; преобр.значений к способу хранения и их кодирование
 ; -----------------------------------------------------
 ;i P("TreeT")=1 d LoadXMLGo5 q
 i Label="elm" d  d LoadXMLGo5 q
 .f n=1:1:att d  ; для атрибутов
 ..i attS(n)="C" s AttQQC=attV(n) q
 ..i (attS(n)="M")!(attS(n)="X") q
 ..i attS(n)="T" d LoadXMLToText("attV("_n_")") q
 ..i attS(n)="D" d  q
 ...d LoadXMLToTokens("attV("_n_")")
 ..i attS(n)="*" d  q
 ...d LoadXMLToTokens("attV("_n_")")
 ...d LoadXMLCodingValue(attC(n),"attV("_n_")","attVC("_n_")") 
 i Label="txt" d  d LoadXMLGo5 q
 .d
 ..i (elmS(L-1)="M")!(elmS(L-1)="X") q
 ..i elmS(L-1)="T" d LoadXMLToText("txtV") q
 ..i elmS(L-1)="D" d  q
 ...d LoadXMLToTokens("txtV")
 ..i elmS(L-1)="*" d  q
 ...d LoadXMLToTokens("txtV")
 ...d LoadXMLCodingValue(elmC(L),"txtV","txtVC")
 i Label="node" d  d LoadXMLGo5 q
 .d
 ..i nodeS="M" q
 ..i nodeS="T" d LoadXMLToText("nodeV") q
 d LoadXMLGo5 q


LoadXMLGo5      
 ; устанавл.qqc текущего уровня и следующего
 ; -----------------------------------------------------
 n LenCd,LenCur,ChildCd,FrCd,Flag
 i Label="txt" s elmC(L)=txtC
 i Label="node" s elmC(L)=nodeC

 i $g(AttQQC)'="" s QQC(L)=AttQQC k AttQQC,QQC(L+1) d LoadXMLGo6 q  ; qqc указан в значении 'C'-атрибута
 i P("Pos")=1 d  ; сквозная нумерация всех дочерних узлов
 .i P("TreeT")=1 s QQC(L)=$g(QQC(L),0)+1 k QQC(L+1) q
 .i $g(QQC(L))="" d
 ..s LenCur=$g(@Sw@("CxObj",elmC(L),"X50")) i LenCur="" s LenCd=3
 ..e  s LenCd=LenCur-$g(@Sw@("CxObj",elmC(L-1),"X50"),0)
 ..s FrCd="",$p(FrCd,"A",LenCd+1)="",QQC(L)=QQC(L-1)_FrCd
 .s QQC(L)=$$LoadXMLNextCode(QQC(L)) k QQC(L+1) q
 i P("Pos")=0 d  ; каждый именованый узел нумеруется индивидуально
 .i P("TreeT")=1 d  q
 ..s Glb=$na(@Tw) f n=1:1:L-1 s Glb=$na(@Glb@(elmC(n),QQC(n)))
 ..i $d(@Glb@(elmC(L)))<10 s QQC(L)=0 q
 ..s QQC(L)=$o(@Glb@(elmC(L),""),-1)+1 q
 .s Flag=1 i $d(@Tw@(elmC(L)))>1 d
 ..s ChildCd=$o(@Tw@(elmC(L),QQC(L-1)_"{"),-1)
 ..i ($F(ChildCd,QQC(L-1)))=($L(QQC(L-1))+1) s QQC(L)=$$LoadXMLNextCode(ChildCd),Flag=0
 .i Flag d
 ..s LenCur=$g(@Sw@("CxObj",elmC(L),"X50")) i LenCur="" s LenCd=3
 ..e  s LenCd=LenCur-$g(@Sw@("CxObj",elmC(L-1),"X50"),0)
 ..s FrCd="",$p(FrCd,"A",LenCd+1)="",QQC(L)=QQC(L-1)_FrCd
 ..s QQC(L)=$$LoadXMLNextCode(QQC(L))
 d LoadXMLGo6 q

LoadXMLGo6      
 ; запись узлов
 ; -----------------------------------------------------

 d  ; для всех типов узлов
 .i P("TreeT")=0 d  ; лог.дер
 ..s @Tw@(elmC(L))=$g(@Tw@(elmC(L)),0)+1  ; счетчик экз.
 ..s Glb=$na(@Tw@(elmC(L),QQC(L)))
 .i P("TreeT")=1 d  ; физ.дер
 ..i L=1 s @Tw@(elmC(L))=$g(@Tw@(elmC(L)),0)+1  ; счетчик экз.
 ..s Glb=$na(@Tw) f n=1:1:L s Glb=$na(@Glb@(elmC(n),QQC(n)))
 .i P("TreeT")=2 d  ; лог.дер.с XORef
 ..s @Tw@(elmC(L))=$g(@Tw@(elmC(L)),0)+1  ; счетчик экз.
 ..s XORef=elmC(1) f n=2:1:L s XORef=XORef_","_elmC(n)
 ..s Glb=$na(@Tw@(XORef,QQC(L)))
 ;
 i Label="elm" d  d LoadXMLGo7 q
 .s @Glb=""  ; запись элемента
 .f n=1:1:att d  ; запись его атрибутов
 ..i attS(n)="C" q
 ..i attS(n)="CC" s @Glb=attV(n) q
 ..i (attS(n)="M")!(attS(n)="X") d  q
 ...s @Glb@(attC(n))=attV(n) q
 ..i attS(n)="*" d  q
 ...s @Glb@(attC(n))=""
 ...f nn=1:1:attVC(n) d
 ....i @Glb@(attC(n))="" s @Glb@(attC(n))=attVC(n,nn)
 ....e  s @Glb@(attC(n))=@Glb@(attC(n))_" "_attVC(n,nn) q
 ..i attS(n)="D" d  q
 ...s @Glb@(attC(n))=""
 ...f nn=1:1:attV(n) d
 ....i $g(@Glb@(attC(n)))="" s @Glb@(attC(n))=attV(n,nn)
 ....e  s @Glb@(attC(n))=@Glb@(attC(n))_" "_attV(n,nn) q
 ..i attS(n)="T" d  q
 ...s @Glb@(attC(n))=""
 ...f nn=1:1:attV(n) s @Glb@(attC(n),nn-1)=attV(n,nn)
 i Label="txt" d  d LoadXMLGo7 q
 .i (elmS(L-1)="M")!(elmS(L-1)="X") d  q
 ..s @Glb=txtV q
 .i elmS(L-1)="*" d  q
 ..f nn=1:1:txtV d
 ...i $g(@Glb)="" s @Glb=txtVC(nn)
 ...e  s @Glb=@Glb_" "_txtVC(nn) q
 .i elmS(L-1)="D" d  q
 ..f nn=1:1:txtV d
 ...i $g(@Glb)="" s @Glb=txtV(nn)
 ...e  s @Glb=@Glb_" "_txtV(nn) q
 .i elmS(L-1)="T" d  q
 ..s @Glb=""
 ..f nn=1:1:txtV s @Glb@(nn-1)=txtV(nn)
 i Label="node" d  d LoadXMLGo7 q
 .i nodeS="M" d  q
 ..s @Glb=nodeV q
 .i nodeS="T" d
 ..s @Glb=""
 ..f nn=1:1:nodeV s @Glb@(nn-1)=nodeV(nn)
 d LoadXMLGo7 q


LoadXMLGo7      
 ; делать словарную ссылку
 ; -----------------------------------------------------
 i P("CodeV")=1 d LoadXMLGo8 q
 i P("TreeT")=1 d LoadXMLGo8 q
 i Label="elm" d  d LoadXMLGo8 q
 .f n=1:1:att d  ;q  ; запись атрибутов
 ..i (attS(n)="*")!(attS(n)="D") d  q
 ...f nn=1:1:attV(n) d
 ....i P("TreeT")=0 s @Rw@(attC(n),attV(n,nn),elmC(L),QQC(L))=$s(nn=1:"",1:nn-1) q
 ....i P("TreeT")=2 s @Rw@(attC(n),attV(n,nn),XORef,QQC(L))=$s(nn=1:"",1:nn-1) q
 i Label="txt" d  d LoadXMLGo8 q
 .d
 ..i (elmS(L-1)="*")!(elmS(L-1)="D") d  q
 ...f nn=1:1:txtV d
 ....i P("TreeT")=0 s @Rw@(elmC(L),txtV(nn),elmC(L-1),QQC(L-1))=$s(nn=1:"",1:nn-1) q
 ....i P("TreeT")=2 s @Rw@(elmC(L),txtV(nn),XORef,QQC(L))=$s(nn=1:"",1:nn-1) q
 d LoadXMLGo8 q


LoadXMLGo8           
 q


LoadXMLSetNSpace                    
 f ss=1:1:S s qPr=$g(@S(ss)@("xNSp",NSp)) q:qPr'=""  ; поиск намспейса и префикса
 i qPr="",Pr'="@" s qPr=Pr f ss=1:1:S i $g(@S(ss)@("CxNSp",Pr))'="" s qPr="" q  ; пробуем использ.преф.из документа
 i qPr="" s P("NSBegin")=P("NSBegin")+1,qPr="q"_P("NSBegin")
 s @Sw@("xNSp",NSp)=qPr
 s @Sw@("CxNSp",qPr)=NSp
 q
LoadXMLCreateWoc                    
 f ss=1:1:S s attC(n)=$g(@S(ss)@("xWoc",attN(n))) q:attC(n)'=""  ; поиск qqw
 i attC(n)'="" d  ; найдены описания в S, копируем их в Sw
 .s @Sw@("xWoc",attN(n))=attC(n) 
 .f ss=S:-1:1 M @Sw@("CxWoc",attC(n))=@S(ss)@("CxWoc",attC(n))
 e  d  ; описания не найдены в S, создаем их в Sw (постоян.часть опис.)
 .s P("QQBegin")=P("QQBegin")+1,attC(n)=P("AttVDef")_P("QQBegin")
 .s @Sw@("xWoc",attN(n))=attC(n)
 .s @Sw@("CxWoc",attC(n))=attN(n)
 q
LoadXMLCreateObj               
 f ss=1:1:S s elmC(L)=$g(@S(ss)@("xObj",elmN(L))) q:elmC(L)'=""  ; поиск qqo
 i elmC(L)'="" d  ; найдены описания в S, копируем их в Sw
 .s @Sw@("xObj",elmN(L))=elmC(L) 
 .f ss=S:-1:1 M @Sw@("CxObj",elmC(L))=@S(ss)@("CxObj",elmC(L))
 e  d  ; описания не найдены в S, создаем их в Sw (постоян.часть опис.)
 .s P("QQBegin")=P("QQBegin")+1,elmC(L)=P("TxtVDef")_P("QQBegin")
 .s @Sw@("xObj",elmN(L))=elmC(L)
 .s @Sw@("CxObj",elmC(L))=elmN(L)
 .i P("TreeT")=0 d
 ..s @Sw@("CxObj",elmC(L),"X50")=3*L
 ..s XORef=elmC(1) f n=2:1:L s XORef=XORef_","_elmC(n)
 ..s @Sw@("CxObj",elmC(L),"XORef")=XORef
 q
LoadXMLSetObj      ; не пост. часть описаний
 s Flag=1
 s Glb=$na(@Sw@("CxObj",elmC(L-1),"xObj")) d
 .i $g(@Glb)="" s @Glb=elmC(L) q
 .f nn=1:1:$L(@Glb," ") i $p(@Glb," ",nn)=elmC(L) s Flag=0 q
 .i Flag s @Glb=@Glb_" "_elmC(L) q
 q
LoadXMLSetWoc      ; не пост. часть описаний
 s Flag=1
 s Glb=$na(@Sw@("CxObj",elmC(L),"xWoc")) d
 .i $g(@Glb)="" s @Glb=attC(n) q
 .f nn=1:1:$L(@Glb," ") i $p(@Glb," ",nn)=attC(n) s Flag=0 q
 .i Flag s @Glb=@Glb_" "_attC(n) q
 q


LoadXMLToTokens(name)     
 ; преобр.строки в массив слов 
 n bb,pbb,n,Str1,Flag,Ent,Sim,Word
 s Str1="",Flag=0,Ent="",Sim=""
 f n=1:1:$L(@name) s bb=$e(@name,n) d  ; обрабат.компоненты
 .i bb="&" s Flag=1 q
 .i Flag=0 s Str1=Str1_bb q
 .i bb=";" d  q
 ..i $e(Ent)="#" s Sim=$c($e(Ent,2,10))
 ..e  s Sim=$s(Ent="amp":"&",Ent="lt":"<",Ent="gt":">",Ent="apos":"'",Ent="quot":"""",1:"")
 ..i Sim="" s Sim=" "_$c(0)_Ent_"; "  ; значит не символьный компонент
 ..s Str1=Str1_Sim
 ..s Flag=0,Ent="",Sim=""
 .s Ent=Ent_bb q
 s pbb=" ",Word="",i=0
 f n=1:1:$L(Str1) s bb=$e(Str1,n) d  ; расклад.в массив
 .i $a(bb)<32,$a(bb)'=0 s bb=" "
 .i bb=" ",pbb=" " q
 .s pbb=bb
 .i bb=" " s i=i+1,@name@(i)=Word,Word=""
 .e  s Word=Word_bb
 i Word'="" s i=i+1,@name@(i)=Word,Word=""
 s @name=i
 q

LoadXMLToText(name)     
 ; преобр.строки в массив предложений 
 n bb,pbb,n,Str1,Flag,Ent,Sim,Para
 s Str1="",Flag=0,Ent="",Sim=""
 f n=1:1:$L(@name) s bb=$e(@name,n) d  ; обрабат.компоненты
 .i bb="&" s Flag=1 q
 .i Flag=0 s Str1=Str1_bb q
 .i bb=";" d  q
 ..i $e(Ent)="#" s Sim=$c($e(Ent,2,10))
 ..e  s Sim=$s(Ent="amp":"&",Ent="lt":"<",Ent="gt":">",Ent="apos":"'",Ent="quot":"""",1:"")
 ..i Sim="" s Sim=$c(0)_Ent_"; "  ; значит не символьный компонент
 ..s Str1=Str1_Sim
 ..s Flag=0,Ent="",Sim=""
 .s Ent=Ent_bb q
 s pbb=" ",Para="",i=0
 f n=1:1:$L(Str1) s bb=$e(Str1,n) d  ; расклад.в массив
 .i bb=$c(13) s bb=$c(10)
 .i bb=$c(10),pbb=$c(10) q
 .s pbb=bb
 .i bb=$c(10) s i=i+1,@name@(i)=Para,Para=""
 .e  s Para=Para_bb
 i Para'="" s i=i+1,@name@(i)=Para,Para=""
 s @name=i
 q


LoadXMLCodingValue(qq,name1,name2)       
 ; кодируем массив слов в массив кодов слов
 ;n nn
 s @name2=@name1
 f nn=1:1:@name1 d
 .i $e(@name1@(nn))=$c(0) s @name2@(nn)=@name1@(nn) q  ; компоненты просто переносим
 .i P("CodeV")=1 s @name2@(nn)=@name1@(nn) q  ;коды тоже просто переносим
 .s @name2@(nn)=$g(@Dw@(qq,@name1@(nn)))  ; возм.слово уже есть в словаре
 .i @name2@(nn)="" d
 ..s @name2@(nn)=$$LoadXMLNextCode($g(@Dw@(qq),"A"))
 ..s @Dw@("C"_qq,@name2@(nn))=@name1@(nn)
 ..s @Dw@("C"_qq)=$g(@Dw@("C"_qq),-1)+1  ; колич.слов
 ..s @Dw@(qq,@name1@(nn))=@name2@(nn)
 ..s @Dw@(qq)=@name2@(nn)  ; посл.использ.код слова
 q


LoadXMLLinearModel           
 ; линейная модель используется для отладки парсера
 s NumLinMod=NumLinMod+1
 s ^Qdebug=NumLinMod
 s ^Qdebug(NumLinMod)=""
 s ^Qdebug(NumLinMod,"ТипСообщения")=$g(T)
 s ^Qdebug(NumLinMod,"Содержимое")=$g(N)
 s ^Qdebug(NumLinMod,"Уровень")=$g(L)
 ;k T,N
 q


LoadXMLNextCode(LastCode)                 
 ;выдает следующий код для экземпляра 'qqc' или слова 'qqz'
 ;
 n n,s,Flag,Str
 s s=$L(LastCode) f n=1:1:s s s(n)=$e(LastCode,n)
 s n=s,s(0)="",Flag=0
 f  d  q:Flag
 .i s(n)="" s s(n)="A",Flag=1 q
 .i s(n)="Z" s s(n)="a",Flag=1 q
 .i s(n)'="z" s s(n)=$c($a(s(n))+1),Flag=1 q
 .s s(n)="A",n=n-1 q
 s Str="" f n=0:1:s s Str=Str_s(n)
 q Str


LoadXMLErr(ErrName)                
 q

LoadXMLFindQQC       
 ; ищет последние 'qqc' среди всех детей от 'P("qqoParent")', чтобы они были детьми от
 ; 'P("qqcParent")', сортирует и выбирает наибольший, кот.записывает в 'P("qqcBegin")'
 n ObjList,ss,nn,item,MaxList,qqcMax
 ;i P("TreeT")=0 d  ; лог.дерево
 s ObjList="" f ss=1:1:S s ObjList=$g(@S(ss)@("CxObj",P("qqoParent"),"xObj")) q:ObjList'=""
 i ObjList="",P("TreeT")=1 d  ;для физ.дер.если нет ObjList, то составляем сами
 .s item="" f  s item=$o(@Tw@(item)) q:item=""  d
 ..i ObjList="" s ObjList=item
 ..e  s ObjList=ObjList_" "_item
 i ObjList="" s P("qqcBegin")="" q
 f nn=1:1:$L(ObjList," ") s item=$p(ObjList," ",nn) d
 .i $d(@Tw@(item))=0 q
 .i P("TreeT")=1 s qqcMax=$o(@Tw@(item,"{"),-1) ; для физ.дер.
 .e  s qqcMax=$o(@Tw@(item,P("qqcParent")_"{"),-1) i qqcMax'[P("qqcParent") q  ; для лог.дер.
 .s MaxList(qqcMax)=item
 i $g(MaxList)'="" s P("qqcBegin")=$o(MaxList(""),-1)
 e  s P("qqcBegin")=""
 q
]]></Implementation>
</Method>

<Method name="OOXSL">
<Description><![CDATA[
20110210 rda Учет флага "Разрешение редактирования". если =0 ячейки таблицы защищаются от редактирования.
20110128 rda Изменена обработка "rowspan" для поддержки динамического объединения строк таблицы (такой вариант подойдет только для Writer. Calc - в пролете)
20101001 rda Добавлена обработка отображения для печати в OO Calc.
20100902 rda Добавлена обработка сложных колонтитулов.
20100826 rda исправлен учет формата обрамления ячейки бланк/таблица
20100805 rda исправлено в метке PageSize (по умолчанию считается формат А4) + добавлена метка continue2 при обходе 
        колонок для перехода к следующей ячейке для ячеек с rowspan=0 (ключ.слово CONTINUE использовать нельзя, т.к. его нет в Cache4)
20100707 rda - если ширина колонки =0, не не выводим ее. 
20100521 добавлен параметры rowspan и "поворот текста в ячейке"
XSL для документов  OpenOffice <br/>
 qqdev, table, qqview, xslRef как в методе qWEB.XSL() <br/>
qOutput =""  - обработка основного отображения <br/>
            ="header" - обработка верхнего колонтитула, запись в Col("header") локального массива по отображению <br/>
            ="footer" - обработка нижнего колонтитула, запись в Col("footer") локального массива по отображению <br/>
innerRef - ссылка на глобал, куда пишутся стили для ОО (ширина столбцов встроеных таблиц, встроеная разметка) @rda 20090525
spaceBefore - отступ сверху в основной области печати в мм
rda@sparm.com]]></Description>
<Internal/>
<FormalSpec>qqdev:%String="qword.xsl",table:%String,qqview:%Library.String,xslRef:%Library.String,qOutput:%String,Col,innerRef,spaceBefore:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;k ^uuu
 S qqview=$G(qqview)
 i @qqview="" s qqview="$g(Vo(qqnump,-1,-1))_$s($g(Vo(qqnump,-1,-1))'="""":$C(1),1:"""")_Vo(qqnump)"
 
 N prs,colset,X364,X3641,X3695,x3697,X3691,X3698,X3642,sort,page,prtRef,i,j,k,st,headerRow,stName
 N qqoView,View,M,qqwxml,rowspan
 s View=@qqview
 S qqoView=$S($g(View)'[$C(1):"XView",1:$P($g(View),$C(1))) S:$g(View)[$C(1) View=$P($g(View),$C(1),2,255) ;Маслова 06.08.2010
 
 S qOutput=$G(qOutput)
 S Col=$G(Col)

 S X364=$P(qARM.GetPar("X364",@qqview),"table ")   ; параметры страницы 
 S X3641=$P(qARM.GetPar("X364",@qqview),"table ",2)   ;X3641 или после слова table
 S:X3641="" X3641=qARM.GetPar("X3641",@qqview)   ;отступы для всех ячеек таблицы (padding)
 S x3697=qARM.GetPar("x3697",@qqview)   ; отступ иерархии
 S X3691=qARM.GetPar("X3691",@qqview)   ; сохранять размеры колонок
 S sort=$TR(qARM.GetPar("X361",@qqview),"@","o") ; порядок сортировки ;@Dol 21.10.09
 S X3695=qARM.GetPar("X3695",@qqview)       ;флаг подавления цвета
 S X3698=qARM.GetPar("X3698",@qqview)       ;учет динамических параметров ячеек, создание динамического стиля для ячейки
 S X3642=qARM.GetPar("X3642",@qqview)       ; Разрешение редактирования: !если флаг =0 ячейки таблицы защищаются от редактирования
 ; ! динамический стиль полностью заменяет стиль ячейки! ПЛОХО - для каждого экземпляра с дин. параметрами создается свой динамический стиль
 I $G(table)="" S table=qARM.GetPar("x321",@qqview)   ; вид печати бланк/таблица - определяет только наличие обрамления
 //s prtRef = $na(^Q(1,"XView",$S(@qqview="":Vo(qqnump),1:@qqview),"XPrint",Vo(qqnump,-1,30)))
 ;$na(^Q(1,qqoView,View,"XPrint",Vo(qqnump,-1,30)))   ;Маслова 06.08.2010
 s prtRef = $NA(Vo(qqnump,-1,3))  ; @rda 26.01.2011 

 S prs("main")=qARM.GetPar("X355",@qqview)   ;основной шрифт и размеры шрифта
   ; массив с параметрами печати
   ; prs("main") - основной шрифт и фон
   ; prs("def")  - параметры констант, понятий, выражений по умолчанию
   ; prs("col")  - параметры колонки
   ; prs("str")  - параметры строки
   ; prs("cell") - параметры ячейки

 D
 . I $G(xslRef)'="" S @xslRef=0 Q
 . ; старая печать
 . D ..OpenDev(qqdev)
 . i qqdev="" s xslRef=$na($$$tmpGl(1,$J)) q
 . s xslRef=$na($$$tmpGl(qqdev,$J))
 . k @xslRef
 s obj=$O(Vo(qqnump,""))

 ; обход отображения
 do PageSize
 d GetObj(obj,,-1) 
 ; если вызов для колонтитулов, то записываем результаты обхода и выходим. в xslRef/qqdev ничего не пишем
 if Col'="",qOutput'="" m @Col@(qOutput)=M Q 
 
 ; Запись заголовков XSL и начало стилей, общих для sWriter и sCalc
 d ..OOXSLhead(xslRef)
 ; запись стилей
 s i="" F  S i=$O(M("Style",i)) Q:i=""  D  
 .d ooXSLwrite( "<style:style style:name="""_i_""" style:family="""_M("Style",i)_""">")
 .S j="" F  S j=$O(M("Style",i,j)) Q:j=""  D
 ..S st="<"_j
 ..S k="" F  S k=$O(M("Style",i,j,k)) Q:k=""  S st=st_" "_k_"="""_M("Style",i,j,k)_""""
 ..d ooXSLwrite( st_"/>") 
 .d ooXSLwrite( "</style:style>"_$C(13,10))
 ;запись стилей для встроеных таблиц(описание ширины столбцов)
 i $D(@innerRef@("InnerTable")) s i="" F  s i=$O(@innerRef@("InnerTable",i)) Q:i=""  d ooXSLwrite(@innerRef@("InnerTable",i)) 
 ; запись динамических стилей (пишем вначале стиль самой ячейки, а в конце сами динамические параметры, если есть повторения, применяются последние записаные)
 i $D(@innerRef@("DinamicStyle")) s i="" F  s i=$O(@innerRef@("DinamicStyle",i)) Q:i=""  d
 .s st=@innerRef@("DinamicStyle",i,"cell"), obj=$P(st," "),row=$P(st," ",2),col=$P(st," ",3)
 .d ooXSLwrite("<style:style style:name='"_i_"' style:family='table-cell'>")
 .S styleName=$$StyleName($S(obj=-1:"baseO",1:"O"_obj),row,col),j="" F  S j=$O(M("Style",styleName,j)) Q:j=""  D
 ..S st="<"_j, k="" F  S k=$O(M("Style",styleName,j,k)) Q:k=""  S st=st_" "_k_"="""_M("Style",styleName,j,k)_""""
 ..d ooXSLwrite( st_"/>")
 .d ooXSLwrite(@innerRef@("DinamicStyle",i)_"</style:style>"_$C(13,10))
 
 ; если передан параметр spaceBefore, то создадим стиль для строки таблицы с нужной высотой
 if +$G(spaceBefore)>0 d ooXSLwrite("<style:style style:name=""SpaceBefore"" style:family=""table-row""><style:table-row-properties style:rel-width=""100%"" style:row-height="""_spaceBefore_"mm"" /></style:style>")
 
 d PageLayoutProp()     ;запись стилей для колонтитулов и разметки страницы
 
 d ooXSLwrite( "<office:body>"_$C(13,10))
 d ooXSLwrite( "<office:"_$S($G(x320)=11:"spreadsheet",1:"text text:use-soft-page-breaks=""true""")_">")
 d OOXSLTableHead   ;запись заголовка таблицы(открытие тега <table:table>  и разметка столбцов)
 
 ; если передан параметр spaceBefore, то создадим пустую строку с нужной высотой
 if +$G(spaceBefore)>0 d ooXSLwrite("<table:table-row table:style-name=""SpaceBefore""></table:table-row>")
 
 d ooXSLwrite( "<xsl:apply-templates select="""_M("O",$O(M("O","")))_"""/>")
 d ooXSLwrite( "</table:table>")
 d ooXSLwrite( "</office:"_$S($G(x320)=11:"spreadsheet",1:"text")_">"_$C(13,10)_"</office:body>")
 d ooXSLwrite( "</office:document>")
 d ooXSLwrite( "</xsl:template>"_$C(13,10))
 
 do ooXSLtemplateMatch($NAME(M))
 if $D(@Col@("header")) do ooXSLtemplateMatch($NAME(@Col@("header")),"header")
 if $D(@Col@("footer")) do ooXSLtemplateMatch($NAME(@Col@("footer")),"footer")
 d ooXSLwrite( "</xsl:transform>")
 ;m:$g(quser)="rda" ^uuu($i(^uuu),"OOXSL","M")=M
 ;m:$g(quser)="rda" ^uuu($i(^uuu),"OOXSL","Colon","header")=@Col@("header")
 ;m:$g(quser)="rda" ^uuu($i(^uuu),"OOXSL","Colon","footer")=@Col@("footer")
 Q

ooXSLtemplateMatch(ref,prefix) 
 ;запись тэмплейтов для объектов отображения 
 S headerRow=0,i="" F  S i=$O(@ref@("O",i)) Q:i=""  D 
 . d ooXSLwrite( "<xsl:template match="""_@ref@("O",i)_""""_$S($G(prefix)'="":" mode="""_prefix_"""",1:"")_">")
 . d AddPageBreak(i,"before")        ; обработка разрыва страницы
 . S j="" F  S j=$O(@ref@("O",i,"R",j)) Q:j=""  D  
 .. ; прежде всего проверим, не надо ли закрыть заголовок таблицы.
 .. if headerRow=1,(($G(@ref@("O",i,"R",j,"RepStr"))="")||$D(@ref@("O",i,"R",j,"Child"))) do 
 ... s headerRow=0 
 ... d ooXSLwrite("</table:table-header-rows>")
 ..
 .. if $D(@ref@("O",i,"R",j,"Child")) d   ;Q  
 ... d ooXSLwrite( "<xsl:apply-templates select="""_@ref@("O",i,"R",j,"Child")_""""_$S($G(prefix)'="":" mode="""_prefix_"""",1:"")_">") 
 ... s val=$P(@ref@("O",i,"R",j,"Child"),"O",2)
 ... F n=1:1:$L(sort," ") I val=$P($P(sort," ",n),":") do  
 .... F x=1:1:$L($P($P(sort," ",n),":",2),",") do
 ..... D ooXSLwrite("<xsl:sort select='"_$TR($P($P($P(sort," ",n),":",2),",",x),"-#*","")_"'"_$S($E($TR($P($P($P(sort," ",n),":",2),",",x),"#",""))="-":" order='descending'",1:"")_""_$S($E($TR($P($P($P(sort," ",n),":",2),",",x),"-",""))="#":" data-type='number'",1:"")_"/>")
 ... d ooXSLwrite( "</xsl:apply-templates>") 
 .. 
 .. i $G(@ref@("O",i,"R",j,"RepStr"))=1,headerRow=0,$G(x320)'=11 do   ;обработка сквозных строк.
 ... ; разрыв таблицы, вставка заголовка таблицы и тега table-header-rows
 ... s headerRow=1
 ... d ooXSLwrite("<xsl:text disable-output-escaping='yes'><![CDATA[<table:table-row table:style-name=""SlimRow""/></table:table>")   
 ... d OOXSLTableHead
 ... d ooXSLwrite("]]]]><![CDATA[></xsl:text><table:table-header-rows>")
 ..
 .. Q:$D(@ref@("O",i,"R",j,"Child"))
 .. ; обработка параметра выводимых строк
 .. do:$G(@ref@("ObjOutStr",i)) ooXSLwrite("<xsl:if test=""not(NotOutStr[@num='"_j_"'])"">")    
 .. 
 .. d ooXSLwrite("<table:table-row"_$$GetAttributes($NA(@ref@("O",i,"R",j)))_">") 
 .. s k="" F  S k=$O(@ref@("O",i,"R",j,"C",k)) Q:k=""  Do
 ... s qqwxml=$G(@ref@("qqwxml",$$StyleName($S(i=-1:"baseO",1:"O"_i),j,k)))     ; путь в xml для понятия
 ... s rowspan=$G(@ref@("O",i,"R",j,"C",k,"attr","rowspan"))                        ; rowspan ячейки.
 ... do
 .... D ooXSLwrite("<xsl:choose>")
 .... I X3698'=1 D ooXSLwrite("<xsl:when test='"_$S(rowspan=0:"true()",1:"false()")_"'></xsl:when>") Q
 .... D ooXSLwrite("<xsl:when test='"_qqwxml_"/@rowspan and "_qqwxml_"/@rowspan=0'></xsl:when>")
 .... I (rowspan '="") D ooXSLwrite("<xsl:when test='not("_qqwxml_"/@rowspan) and "_$S(rowspan=0:"true()",1:"false()")_"'></xsl:when>")
 ... D ooXSLwrite("<xsl:otherwise>")
 ... 
 ... d ooXSLwrite( "<table:table-cell"_$$GetAttributes($NA(@ref@("O",i,"R",j,"C",k)))_" office:value-type=""string"""_$S(X3642=0:"  table:protected='true'",1:"")_">")
 ... ; учет динамических параметров - замена стиля ячейки на динамический
 ... d:X3698=1 
 .... D ooXSLwrite("<xsl:if test="""_qqwxml_"/@styleName""><xsl:attribute name='table:style-name'><xsl:value-of select='"_qqwxml_"/@styleName'/></xsl:attribute></xsl:if>")
 ... 
 ... ; rowspan
 ... D ooXSLwrite("<xsl:attribute name='table:number-rows-spanned'>") 
 ... D  ; динамические параметры не учитываются/учитываются
 .... I ('X3698) D ooXSLwrite($S(+rowspan:rowspan,1:1))  Q
 .... D ooXSLwrite("<xsl:choose>")
 .... D ooXSLwrite("<xsl:when test='"_qqwxml_"/@rowspan'><xsl:value-of select='"_qqwxml_"/@rowspan'/></xsl:when>")
 .... ;i (rowspan'="") D ooXSLwrite("<xsl:otherwise>"_rowspan_"</xsl:otherwise>")  ; 20110221 rda если rowspan пусто, то ломается Calc
 .... D ooXSLwrite("<xsl:otherwise>"_$S(+rowspan:rowspan,1:1)_"</xsl:otherwise>")
 .... D ooXSLwrite("</xsl:choose>")
 ... D ooXSLwrite("</xsl:attribute>")
 ... 
 ... 
 ... d:$G(@ref@("O",i,"R",j,"C",k,"Value","p"))=0 ooXSLwrite( "<text:p>")
 ... d:$G(Vo(qqnump,i,0,j,k,6))'="" OOXSLpic(i,j,k)
 ... d ooXSLwrite($G(@ref@("O",i,"R",j,"C",k,"Value")))
 ... d:$G(@ref@("O",i,"R",j,"C",k,"Value","p"))=0 ooXSLwrite("</text:p>")
 ... 
 ... d ooXSLwrite( "</table:table-cell>")
 ... ;
 ... D ooXSLwrite("</xsl:otherwise>")
 ... D ooXSLwrite("</xsl:choose>")
 ... ;
 ... d:$G(@ref@("O",i,"R",j,"C",k,"Attributes","table:number-columns-spanned"),0)>1 ooXSLwrite( "<table:covered-table-cell table:number-columns-repeated="""_(+@ref@("O",i,"R",j,"C",k,"Attributes","table:number-columns-spanned")-1)_"""/>")
 .. d ooXSLwrite( "</table:table-row>")
 ..
 .. do:$G(@ref@("ObjOutStr",i)) ooXSLwrite("</xsl:if>")
 . 
 . ; --- Обработка сквозных строк + обработка разрыва страницы
 . if headerRow=1 do  s headerRow=0 d ooXSLwrite("</table:table-header-rows>")
 . d AddPageBreak(i,"after")        ; обработка разрыва страницы
 . d ooXSLwrite( "</xsl:template>") 
 Q

GetObj(obj,objNum,level)
 ; Обход объектов
 s obj=$G(obj) Q:obj=""
 N row,col,objName,tmp,k,cell,rowspan,colspan,colnext,qqw
 S objName=$CASE(obj,-1:"baseO",:"O"_obj),objNum=$G(objNum)+1
 S M("O",obj)=objName
 S M("ObjOutStr",obj) = ($g(Vo(qqnump,obj,249))'="") ;флаг для параметра "выводимые строки" X5249

 I obj=-1 D GetColWidth(obj)    ; если объект =-1, то высчитываем ширину столбцов
 S row=$O( Vo(qqnump,obj,0,""))
 d SetPageBreak("before")   ; проверка и установка разрыва страницы перед текущим объектом (если есть разрыв и перед и после, то ставится только после)
   ; обход строк
 while row '= "" {
        ;зачеркнутые строки не обрабатываются (=2)
     if $G(Vs(qqnump,1,obj,row))=2 GOTO continue1   ;continue    
     I $D(Vs(qqnump,1,obj,row)) S val=0 D  if 'val  GOTO continue1  ;если флаг =0 continue
     .F col=0:1:colset("lst") I $L($G(Vo(qqnump,obj,0,row,col)))>1,'$G(Vs(qqnump,1,obj,row,col)) S val=1 Q  ; есть содержимое или не зачёркнута - выставляем флаг
        ;если зачеркнуты все строки кроме первой - не обрабатываем
     I row,$G(Vs(qqnump,1,obj,0))=-2,$G(Vo(qqnump,obj,0,row))=""  GOTO continue1
     I $G(Vo(qqnump,obj,0,row))'="",$G(Vs(qqnump,3,obj))  GOTO continue1
        ;если текущий объект - зачеркнут, то его ячейки не обрабатываем,
     I $G(Vs(qqnump,1,obj)) GOTO continue1
        ;если ячейка 0 строки 0 объекта -1 пустая - нет заголовков
     if ((obj=-1) & (row=0) & ($E($G(Vo(qqnump,obj,0,row,0)),2,255)="")) GOTO continue1
     
     s prs("str")=$G(Vo(qqnump,obj,0,row,0,2))   ;если высота строки =0, строка не выводится.
     if $P(prs("str"),",",16)=0 GOTO continue1 
     
     ; обход столбцов   
     for col=colset("fst"):1:colset("lst")
     {  
        ; определяем следующую ячейку
        F colnext=col+1:1:colset("lst")+1 I $G(colset("num",colnext)),$L($G(Vo(qqnump,obj,0,row,colnext)))>1,'$G(Vs(qqnump,1,obj,row,colnext)) Q
        
        ; определяем rowspan
        S rowspan=$P($G(Vo(qqnump,obj,0,row,col,2)),",",20)
        ; пропускаем пустые и зачёркнутые ячейки
        I rowspan=0  GOTO continue2 
        ;S:rowspan>1 M("O",obj,"R",row,"C",col,"Attributes","table:number-rows-spanned")=rowspan
        S M("O",obj,"R",row,"C",col,"attr","rowspan")=rowspan
        
        ;высчитываем colspan
        S colspan=0 F i=col:1:colnext-1 I colset("num",i) S colspan=colspan+1
        S:colspan>1 M("O",obj,"R",row,"C",col,"Attributes","table:number-columns-spanned")=colspan
        
        s cell=$G(Vo(qqnump,obj,0,row,col)),tc=$E(cell)   ;Q:cell="" 
        d SetCellProp   ;устанавливаем параметры ячейки
        if tc,"67"'[tc {
            if $E(cell,2)'="L" {
            S cell=$S(tc=5:"Zs"_row_"c"_col, 1:$TR($S($E(cell,2)?1N:"O",1:"")_$E($P($P(cell," "),"{"),2,255),"@:{}<>()""=/","ooooooooooo"))
            // место для обработки спец. полей 
            I $P(cell,"_")="oZXXPF" S cell=$P(cell,"_",2) d ..OOXSLspecField($NA(M("O",obj,"R",row,"C",col,"Value")), cell)
            else  d
            .s xmlTag=$G(Vo(qqnump,obj,0,row,col,64)) ;прозрачные XML-теги. понятие X764
            .;i (tc=3!$E(cell)!xmlTag!($G(Vo(qqnump,obj,0,row,col,10))=3)!($P(pts,",",3)=1)) s M("O",obj,"R",row,"C",col,"Value")="<xsl:apply-templates select='"_cell_""_$S(xmlTag:"'  mode='nested'",1:"/p'")_"/>", M("O",obj,"R",row,"C",col,"Value","p")='xmlTag 
            .i ((tc=3)!$E(cell)!xmlTag!($G(Vo(qqnump,obj,0,row,col,10))=3)!($P(pts,",",3)=1)) s M("O",obj,"R",row,"C",col,"Value")="<xsl:"_$S(1:"copy-of",1:"apply-templates")_" select='"_$S($G(qOutput)'="":"/baseO/",1:"")_cell_""_$S(xmlTag:"/node()'",1:"/node()'")_"/>", M("O",obj,"R",row,"C",col,"Value","p")=1 ;'xmlTag  ;@rda20090826 $S($G(qOutput) для колонтитулов
            .else  S M("O",obj,"R",row,"C",col,"Value")="<xsl:copy-of select='"_$S($G(qOutput)'="":"",1:"")_cell_"/node()'/>", M("O",obj,"R",row,"C",col,"Value","p")=1 ;@rda20090826 $S($G(qOutput) для колонтитулов
            .S:X3698 M("qqwxml",stName)="./"_cell               
            }
            else  {
                s str="<xsl:for-each select='"_$E($S(tc=5:"5Zs"_row_"c"_col,1:$TR($P($P(cell," "),"{"),"@:{}<>()""=/","ooooooooooo")),2,20)_"'>"
                s str=str_"<xsl:if test='Num'>Num=<xsl:value-of select='Num'/></xsl:if><xsl:if test='Sum'> Sum=<xsl:value-of select='Sum'/></xsl:if>"
                s str=str_"<xsl:if test='Min'> Min=<xsl:value-of select='Min'/></xsl:if><xsl:if test='Max'> Max=<xsl:value-of select='Max'/></xsl:if>"
                s str=str_"<xsl:if test='Mid'> Mid=<xsl:value-of select='Mid'/></xsl:if></xsl:for-each>"
                s M("O",obj,"R",row,"C",col,"Value")=str
                s M("O",obj,"R",row,"C",col,"Value","p")=0
            }
         
        }
        if tc=0{
             s qqw=$E(cell,2,30000) I $E(qqw,1)="@" S qqw=$E($P(qqw," "),2,255),qqw=$TR($S(qqw="":qW.GetWoc("CxObj",obj),1:qW.GetWoc("CxWoc",qqw)),"_%"," ")
             s M("O",obj,"R",row,"C",col,"Value")=$S(qqw=" ":"&#160;",qqw[$C(13,10):$$OOXSLconstant(qqw),1:qW.CXML(qqw))
             s M("O",obj,"R",row,"C",col,"Value","p")=$S(qqw[$C(13,10):1,1:0)
             S:X3698 M("qqwxml",stName)="./Zs"_row_"c"_col
         }
continue2
         s col=colnext-1
    }
continue1
    if $G(Vo(qqnump,obj,0,row )) '=""
        {s tmp=Vo(qqnump,obj,0,row )
          s M("O",obj,"R",row,"Child")="O"_$TR(tmp,"@","o")
          d GetObj(tmp,objNum,level+1)
        }           
     s row=$O( Vo(qqnump,obj,0,row))
    }
    d SetPageBreak("after")
 Q
   ; установка размеров столбцов в массив colset (аналог col в методе ..XSL)
GetColWidth(obj)
 s colset("fst")=-1, colset("lst")=Vo(qqnump,-1,9)
 for i=0:1:colset("lst") d 
 .d
 ..if ($G(Vs(qqnump,"ColWidth",i)) '="" )   s res=Vs(qqnump,"ColWidth",i) q   ; если есть динамическое значение, то берём его
 ..S val=$P($G(Vo(qqnump,-1,9,i)),",",1)    ; иначе берём хранимое значение
 ..if val="" S res=15*$P(W("Zfont"),",",3) q
 ..if val=-1 S res=15*$P(W("Zfont"),",",3) q
 ..if val=+val S res=val*$P(W("Zfont"),",",3) q   ; в символах
 ..if $TR(val,"1234567890.")="%" S res=qARM("Screen","Width")*(+val)\100 q   ; в процентах
 ..if $TR(val,"1234567890.")="px" S res=+val     q   ; в px
 ..S res=15*$P(W("Zfont"),",",3)            ; ошибочное значение
 .S colset("num",i)=res                     ; запоминаем размер в массив col
 .S colset("all")=$G(colset("all"),0)+res   ; сумма размеров колонок в px
 .I res,colset("fst")=-1 S colset("fst")=i  ; сохраняем номер первой колонки с шириной'=0
 
 I (X3691||(qOutput'="")),$G(colset("all","mm")) F i=0:1:colset("lst") S colset("num",i,"mm")=$J(colset("all","mm")*colset("num",i)/colset("all"),0,1)
 ; ---
 ; 20100707 rda - если ширина колонки =0, не выводим ее
 for i=colset("fst"):1:colset("lst") do:(+$G(colset("num",i,"mm"))>0)||('X3691)
 . s M("Colgroup",i,"Attributes","table:style-name")=qOutput_"C"_i
 . s M("Style",qOutput_"C"_i)="table-column" 
 . s:X3691 M("Style",qOutput_"C"_i,"style:table-column-properties","style:column-width")=$G(colset("num",i,"mm"))_"mm" 
 s M("Colgroup")=colset("fst")_" "_colset("lst")
 ;m:$g(quser)="rda" ^uuu($i(^uuu),"OOXSL","colset")=colset
 ;s:$g(quser)="rda" ^uuu($i(^uuu),"OOXSL","xView")=@qqview
 ;s:$g(quser)="rda" ^uuu($i(^uuu),"OOXSL","X3691")=X3691
 Q
   ;
   ;добыча и установка параметров ячейки
SetCellProp
 s stName=$$StyleName(objName,row,col)   
 s prs("col")=$G(Vo(qqnump,-1,0,0,col,2))
 s prs("def")=$G( Vo(qqnump, -1, $S("067"[tc:50,tc=5:51,$E(cell,1,4)="2@ZX":51,1:52) ) )
 s:prs("main")'="" prs("def")=$$Combine(prs("def"), ",,,"_$P(prs("main"),",",1)_",,"_$P(prs("main"),",",2))
 
 s pts=$G(Vo(qqnump,obj,0,row,col,2))
 S:prs("def")'="" pts=$$Combine(pts, prs("def")) 
 if $G(Vo(qqnump,obj,0,row,col,6))'=""  ; если в ячейке картинка - устанавливаем для нее стиль
    {s k="IMG"_objName_"R"_row_"C"_col
     s M("Style",k)="graphic"" style:parent-style-name=""Graphics", M("Style",k,"style:graphic-properties","style:mirror")="none"
     s M("Style",k,"style:graphic-properties","style:image-opacity")="100%", M("Style",k,"style:graphic-properties","style:color-mode")="standard"
     s M("Style",k,"style:graphic-properties","style:color-inversion")="false"
     s M("Style",k,"style:graphic-properties","fo:clip")="rect(0cm, 0cm, 0cm, 0cm)"
    } 
    ; записываем параметры ячейки
 d ..OOXSLSetCellProperties(.M, pts, obj, row, col, stName, X3695, X3641, table)
    ; отображение уровня иерархии - только если не сохранять размеры колонок, первая выводимая колонка
 I col=colset("fst"),level>0,x3697 S M("Style",stName,"style:table-cell-properties","fo:padding-left")=(7*level)_"pt"
 Q 
ooXSLwrite(str)
 I $G(xslRef)'="" S @xslRef@($I(@xslRef))=str_$C(13,10) Q
 D ..write(str)
 Q
OOXSLTableHead
 n i d ooXSLwrite( "<table:table table:style-name=""TBL"" table:name=""qWord"" table:protected='true'>")   ; ????table:protection-key="DVOZUIQnznlVbNpxkYAgwejRW1M=" 
 S i="" F  S i=$O(M("Colgroup",i)) Q:i=""  d ooXSLwrite( "<table:table-column"_$$GetAttributes($NA(M("Colgroup",i)))_" table:default-cell-style-name=""DefCellStyle""/>")
 Q
AddPageBreak(obj,pos)
 Q:$G(M("O",obj,"PageBreak","place"))'=pos
 Q:$G(x320)=11  ;никаких разрывов страниц для ООCalc
 d ooXSLwrite("<xsl:if test='"_$G(M("O",obj,"PageBreak","BreakPosExpr"))_"'><xsl:text disable-output-escaping='yes'><![CDATA[<table:table-row table:style-name=""SlimRow""/></table:table><text:p text:style-name=""PageBreak""/>")
 d OOXSLTableHead d ooXSLwrite("]]]]><![CDATA[></xsl:text></xsl:if>")
 Q
SetPageBreak(place)  
 n placeCode s placeCode("before") = 0 s placeCode("after") = 1   ; таблица кодов положений
 n placeRef
 i '$d(@prtRef@("XPageBreakObj", obj)) q    ; есть нет такого объекта разрыва - выходим
 s placeRef = $na(@prtRef@("XPageBreakObj", obj, "XPageBreakPlace", placeCode(place)))   ; если нет такого положения разрыва - выходим
 i '$d(@placeRef) q
 n pageBreakType s pageBreakType = +$g(@placeRef@("xPageBreakType"))   ; получаем тип разрыва
 i pageBreakType = 0 q   ; тип не определён - выходим
 n pageBreakPos s pageBreakPos = ..XslGetPageBreakPos(placeRef)   ; получаем позицию разрыва
 i pageBreakPos = "" q   ; позиция не определена - выходим
 s M("O",obj,"PageBreak","place")=place, M("O",obj,"PageBreak","BreakPosExpr")=pageBreakPos
 Q
StyleName(obj,rw,cl)
 Q:$G(obj)="" "DefaultTXT"
 Q qOutput_obj_"R"_rw_$S($D(cl):"C"_cl,1:"") ; @@@
 ;Q obj_"R"_rw_$S($D(cl):"C"_cl,1:"")
Combine(one, two, separator=",")
 n result,i
 s result=$G(one)
 for i=1:1:$L(two,separator)    if ( ($P(one,separator,i) ="") & ($P(two,separator,i) '="") )   s $P(result,separator,i) = $P(two,separator,i)  
 Q result
GetAttributes(m)
 Q:$G(m)="" ""
 Q:'$D(@m@("Attributes")) ""
 N %i,%s S (%i,%s)=""
 F  S %i=$O(@m@("Attributes",%i)) Q:%i=""  S %s=%s_" "_%i_"="""_@m@("Attributes",%i)_""""
 Q %s
OOXSLconstant(val)
 N i,res S res=""
 F i=1:1:$L(val,$C(13,10)) S:$P(val,$C(13,10),i)'="" res=res_"<text:p>"_qW.CXML($P(val,$C(13,10),i))_"</text:p>"
 Q res
OOXSLpic(obj,row,col)   ; вставка картинок в ячейку
 S objName=$CASE(obj,-1:"baseO",:"O"_obj)
 n stName
 S stName="IMG"_objName_"R"_row_"C"_col
 D:$G(M("O",obj,"R",row,"C",col,"Value","p"))=1 ooXSLwrite("<text:p>")
 D ooXSLwrite("<xsl:for-each select=""Opic"_row_"c"_col_""">")
 D ooXSLwrite("<text:span><draw:frame draw:style-name="""_stName_""" draw:name=""n"_stName_""" text:anchor-type='as-char'>")
 D ooXSLwrite("<xsl:if test='@height'><xsl:attribute name='svg:height'><xsl:value-of select='@height'/>pt</xsl:attribute></xsl:if>")
 D ooXSLwrite("<xsl:if test='@width'><xsl:attribute name='svg:width'><xsl:value-of select='@width'/>pt</xsl:attribute></xsl:if>")
 D ooXSLwrite("<draw:image xlink:href=""../{@src}"" xlink:type=""simple"" xlink:show=""embed""/></draw:frame>")
 D ooXSLwrite("</text:span></xsl:for-each>")
 D:$G(M("O",obj,"R",row,"C",col,"Value","p"))=1 ooXSLwrite("</text:p>")
 Q
 
PageLayoutProp()
   ; стили для колонтитулов
 if Col'="" for tmp="header","footer" if $D(@Col@(tmp)) d
 .s i="" F  S i=$O(@Col@(tmp,"Style",i)) Q:i=""  D
 ..d ooXSLwrite( "<style:style style:name="""_i_""" style:family="""_@Col@(tmp,"Style",i)_""">")
 ..S j="" F  S j=$O(@Col@(tmp,"Style",i,j)) Q:j=""  D
 ...S st="<"_j
 ...S k="" F  S k=$O(@Col@(tmp,"Style",i,j,k)) Q:k=""  S st=st_" "_k_"="""_@Col@(tmp,"Style",i,j,k)_""""
 ...d ooXSLwrite( st_"/>")
 ..d ooXSLwrite( "</style:style>")
  ; стиль разметки страницы
 d ooXSLwrite("<style:page-layout style:name=""pm1"">")
 d ooXSLwrite("<style:page-layout-properties "_page("width")_page("height")_page("orient"))
 s:page("margin")="" page("margin")="fo:margin-top=""20mm"" fo:margin-left=""25mm"" fo:margin-right=""15mm"" fo:margin-bottom=""15mm"""   
 d ooXSLwrite($G(page("margin")))
 d ooXSLwrite("></style:page-layout-properties>")
 ;запись отступов для колонитулов
 I $TR($P(X364," ",7,8)," ")'="" S val=$P(X364," ",7,8) D
 .S val=..XslAddSize(val," ",2) F i=1,2 S res=..XslCheckSize($P(val," ",i)) I res'="" D
 ..D ooXSLwrite("<style:"_$P("header footer"," ",i)_"-style><style:header-footer-properties fo:min-height="""_res_"""/></style:"_$P("header footer"," ",i)_"-style>")
 d ooXSLwrite("</style:page-layout></office:automatic-styles>")
 ; описание мастер-страницы
 d ooXSLwrite( "<office:master-styles><style:master-page style:name=""Standard"" style:page-layout-name=""pm1"">")
 ; Запись темплейтов для колонтитула
 if Col'="" for tmp="header","footer" d:$D(@Col@(tmp))
 . d ooXSLwrite("<style:"_tmp_">")
 . d ooXSLwrite( "<table:table table:name="""_tmp_""" table:style-name=""Standard"">")
 . S i="" F  S i=$O(@Col@(tmp,"Colgroup",i)) Q:i=""  d ooXSLwrite( "<table:table-column"_$$GetAttributes($NA(@Col@(tmp,"Colgroup",i)))_"/>")
 . S i=$O(@Col@(tmp,"O",""))
 . do ooXSLwrite( "<xsl:apply-templates select="""_@Col@(tmp,"O",i)_""""_$S($G(tmp)'="":" mode="""_tmp_"""",1:"")_"/>")
 . ;s j="" F  S j=$O(@Col@(tmp,"O",i,"R",j)) Q:j=""  D
 .. if $D(@Col@(tmp,"O",i,"R",j,"Child")) d ooXSLwrite( "<xsl:apply-templates select=""11111"_tmp_@Col@(tmp,"O",i,"R",j,"Child")_"""/>") Q
 .. d ooXSLwrite( "<table:table-row"_$$GetAttributes($NA(@Col@(tmp,"O",i,"R",j)))_">")
 .. S k="" F  S k=$O(@Col@(tmp,"O",i,"R",j,"C",k)) Q:k=""  D
 ... d ooXSLwrite( "<table:table-cell "_$$GetAttributes($NA(@Col@(tmp,"O",i,"R",j,"C",k)))_" office:value-type=""string"">")
 ... d:$G(@Col@(tmp,"O",i,"R",j,"C",k,"Value","p"))=0 ooXSLwrite( "<text:p>")
 ... ;d:$G(Vo(qqnump,i,0,j,k,6))'="" OOXSLpic(i,j,k)
 ... d ooXSLwrite($G(@Col@(tmp,"O",i,"R",j,"C",k,"Value")))
 ... d:$G(@Col@(tmp,"O",i,"R",j,"C",k,"Value","p"))=0 ooXSLwrite( "</text:p>")
 ... d ooXSLwrite( "</table:table-cell>")
 .. d ooXSLwrite( "</table:table-row>") 
 . d ooXSLwrite( "</table:table>")
 . d ooXSLwrite("</style:"_tmp_">") 
 d ooXSLwrite( "</style:master-page></office:master-styles>")
 Q
PageSize
 s page("orient")="style:print-orientation=""portrait"" "
 s page("width")="fo:page-width=""210mm"" "
 s page("height")="fo:page-height=""297mm"" "
 s page("margin")=""
 n width, val, res,i
 if X364'="" {
     S val=$TR($P(X364," "),"xXхХaAаАbBВ","XXXXAAAABBB")   ; замена возможных вариантов обозначений на единообразные
     I val?1(1"A4",1"A5",1"B5") {   ; если размер страницы задан в виде стандартного обозначения
        S val=$S(val="A4":"210X297",val="A5":"148X210",val="B5":"182X257")
        I $P(X364," ",2)=1 S val=$P(val,"X",2)_"X"_$P(val,"X")  s page("orient")="style:print-orientation=""landscape"" "
     }
    s val=..XslAddSize(val,"X",2)   ; если указан только один размер - дописываем второй
    S res="" F i=1,2 S res=res_" "_..XslCheckSize($P(val,"X",i))   ; проверяем
    S $E(res)=""
    if $P(res," ",1)'="",$P(res," ",2)'=""{ ;если ширина или высота не указаны, то размер не записывается
        S page("width")="fo:page-width="""_$P(res," ")_""" ", page("height")="fo:page-height="""_$P(res," ",2)_""" ", width=$P(res," ")
    }  
  I $TR($P(X364," ",3,6)," ")'="" {
       S val=$P(X364," ",3,6)
       S val=..XslAddSize(val," ",4)
       F i=1:1:4  S res=..XslCheckSize($P(val," ",i)) s:res'="" page("margin")=page("margin")_"fo:margin-"_$P("top right bottom left"," ",i)_"="""_res_""" " s:((i#2)=0&$G(width)'="") width=$G(width)-res
    }
 }
 s colset("all","mm")=$G(width,210)
 Q
]]></Implementation>
</Method>

<Method name="OOXSLSetCellProperties">
<Description><![CDATA[
20110124 rda добавлен поворот ячейки для OOCalc (для Writer - поворот текста в ячейке, для Calc - поворот ячейки)
20100826 rda исправлен учет формата обрамления ячейки бланк/таблица
20100521 добавлен параметр "поворот текста в ячейке"
установка параметров ячейки <br/>
M - массив для XSL <br/>
pts - строка    - параметры ячейки <br/>
obj, row, col   - объект, строка и столбец обрабатываемой ячейки <br/>
stName      - имя стиля для текущей ячейки <br/>
ColorSuppression    - подавление цвета  (X3695) <br/>
CellPadding         - отступ в ячейках для отображения (X3641) <br/>
rda@sparm.com]]></Description>
<Internal/>
<FormalSpec>M:%String,pts:%String,obj:%String,row:%String,col:%String,stName:%String,ColorSuppression:%String,CellPadding:%String,table</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n res, val,rowStName
 // 16й параметр нулевой ячейки  - высота строки. если есть, пишем его, если нет - ставим оптимальную высоту
 if col=colset("fst") d
 .;s rowStName=$G(qOutput)_$S(obj=-1:"baseO",1:"O"_obj)_"R"_row
 .s rowStName=$S(obj=-1:"baseO",1:"O"_obj)_"R"_row
 .s M("Style",rowStName)="table-row", M("O",obj,"R",row,"Attributes","table:style-name")=rowStName
 .s M("Style",rowStName,"style:table-row-properties","style:use-optimal-row-height")="true"
 .s val=$P(pts,",",16) ;высота строки
 .s:(val'="") val=..XslCheckSize(val),M("Style",rowStName,"style:table-row-properties","style:row-height")=val
 .s M("Style",rowStName,"style:table-row-properties","fo:break-before")="auto"
 .s:$P(pts,",",18) M("Style",rowStName,"style:table-row-properties","fo:keep-together")="always" ;параметр "запрет разрыва строки"
 //for i=2,4,5,6,7,8,9,10,14,15 интерпретируем параметры для ячейки.
 S:$P(pts,",",2)'="" M("Style",stName,"style:paragraph-properties","fo:text-align")=$CASE($P(pts,",",2),1:"center",2:"right",:"left")
 i $P(pts,",",4) s M("Style",stName,"style:text-properties","style:font-name")=$CASE($P(pts,",",4),0:"MS Sans Serif",1:"Courier New",2:"Arial",3:"PDF 417 Font",:"Arial")
 e  s:$P(pts,",",4)'="" M("Style",stName,"style:text-properties","style:font-name")=$TR($P(pts,",",4),"_"," ")
 I $P(pts,",",5)'="" d 
 .S:$P(pts,",",5)<2!($P(pts,",",5)=4) M("Style",stName,"style:text-properties","fo:font-weight")=$CASE($P(pts,",",5),0:"normal",:"bold")
 .S:$P(pts,",",5)=2 M("Style",stName,"style:text-properties","fo:font-style")="italic"
 .S:$P(pts,",",5)>2 M("Style",stName,"style:text-properties",$CASE($P(pts,",",5),5:"style:text-line-through-style",:"style:text-underline-style"))="solid"
 
 S:$P(pts,",",6)'="" val=$P(pts,",",6), M("Style",stName,"style:text-properties","fo:font-size")=$S($P(prs("main"),",",2)'="":val_"pt",1:val/8*12_"pt")    ; использовать проценты можно только не с автоматическими стилями
 S:$P(pts,",",7)'="" M("Style",stName,"style:table-cell-properties","style:vertical-align")=$CASE($P(pts,",",7),1:"top",2:"bottom",:"middle")

 I $G(ColorSuppression)'=1 d  ;если нет подавления цвета, то устанавливаем цвет фона ячейки и цвет шрифта
 .S:$P(pts,",",8)'="" t=$TR($J($ZHEX(+$P(pts,",",8)),6)," ",0),M("Style",stName,"style:text-properties","fo:color")="#"_$E(t,5,6)_$E(t,3,4)_$E(t,1,2)
 .S:$P(pts,",",9)'="" t=$TR($J($ZHEX(+$P(pts,",",9)),6)," ",0),M("Style",stName,"style:table-cell-properties","fo:background-color")="#"_$E(t,5,6)_$E(t,3,4)_$E(t,1,2)
 
 D ..OOXSLborder( $NA(M("Style",stName)), $P(pts,",",10), table )
 ;параметр 11 - фильтр ячейки опускаем  - неясно что делать с ним.
 ;если $P(pts,",",14) не задан, то берем значения из понятия X3641. если есть хоть что-то - записываем padding
 s:$TR($P(pts,",",14)," ")="" $P(pts,",",14)=$G(CellPadding) I $TR($P(pts,",",14)," ")'="" d
 .S val=..XslAddSize($P(pts,",",14)," ",4) F i=1:1:4 S res=..XslCheckSize($P(val," ",i)) I res'="" S M("Style",stName,"style:table-cell-properties","fo:padding-"_$P("top right bottom left"," ",i)) =res
 S:$P(pts,",",15)'="" M("Style",stName,"style:paragraph-properties","fo:text-indent")=..XslCheckSize($P(pts,",",15))
 ;ставим флаг, что строка - заголовок таблицы, для реализации сквозной строки.
 S:$P($G(Vo(qqnump,obj,0,row,0,2)),",",17)=1 M("O",obj,"R",row,"RepStr")=1
 ; обработка поворота текста в ячейке
 s val=$P(pts,",",19) i val'="",val'=0 do
 . s (M("Style",stName,"style:table-cell-properties","style:rotation-angle"),M("Style",stName,"style:text-properties","style:text-rotation-angle"))=$s(val=1:90,val=2:270,1:"")
 . s:(val=1)||(val=2) M("Style",stName,"style:text-properties","style:text-rotation-scale")="fix" ;"line-height"
  
 Q:$D(M("Style",stName))=0   //если стиль пустой то и писать его не надо
 S M("Style",stName)="table-cell"
 S M("O",obj,"R",row,"C",col,"Attributes","table:style-name")=$G(stName)
 ;дополнительно - переносы слов. устанавливаем текст ячейки как русский, иначе офис не знает какие правила переноса применять
 s M("Style",stName,"style:table-cell-properties","fo:wrap-option")="wrap"
 s M("Style",stName,"style:text-properties","fo:hyphenate")="true"
 s M("Style",stName,"style:text-properties","fo:hyphenation-remain-char-count")="2"
 s M("Style",stName,"style:text-properties","fo:hyphenation-push-char-count")="2"
 s M("Style",stName,"style:paragraph-properties","fo:hyphenation-ladder-count")="0"
 s M("Style",stName,"style:text-properties","fo:language")="ru"
 s M("Style",stName,"style:text-properties","style:text-outline")="false"   ;для OO Calc - не показывать структуру документа
 Q
]]></Implementation>
</Method>

<Method name="OOXSLborder">
<Description><![CDATA[
20100826 rda исправлен учет формата бланк/таблица
20100729 rda разбор значения параметра "граница" ячейки переделан.Сделано так же как в ..XSL
Метод определения обрамления ячеек для OO. <br/>
m - ссылка на массив для посроения XSL <br/>
PR - 10й параметр ячейки <br/>
table=0/1 - бланк/таблица <br/>
rda@sparm.com]]></Description>
<Internal/>
<FormalSpec>m,PR,table</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S m=$G(m) Q:m=""
 n b,b1
 S m=$NA(@m@("style:table-cell-properties"))
 if ($G(PR)="")||(PR=0) do  Q
 . if $G(table)=1 s @m@("fo:border")="0.5pt solid #000000" Q
 . if $G(table)=0 s @m@("fo:border")="none" Q
 I PR=1 S @m@("fo:border")="none" Q
 I PR=2 S @m@("fo:border")="0.5pt solid #000000" Q
 F b=1:1:4 do
 . ; tdv 20100330 если размер > 4, делим на 10
 . s b1=+$E(PR,b) s:b1>4 b1=b1/10   ;$S(+$E(PR,b)>4:+$E(PR,b)/10,1:+$E(PR,b))
 . S @m@("fo:border-"_$CASE(b,1:"left",2:"top",3:"right",4:"bottom"))=b1_"pt solid #000000"
 Q
]]></Implementation>
</Method>

<Method name="OOXSLhead">
<Description>
Вспомогательный метод для OOXSL - запись шапки и стандартных стилей
rda@sparm.com</Description>
<Internal/>
<FormalSpec>xslRef:%String,table:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 d ..XslWrite( xslRef,  "<?xml version=""1.0"" encoding=""windows-1251""?>")
 ; ODS <office:document-content xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:style="urn:oasis:names:tc:opendocument:xmlns:style:1.0" xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0" xmlns:table="urn:oasis:names:tc:opendocument:xmlns:table:1.0" xmlns:draw="urn:oasis:names:tc:opendocument:xmlns:drawing:1.0" xmlns:fo="urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:number="urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0" xmlns:presentation="urn:oasis:names:tc:opendocument:xmlns:presentation:1.0" xmlns:svg="urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0" xmlns:chart="urn:oasis:names:tc:opendocument:xmlns:chart:1.0" xmlns:dr3d="urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0" xmlns:math="http://www.w3.org/1998/Math/MathML" xmlns:form="urn:oasis:names:tc:opendocument:xmlns:form:1.0" xmlns:script="urn:oasis:names:tc:opendocument:xmlns:script:1.0" xmlns:ooo="http://openoffice.org/2004/office" xmlns:ooow="http://openoffice.org/2004/writer" xmlns:oooc="http://openoffice.org/2004/calc" xmlns:dom="http://www.w3.org/2001/xml-events" xmlns:xforms="http://www.w3.org/2002/xforms" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rpt="http://openoffice.org/2005/report" xmlns:of="urn:oasis:names:tc:opendocument:xmlns:of:1.2" xmlns:rdfa="http://docs.oasis-open.org/opendocument/meta/rdfa#" office:version="1.2">

 d ..XslWrite( xslRef,  "<xsl:transform version=""1.0"" xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"" xmlns:table=""urn:oasis:names:tc:opendocument:xmlns:table:1.0"" xmlns:office=""urn:oasis:names:tc:opendocument:xmlns:office:1.0"" xmlns:text=""urn:oasis:names:tc:opendocument:xmlns:text:1.0""")
 d ..XslWrite( xslRef,  " xmlns:draw=""urn:oasis:names:tc:opendocument:xmlns:drawing:1.0"" xmlns:xlink=""http://www.w3.org/1999/xlink""  xmlns:svg=""urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0"" xmlns:fo='urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0' xmlns:style='urn:oasis:names:tc:opendocument:xmlns:style:1.0'>") 
 ;d ..XslWrite( xslRef,  "<xsl:template match='p' mode='nested'><xsl:choose><xsl:when test=""count(child::p)>0""><xsl:apply-templates mode='nested'/></xsl:when><xsl:otherwise><text:p><xsl:copy-of select='./node()'/></text:p></xsl:otherwise></xsl:choose></xsl:template>")
 d ..XslWrite( xslRef,  "<xsl:template match=""/"">")
 d ..XslWrite( xslRef,  "<office:document xmlns:office=""urn:oasis:names:tc:opendocument:xmlns:office:1.0"" xmlns:style=""urn:oasis:names:tc:opendocument:xmlns:style:1.0"" xmlns:text=""urn:oasis:names:tc:opendocument:xmlns:text:1.0"" xmlns:table=""urn:oasis:names:tc:opendocument:xmlns:table:1.0""")
 d ..XslWrite( xslRef,  "xmlns:draw=""urn:oasis:names:tc:opendocument:xmlns:drawing:1.0"" xmlns:fo=""urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0"" xmlns:xlink=""http://www.w3.org/1999/xlink"" xmlns:dc=""http://purl.org/dc/elements/1.1/"" xmlns:meta=""urn:oasis:names:tc:opendocument:xmlns:meta:1.0"" xmlns:number=""urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0"" xmlns:svg=""urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0"" xmlns:chart=""urn:oasis:names:tc:opendocument:xmlns:chart:1.0"" ")
 d ..XslWrite( xslRef,  "xmlns:dr3d=""urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0"" xmlns:math=""http://www.w3.org/1998/Math/MathML"" xmlns:form=""urn:oasis:names:tc:opendocument:xmlns:form:1.0"" xmlns:script=""urn:oasis:names:tc:opendocument:xmlns:script:1.0""")
 d ..XslWrite( xslRef,  " xmlns:ooo=""http://openoffice.org/2004/office"" xmlns:ooow=""http://openoffice.org/2004/writer"" xmlns:oooc=""http://openoffice.org/2004/calc"" xmlns:dom=""http://www.w3.org/2001/xml-events"" xmlns:xforms=""http://www.w3.org/2002/xforms"" xmlns:xsd=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" office:version=""1.1"">")
 d ..XslWrite( xslRef,  "<office:scripts/> "_$C(13,10)_"<office:font-face-decls>")
 d ..XslWrite( xslRef,  "<style:font-face style:name=""Times New Roman"" svg:font-family=""&apos;Times New Roman&apos;"" style:font-family-generic=""roman"" style:font-pitch=""variable""/> ")
 d ..XslWrite( xslRef,  "<style:font-face style:name=""Courier New"" svg:font-family=""&apos;Courier New&apos;"" style:font-family-generic=""modern"" style:font-pitch=""fixed""/>")
 d ..XslWrite( xslRef,  "<style:font-face style:name=""Arial"" svg:font-family=""Arial"" style:font-family-generic=""swiss"" style:font-pitch=""variable""/>")
 d ..XslWrite( xslRef,  "</office:font-face-decls>")
 ; общие стили
 d ..XslWrite( xslRef,  "<office:styles>")
 d ..XslWrite( xslRef,  "<style:style style:name=""TBLint"" style:family=""table""><style:table-properties style:rel-width=""100%"" table:align=""left"" table:border-model=""collapsing"" style:may-break-between-rows=""true""/></style:style>")
 d ..XslWrite( xslRef,  "</office:styles>")
 ; автоматические стили
 d ..XslWrite( xslRef,  "<office:automatic-styles>")
 d ..XslWrite( xslRef,  "<style:style style:name=""TBL"" style:family=""table""><style:table-properties style:rel-width=""100%"" table:align=""left"" table:border-model=""collapsing"" style:may-break-between-rows=""true""/></style:style>")
 d ..XslWrite( xslRef,  "<style:style style:name=""SlimRow"" style:family=""table-row""><style:table-row-properties style:row-height=""0.01""/></style:style>")
 d ..XslWrite( xslRef,  "<style:style style:name=""PageBreak"" style:family=""paragraph""><style:paragraph-properties fo:height=""0.01"" fo:break-after=""page""/></style:style>")  ;будет работать в OOCalc и для стиля строки таблицы
 d ..XslWrite( xslRef,  "<number:date-style style:name=""dateColon"" number:automatic-order='true'><number:day number:style='long' /><number:text> </number:text><number:month number:style='long'/><number:text> </number:text><number:year number:style='long'/></number:date-style>") ;стиль для отображения спецполя ДАТА
 d ..XslWrite( xslRef,  "<number:date-style style:name=""timeColon""><number:hours number:style='long' /><number:text>.</number:text><number:minutes number:style='long' /><number:text>.</number:text><number:seconds number:style='long'/></number:date-style>") ;стиль для отображения спецполя ВРЕМЯ
 d ..XslWrite( xslRef,  "<style:style style:name='BOLD' style:family=""text""><style:text-properties fo:font-weight='bold'/></style:style><style:style style:name='ITALIC' style:family='text'><style:text-properties fo:font-style='italic'/></style:style><style:style style:name='UNDER' style:family='text'><style:text-properties style:text-underline-style='solid' style:text-underline-width='auto' style:text-underline-color='font-color'/></style:style>")
 d ..XslWrite( xslRef,  "<style:style style:name='SUB' style:family='text'><style:text-properties style:text-position='sub 58%'/></style:style><style:style style:name='SUP' style:family='text'><style:text-properties style:text-position='super 58%'/></style:style><style:style style:name='BORDERED_CELL' style:family='table-cell'><style:table-cell-properties fo:border='0.5pt solid #000000'/></style:style>")
 d ..XslWrite( xslRef,  "<style:style style:name='P_RIGHT' style:family='paragraph'><style:paragraph-properties fo:text-align='right'/></style:style><style:style style:name='P_CENTER' style:family='paragraph'><style:paragraph-properties fo:text-align='center'/></style:style><style:style style:name='P_LEFT' style:family='paragraph'><style:paragraph-properties fo:text-align='left'/></style:style>")
 ;d ..XslWrite( xslRef,  "<style:style style:name='BORDERED_CELL_CENTER' style:family='table-cell'><style:table-cell-properties fo:border='1pt solid #000000'/><style:paragraph-properties fo:text-align='center'/></style:style><style:style style:name='BORDERED_CELL_RIGHT' style:family='table-cell'><style:table-cell-properties fo:border='1pt solid #000000'/><style:paragraph-properties fo:text-align='right'/></style:style>")
]]></Implementation>
</Method>

<Method name="OOXSLspecField">
<Description>
Обработка Спецполей для OO
rda@sparm.com</Description>
<Internal/>
<FormalSpec>ValRef:%String,FieldType:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    ;№ страницы 
 I FieldType="PAGE"             s @ValRef="<text:p><text:page-number text:select-page='current'>page#</text:page-number></text:p>" Q
    ;количество страниц
 I FieldType="NUMPAGES"         s @ValRef="<text:p><text:page-count>page nums</text:page-count></text:p>" Q
    ;путь и имя файла с расширением
 I FieldType="FILENAME"         s @ValRef="<text:p><text:file-name text:display='full'>filename w path</text:file-name></text:p>" Q
    ;имя файла без расширения
 I FieldType="FILENAMESHT"  s @ValRef="<text:p><text:file-name text:display='name'>filename w path</text:file-name></text:p>" Q
    ;дата
 I FieldType="DATE"             s @ValRef="<text:p><text:date style:date-style-name='dateColon'>DATE</text:date></text:p>" Q
    ;время
 I FieldType="TIME"             s @ValRef="<text:p><text:time style:date-style-name='timeColon'>TIME</text:time></text:p>" Q
   ; Стр. № из количество_страниц
 I FieldType="PN"           s @ValRef="<text:p>Стр. <text:page-number text:select-page='current'>page#</text:page-number> из <text:page-count>page nums</text:page-count></text:p>" Q
 Q
]]></Implementation>
</Method>

<Method name="OnPage">
<Description>
Обеспечивает вывод картинок на не qARM клиента.
Обращение к cls происходит через CSP приложение области Samples ,
поэтому необходимо наличие оного (вызов cls скрипта в методе GetLine класса qWORD).</Description>
<Internal/>
<ClassMethod>1</ClassMethod>
<Language>cache</Language>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Do ..OnPageCSPROOT()
 Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnPageCSPROOT">
<Description>
Обеспечивает вывод картинок на не qARM клиента.
Обращение к cls происходит через CSP приложение области Samples ,
поэтому необходимо наличие оного (вызов cls скрипта в методе GetLine класса qWORD).</Description>
<Internal/>
<ClassMethod>1</ClassMethod>
<Language>cache</Language>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 s R=%request.Data("R",1)
 s N=%request.Data("N",1)
 s A=%request.Data("A",1)
 s S=%request.Data("S",1)
 s oRs=##class(%qWEB).%New()
 s oRs.vBLOBvRLen=30000
 s retn=oRs.vBLOBInit(R,N,A,S)
 while (retn>0)
 { 
 w oRs.vBLOB.Read(retn)
 s retn=oRs.vBLOBLoad()
 }
 Write !
 Set %session.EndSession=1
]]></Implementation>
</Method>

<Method name="OpenDev">
<Description>
Если Arg1="" - очистка $$$tmpGl($J), где $$$tmpGl - макрос, возвращающий имя временного глобала
Иначе, открытие файла</Description>
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
    I Arg1=0 Q:$Q "" Q 
    S:Arg1="" Arg1=1 I Arg1?1.N K $$$tmpGl(Arg1,$J) S $$$tmpGl(Arg1,$J)=-1 Q:$Q "" Q  ;индексы у Володи с 0 ; 15.12.2008 Kokarev
    O Arg1:"WN" Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="OpenPrint">
<Description>
Создает контекст отображения для формирования выходной формы.

qqpar1 -  отображениe, контекст которого нужно использовать для формирования
( qview_" "_quser или qview. если quser="#" - администратор )
qqtable -0/1 бланк/таблица
qqpar3=1 - (по умолчанию), блокировка вывода сообщений через метод Message
qqpar4=qqc_" "_qqo (если qqpar1="" )
qqpar6 =вызываемое отображение (qview_" "_quser)
Job - номер задания для получения контекста отображения вызова (по умолчанию -$Job)  в $$$tmpGl("q",job) . См. qARM.SaveView.
Если Job="Q"_quiry - то контекст берется из описания запроса  ^Q(1,"XQuiry",quiry)
Если Job="W" - то контекст берется из ^Q("V"_qview), как и в OpenWindow. Предназначен для
вызова через WebLink.
pvar - явно заданный набор печати (если не задан, тот, что в отображении)
может быть в виде код_отображения:номер_набора или номер_набора (если отображение текущее)

qqpar5 - запуск поиска (пока не задействован)


Создается локальная среда отображения для псевдо окна qqnump="P". (см.qARM.OpenWindow).</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qtable:%String,qqpar3:%String,qqpar4:%String,qqpar5:%String,qqpar6:%String,Job:%String,pvar:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 ;N $ET S $ET="Q $ZE"
 N qqoView
 S qqoView=$S($g(qqpar6)'[$C(1):"XView",1:$P($g(qqpar6),$C(1))) S:$g(qqpar6)[$C(1) qqpar6=$P($g(qqpar6),$C(1),2,255) ;Маслова 06.08.2010
 
 S:$G(qqnump)'="P" qqParent=" "_$G(qqnump)_" "_$G(qqw)
 N qqWS S qqWS=" "_$G(qqnump) I qqWS'=" " D qARM.csav() ;сохрним в WS текущее состояние
 S qql=1 ;слой
 S qqnump=$S($E($G(Job))="Q":"Q",$E($G(Job))="W":"W",1:"P") ;контекст печати ???? для диалога через WEB??
 K W,N,Vo(qqnump),Vs(qqnump),Vt(qqnump)
 Set qwin="Q"_qqnump
 S W("Zfont")=$G(qqscrfont,"8,7,7") ;надо что-то придумать
 S qqp4=$G(qqpar4),qqp5=$G(qqpar5),qqp6=$G(qqpar6)
 S (qqred,qqwchg)=""
 S $$$ReFind=0,$$$RelNum=0,$$$Relind=0
 S qqc=""
 S W("ZBtred")=''$P(qqp4," ",3)
 ;
 I $G(qqpar3)!($E($G(Job))="W") S W("Zmesb")=1 ;блокировка вывода сообщений (переключение на текущее у-во)
 N qqerr
 I $E(qqp6)="N",$L(qqp6)>7 S qqp6=$E(qqp6,2,4)_$E(qqp6,8,255) ;старый код отображения
 I $E(qqp6,4,6)'="sys",'$D(^Q(1,qqoView,$P(qqp6," "))) S qqerr="Нет отображения печати/запроса "_$P(qqp6," ") G OpenPrintEr
 ;
 I $G(qqpar1)="" D  G:$G(qqerr)'="" OpenPrintEr I 1 ;@dol 24.06.03 - убран контроль на quser
 .S quser=$P(qqp6," ",2)
 .;I $S(quser="":1,quser="#":0,quser="U":0,1:'$D(^Q(1,"XUser",quser))) S qqerr="Незарегистрированный пользователь" Q
 .S qview=$P(qqp6," ")_$S(quser="#":"",quser="U":" "_$J,1:" "_quser)
 E  S qview=qqpar1
 ;
 S W("ZBtred")=''$P(qqp4," ",3)
 S W("Zadm")=0 ;режим Пользователь/Администратор
 S W("ZBt0")=0 ;режим редактирования объектов
 S W("Znsort")=1 ;сортировка по первому слову
 ;
 N qqmas S qqmas=$S($E($G(Job))="Q":$S($E(Job,2)'="":$S(Job'[":":$NA(^Q(1,"XQuery",$E(Job,2,255))),1:$NA(^Q(1,$P($E(Job,2,255),":",1),$P($E(Job,2,255),":",2,255)))),1:$NA(^Q("V"_qview))),$E($G(Job))="W":$NA(^Q("V"_qview)),1:$NA($$$tmpGl("q",$S($G(Job)="":$J,1:Job)))) ;@Dol 18.03.08 qqoQu:query ; 15.12.2008 Kokarev
 I $E($G(Job))="W",quser="U" D  ;очистка отображений текущего внешнего интернет-пользователя
 .K ^Q("V"_qview) ;состояние отображения
 .K ^Q(0_qview),^Q(1_qview) ;перечни релевантных
 .;K ^Q("A"_qview) ;аналитика
 ;восстановление контекста
 N qqZot S qqZot=$P(qqp6," ") ;код отображения
 I $E(qqZot,4,6)="sys" D  I 1
 .I $D(@qqmas@("Vo")) M Vo(qqnump)=@qqmas@("Vo") K Vs(qqnump) M Vs(qqnump)=@qqmas@("XObjStat") Q   ;@dol 17.11.03 M Vs(....
 .K Vs(qqnump) D
 ..;I $E($G(Job))="W" D qSYS.ViewStat(0,1) Q  ;для WWW состояние берется из XViewStat
 ..M Vs(qqnump)=@qqmas@("XObjStat")
 .S $$$CondFind="",qqc="",$$$ReFind=0,$$$RelNum=0
 .;что-то не так. зачем qqpar1="" ????
 .;D qSYS.sysView($E(qqp6,4,7),$S($E(qqp6,4,7)="sysV":$E($P(qqp6," "),8,255),$G(qqpar1)'="":qqpar1,1:$E($P(qqp6," "),12,255))) S Vo(qqnump)=qqZot
 .D qSYS.sysView($E(qqZot,4,7),$S($E(qqZot,4,7)="sysV":$E(qqZot,8,255),$G(qqpar1)'="":$P(qqpar1," "),1:$E(qqZot,12,255))) S Vo(qqnump)=qqZot
 E  D
 .;I $D(@qqmas@("Vo")) M Vo(qqnump)=@qqmas@("Vo") Q
 .D qSYS.CreVo(qqoView_$C(1)_qqZot)   ;Маслова 06.08.2010
 .K Vs(qqnump) D
 ..;I $E($G(Job))="W" D qSYS.ViewStat(0,1) Q  ;для WWW состояние берется из XViewStat
 ..M Vs(qqnump)=@qqmas@("XObjStat")
 I $D(View),$E(View,4,6)'="sys",Vo(qqnump)'=View D  ;$P(qview," ")'=View D  ;@dol 17.11.03 $E(View,4,6)'="sys" ;;;а если разные отображения нужно удалить лишнее
 .N i F i=0:1:6,"Vt" K Vs(qqnump,i) ;S AaA=View_"/"_qview
 ;I '$D(Vs(qqnump)) M Vs(qqnump)=^Q("V"_qqZot,"XObjStat")
 M Vt(qqnump,0)=Vs(qqnump,"Vt") ;учет постоянных условий наследуется
 S W("Zadm")=+$G(Vs(qqnump,"Zadm")) ;режим администратора наследуется печатной формой
 S W("ZBtred")=+$G(Vs(qqnump,"ZBtred"))
 D  ;
 .S $$$ReFind=$G($$$ReFind,0)
 .S $$$RelNum=$G($$$RelNum,0)
 .S qqc=$G($$$ID,"")
 .S $$$Relind=$G($$$Relind,0)
 .S $$$CurObj=$G($$$CurObj,"")
 .S $$$CondFind=$G($$$CondFind,"")
 .;S:$$$CondFind'="" $$$CondFind=" "_$P($$$CondFind," ",2,6)_"  "_$P($$$CondFind," ",8,11),$P($$$CondFind," ",5)="" ;востановим старый контекст убрав упорядоченность
 ;
 I $D(Vs("par")) M Vs(qqnump)=Vs("par") K Vs("par")
 I $D(Vo("par")) M Vo(qqnump)=Vo("par") K Vo("par")
 ;
 S Vt(qqnump,"Zparent")=$G(qqParent)
 S:$P(qqp4," ")'="" qqc=$P(qqp4," ") S:$P(qqp4," ",2)'="" $$$CurObj=$P(qqp4," ",2) I $$$Tree,$P(qqp4," ",4)'="" S $$$GloRef=$P(qqp4," ",4) ;если были при вызове
 I $P(qqp4," ",5)'="" K Vs(qqnump,7) D qARM.wfot($P(qqp4," ",5),0) ;фиксация
 S $$$RelNum=$D(^Q($$$Relind_qview))>1
 ;I '$G(Vs(qqnump,99,"Pic")),qARM.GetPar("X3690") S Vs(qqnump,99,"Pic")=1 ;@dol 14.1.04, tdv 20.04.07 - закоментировано
 I $E($G(Job))="Q"!($E($G(Job))="W") Q:$Q "" Q  ;S $$$RelNum=qW.qFind(+$G(Vs(qqnump,99,"Find")),+$G(Vs(qqnump,99,"Find",2))) D qARM.SaveView(1,"",qqZot),..Print($J) Q ""
 ;<oleg> "Действие по входу печати" (X325) ДОДЕЛАТЬ (при вызове на печать системного отображения  - заменяется в методе qSYS.sysView())
 N qqview S qqview=$S($G(pvar)'=""&&($L(pvar,":")>1):$P(pvar,":"),1:"") S:qqview'="" pvar=+$P(pvar,":",2)
 I $G(pvar)'="" S Vo(qqnump,-1,30)=pvar ;набор печати (если не задан, то умолчание) ; tdv 20081120 - было после вызова qARM.GetPar("X3690",qqview)
 I '$G(Vs(qqnump,99,"Pic")),qARM.GetPar("X3690",qqview) S Vs(qqnump,99,"Pic")=1 ;@dol 14.1.04, tdv 20.04.07 - добавлен qqview
 
 I qqview="" S qqview=qqoView_$C(1)_qqpar6 ; 20110512 maslova+tdv
 
 ; перенос описания разрывов страниц - tdv 20110126
 new viewObj set viewObj = $select(qqview '[ $char(1): "XView", 1: $piece(qqview, $char(1), 1))
 new viewInst set viewInst = $select(qqview '[ $char(1): $S(qqview'="": qqview, 1: Vo(qqnump)), 1: $piece(qqview, $char(1), 2))
 if '$data(Vo(qqnump,-1,30)) set Vo(qqnump,-1,30) = +$get(^Q(1, viewObj, viewInst, "X130"))
 merge Vo(qqnump, -1, 3, "XPageBreakObj")=^Q(1, viewObj, viewInst, "XPrint", Vo(qqnump,-1,30), "XPageBreakObj")
 
 ;до или после действия ????
 I $G(qtable)="" S qtable=qARM.GetPar(321,qqview) I 1
 E  D qARM.SetPar(321,qtable)
 S qqZN=qARM.GetPar(367,qqview) I qqZN'="" D  G:qqZN=-1 OpenPrintDo
 .I qqZN=-1 K Vs(qqnump,7) S qqc="",$$$CurObj="",$P($$$CondFind," ",10)="" Q  ;принудительная разфиксация
 .S ($$$CurObj,Vs(qqnump,7))=qqZN,qqc=$E(qqc,1,$$$ObjLqqc(qqZN)),$P($$$CondFind," ",10)=qqc ;принудительная фиксация
 I $G(Vs(qqnump,7))'="" S qqc=$P($$$CondFind," ",10),$$$CurObj=Vs(qqnump,7) G OpenPrintDo
 I qtable S qqc="",$$$CurObj="" G OpenPrintDo ;если таблица и нет фиксации - печатать с начала
 I 'qtable,'$$$RelNum S Vs(qqnump,7)=$$$CurObj,$P($$$CondFind," ",10,11)=qqc_" "_qqc G OpenPrintDo ;принудительно зафиксируемся, если бланк ????
 I 'qtable,$$$RelNum S qqc="",$$$CurObj="" G OpenPrintDo
OpenPrintDo ;
 I $$$Tree,$G(Vs(qqnump,7))="",$G($$$GloRef)'="" S $$$GloRef=$NA(@$$$GloRef,1) ;чтобы печаталось все дерево
 I '$D($$$CurObj) S qqerr="Отображение отсутствует" G OpenPrintEr
 ;
 K qqZN M qqZN=qqP1 N qqP1 M qqP1=qqZN ;путь для картинок может быть изменен в действии перед печатью
 ;
 N q S q=qARM.GetPar(325,qqview) I q'="" N qqend D qARM.Value(q,"X") I $G(qqend)'="" S qqerr=$S(qqend'=1:qqend,1:"") G OpenPrintEr ;действие перед вызовом печати отображения
 ;
 I $G(qqp5)'="" D  ;выполнить поиск ????
 I $$$RelNum,$G(Vs(qqnump,7))="" S $$$ReFind=1 ;D
 Q:$Q "" Q
OpenPrintEr ;восстановление контекста и выход с сообщением
 I qqWS'=" " D qARM.crst("",$P(qqWS," ",2)) S qwin="Q"_qqnump
 Q:$Q qqerr Q
]]></Implementation>
</Method>

<Method name="OpenWebDiag">
<Description><![CDATA[
OpenWebDiag - метод для отображения диаграмм в браузере. <br/>
для использования в настройках базы необходимо указать <br/>адрес странички со скриптом для обработки  данных диаграммы<br/>
Например: http://192.168.10.50/_old_site/umka/diag/index.php
rda@sparm.com]]></Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 n style, filename
 if $G(^Q(1,"XBase",0, "XBWeb" ))="" d qARM.Message("Адрес Веб портала не указан! Выполнение невозможно.") Q
 k node5673
 s filename=qWEB.ClientPath()_"qwordD.htm" 
 s i=$O(QDiag("")), j=0 
 s node5673( $I(j)) = "<html><body><form method='post' action='"_$G(^Q(1,"XBase",0, "XBWeb" ))_"'>"_$C(13,10)
 s node5673( $I(j)) = "<label for='sizex'>Ширина диаграммы </label><input type='text' name='sizex' value='800' />"_$C(13,10)
 s node5673( $I(j)) = "<label for='sizey'>Высота диаграммы </label><input type='text' name='sizey' value='600' /><br/>"_$C(13,10)
 s node5673( $I(j)) = "<input type='submit' value='Отправить данные для обработки' />"_$C(13,10)
 while ( i '= "" )
    {s ii=$O(QDiag(i, ""))
     while ( ii '= "" )
        {s node5673( $I(j)) = "<input type='hidden' name='QDiag["_i_"]["_ii_"]' value='"_QDiag(i,ii)_"'> </input>"_$C(13,10)
         s ii=$O(QDiag(i, ii))
        }
      s i=$O(QDiag(i))
    }
 s style=+$P(Vs(qqnump, 13,"R"), " ", 2 )
 s:(style=4) style=3        //пока нету диаграммы из точек. ставим линии.
 s:( (style=2)  &&  ( +$P(Vs(qqnump, 13,"R"), " ", 3 )   = 0) ) style=5
 s node5673( $I(j)) = "<input type='hidden' name='style' value='"_style_"' />"_$C(13,10)    
 s node5673( $I(j)) = "</form></body></html>"
 d qARM.wM("-qARM","FileFastSave",$Name(node5673),filename) 
 d qARM.wM("-qARM","ShellExecute",0, "open", """"_filename_"""", "","",1)
 d qARM.wM("-qARM","Xecute","k node5673") 
 Q
]]></Implementation>
</Method>

<Method name="ParStr">
<Description><![CDATA[
Записывает параметры страницы, если определена переменная X364 в параметрах печати для отображения
и приемником печатной формы является MS Word.
В случае вывода в IE параметры страницы не учитываются.
Метод вызывается из %qWEB.XSL.
Параметры страницы определяются в блоке <style>...</style> (см. %qWEB.XSL)  через селектор @page Section1.
Затем определяется класс Section1 для тега <div>, который обрамляет все тело документа (см. %qWEB.XSL)
Параметры: par1 - содержит строку, которая определяет параметры страницы (см. описание X364)
qqview - код отбражения, из которого нужно брать параметры печати (если "" - то текущее)]]></Description>
<Internal/>
<FormalSpec>par1:%String,qqview:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 //Q:par1="" ""
 D ..write("@page Section1{") ;записываем в выходной документ селектор
 S qqview=$G(qqview)
 N i,p I $P(par1," ")'="" S p=$P(par1," ") D  ;если определены размеры страницы
 .S p=$TR(p,"xXхХaAаАbBВ","XXXXAAAABBB") ;замена возможных вариантов обозначений на единообразные
 .;если размер страницы задан в виде стандартного обозначения, то подставляем размеры для ориентации "portret"
 .;если ориентация "landscape", то меняем местами ширину и длину, и записываем признак ориентации
 .I $L(p,"X")=1 S p=$S(p="A4":"210X297",p="A5":"148X210",p="B5":"182X257",1:"") Q:p=""  I $P(par1," ",2) S p=$P(p,"X",2)_"X"_$P(p,"X") D ..write("mso-page-orientation:landscape;")
 .N str S str="" F i=1,2 S str=str_" "_$$ParStrDop($P(p,"X",i))
 .S $E(str)="" Q:$P(str," ")=""  Q:$P(str," ",2)=""  D ..write("size:"_str_";") ;если ширина или высота не указаны, то размер не записывается
 ;определение отступов
 F i=3:1:6 S p=$$ParStrDop($P(par1," ",i)) I p'="" D ..write("margin-"_$P("top right bottom left"," ",i-2)_":"_p_";")
 ;определение отступов для коллонтитулов
 F i=7,8 S p=$$ParStrDop($P(par1," ",i)) I p'="" D ..write("mso-"_$S(i=7:"header",1:"footer")_"-margin:"_p_";")

 //////////////// для колонтитулов

 // полный путь к xml-файлу
 N xmlPath S xmlPath = ..xmlPath(qARM.GetPar(368,qqview))              
 N Separator S Separator = $S($F(xmlPath,"\") '= 0: "\", 1: "/")
 // название xml-файла без расширения
 N xmlFileName S xmlFileName = $P( $P(xmlPath, Separator, $L(xmlPath, Separator)), ".")

 N IsHeaderColText S IsHeaderColText = $D(^Q(1,"XView",$S(qqview="":Vo(qqnump),1:qqview),"XPrint",Vo(qqnump,-1,30),"TB362"))
 N IsFooterColText S IsFooterColText = $D(^Q(1,"XView",$S(qqview="":Vo(qqnump),1:qqview),"XPrint",Vo(qqnump,-1,30),"TB363"))

 //////////////// для колонтитулов

 ;если есть отображение для коллонтитулов, то вставляем ссылки
 I qARM.GetPar(362,qqview)'=""||(IsHeaderColText) D
 .D ..write("mso-header:url('"_xmlFileName_"_headerH.doc')h1")
 I qARM.GetPar(363,qqview)'=""||(IsFooterColText) D
 .D ..write("mso-footer:url('"_xmlFileName_"_headerF.doc')f1")
 D ..write("}") ;закрываем селектор @page
 D ..write("div.Section1{page:Section1;}") ;определяем класс для тега <div>
 Q:$Q "" Q
ParStrDop(par2)
 Q:par2="" "" S par2=$TR(par2,",",".") Q:par2=+par2 par2_"mm" ;по умолчанию все размеры в mm
 Q +par2_$TR($TR(par2,"1234567890."),"ср","cp") ;на всякий случай замена русских букв на латинские
]]></Implementation>
</Method>

<Method name="ParserXML">
<Internal/>
<FormalSpec>SourXML:%String,DomXML:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;New 
 k @DomXML
 i SourXML="" d ParserXMLSourStream q ""
 i $e(SourXML,2,3)=":\" d ParserXMLSourFile I 1
 e  d ParserXMLSourGlobal
 q ""
ParserXMLSourStream 
 d ParserXMLCreateDocFragment s L=0,T=0  ; узел документ-фрагмент
 f  d  q:StrXML=""
 .s StrXML=%request.Content.Read(1000)
 .d ParserXMLStringStream(StrXML)
 q
ParserXMLSourFile
 d ParserXMLCreateDocFragment s L=0,T=0  ; узел документ-фрагмент         
 i $zu(68,40,1) Open SourXML:("RF":2500):0 
 e  w "NoSource" q
 f  Use SourXML Read StrXML q:$zeof<0  d ParserXMLStringStream(StrXML)
 Close SourXML
 q
ParserXMLSourGlobal
 i $d(@SourXML)=0 w "NoSource" q  ; Err("NoSource")
 i $d(@SourXML)=10 s SourXML=$q(@SourXML)
 d ParserXMLCreateDocFragment s L=0,T=0  ; узел документ-фрагмент
 f  d ParserXMLStringStream(@SourXML) s SourXML=$q(@SourXML) q:SourXML=""
 q       
ParserXMLStringStream(St) 
 s PrevChar=" "  
 f n=1:1:$l(St) d
 .s CurChar=$e(St,n)
 .s CurChar=$s($a(CurChar)<32:" ",1:CurChar)
 .;i CurChar=" "&(PrevChar=" "!PrevChar="<"!PrevChar=">") q
 .d ParserXMLSimbolStream(CurChar)
 .s PrevChar=CurChar
 q                
ParserXMLSimbolStream(aa) 
 ; T-тип узла согласно MS DOM
 ; N-имя узла
 ; V-значение узла
 ; L-уровань иерархии
 ; X-признак, в каком месте читаем узел
 i T=0 d  q  ; находимся вне узла
 .i aa=" " q
 .i aa="<" s L=L+1,T=-1 q
 .i aa="&" s L=L+1,T=5,X="N",N="" q
 .e  s L=L+1,T=3,X="V",V=aa q
 i T=3,X="V" d  q  ;текст
 .i aa="<" d ParserXMLCutSpace d ParserXMLCreateNode s T=-1 q
 .i aa="&" d ParserXMLCutSpace d ParserXMLCreateNode s T=5,X="N",N="" q
 .e  s V=V_aa q
 i T=-1 d  q  ; либо: закрыв.тег, ПИ, коментарий, данные, ДТД, откр.тег
 .i aa=" " q
 .i aa="/" s L=L-2,T=-10 q
 .i aa="?" s T=7,X="N",N="" q
 .i aa="!" s T=-2 q
 .e  s T=1,X="N",N=aa q
 i T=-10 d  q  ; закрыв.тег
 .i aa=" " q
 .i aa=">" s T=0 q
 .e  q           
 i T=1,X="N" d  q  ; откр.тег или пустой тег
 .i aa=">" d ParserXMLCreateNode s T=0 q
 .i aa="/" d ParserXMLCreateNode s L=L-1,T=-11 q
 .i aa=" " d ParserXMLCreateNode s T=-11 q
 .e  s N=N_aa q
 i T=-11 d  q  ; внутри откр.тега возможно есть атрибуты, а возм.нет
 .i aa=" " q     
 .i aa=">" s T=0 q  
 .i aa="/" s L=L-1 q     
 .e  s L=L+1,T=2,X="N",N=aa q
 i T=2,X="N" d  q  ; атрибут
 .i aa=" " d ParserXMLCreateNode s T=-11,L=L-1 q
 .i aa="=" s T=2,X="?" q       
 .e  s N=N_aa q        
 i T=2,X="?" d  q  ; атрибут с неизвестной кавычкой у значения
 .i aa=" " q
 .i aa="""" s X="q",V="" q
 .i aa="'" s X="a",V="" q    
 .e  q
 i T=2,X="q" d  q  ; атрибут с кавычкой
 .i aa="""" d ParserXMLCreateNode s T=-11,L=L-1 q
 .e  s V=V_aa q
 i T=2,X="a" d  q  ; атрибут с апострофом
 .i aa="'" d ParserXMLCreateNode s T=-11,L=L-1 q
 .e  s V=V_aa q                                
 i T=7,X="N" d  q  ; ПИ
 .i aa=" " s X="V",V="",paa="" q    
 .e  s N=N_aa q
 i T=7,X="V" d  q  ; ПИ
 .i aa=">",paa="?" d ParserXMLCreateNode s T=0,L=L-1 q    
 .e  s V=V_paa,paa=aa q
 i T=-2 d  q  ; либо: коментарий, данные, ДТД
 .i aa=" " q
 .i aa="-" s T=-3 q
 .i aa="[" s T=4,X="N",N="" q
 .e  s T=10,X="N",N=aa q
 i T=-3 d  q  ; либо: коментарий, ошибка     
 .i aa="-" s T=8,X="V",V="",paa="",ppaa="" q
 .e  s E=Err("--") q
 i T=8,X="V" d  q  ; коментарий
 .i aa=">",paa="-",ppaa="-" d ParserXMLCreateNode s T=0,L=L-1 q
 .e  s V=V_ppaa,ppaa=paa,paa=aa q
 i T=4,X="N" d  q  ; данные
 .i aa="[" s X="V",V="",paa="",ppaa="" q    
 .e  s N=N_aa q        
 i T=4,X="V" d  q  ; данные
 .i aa=">",paa="]",ppaa="]" d ParserXMLCreateNode s T=0,L=L-1 q
 .e  s V=V_ppaa,ppaa=paa,paa=aa q
 i T=5,X="N" d  q  ; компонент
 .i aa=" " q     
 .i aa=";" d ParserXMLCreateNode s T=0,L=L-1 q
 .e  s N=N_aa q
 i T=10,X="N" d  q  ; ДТД
 .i aa="[" s X="V",V="",paa="" q    
 .e  s N=N_aa q
 i T=10,X="V" d  q  ; ДТД
 .i aa=">",paa="]" d ParserXMLCreateNode s T=0,L=L-1 q
 .e  s V=V_paa,paa=aa q
 q

ParserXMLCreateDocFragment 
 s CurCode=0,ParCode(0)=CurCode,NumAttr(0)=0,NumChild(0)=0        
 s @DomXML@(CurCode,"t")=11
 s CurCode=$$ParserXMLNextCode(CurCode)        
 k T,N,V,X
 q        
ParserXMLCreateNode 
 s @DomXML@(CurCode,"t")=T
 s @DomXML@(CurCode,"level")=L   
 i $d(N) s @DomXML@(CurCode,"n")=N
 i $d(V) s @DomXML@(CurCode,"v")=V
 i T=2 d
 .s @DomXML@(ParCode(L-1),"a",NumAttr(L-1))=CurCode
 .s NumAttr(L-1)=NumAttr(L-1)+1  
 e  d
 .s @DomXML@(ParCode(L-1),"c",NumChild(L-1))=CurCode
 .s NumChild(L-1)=NumChild(L-1)+1
 i T=1 s ParCode(L)=CurCode,NumAttr(L)=0,NumChild(L)=0
 s CurCode=$$ParserXMLNextCode(CurCode)        
 k T,N,V,X
 q


ParserXMLNextCode(LastCode) 
 q LastCode+1


ParserXMLCutSpace 
 q       
 s PrevAA="",VV=""
 f n=1:1:$l(V) d
 .s AA=$e(V,n)
 .i AA=" " i PrevAA=" "!PrevAA="" q
 .s VV=VV_PrevAA,PrevAA=AA
 i PrevAA'=" " s VV=VV_PrevAA
 s V=VV
 q

ParserXMLErr(ErrName) q
]]></Implementation>
</Method>

<Method name="Print">
<Description><![CDATA[
Вывод печатной формы
X130 - выводимый вариант набора.
Может быть задано в виде Код_отображения:набор_печати. В этом случае используется набор печати указанного отображения.
Если не задано, то берется понятие X130 .
x320 определяет приемник печатной формы. Если не задано, то берется понятие x320.
NoWin - печать в текущем контексте (не создается отображение с qqnump="P"), >10 - не загружаются пармаетры печати (берутся из Vo(qqnump,-1,3,par) ), действие по входу в печать не выполняется ;@Dol 05.03.10
OpenFile - (1 или пусто) - открывать файл, 0 - нет
spaceBefore - отступ сверху в основной области печати в мм]]></Description>
<Internal/>
<FormalSpec>Job:%String,X130:%String,x320:%String,OpenFile:%Library.String,qqdev:%Library.String=0,NoWin:%Library.String,spaceBefore:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 n Fld,ColDBF s ColDBF=0 ;sasha 20080929
 ;X130 - определяет набор печати, если начинается с @, то считаем, что это выражение
 S X130=$G(X130) I $E(X130)="@" S X130=qARM.Value($E(X130,2,$L(X130)))
 n ViewX130
 I $L(X130,":")>1 s ViewX130=$P(X130,":")  s:ViewX130'[$C(1) ViewX130=$s($d(^Q(1,"XView",ViewX130  )):ViewX130,1:qUSER.viOrg(ViewX130)) i $g(ViewX130)=""  Q:$Q "" Q
 S X130=$s($L(X130,":")>1: ViewX130_":"_$P(X130,":",2), 1:$g(X130))  ;Маслова 31.08.2010 
 
 N qqoView,View
 
  ;Маслова 31.08.2010   
 I '$G(NoWin) S View=$P($$$tmpGl("q",Job)," ",1)
 I $g(View)="" s View=$g(Vo(qqnump,-1,-1))_$s($g(Vo(qqnump,-1,-1))'="":$C(1),1:"")_Vo(qqnump)
  
 S qqoView=$S($g(View)'[$C(1):"XView",1:$P($g(View),$C(1))) S:$g(View)[$C(1) View=$P($g(View),$C(1),2,255) ;Маслова 31.08.2010  
 
 n qqoViewX130
 I $L(X130,":")>1 s ViewX130=$P(X130,":") S qqoViewX130=$S(ViewX130'[$C(1):"XView",1:$P(ViewX130,$C(1))) S:ViewX130[$C(1) ViewX130=$P(ViewX130,$C(1),2,255) ;Маслова 31.08.2010 
  
 N %1 S %1=..PrintStart(Job,X130,$G(NoWin)) Q:%1'="" %1 K NoWin ;@Dol K NoWin для колон-титулов
 ; после вызова в Vo(qqnump,-1,30) - номер набора печати в этом отображении
 ; определяем отображение, откуда брать параметры печати
 S X130=$S($L(X130,":")>1:$P(X130,":"),1:"")
 
 S:'$D(x320) x320=qARM.GetPar(320,X130) ; приемник
 S x320=$P(x320," ") ; tdv 20110302 - если не обработан список приёмников печати (см. qARM.Print)
 
 ;sas 20090427
 //s:($E($G(qqchoice),7,8)'="0")&&(+$E($G(qqchoice),7,8)=0)&&($G(qqXBPrttoOOW)=1) x320=10
 ; tdv 20100409 - добавлена проверка на режим администратора
 ; @ank,tdv,rda,sas 20100609  - добавлено условие для печати в OpenOffice x320?1(1"0",1"1") , блок перенесён из начала метода
 //d
 //.i $G(W("Zadm")) s:($E($G(qqchoice),7,8)'="0")&&(+$E($G(qqchoice),7,8)=0)&&($G(qqXBPrttoOOW)=1) x320=10 q
 //.i ($G(qqXBPrttoOOW)=1),x320?1(1"0",1"1") s x320=10
 
 i '$G(W("Zadm")),$G(qqXBPrttoOOW)=1 S x320=$S(x320=1:10,x320=2:11,1:x320)  ; tdv 20110527 печать в OO Writer вместо MS Word и OO Calc вместе MS Excel
 
 N vxsl S vxsl=qARM.GetPar(322,X130)    ; откуда брать XSL
 n x326 s x326=qARM.GetPar("x326",X130) ; действие с файлом результата
 n X327 s X327=qARM.GetPar("X327",X130) ; принтер

 ;@Pav
 N XMLPath,File,Noxml
 ;@dol 14.12.04 вместо двух закомментированных строк
  S File=qARM.GetPar(368,X130) S:$E(File)="@" @("File="_$E(File,2,32000)) I $E(File)="-" S Noxml=1,File=$E(File,2,30000) ;@Dol 14.12.04 свой XML в $$$tmpGl(2,$Job)

 ; новая печать - если установлен флаг, задано имя
 I $G(^Q(1,"XBase",0,"XBPrt2"))=1,File'?1.n D ..Print2(X130,x320,vxsl,$G(OpenFile),x326,X327,$G(spaceBefore)) Q ""
 
 I File?1.n D ..XML(File,,,0,0,,,,X130,x320) Q:$Q "" Q  ; запись в массив $$$tmpGl(File,$J) если задааный файл - число
 S XMLPath = ..xmlPath(File)

 I x320=8 D  Q:$Q "" Q   ;Шаблон Excel (@Mike)
 .D ..XML(qqdev+2,,,0,0,,,,X130,6)
 .D qARM.OpenIE(qqdev+2,$P(XMLPath,".",1,$L(XMLPath,".")-1)_".txt",0)
 .D qARM.OpenIE($NA(^Q(1,$S(X130="":qqoView,1:qqoViewX130),$S(X130="":View,1:ViewX130),"XPrint",Vo(qqnump,-1,30),"YEx")),$P(XMLPath,".",1,$L(XMLPath,".")-1)_".xls",0)
 .D qARM.wM("-qARM","ShellExecute",0,"open",""_$P(XMLPath,".",1,$L(XMLPath,".")-1)_".xls"_"","",""_qARM("ClientPath")_"",1)

 ; полный путь к xsl-файлу
 N XSLPath S XSLPath=$P(XMLPath,".",1,$L(XMLPath,".")-1)_".xsl"
 ; если вариант XSL - файл, то параметр X365 содержит путь к файлу
 I vxsl=2,x320<5 S XSLPath=..XslPath(qARM.GetPar(365,X130))

 ; tdv 13.03.2006 сначала формируем XML
 D:'$G(Noxml) ..XML(qqdev+2,,,$S(vxsl=2:XSLPath'="",vxsl'=1:1,1:0),0,,,,X130,x320) ;не включать id=qqc 17.03.04 @dol если файл не указан
 
 N XMLRef S XMLRef=$NA($$$tmpGl(qqdev+2,$J)) ; 15.12.2008 Kokarev
 N XSLRef S XSLRef=$NA($$$tmpGl(qqdev+1,$J)) ; 15.12.2008 Kokarev
 
 g:x320=10 Print10    //OO roma&vol 20081202 
 // получаем XSL
 D:vxsl'?1(1"1",1"2")&&(x320<5)  ;x320=6 TXT+GT, 5- внешний XML
 .// формируется
 .I 'vxsl D ..XSL(qqdev+1,,,,x320,,X130) D qARM.OpenIE(qqdev+1,XSLPath,0) Q
 .;ссылка на текст
 .I vxsl=4 S XSLRef=qARM.GetPar(365,X130) S:$E(XSLRef)="@" XSLRef=qARM.Value($E(XSLRef,2,32000)) D qARM.OpenIE(XSLRef,XSLPath,0) Q
 .;хранимый текст (vxsl=3)
 .S XSLRef=$NA(^Q(1,$S(X130="":qqoView,1:qqoViewX130),$S(X130="":View,1:ViewX130),"XPrint",Vo(qqnump,-1,30),"TB323")) D qARM.OpenIE(XSLRef,XSLPath,0) Q

 N start S start=(x320'=4)&&$S($G(OpenFile)="":1,1:OpenFile)
 S:x320'=9 %1=..SendXML(qqdev+2,x320,XMLPath,XSLPath,start,vxsl=2,X130)
 ;S %1=..SendXML(qqdev+2,x320,XMLPath,XSLPath,start,vxsl=2,X130)
 I x320=3||(x320=6)||(x320=5)||(x320=7),'qARM.GetPar("X3692",X130) D qARM.Message("Сформирован "_$S(x320'=6&&(x320'=7):XMLPath,XMLPath'[".xml":XMLPath,1:$P(XMLPath,1,$L(XMLPath,".")-1)_".txt")_$S(vxsl=2||(x320>4):"",1:" и "_XSLPath)) Q:$Q "" Q  ;@Dol 21.03.05 учет X3692
 ; sasha 20080929
 ///I (x320=9),'qARM.GetPar("X3692",X130) D:$G(Fld(-1))'=-1 qARM.wM("-qARM","FileFastSave",$NA(^CacheTemp(qqdev+2,$J)),$P(XMLPath,".")_".dbf"),qARM.Message("Сформирован "_$P(XMLPath,".")_".dbf") Q:$Q "" Q
 ///I (x320=9),'qARM.GetPar("X3692",X130) i $G(Fld(-1))'=-1 s DBFtrue=1 D qARM.wM("-qARM","FileFastSave",$NA(^CacheTemp(qqdev+2,$J)),$P(XMLPath,".")_".dbf","s DBFtrue=0 d qARM.Message(""Ошибка при создании файла. Файл возможно открыт на просмотр "_$P(XMLPath,".")_".dbf"",,1)") d qARM.Wait("d:DBFtrue=1 qARM.Message(""Сформирован "_$P(XMLPath,".")_".dbf"") k DBFtrue") Q:$Q "" Q
 I (x320=9) i $G(Fld(-1))'=-1 s DBFtrue=1 D qARM.wM("-qARM","FileFastSave",$NA($$$tmpGl(qqdev+2,$J)),$P(XMLPath,".")_".dbf","s DBFtrue=0 d qARM.Message(""Ошибка при создании файла. Файл возможно открыт на просмотр "_$P(XMLPath,".")_".dbf"",,1)") d:'qARM.GetPar("X3692",X130) qARM.Wait("d:DBFtrue=1 qARM.Message(""Сформирован "_$P(XMLPath,".")_".dbf"") k DBFtrue") Q:$Q "" Q  ; 15.12.2008 Kokarev
 Q:$Q %1 Q
Print10
 N start S start=(x320'=4)&&$S($G(OpenFile)="":1,1:OpenFile)
 //пересылка xml на клиента sas 20081205
 N path S path=$P(XMLPath,".",1,$L(XMLPath,".")-1)_"\"
 I +$G(^Q(1,"XBase",0,"XBPrt2"))=0 s %1=..SendXML(qqdev+2,10,XMLPath,XSLPath,start,vxsl=2,X130)
 D ..OOXSL("","","Vo(qqnump)", XSLRef )
 D qARM.wM("-qARM","FileFastSave", XSLRef, XSLPath)
 D qARM.wM("-qARM","ForceDir", path_"META-INF" ,"","")
 s manifest(0)="<?xml version=""1.0"" encoding=""UTF-8""?><manifest:manifest xmlns:manifest=""urn:oasis:names:tc:opendocument:xmlns:manifest:1.0""> <manifest:file-entry manifest:media-type=""application/vnd.oasis.opendocument.text"" manifest:full-path=""/""/> <manifest:file-entry manifest:media-type=""text/xml"" manifest:full-path=""content.xml""/></manifest:manifest>"
 D qARM.wM("-qARM","FileFastSave", "manifest", path_"META-INF\manifest.xml") 
 D GetRz(XMLPath,XSLPath, path)
 D qARM.wM("-qARM","ChgDir",..ClientPath())
 D qARM.wM("-qARM","ModalExec","zip32 -add=update -move -silent -dir=relative qword """_path_"*.*""",1)
 D qARM.wM("-qARM","ModalExec","cmd /c del qword.odt",1)
 D qARM.wM("-qARM","ModalExec","cmd /c ren qword.zip qword.odt",1)
 ;D qARM.wM("-qARM","ModalExec","qword.odt",1)
 D qARM.wM("-qARM","ShellExecute",0, "open", "qword.odt", "","",1)
 Q ""   
GetRz(fileXML,fileXSL,fResult)
 n ObjName
 s ObjName="XSLTOO"
 D:'$D(qwin(ObjName))
 .s qwin(ObjName)=1
 .D qARM.wC("TXMLProcessor",ObjName)
 D qARM.wM(ObjName,"Initialize",0,fResult)
 D qARM.wM(ObjName,"New","content.xml")
 D qARM.wM(ObjName,"LoadXML",fileXML)
 D qARM.wM(ObjName,"LoadXSL",fileXSL)
 D qARM.wM(ObjName,"ReplaceCharset",0,"UTF-16","windows-1251",1)
 D qARM.wM(ObjName,"TransformNode")
 D qARM.wM(ObjName,"CloseMIME")
]]></Implementation>
</Method>

<Method name="Print2">
<Description><![CDATA[
Вывод печатной формы. Печать версия 2<br/>
Параметры:<br/>
view    - отображение, из которого берутся параметры печати<br/>
x320    - приёмник печатной формы: 0(IE), 1(Word), 2(Excel), 3 (файл), 4 (-), 5 (внешний XML), 6 (TXT с разделителями), 7 (TXT c фиксированными полями), 8 (Excel с шаблоном)<br/>
x322    - вариант XSL: - 0 (формируется), 1 (отсутствует), 2 (файл), 3 (текст), 4 (ссылка на текст)<br/>
start   - (+$G(start))'=0 - открывать выходной файл, иначе только формировать<br/>
x326    - действие с файлом результата<br/>
X327    - принтер<br/>
spaceBefore - отступ сверху в основной области печати в мм]]></Description>
<Internal/>
<FormalSpec>view:%Library.String,x320:%Library.String,x322:%Library.String,start:%Library.String,x326:%Library.String,X327:%String,spaceBefore:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n printView s printView = $piece($G($$$tmpGl("q", $j)), " ", 1) ;@Dol 19.05.09
    
 ; обрабатываем входные параметры   
 i $g(x320) = "" s x320 = 0 
 i $g(x322) = "" s x322 = 0
 ;;i $g(view) = "" s view = Vo(qqnump)
 i $g(view) = "" s view = $g(Vo(qqnump,-1,-1))_$s($g(Vo(qqnump,-1,-1))'="":$C(1),1:"")_Vo(qqnump)    ;Маслова 01.09.2010
 i $g(x326) = "" s x326 = 0
 i $g(X327) = "" s X327 = ""
 ; запускать если параметр "" или не равен 0
 s start = $s($g(start) = "" : 1, 1 : start '= 0)
 ; номер набора параметров печати
 n set s set = Vo(qqnump, -1, 30)

 ; удаление объекта класса открытия документа
 d ..Print2DocOpenDestroy()

 ; глобал  печати
 n prtRef s prtRef = ..Print2GetGlbPrs("ref")

 ; ind - индекс печати
 ; основной документ (body)
 ; xsl
 ; @prtRef@("ind",ind,"body","xsl")=form/ref/file - вариант xsl (сформирован, ссылка на текст, файл)
 ; @prtRef@("ind",ind,"body","xsl","form") - текст xsl
 ; @prtRef@("ind",ind,"body","xsl","ref")  - ссылка на текст xsl
 ; @prtRef@("ind",ind,"body","xsl","file") - имя файла xsl
 ; xml
 ; @refPrt@("ind",ind,"body","xml")=form/ref/file - вариант xml (сформирован, ссылка на текст, файл)
 ; @refPrt@("ind",ind,"body","xml","form") - текст xml
 ; @refPrt@("ind",ind,"body","xml","ref")  - ссылка на текст xml
 ; @refPrt@("ind",ind,"body","xml","file") - имя файла xml
 ; txt
 ; @refPrt@("ind",ind,"body","txt")=form   - вариант txt (сформирован)
 ; @refPrt@("ind",ind,"body","txt","form") - текст txt
 ; @refPrt@("ind",ind,"body","txt","file") - имя файла txt
 ; xls
 ; @refPrt@("ind",ind,"body","xls")=ref    - вариант xls (ссылка на текст)
 ; @refPrt@("ind",ind,"body","xls","ref")  - ссылка на текст xls
 ; @refPrt@("ind",ind,"body","xls","file") - имя файла xls
 ; res
 ; @refPrt@("ind",ind,"body","res")=file   - вариант результата (файл)
 ; @refPrt@("ind",ind,"body","res","file") - короткое имя файла результата
 ; @refPrt@("ind",ind,"body","res","file","dir") - папка результата
 ; @refPrt@("ind",ind,"body","res","file","sht") - короткое имя файла результата без расширения
 ;
 ; верхний колонтитул (head)
 ; xsl
 ; @refPrt@("ind",ind,"head","xsl")=form/ref/file - вариант xsl (сформирован, ссылка на текст, файл)
 ; @refPrt@("ind",ind,"head","xsl","form") - текст xsl
 ; @refPrt@("ind",ind,"head","xsl","ref")  - ссылка на текст xsl
 ; @refPrt@("ind",ind,"head","xsl","file") - имя файла xsl
 ; xml
 ; @refPrt@("ind",ind,"head","xml")=ref/file - вариант xml (ссылка на текст, файл)
 ; @refPrt@("ind",ind,"head","xml","ref")  - ссылка на текст xml
 ; @refPrt@("ind",ind,"head","xml","file") - имя файла xml
 ; res
 ; @refPrt@("ind",ind,"head","res")=file   - вариант результата (файл)
 ; @refPrt@("ind",ind,"head","res","file") - короткое имя файла результата
 ;
 ; нижний колонтитул (foot)
 ; xsl
 ; @refPrt@("ind",ind,"foot","xsl")=form/ref/file - вариант xsl (сформирован, ссылка на текст, файл)
 ; @refPrt@("ind",ind,"foot","xsl","form") - текст xsl
 ; @refPrt@("ind",ind,"foot","xsl","ref")  - ссылка на текст xsl
 ; @refPrt@("ind",ind,"foot","xsl","file") - имя файла xsl
 ; xml
 ; @refPrt@("ind",ind,"foot","xml")=ref/file - вариант xml (ссылка на текст, файл)
 ; @refPrt@("ind",ind,"foot","xml","ref")  - ссылка на текст xml
 ; @refPrt@("ind",ind,"foot","xml","file") - имя файла xml
 ; res
 ; @refPrt@("ind",ind,"foot","res")=file   - вариант результата (файл)
 ; @refPrt@("ind",ind,"foot","res","file") - корткое имя файла результата
 ;
 ; узел с картинками (pic) - заполняется в qW.GetLine (вызывается через qWEB.XML --> qW.gForm)
 ; @refPrt@("ind",ind,"pic")=form - вариант картинок (сформированы)
 ; @refPrt@("ind",ind,"pic","temp",src)=name                     - вспомогательный формат
 ; @refPrt@("ind",ind,"pic","form",num)=srs_$C(13)_name_$C(13)   - требуемый формат для qARMProj
 ; src    - ссылка на ресурс (F,имя файла; M,ссылка за глобал; R,номер в qARM.dll)
 ; name   - короткое имя картинки со значимым расширение (должно быть допустимым в качестве имени файла)
 ; num    - номер картинки
 ;
 ; общие параметры (prs)
 ; @refPrt@("ind",ind,"prs","receiver")    - приёмник печатной формы
 ; @refPrt@("ind",ind,"prs","start")=1     - открывать печатную форму
 ; @refPrt@("ind",ind,"prs","xxl")=1       - создавать файлы xml,xsl
 ; @refPrt@("ind",ind,"prs","mime")=1      - создавать результирующий файл как MIME
 ; @refPrt@("ind",ind,"prs","edit")=1      - разрешено редактирование при выводе через OpenDocument
 ; @refPrt@("ind",ind,"prs","message")=1   - выводить сообщение об успешном формировании файлов
 ; @refPrt@("ind",ind,"prs","resAct")      - действие с файлом результата

 ; ссылка на индекс печати
 n indRef s indRef = $na(@prtRef@("ind", $i(@prtRef@("ind"))))

 ; ссылка на параметры
 n prsRef s prsRef = $na(@indRef@("prs"))

 ; приёмник
 n rcvr s rcvr = ..Print2GetRcvr(x320, "in", "fld")
 ; устанавливаем приёмник
 s @prsRef@("receiver") = rcvr
 
 ; приёмник только для файлов xxl (без формирования результата)
 n isRcvrForSingleXxl s isRcvrForSingleXxl = (rcvr ?1(1"FILE",1"XML_EXTERNAL"))
 
 ; приёмник для xxl
 n isRcvrForXxl s isRcvrForXxl = ((rcvr ?1(1"IE",1"WORD",1"EXCEL"))||(isRcvrForSingleXxl))
 
 ; приёмник только для файлов txt (без формирования результата)
 n isRcvrForSingleTxt s isRcvrForSingleTxt = (rcvr ?1(1"TXT_TABULATED",1"TXT_FIXED"))
 
 ; приёмник для txt
 n isRcvrForTxt s isRcvrForTxt = ((rcvr ?1(1"EXCEL_TEMPLATE"))||(isRcvrForSingleTxt))
 
 ; приёмник для dbf
 n isRcvrForDbf s isRcvrForDbf = (rcvr ?1(1"DBF"))
 
 ; приёмник для odf
 n isRcvrForOdf s isRcvrForOdf = (rcvr ?1(1"ODT",1"ODS"))
 
 ; приёмник для явного не запуска/запуска
 n isRcvrForStart
 s isRcvrForStart(0) = ((isRcvrForSingleXxl)||(isRcvrForSingleTxt)||(isRcvrForDbf))
 ;s isRcvrForStart(1) = ""
 
 ; приёмник для явного не формирования/формирования файлов xxl
 n isRcvrForSrc
 s isRcvrForSrc(0) = ((isRcvrForTxt)||(isRcvrForDbf))
 s isRcvrForSrc(1) = (isRcvrForSingleXxl)
 
 ; приёмник для явного не формирования/формирования формирования MIME
 n isRcvrForMIME
 s isRcvrForMIME(0) = ((isRcvrForSingleXxl)||(isRcvrForTxt)||(isRcvrForDbf)||(isRcvrForOdf))
 ;s isRcvrForMIME(1) = ""
 
 ; приёмник для явного не вывода/вывода сообщения
 n isRcvrForMes
 ;s isRcvrForMes(0) = ""
 s isRcvrForMes(1) = ((isRcvrForSingleXxl)||(isRcvrForSingleTxt)||(isRcvrForDbf))
 
 ; вариант xsl
 n xslVar s xslVar = ..Print2GetVar("xsl", x322, "in", "fld")
 ; вариант xml
 n xmlVar s xmlVar = "FORM"
 
 ; открывать печатную форму
 d
 .; явно не запускать, если приёмник для явно не запуска
 .i $d(rcvrForStart(0)), rcvrForStart(0) s start = 0 q
 .; явно не запускать, если приёмник для xxl и вариант xsl - отсутствует
 .i isRcvrForXxl, xslVar = "NO" s start = 0
 ; устанавливаем флаг - открывать печатную форму
 s @prsRef@("start") = start

 ; разрешено редактирование при выводе через OpenDocument
 n editable s editable = 0
 i start=1 s editable = ''qARM.GetPar("X3642", view)
 s @prsRef@("edit") = editable
 
 ; действия с файлом результата
 n resAct s resAct = ..Print2GetResAct(x326, "in", "fld")
 ; если не стартовать - то ставим только создавать
 i (start = 0) s resAct = "CREATE"
 s @prsRef@("resAct") = resAct
 
 ; принтер 
 n printer s printer = X327
 s @prsRef@("printer") = printer
 
 ; отступ
 s @prsRef@("spaceBefore") = spaceBefore

 ; формировать xml,xsl
 n isXXL s isXXL = ..Print2GetGlbPrs("xxl")
 d
 .; явно формировать, если приёмник для явно формировать
 .i $d(isRcvrForSrc(1)), isRcvrForSrc(1) s isXXL = 1 q
 .; явно не формировать, если приёмник для явно формировать
 .i $d(isRcvrForSrc(0)), isRcvrForSrc(0) s isXXL = 0
 ; устанавливаем флаг - формировать xml,xsl
 s @prsRef@("xxl") = isXXL

 ; формировать MIME
 n isMIME s isMIME = '..Print2GetGlbPrs("notmime")
 ; явно не формировать, если приёмник для явно не формировать
 i $d(isRcvrForMIME(0)), isRcvrForMIME(0) s isMIME = 0
 ; устанавливаем флаг - формировать MIME
 s @prsRef@("mime") = isMIME

 ; выводить сообщение
 n isMes s isMes = 0
 d
 .; не выводить, если установлен флаг "Не выводить сообщение о формировании файла"
 .n notMes s notMes = qARM.GetPar("X3692", view) i notMes = 1 q
 .; явно выводить, если приёмник для явного вывода
 .i $d(isRcvrForMes(1)), isRcvrForMes(1) s isMes = 1
 ; устанавливаем флаг - выводить сообщение
 s @prsRef@("message") = isMes
  
 ; глобал с информацией о результате
 n resRef s resRef = $na(@indRef@("body", "res"))

 ; полный путь к xml-файлу
 n file s file = qARM.GetPar("X368", view)
 i $e(file) = "@" s @("file = "_$e(file, 2, $l(file)))
 
 i $e(file)="-" d
 .s file = $e(file, 2, $l(file))
 .s xmlVar = "REF"
 
 s file = ..xmlPath(file)
 n sep s sep = $s(file [ "\" : "\", 1 : "/")
 ; папка
 n dir s dir = $p(file, sep, 1, $l(file, sep) - 1)
 s @resRef@("file", "dir") = dir _ sep
 ; короткое имя файла
 s file = $p(file, sep, $l(file, sep))
 ; короткое имя файла без расширения
 n sht s sht = $p(file, "." ,1, $l(file, ".") - 1)
 s @resRef@("file", "sht") = sht
 
 ; вывод в xml, xsl
 ; выводить, если приёмник для xxl
 i isRcvrForXxl d
 .; вариант xsl - уже получили
 .; вариант xml - уже получили
 .; вариант картинок 
 .n picVar s picVar = "FORM"
 .; вариант результата
 .n resVar s resVar = "FILE"
 .
 .; получение xml и xsl
 .d ..Print2GetXxl(indRef, view, set, xslVar, xmlVar, picVar, resVar)
 .; формирование файлов
 .d ..Print2SendXxl(indRef)

 ; вывод в текстовый файл
 ; выводить, если приёмник для txt
 i isRcvrForTxt d
 .; вариант txt
 .n txtVar s txtVar = "FORM"
 .; вариант xls
 .n xlsVar s xlsVar = "TEXT"
 .; вариант результата
 .n resVar s resVar = "FILE"
 .
 .; получение txt
 .d ..Print2GetTxt(indRef, view, set, txtVar, xlsVar, resVar)
 .; формирование файлов
 .d ..Print2SendTxt(indRef)
 
 ; dbf
 i isRcvrForDbf d
 .; вариант dbf
 .n dbfVar s dbfVar = "FORM" 
 .; получение dbf
 .d ..Print2GetDbf(indRef, view, set, dbfVar)
 .; формирование файлов
 .d ..Print2SendDbf(indRef)
 
 /*
 i isRcvrForOdf d
 .new colRef set colRef = $name(@indRef@("content", "xsl"))
 .// формируем коллонтитулы
 .new isCol set isCol = ..Print2GetOdfCol(indRef, view, set, colRef)
 .
 .i isCol d
 ..; сохраняем состояние отображения
 ..d qARM.SaveView(1, "", printView)
 ..; формируем контекст печати
 ..d ..PrintStart($j, view _ ":" _ set)
 .
 .n picVar s picVar = "FORM"
 .
 .n varArray
 .s varArray("content", "xsl") = "FORM"
 .s varArray("content", "xml") = "FORM"
 .s varArray("content", "res") = "FILE"
 .
 .s varArray("manifest", "xsl") = "NO"
 .s varArray("manifest", "xml") = "NO"
 .s varArray("manifest", "res") = "FILE"
 .
 .s varArray("body", "xsl") = "NO"
 .s varArray("body", "xml") = "NO"
 .s varArray("body", "res") = "FILE"
 .
 .; получение odf
 .d ..Print2GetOdf(indRef, view, set, .varArray, picVar, colRef)
 .; формирование файлов
 .d ..Print2SendOdf(indRef)
 */
 
 i isRcvrForOdf d
 .new envRef set envRef = $name(@indRef@("content", "env"))
 .
 .new qqmas set qqmas=$na($$$tmpGl("q",$j))
 .merge @envRef@("qqmas")=@qqmas
 .
 .D qARM.csav()
 .merge @envRef@("WS")=WS(qqnump)
 .N qqnumpMain S qqnumpMain=qqnump
 .
 .//merge @envRef@("qwin")=qwin(qwin,"child")
 .N qwinMain S qwinMain=qwin
 .
 .new array for array="Vo","Vs","Vt","Vc" merge @envRef@(array)=@array@(qqnump)
 .
 .// формируем коллонтитулы
 .new colRef set colRef = $name(@indRef@("content", "xsl"))
 .new isCol set isCol = ..Print2GetOdfCol(indRef, view, set, colRef)
 .
 .i isCol d
 ..; сохраняем состояние отображения
 ..;d qARM.SaveView(1, "", printView)
 ..; формируем контекст печати
 ..;d ..PrintStart($j, view _ ":" _ set)
 ..
 ..kill WS(qqnumpMain) merge WS(qqnumpMain)=@envRef@("WS")
 ..D qARM.crst(,qqnumpMain,1)
 ..
 ..s qwin=qwinMain //kill qwin(qwin, "child") merge qwin(qwin, "child")=@envRef@("qwin")
 ..
 ..for array="Vo","Vs","Vt","Vc" kill @array@(qqnump) merge @array@(qqnump)=@envRef@(array)
 ..
 ..kill @qqmas m @qqmas=@envRef@("qqmas")
 .
 .n picVar s picVar = "FORM"
 .
 .n varArray
 .s varArray("content", "xsl") = "FORM"
 .s varArray("content", "xml") = "FORM"
 .s varArray("content", "res") = "FILE"
 .
 .s varArray("manifest", "xsl") = "NO"
 .s varArray("manifest", "xml") = "NO"
 .s varArray("manifest", "res") = "FILE"
 .
 .s varArray("settings", "xsl") = "NO"
 .s varArray("settings", "xml") = "NO"
 .s varArray("settings", "res") = "FILE"
 .
 .s varArray("body", "xsl") = "NO"
 .s varArray("body", "xml") = "NO"
 .s varArray("body", "res") = "FILE"
 .
 .; получение odf
 .d ..Print2GetOdf(indRef, view, set, .varArray, picVar, colRef)
 .; формирование файлов
 .d ..Print2SendOdf(indRef)
 
 ; выводим сообщение
 i isMes = 1 d ..Print2Mes(indRef)

 ; открываем/печатаем файл результата
 i (resAct ?1(1"CREATE_OPEN",1"CREATE_PRINT")) d ..Print2Open(indRef)

 q
]]></Implementation>
</Method>

<Method name="Print2DocOpenCreate">
<Description><![CDATA[
Создание объекта класса открытия документа<br/>
Параметры:<br/>
resPath - открываемый файл<br/>]]></Description>
<Internal/>
<FormalSpec>resPath:%Library.String,editable:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; класс открытия документа
 n openCls s openCls = "TOpenDocument"
 ; объект открытия документа
 n openObj s openObj = "print2opendoc"

 ; замещать выходную форму
 ;Замещать при установленном флаге qqXBPrttoOOW в OOW, только если формат ODT. Временно закомментировано.
 ;sas 20090717
 ;n typefile s typefile=$ZCVT($P(resPath,".",2),"U")
 ;d qARM.wC(openCls, openObj, resPath,$S($G(typefile)="ODT":$G(qqXBPrttoOOW),1:0))
 d qARM.wC(openCls, openObj, resPath)

 ; разрешаем редактирование
 i editable d qARM.wP(openObj, "ReadOnly", 0) 

 ; устанавливаем флаг, что объект существует
 d ..Print2SetGlbObj(openCls, openObj, 1)

 q
]]></Implementation>
</Method>

<Method name="Print2DocOpenDestroy">
<Description><![CDATA[
Удаление объекта класса открытия документа<br/>]]></Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 ; класс открытия документа
 n openCls s openCls = "TOpenDocument"
 ; объект открытия документа
 n openObj s openObj = "print2opendoc"

 ; флаг наличия объекта
 n isOpenObj s isOpenObj = ..Print2GetGlbObj(openCls, openObj)
 ; если объект уже есть  - удаляем его
 i isOpenObj d
 .; удаляем
 .d qARM.wM(openObj, "Destroy")
 .; устанавливаем флаг, что объекта не существует
 .d ..Print2SetGlbObj(openCls, openObj, 0)

 q
]]></Implementation>
</Method>

<Method name="Print2GetDbf">
<Internal/>
<FormalSpec>indRef:%String,view:%String,set:%String,dbfVar:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; приёмник
 n rcvr S rcvr = @indRef@("prs", "receiver")
 ; входной вариант приёмника
 n rcvrIn s rcvrIn = ..Print2GetRcvr(rcvr, "fld", "in")

 ; глобал с информацией o результате
 n indResRef s indResRef = $na(@indRef@("body", "res"))
 ; папка результата
 n dir s dir = @indResRef@("file", "dir")
 ; короткое имя результата без расширения
 n sht s sht = @indResRef@("file", "sht")
 ; полное имя результата без расширения
 n fll s fll = dir _ sht

 ; dbf
 ; флаг получения dbf
 n isDbf s isDbf = 0
 ; выходной вариант dbf
 n dbfVarOut s dbfVarOut = ..Print2GetVar("dbf", dbfVar, "fld", "out")
 ; путь к dbf-файлу, ссылка на текст dbf
 n dbfPath, dbfRef
 ; глобал с информацией o dbf
 n indDbfRef s indDbfRef = $na(@indRef@("body", "dbf"))

 ; получаем dbf, если
 ; приёмник    - DBF
 ; вариант DBF - формируется
 n isRcvrForDbf s isRcvrForDbf = (rcvr ?1(1"DBF"))
 n isDbfVarValid s isDbfVarValid = (dbfVar = "FORM")
 i isRcvrForDbf, isDbfVarValid d
 .; полный путь к dbf-файлу
 .s dbfPath = fll_".dbf"
 .
 .; формируется
 .i dbfVar = "FORM" d  q
 ..; ссылка на глобал, в котором будем формировать текст dbf
 ..s dbfRef = $na(@indDbfRef@(dbfVarOut))
 ..; формируем dbf
 ..d ..XML( , , , 0, 0, , , , view, rcvrIn, dbfRef)
 ..i '$d(@dbfRef) q
 ..s isDbf = 1

 ; если получили dbf - записываем имя файла для всех вариантов dbf
 i isDbf d
 .; записываем выходной вариант dbf
 .s @indDbfRef = dbfVarOut
 .; записываем имя dbf-файл
 .s @indDbfRef@("file") = dbfPath

 q
]]></Implementation>
</Method>

<Method name="Print2GetGlbObj">
<Description><![CDATA[
/// Получение глобальных параметров печати - объекты классов Delphi<br/>
Параметры:<br/>
class   - имя класса:<br/>
TOpenDocument - открытие документа с замещением выходной формы<br/>
TOleXMLDOM - обработка XML-XSL в печати версии 1<br/>
TXMLProcessor - обработка XML-XSL в печати версии 2<br/>

object  - имя объекта:<br/>
class = TOpenDocument:<br/>
docxml        - печать версия 1<br/>
print2opendoc - печать версия 2<br/>

class = TOleXMLDOM (только версия 1)<br/>
имя объекта не указывается<br/>

class = TXMLProcessor (только версия 2)<br/>
print2xmlproc<br/>

Возвращаемое значение:<br/>
возвращает 1, если объект (объекты) соответвующего класса Delphi уже созданы<br/>
возвращает 0, если объекты не созданы<br/>
в случае ошибки возвращает пусто<br/>]]></Description>
<Internal/>
<FormalSpec>class:%Library.String,object:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; глобальные параметры печати (glb)
 ; объекты Delphi
 ; @ref@("glb","obj","TOpenDocument","docxml")=1        - объект docxml класса TOpenDocument уже был создан
 ; @ref@("glb","obj","TOpenDocument","print2opendoc")=1 - объект print2opendoc класса TOpenDocument уже был создан
 ; @ref@("glb","obj","TOleXMLDOM")=1                    - объекты класса TOleXMLDOM уже были созданы
 ; @ref@("glb","obj","TXMLProcessor","print2xmlproc")=1 - объект print2xmlproc класса TXMLProcessor уже был создан

 ; возвращаемое значение
 n result s result = ""

 ; проверка значений входных параметров
 ; класс д.б. задан, объект может отсутствовать
 i $g(class) = "" q result
 s object = $g(object)

 ; допустимые значения входных параметров
 n valid
 s valid("TOpenDocument", "docxml") = ""
 s valid("TOpenDocument", "print2opendoc") = ""
 s valid("TOleXMLDOM") = ""
 s valid("TXMLProcessor", "print2xmlproc") = ""
 s valid("THTMLMerge", "print2merge") = ""

 ; если имя класса недопустимо - выходим
 i '$d(valid(class)) q result

 ; если объект не указан, но д.б. задан - выходим
 i object = "", $d(valid(class)) = 11 q result

 ; если объект указан, и имя объекта недопустимо - выходим
 i object '= "", '$d(valid(class, object)) q result

 ; ссылка на массив с глабальными параметрами печати
 n glbRef s glbRef = ..Print2GetGlbRef()

 ; содержимое - объекты (obj)
 n content S content = "obj"
 d
 .; если объект не указан - возвращаем по классу
 .i object = "" s result = $g(@glbRef@(content, class), 0) q
 .; если объект указан - возвращаем по объекту
 .s result = $g(@glbRef@(content, class, object))

 q result
]]></Implementation>
</Method>

<Method name="Print2GetGlbPrs">
<Description><![CDATA[
Получение глобальных параметров печати - общие параметры<br/>
Параметры:<br/>
parName - имя параметра:<br/>
version  - версия печати (1 - старая, 2 - текущая)<br/>
ref      - ссылка на глобал печати<br/>
notmime  - не формировать результат как MIME-файл (0 - формировать, 1 - не формировать)<br/>
xxl      - формировать отдельные файлы XML и XSL (0 - нет, 1 - да)<br/>
Возвращаемое значение:<br/>
возвращает значение параметра, имя которого передано в метод<br/>
в случае ошибки возвращает пусто<br/>]]></Description>
<Internal/>
<FormalSpec>parName:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; глобальные параметры печати (glb)
 ; общие параметры
 ; @ref@("glb","prs","version")    - версия печати (1 - версия 1, 2 - версия 2)
 ; @ref@("glb","prs","notmime")    - значение флага "Не формировать MIME"
 ; @ref@("glb","prs","xxl")        - значение флага "Формировать файлы XML и XSL"
 ; @ref@("glb","prs","ref")        - ссылка на глобал печати

 ; возвращаемое значение
 n result s result = ""

 ; проверка значений входных параметров
 ; имя параметра д.б. задано
 i $g(parName) = "" q result

 ; если имя параметра недопустимо - выходим
 i parName '?1(1"version",1"notmime",1"xxl",1"ref") q result

 ; ссылка на массив с глабальными параметрами печати
 n glbRef s glbRef = ..Print2GetGlbRef()

 ; содержимое - общие параметры (prs)
 n content S content = "prs"

 ; возвращаем параметр
 s result = $g(@glbRef@(content, parName))

 q result
]]></Implementation>
</Method>

<Method name="Print2GetGlbRef">
<Description><![CDATA[
Метод возвращает ссылку на массив с глобальными параметрами печати<br/>]]></Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; получаем ссылку на массив с параметрами печати
 n prtRef s prtRef = ..Print2GetRef()

 ; ссылка на массив с глобальными параметрами печати
 n glbRef s glbRef = $na(@prtRef@("glb"))

 q glbRef
]]></Implementation>
</Method>

<Method name="Print2GetMergeObj">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 new mergeObj set mergeObj = "print2merge"
 
 quit mergeObj
]]></Implementation>
</Method>

<Method name="Print2GetOdf">
<Internal/>
<FormalSpec>indRef:%String,view:%String,set:%String,varArray:%String,picVar:%String,colRef:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 // приёмник
 new rcvr set rcvr = @indRef@("prs", "receiver")
 // входной варианта приёмника
 new rcvrIn set rcvrIn = ..Print2GetRcvr(rcvr, "fld", "in")
 
 ; отступ сверху
 n spaceBefore s spaceBefore = @indRef@("prs", "spaceBefore")
 
 new clientDir set clientDir = qWEB.ClientPath()
 
 // папка в которую будем складывать результат
 new resDir set resDir = @indRef@("body", "res", "file", "dir")
 // короткое имя файла результата без расширения
 new resSht set resSht = @indRef@("body", "res", "file", "sht")
  
 // папка, в которой будут формироваться элементы
 new odfDir set odfDir = clientDir _ "odf\"
 
 // папка, в которую будет записываться manifest
 new odfMetaDir set odfMetaDir = odfDir _ "META-INF\"
    
 new manifest set manifest(0) = "<?xml version=""1.0"" encoding=""UTF-8""?>"
 set manifest(0) = manifest(0) _ "<manifest:manifest xmlns:manifest=""urn:oasis:names:tc:opendocument:xmlns:manifest:1.0"">"
 set manifest(0) = manifest(0) _ " " _ "<manifest:file-entry manifest:media-type=""application/vnd.oasis.opendocument."_$select(rcvr="ODT":"text",rcvr="ODS":"spreadsheet",1:"")_""" manifest:full-path=""/""/>"
 set manifest(0) = manifest(0) _ " " _ "<manifest:file-entry manifest:media-type=""text/xml"" manifest:full-path=""content.xml""/>"
 set manifest(0) = manifest(0) _ "</manifest:manifest>" 
 
 new settings set settings(0) = "<?xml version=""1.0"" encoding=""UTF-8""?>"
 set settings(0) = settings(0) _ "<office:document-settings xmlns:office=""urn:oasis:names:tc:opendocument:xmlns:office:1.0"" xmlns:xlink=""http://www.w3.org/1999/xlink"" xmlns:config=""urn:oasis:names:tc:opendocument:xmlns:config:1.0"" xmlns:ooo=""http://openoffice.org/2004/office"" office:version=""1.2"">"
 set settings(0) = settings(0) _" " _ "<office:settings>"
 set settings(0) = settings(0) _"  " _ "<config:config-item-set config:name=""ooo:configuration-settings"">"
 set settings(0) = settings(0) _"   " _ "<config:config-item config:name=""LoadReadonly"" config:type=""boolean"">true</config:config-item>"
 set settings(0) = settings(0) _"  " _ "</config:config-item-set>"
 set settings(0) = settings(0) _" " _ "</office:settings>"
 set settings(0) = settings(0) _ "</office:document-settings>"
    
 new paramArray
 new item
 new part
 
 new partVar
 new partVarOut
 new isPart
 new partPath
 new partRef
 new partDir
 new partSht
 
 ; pic
 ; выходной вариант картинок
 new picVarOut set picVarOut = ..Print2GetVar("pic", picVar, "fld", "out")
 ; ссылка на глобал картинок
 new picRef
 ; флаг наличия картинок
 new isPic set isPic = 0
 
 ; innerRef - ссылка на глобал, куда пишутся стили для ОО (ширина столбцов встроеных таблиц, встроеная разметка) @rda 20090525
 new innerRef
 new isInner set isInner = 0
 
 // если запрет редактирования - добавляем settings
 new itemList set itemList = $listBuild("content", "manifest") _ $select($get(qqXBPrtReadOnly): $listBuild("settings"), 1: "") _ $listBuild("body")
 new itemCnt
 
 for itemCnt = 1: 1: $listLength(itemList) {
     set item = $list(itemList, itemCnt)
     
     for part = "xsl", "xml", "res" {
         set paramArray(part, "var") = varArray(item, part)
         set paramArray(part, "varOut") = ..Print2GetVar("xsl", varArray(item, part), "fld", "out")
     }
     
     // --- XML
     set part = "xml"
     set partVar = paramArray(part, "var")
     set partVarOut = paramArray(part, "varOut")
     set isPart = 0
     set partPath = ""
     set partRef = ""
     set isPic = 0
     set isInner = 0
     
     if (partVar ?1(1"FILE",1"FORM",1"TEXT",1"REF")) {
         if (item ?1(1"content",1"manifest",1"settings")) {
             set partPath = resDir _ resSht _ "-odf-" _ item _ "." _ part
         }
         
         if (partVar = "FILE") {}
         elseif (partVar = "FORM") {
             set partRef = $name(@indRef@(item, part, partVarOut))
             set picRef = $name(@indRef@(item, "pic"))
             set innerRef = $name(@indRef@(item, "inner"))
             if (item = "content") {
                 do ..XML( , , , 0, 0, , , , view, rcvrIn, partRef, picRef, resSht, innerRef)
             }
             
             if ($data(@partRef)) {
                 set isPart = 1
                 
                 if (picVar = "FORM") {
                     if ($data(@picRef@(picVarOut))) {
                         set isPic = 1
                     }
                 }
                 
                 if ($data(@innerRef)) {
                     set isInner = 1
                 }
             }
         }
         elseif (partVar = "TEXT") {}
         elseif (partVar = "REF") {}
     }
     
     if (isPart) {
         set @indRef@(item, part) = partVarOut
         
         set @indRef@(item, part, "file") = partPath
     }
     
     if (isPic) {
         set @picRef = picVarOut
     }
     // --- XML
     
     // --- XSL
     set part = "xsl"
     set partVar = paramArray(part, "var")
     set partVarOut = paramArray(part, "varOut")
     set isPart = 0
     set partPath = ""
     set partRef = ""
     
     if (partVar ?1(1"FILE",1"FORM",1"TEXT",1"REF")) {
         if (item ?1(1"content",1"manifest",1"settings")) {
             set partPath = resDir _ resSht _ "-odf-" _ item _ "." _ part
         }

         if (partVar = "FILE") {}
         elseif (partVar = "FORM") {
             set partRef = $name(@indRef@(item, part, partVarOut))
             if (item = "content") {
                 do ..OOXSL("","","view", partRef, "", colRef, innerRef, spaceBefore)
             }
             if ($data(@partRef)) set isPart = 1
         }
         elseif (partVar = "TEXT") {}
         elseif (partVar = "REF") {}
     }
     
     if (isPart) {
         set @indRef@(item, part) = partVarOut
         
         set @indRef@(item, part, "file") = partPath
     }
     // --- XSL
     
     
     
     // --- RES
     set part = "res"
     set partVar = paramArray(part, "var")
     set partVarOut = paramArray(part, "varOut")
     set isPart = 0
     set partDir = ""
     set partSht = ""
     set partRef = ""
     
     if (partVar ?1(1"FILE")) {
         if (item = "content") {
             set partDir = odfDir
             set partSht = item
             set partExt = "xml"
         }
         elseif (item = "manifest") {
             set partDir = odfMetaDir
             set partSht = item
             set partExt = "xml"
         }
         elseif (item = "settings") {
             set partDir = odfDir
             set partSht = item
             set partExt = "xml"
         }
         elseif (item = "body") {
             set partDir = resDir
             set partSht = resSht
             set partExt = $select(rcvr = "ODT": "odt",rcvr = "ODS": "ods",1:"")
         }
         
         if (partVar = "FILE") {
             if (item = "content") {
                 set @indRef@(item, part, "form") = "transform_part"
             }
             elseif (item = "manifest") {
                 set @indRef@(item, part, "ref") = $name(@indRef@(item, part, "ref"))
                 merge @indRef@(item, part, "ref")=manifest
             }
             elseif (item = "settings") {
                 set @indRef@(item, part, "ref") = $name(@indRef@(item, part, "ref"))
                 merge @indRef@(item, part, "ref")=settings
             }
             elseif (item = "body") {
                 set @indRef@(item, part, "form") = "join_item"
             }
             
             set isPart = 1
         }
     }
     
     if (isPart) {
         set @indRef@(item, part) = partVarOut
         
         set @indRef@(item, part, "file") = partSht _ "." _ partExt
         set @indRef@(item, part, "file", "dir") = partDir
         set @indRef@(item, part, "file", "sht") = partSht
         set @indRef@(item, part, "file", "ext") = partExt
     }
     // --- RES
 }
 
 quit
]]></Implementation>
</Method>

<Method name="Print2GetOdfCol">
<Internal/>
<FormalSpec>indRef:%Library.String,view:%Library.String,set:%Library.String,colRef:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
    
 N qqoView,qqview s qqview=view
 S qqoView=$S($g(qqview)'[$C(1):"XView",1:$P($g(qqview),$C(1))) S:$g(qqview)[$C(1) qqview=$P($g(qqview),$C(1),2,255) ;Маслова 06.08.2010    
 
 ; массив с параметрами
 n prs
 ; верхний колонтитул
 s prs("head", "num") = 2           ; номер параметра
 s prs("head", "lab") = "H"         ; метка колонтитула
 s prs("head", "xsl") = "NO"        ; вариант xsl
 s prs("head", "view") = ""         ; отображение, по которому формируется xsl колонтитула
 s prs("head", "set") = ""          ; набор параметор печати в виде код_отображения:номер_набора или просто номер_набора
 ; нижний колонтитул
 s prs("foot", "num") = 3           ; номер параметра
 s prs("foot", "lab") = "F"         ; метка колонтитула
 s prs("foot", "xsl") = "NO"        ; вариант xsl
 s prs("foot", "view") = ""         ; отображение, по которому формируется xsl колонтитула
 s prs("foot", "set") = ""          ; набор параметор печати в виде код_отображения:номер_набора или просто номер_набора

 ; для каждого колонтитула проверяем, где находится xsl-текст
 n region, file, xslVarIn
 f region = "head", "foot" d
 .; получаем вариант xsl
 .s xslVarIn = qARM.GetPar("x36" _ prs(region, "num") _ "0", view)
 .s prs(region, "xsl") = ..Print2GetVar("xsl", xslVarIn, "in", "fld")
 .; вариант xsl задан - выходим
 .i prs(region, "xsl") '= "" q
 .
 .; если вариант не определен:
 .; для совместимости со старым вариантом проверяем параметры X362 (X363) и TB362 (TB363) и устанавливаем вариант самостоятельно
 .
 .; получаем значение параметра "отображение колонтитула" (отображение, имя файла, ссылка на текст xsl)
 .; если значение есть, то обрабатываем только в том случае, если это имя файла, устанавливаем вариант xsl - файл
 .s file = qARM.GetPar("X36" _ prs(region, "num"), view)
 .i file '= "" d  q
 ..; если значение является именем файла (странная проверка!) - устанавливаем вариант xsl
 ..i $tr(file, "\/.") '= file s prs(region, "xsl") = "FILE"
 .
 .; если существует TB362 или TB363, то устанавливаем вариант xsl - текст
 .i $d(^Q(1, qqoView, qqview, "XPrint", set, "TB36" _ prs(region, "num"))) s prs(region, "xsl") = "TEXT" q
 .
 .; иначе устананавливаем вариант xsl - отсутствует
 .s prs(region, "xsl") = "NO"

 ; флаг наличия колонтитулов
 n isCol s isCol = 0
 ; если есть хотя бы 1 колонтитул - устанавливаем флаг
 f region = "head", "foot" d  i isCol q
 .i prs(region, "xsl") = "FORM" s isCol = 1
 
 ; если колонтитулы не определены - выходим
 i 'isCol q isCol
 
 s isCol = 0
 
 ; вариант xsl, выходной вариант xsl, путь к xsl-файлу, ссылка на текст xsl, отображения, по которому формируется xsl
 n xslVar, xslVarOut, xslRef, xslView
 ; флаг получения xsl
 n isXsl s isXsl = 0

 f region = "head", "foot" d
 .; вариант xsl
 .s xslVar = prs(region ,"xsl")
 .; если колонтитул не определён выходим
 .i xslVar '= "FORM" q
 .
 .; xsl
 .; выходной вариант xsl
 .s xslVarOut = ..Print2GetVar("xsl", xslVar, "fld", "out")
 .; формируется - здесь получаем только код отображения и набор параметров печати, формирование выполняем отдельно
 .i xslVar = "FORM" d  q
 ..; отображение и набор параметров печати
 ..s xslView = qARM.GetPar("X36" _ prs(region, "num"), view)
 ..i $e(xslView) = "@" s @("xslView = " _ $e(xslView, 2, $l(xslView)))
 ..i xslView = "" q
  
 ..; отображение, по которому формируется xsl колонтитула
 ..s prs(region, "view") = $p(xslView, " ", 1)
 ..s:prs(region,"view")'[$C(1) prs(region, "view")=$s($d(^Q(1,"XView",prs(region, "view") )):prs(region, "view"),1:qUSER.viOrg(prs(region, "view")))
 
 ..; набор параметров печати в виде код_отображения:номер_набора или просто номер_набора
 ..s prs(region, "set") = $p(xslView, " ", 2) 

 ; формирование XML-XSL (пока только XSL)
 f region = "head", "foot" d
 .; вариант xsl
 .s xslVar = prs(region, "xsl")
 .; если не формируется - выходим
 .i xslVar '= "FORM" q
 .
 .; xsl
 .; выходной вариант xsl
 .s xslVarOut = ..Print2GetVar("xsl", xslVar, "fld", "out")
 .s isXsl = 0
 .
 .; формируем xsl, если получили код отображения
 .; формируем xsl, если получили код отображения
 .i prs(region, "view") '= "" d
 ..N qqoViewCol,qqviewCol s qqviewCol=prs(region, "view")
 ..S qqoViewCol=$S($g(qqviewCol)'[$C(1):"XView",1:$P($g(qqviewCol),$C(1))) S:$g(qqviewCol)[$C(1) qqviewCol=$P($g(qqviewCol),$C(1),2,255) ;Маслова 06.08.2010
 ..i '$d(^Q(1,qqoViewCol, qqviewCol)) d  q
 ...d qARM.Message("Отсутствует отображение " _ $s(region = "head": "верхнего", region = "foot": "нижнего", 1:"") _" колонтитула " _  prs(region, "view"))
 ..
 ..s xslRef = $na(@colRef@(region _ "er"))
 ..
 ..; сохраняем состояние отображения
 ..d qARM.SaveView(1, "", prs(region, "view"))
 ..; формируем контекст печати
 ..;;d ..PrintStart($j, xslView_":"_$p(prs(region, "set"), ":", 2) )
 ..; определяем отображение, откуда брать параметры печати
 ..;;s xslView = $s($l(prs(region, "set"), ":") > 1 : $p(prs(region, "set"), ":"), 1 : "")
 ..s xslView = $s($l(prs(region, "set"), ":") > 1 : $p(prs(region, "set"), ":"), 1 : prs(region, "view"))  ;;Маслова 25.08.20010
 ..I xslView '= prs(region, "view") s:xslView'[$C(1) xslView=$s($d(^Q(1,"XView",xslView )):xslView,1:qUSER.viOrg(xslView))
 ..; формируем контекст печати
 ..d ..PrintStart($j, $s(prs(region, "set")="":"",1:   xslView_":"_$p(prs(region, "set"), ":", 2)) )
 ..
 ..; формируем xsl
 ..d ..OOXSL("", "", "xslView", xslRef, region _ "er", colRef)
 ..i '$d(@xslRef) q
 ..s isXsl = 1
 .
 .; если получили xsl
 .i isXsl d
 ..s isCol = 1
 
 q isCol
]]></Implementation>
</Method>

<Method name="Print2GetProcObj">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 new procObj set procObj = "print2xmlproc"
 
 quit procObj
]]></Implementation>
</Method>

<Method name="Print2GetRcvr">
<Description><![CDATA[
Получение и преобразование приёмников<br/>
Параметры:<br/>
valueFrom - преобразуемое значение<br/>
typeFrom - тип, из  которого выполняется преобразование<br/>
typeTo - тип, в  который выполняется преобразование<br/>
Возвращаемое значение:<br/>
преобразованное значение<br/>
"" - если произошла ошибка<br/>]]></Description>
<Internal/>
<FormalSpec>valueFrom:%Library.String,typeFrom:%Library.String,typeTo:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; возвращаемое значение
 n valueTo s valueTo = ""

 ; проверка значений входных параметров
 ; все параметры д.б. заданы
 i $s($g(valueFrom) = "" : 1, $g(typeFrom) = "" : 1, $g(typeTo) = "" : 1, 1 : 0) q valueTo

 ; таблица преобразований приёмников
 n conv
 ; fld -> in
 s conv("fld", "IE", "in") = 0               ; MS Internet Explorer
 s conv("fld", "WORD", "in") = 1             ; MS Word
 s conv("fld", "EXCEL", "in") = 2            ; MS Excel
 s conv("fld", "FILE", "in") = 3             ; файл
 s conv("fld", "-", "in") = 4
 s conv("fld", "XML_EXTERNAL", "in") = 5     ; внешний XML
 s conv("fld", "TXT_TABULATED", "in") = 6    ; текстовый файл с разделителями
 s conv("fld", "TXT_FIXED", "in") = 7        ; текстовый файл с фиксированной шириной полей
 s conv("fld", "EXCEL_TEMPLATE", "in") = 8   ; Excel с шаблоном
 s conv("fld", "DBF", "in") = 9              ; DBF-файл
 s conv("fld", "ODT", "in") = 10             ; Текстовый документ OpenOffice
 s conv("fld", "ODS", "in") = 11             ; Электронная таблица OpenOffice
 ; in -> fld
 s conv("in", 0, "fld") = "IE"               ; MS Internet Explorer
 s conv("in", 1, "fld") = "WORD"             ; MS Word
 s conv("in", 2, "fld") = "EXCEL"            ; MS Excel
 s conv("in", 3, "fld") = "FILE"             ; файл
 s conv("in", 4, "fld") = "-"
 s conv("in", 5, "fld") = "XML_EXTERNAL"     ; внешний XML
 s conv("in", 6, "fld") = "TXT_TABULATED"    ; текстовый файл с разделителями
 s conv("in", 7, "fld") = "TXT_FIXED"        ; текстовый файл с фиксированной шириной полей
 s conv("in", 8, "fld") = "EXCEL_TEMPLATE"   ; Excel с шаблоном
 s conv("in", 9, "fld") = "DBF"              ; DBF-файл
 s conv("in", 10, "fld") = "ODT"             ; Текстовый документ OpenOffice
 s conv("in", 11, "fld") = "ODS"             ; Электронная таблица OpenOffice

 ; если входной тип недопустим - выходим
 i '$d(conv(typeFrom)) q valueTo
 ; если выходной тип недопустим - выходим
 i '$d(conv(typeTo)) q valueTo
 ; если преобразуемое значение недопустимо - выходим
 i '$d(conv(typeFrom, valueFrom)) q valueTo


 ; выполняем преобразование
 d
 .; если типы равны, возвращаем входное значение
 .i typeFrom = typeTo d  q
 ..s valueTo = valueFrom
 .
 .; преобразуем
 .s valueTo = conv(typeFrom, valueFrom, typeTo)

 q valueTo
]]></Implementation>
</Method>

<Method name="Print2GetRef">
<Description><![CDATA[
Метод возвращает ссылку на массив с параметрами печати<br/>]]></Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 n result s result = $na(qqSysPrs("prt"))   
 q result
]]></Implementation>
</Method>

<Method name="Print2GetResAct">
<Description><![CDATA[
Получение и преобразование действия с результатом<br/>
Параметры:<br/>
valueFrom - преобразуемое значение<br/>
typeFrom - тип, из  которого выполняется преобразование<br/>
typeTo - тип, в  который выполняется преобразование<br/>
Возвращаемое значение:<br/>
преобразованное значение<br/>
"" - если произошла ошибка<br/>]]></Description>
<Internal/>
<FormalSpec>valueFrom:%Library.String,typeFrom:%Library.String,typeTo:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; возвращаемое значение
 n valueTo s valueTo = ""

 ; проверка значений входных параметров
 ; все параметры д.б. заданы
 i $s($g(valueFrom) = "" : 1, $g(typeFrom) = "" : 1, $g(typeTo) = "" : 1, 1 : 0) q valueTo

 ; таблица преобразований приёмников
 n conv
 ; fld -> in
 s conv("fld", "CREATE_OPEN", "in") = 0      ; Создавать и открывать в приёмнике
 s conv("fld", "CREATE_PRINT", "in") = 1     ; Создавать и печатать
 s conv("fld", "CREATE", "in") = 2           ; Только создавать
 ; in -> fld
 s conv("in", 0, "fld") = "CREATE_OPEN"      ; Создавать и открывать в приёмнике
 s conv("in", 1, "fld") = "CREATE_PRINT"     ; Создавать и печатать
 s conv("in", 2, "fld") = "CREATE"           ; Только создавать

 ; если входной тип недопустим - выходим
 i '$d(conv(typeFrom)) q valueTo
 ; если выходной тип недопустим - выходим
 i '$d(conv(typeTo)) q valueTo
 ; если преобразуемое значение недопустимо - выходим
 i '$d(conv(typeFrom, valueFrom)) q valueTo

 ; выполняем преобразование
 d
 .; если типы равны, возвращаем входное значение
 .i typeFrom = typeTo d  q
 ..s valueTo = valueFrom
 .
 .; преобразуем
 .s valueTo = conv(typeFrom, valueFrom, typeTo)

 q valueTo
]]></Implementation>
</Method>

<Method name="Print2GetTxt">
<Description><![CDATA[
Получение txt и xls - заполнения глобала печати<br/>
Параметры:<br/>
indRef     - глобал печати<br/>
view       - отображение печати<br/>
set        - номер набора параметров печати<br/>]]></Description>
<Internal/>
<FormalSpec>indRef:%Library.String,view:%Library.String,set:%Library.String,txtVar:%String,xlsVar:%String,resVar:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 
 n qqoView,qqview s qqview=view
 S qqoView=$S($g(qqview)'[$C(1):"XView",1:$P($g(qqview),$C(1))) S:$g(qqview)[$C(1) qqview=$P($g(qqview),$C(1),2,255) ;Маслова 06.08.2010    
 
 ; приёмник
 n rcvr S rcvr = @indRef@("prs", "receiver")
 ; входной вариант приёмника
 n rcvrIn s rcvrIn = ..Print2GetRcvr(rcvr, "fld", "in")

 ; глобал с информацией o результате
 n indResRef s indResRef = $na(@indRef@("body", "res"))
 ; папка результата
 n dir s dir = @indResRef@("file", "dir")
 ; короткое имя результата без расширения
 n sht s sht = @indResRef@("file", "sht")
 ; полное имя результата без расширения
 n fll s fll = dir _ sht

 ; txt
 ; флаг получения txt
 n isTxt s isTxt = 0
 ; выходной вариант txt
 n txtVarOut s txtVarOut = ..Print2GetVar("txt", txtVar, "fld", "out")
 ; путь к txt-файлу, ссылка на текст txt
 n txtPath, txtRef
 ; глобал с информацией o txt
 n indTxtRef s indTxtRef = $na(@indRef@("body", "txt"))

 ; получаем TXT, если
 ; приёмник    - TXT, Excel с шаблоном
 ; вариант TXT - формируется
 n isRcvrForTxt s isRcvrForTxt = (rcvr ?1(1"TXT_TABULATED",1"TXT_FIXED",1"EXCEL_TEMPLATE"))
 n isTxtVarValid s isTxtVarValid = (txtVar = "FORM")
 i isRcvrForTxt, isTxtVarValid d
 .; полный путь к txt-файлу
 .s txtPath = fll_".txt"
 .
 .; формируется
 .i txtVar = "FORM" d  q
 ..; ссылка на глобал, в котором будем формировать текст txt
 ..s txtRef = $na(@indTxtRef@(txtVarOut))
 ..; приёмник для передачи в метод ..XML - если приёмник Excel с шаблоном, заменяем на TXT с разделителями
 ..n rcvrForXml s rcvrForXml = $s(rcvr = "EXCEL_TEMPLATE" : "TXT_TABULATED", 1 : rcvr)
 ..n rcvrInForXml set rcvrInForXml = ..Print2GetRcvr(rcvrForXml, "fld", "in")
 ..; формируем txt
 ..d ..XML( , , , 0, 0, , , , view, rcvrInForXml, txtRef)
 ..i '$d(@txtRef) q
 ..s isTxt = 1

 ; если получили txt - записываем имя файла для всех вариантов txt
 i isTxt d
 .; записываем выходной вариант txt
 .s @indTxtRef = txtVarOut
 .; записываем имя txt-файл
 .s @indTxtRef@("file") = txtPath

 ; шаблон Excel
 ; флаг получения txt
 n isXls s isXls = 0
 ; выходной вариант xls
 n xlsVarOut s xlsVarOut = ..Print2GetVar("xls", xlsVar, "fld", "out")
 ; путь к xls-файлу, ссылка на текст xls
 n xlsPath, xlsRef
 ; глобал с информацией o xls
 n indXlsRef s indXlsRef = $na(@indRef@("body", "xls"))

 ; получаем XLS, если
 ; приёмник    - Excel с шаблоном
 ; вариант XLS - текст
 n isRcvrForXls s isRcvrForXls = (rcvr = "EXCEL_TEMPLATE")
 n isXlsVarValid s isXlsVarValid = (xlsVar = "TEXT")
 i isRcvrForXls, isXlsVarValid d
 .; полный путь к xls-файлу
 .s xlsPath = fll _ ".xls"
 .
 .; ссылка на текст
 .i xlsVar = "TEXT" d  q
 ..; ссылка на глобал, в котором хранится текст шаблона Excel
 ..s xlsRef = $na(^Q(1, qqoView, qqview, "XPrint", set, "YEx"))
 ..i '$d(@xlsRef) q
 ..s @indXlsRef@(xlsVarOut) = xslRef
 ..s isXls = 1

 ; если получили xls
 i isXls d
 .; записываем выходной вариант xls
 .s @indXlsRef = xlsVarOut
 .; записываем имя xls-файл
 .s @indXlsRef@("file") = xlsPath

 ; res
 ; флаг получения результата
 n isRes s isRes = 0
 ; выходной вариант результата
 n resVarOut s resVarOut = ..Print2GetVar("res", resVar, "fld", "out")
 ; короткое имя файла результата
 n resSht
 ; глобал с информацией o результате - определили в начале метода
 ; indResRef

 ; записываем имя файла результата, если
 ; приёмник    - Excel с шаблоном
 ; вариант результата - файл
 ; есть TXT
 ; есть XLS
 n isRcvrForRes s isRcvrForRes = (rcvr = "EXCEL_TEMPLATE")
 n isResVarValid s isResVarValid = (resVar = "FILE")
 i isRcvrForRes, isResVarValid, isTxt, isXls d
 .; файл
 .i resVar = "FILE" d  q
 ..; короткое имя файла результата
 ..s resSht = sht _ ".xls"
 ..s isRes = 1

 ; если получили результат
 i isRes d
 .; записываем выходной вариант результата
 .s @indResRef = resVarOut
 .; записываем короткое имя файла результата
 .s @indResRef@("file") = resSht

 q
]]></Implementation>
</Method>

<Method name="Print2GetVar">
<Description><![CDATA[
Получение и преобразование вариантов содержимого<br/>
Параметры:<br/>
content   - тип содержимого<br/>
valueFrom - преобразуемое значение<br/>
typeFrom - тип, из  которого выполняется преобразование<br/>
typeTo - тип, в  который выполняется преобразование<br/>
Возвращаемое значение:<br/>
преобразованное значение<br/>
"" - если произошла ошибка<br/>]]></Description>
<Internal/>
<FormalSpec>content:%Library.String,valueFrom:%Library.String,typeFrom:%Library.String,typeTo:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; возвращаемое значение
 n valueTo s valueTo = ""

 ; проверка значений входных параметров
 ; все параметры д.б. заданы
 i $s($g(content) = "" : 1, $g(valueFrom) = "" : 1, $g(typeFrom) = "" : 1, $g(typeTo) = "" : 1, 1 : 0) q valueTo

 ; общая проверка
 ; допустимые типы содержимого
 ;i content '?1(1"xml",1"xsl",1"txt",1"xls",1"res",1"pic") q valueTo
 ; допустимые входные типы
 i typeFrom '?1(1"fld",1"out",1"in") q valueTo
 ; допустимые выходные типы
 i typeTo '?1(1"fld",1"out",1"in") q valueTo

 ; допустимые значение входных параметров (допустимые преобразования)
 n valid   ; valid(content, typeFrom, valueFrom)
 ; xsl
 s valid("xsl", "fld", "FORM") = ""
 s valid("xsl", "fld", "NO") = ""
 s valid("xsl", "fld", "FILE") = ""
 s valid("xsl", "fld", "TEXT") = ""
 s valid("xsl", "fld", "REF") = ""
 s valid("xsl", "in", 0) = ""
 s valid("xsl", "in", 1) = ""
 s valid("xsl", "in", 2) = ""
 s valid("xsl", "in", 3) = ""
 s valid("xsl", "in", 4) = ""
 s valid("xsl", "out", "form") = ""
 s valid("xsl", "out", "file") = ""
 s valid("xsl", "out", "ref") = ""
 ; xml
 s valid("xml", "fld", "FORM") = ""
 s valid("xml", "fld", "FILE") = ""
 s valid("xml", "fld", "REF") = ""
 s valid("xml", "out", "form") = ""
 s valid("xml", "out", "file") = ""
 s valid("xml", "out", "ref") = ""
 ; res
 s valid("res", "fld", "FILE") = ""
 s valid("res", "out", "file") = ""
 ; txt
 s valid("txt", "fld", "FORM") = ""
 s valid("txt", "fld", "FILE") = ""
 s valid("txt", "fld", "REF") = ""
 s valid("txt", "out", "form") = ""
 s valid("txt", "out", "file") = ""
 s valid("txt", "out", "ref") = ""
 ; xls
 s valid("xls", "fld", "FILE") = ""
 s valid("xls", "fld", "TEXT") = ""
 s valid("xls", "fld", "REF") = ""
 s valid("xls", "out", "form") = ""
 s valid("xls", "out", "ref") = ""
 ; pic
 s valid("pic", "fld", "FORM") = ""
 s valid("pic", "fld", "REF") = ""
 s valid("pic", "out", "form") = ""
 s valid("pic", "out", "ref") = ""
 ; dbf
 s valid("dbf", "fld", "FORM") = ""
 s valid("dbf", "fld", "FILE") = ""
 s valid("dbf", "fld", "REF") = ""
 s valid("dbf", "out", "form") = ""
 s valid("dbf", "out", "file") = ""
 s valid("dbf", "out", "ref") = ""

 ; если содержимое недопустимо - выходим
 i '$d(valid(content)) q valueTo
 ; если входной тип недопустим - выходим
 i '$d(valid(content, typeFrom)) q valueTo
 ; если выходной тип недопустим - выходим
 i '$d(valid(content, typeTo)) q valueTo
 ; если преобразуемое значение недопустимо - выходим
 i '$d(valid(content, typeFrom, valueFrom)) q valueTo

 ; таблица преобразований вариантов содержимого
 n conv
 ; fld -> in, out
 s conv("fld", "FORM", "in") = 0             ; формируется
 s conv("fld", "FORM", "out") = "form"       ; 
 s conv("fld", "NO", "in") = 1               ; отсутствует
 s conv("fld", "NO", "out") = ""             ; 
 s conv("fld", "FILE", "in") = 2             ; файл
 s conv("fld", "FILE", "out") = "file"       ; 
 s conv("fld", "TEXT", "in") = 3             ; текст
 s conv("fld", "TEXT", "out") = "ref"        ;
 s conv("fld", "REF", "in") = 4              ; ссылка на глобал
 s conv("fld", "REF", "out") = "ref"         ;
 ; in -> fld
 s conv("in", 0, "fld") = "FORM"
 s conv("in", 1, "fld") = "NO"
 s conv("in", 2, "fld") = "FILE"
 s conv("in", 3, "fld") = "TEXT"
 s conv("in", 4, "fld") = "REF"
 ; out -> fld
 s conv("out", "form", "fld") = "FORM"
 s conv("out", "file", "fld") = "FILE"
 s conv("out", "ref", "fld") = "REF"

 ; выполняем преобразование
 d
 .; если типы равны, возвращаем входное значение
 .i typeFrom = typeTo d  q
 ..s valueTo = valueFrom
 .
 .; из in в out или из out в in - сначала преобразуем в fld
 .i typeFrom '= "fld", typeTo '= "fld" d
 ..s valueFrom = conv(typeFrom, valueFrom, "fld")
 ..s typeFrom = "fld"
 .
 .; преобразуем
 .s valueTo = conv(typeFrom, valueFrom, typeTo)

 q valueTo
]]></Implementation>
</Method>

<Method name="Print2GetXxl">
<Description><![CDATA[
Получение xml и xsl - заполнения глобала печати<br/>
Параметры:<br/>
indRef     - глобал печати<br/>
view       - отображение печати<br/>
set        - номер набора параметров печати<br/>
xslVar     - вариант xsl<br/>]]></Description>
<Internal/>
<FormalSpec>indRef:%Library.String,view:%Library.String,set:%Library.String,xslVar:%Library.String,xmlVar:%String,picVar:%String,resVar:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 ; приёмник
 n rcvr s rcvr = @indRef@("prs", "receiver")
 ; входной варианта приёмника
 n rcvrIn s rcvrIn = ..Print2GetRcvr(rcvr, "fld", "in")
 
 ; отступ сверху
 n spaceBefore s spaceBefore = @indRef@("prs", "spaceBefore")

 ; глобал с информацией o результате
 n indResRef s indResRef = $na(@indRef@("body", "res"))
 ; папка результата
 n dir s dir = @indResRef@("file", "dir")
 ; короткое имя результата без расширения
 n sht s sht = @indResRef@("file", "sht")
 ; полное имя результата без расширения
 n fll s fll = dir _ sht
 
 ; xsl
 ; выходной вариант xsl
 n xslVarOut s xslVarOut = ..Print2GetVar("xsl", xslVar, "fld", "out")
 ; путь к xsl-файлу, ссылка на текст xsl
 n xslPath, xslRef
 ; глобал с информацией o xsl
 n indXslRef s indXslRef = $na(@indRef@("body", "xsl"))
 ; флаг получения xsl
 n isXsl s isXsl = 0

 ; получаем XSL, если
 ; приёмник    - IE, Word, Excel, файл
 ; вариант XSL - формируется, файл, хранимый текст, ссылка на текст
 n isRcvrForXsl s isRcvrForXsl = (rcvr ?1(1"IE",1"WORD",1"EXCEL",1"FILE"))
 n isXslVarValid s isXslVarValid = (xslVar ?1(1"FORM",1"FILE",1"TEXT",1"REF"))
 
 i isRcvrForXsl, isXslVarValid d
 .; файл
 .i xslVar = "FILE" d  q
 ..; полный путь к xsl-файлу
 ..s xslPath = qARM.GetPar("X365", view)
 ..i $e(xslPath) = "@" s @("xslPath = " _ $e(xslPath, 2, $l(xslPath)))
 ..i xslPath = "" q
 ..s xslPath = ..XslPath(xslPath)
 ..s isXsl = 1
 .
 .; полный путь к xsl-файлу
 .s xslPath = fll_".xsl"
 .
 .; формируется
 .i xslVar = "FORM" d  q
 ..; ссылка на глобал, в котором будем формировать текст xsl
 ..s xslRef = $na(@indXslRef@(xslVarOut))
 ..; формируем xsl
 ..D ..XSL(, , , , rcvrIn, , view, "windows-1251", xslRef, spaceBefore)
 ..i '$d(@xslRef) q
 ..s isXsl = 1
 .
 .N qqoView,qqview s qqview=view
 .S qqoView=$S($g(qqview)'[$C(1):"XView",1:$P($g(qqview),$C(1))) S:$g(qqview)[$C(1) qqview=$P($g(qqview),$C(1),2,255) ;Маслова 06.08.2010   
 .; хранимый текст
 .i xslVar = "TEXT" d  q
 ..; ссылка на глобал, в котором хранится текст xsl
 ..s xslRef = $na(^Q(1, qqoView, qqview, "XPrint", set, "TB323"))
 ..i '$d(@xslRef) q
 ..; записываем ссылку на глобал
 ..s @indXslRef@(xslVarOut) = xslRef
 ..s isXsl = 1
 .
 .; ссылка на текст
 .i xslVar = "REF" d  q
 ..; ссылка на глобал
 ..s xslRef = qARM.GetPar("X365", view)
 ..i $e(xslRef) = "@" s @("xslRef = "_$e(xslRef, 2, $l(xslRef)))
 ..i xslRef = "" q
 ..i '$d(@xslRef) q
 ..; записываем ссылку на глобал
 ..s @indXslRef@(xslVarOut) = xslRef
 ..s isXsl = 1

 ; если получили xsl
 i isXsl d
 .; записываем выходной вариант xsl
 .s @indXslRef = xslVarOut
 .; записываем имя xsl-файла
 .s @indXslRef@("file") = xslPath

 ; xml
 ; выходной вариант xml
 n xmlVarOut s xmlVarOut = ..Print2GetVar("xml", xmlVar, "fld", "out")
 ; путь к xml-файлу, ссылка на текст xml
 n xmlPath, xmlRef
 ; глобал с информацией o xml
 n indXmlRef s indXmlRef = $na(@indRef@("body", "xml"))
 ; флаг получения xml
 n isXml s isXml = 0

 ; pic
 ; выходной вариант картинок
 n picVarOut s picVarOut = ..Print2GetVar("pic", picVar, "fld", "out")
 ; ссылка на глобал картинок
 n picRef
 ; флаг наличия картинок
 n isPic s isPic = 0

 ; получаем XML, если
 ; приёмник    - IE, Word, Excel, файл, внешний XML
 ; вариант XML - формируется
 n isRcvrForXml s isRcvrForXml = (rcvr ?1(1"IE",1"WORD",1"EXCEL",1"FILE",1"XML_EXTERNAL"))
 n isXmlVarValid s isXmlVarValid = (xmlVar ?1(1"FORM",1"REF"))
 
 i isRcvrForXml, isXmlVarValid d
 .; полный путь к xml-файлу
 .s xmlPath = fll_".xml"
 .
 .; формируется
 .i xmlVar = "FORM" d  q
 ..; ссылка на глобал, в котором будем формировать текст xml
 ..s xmlRef = $na(@indXmlRef@(xmlVarOut))
 ..; ссылка на глобал, в котором будем формировать картинки
 ..s picRef = $na(@indRef@("pic"))
 ..; вставлять в xml ссылку на xsl
 ..n isXslPath s isXslPath = 1
 ..d
 ...; явно не вставлять, если вариант xsl - файл и не получили имя файла
 ...i xslVar = "FILE", xslPath = "" s isXslPath = 0 q
 ...; явно не вставлять , если вариант xsl отсутствует
 ...i xslVar = "NO" s isXslPath = 0
 ..
 ..; формируем xml и картинки
 ..d ..XML( , , , isXslPath, 0, , , , view, rcvrIn, xmlRef, picRef, sht)
 ..i '$d(@xmlRef) q
 ..s isXml = 1
 ..
 ..i picVar = "FORM" d
 ...i '$d(@picRef@(picVarOut)) q
 ...s isPic = 1
 .
 .; ссылка на текст
 .i xmlVar = "REF" d  q
 ..; ссылка на глобал
 ..s xmlRef = $name($$$tmpGl($get(qqdev) + 2, $job)) ; 15.12.2008 Kokarev
 ..i xmlRef = "" q
 ..i '$d(@xmlRef) q
 ..; записываем ссылку на глобал
 ..s @indXmlRef@(xmlVarOut) = xmlRef
 ..s isXml = 1

 ; если получили xml
 i isXml d
 .; записываем выходной вариант xml
 .s @indXmlRef = xmlVarOut
 .; записываем имя xml-файл
 .s @indXmlRef@("file") = xmlPath

 ; если получили картинки
 i isPic d
 .; записываем вариант картинок
 .s @picRef = picVarOut


 ; флаг наличия колонтитулов
 n isCol s isCol=0
 ; для Word обрабатываем колонтитулы
 i rcvr = "WORD" s isCol = ..Print2GetXxlCol(indRef, view, set)

 ; res
 ; выходной вариант результата
 n resVarOut s resVarOut = ..Print2GetVar("res", resVar, "fld", "out")
 ; короткое имя файла результата
 n resSht
 ; флаг получения результата
 n isRes s isRes = 0

 ; флаг - формировать MIME
 n isMIME s isMIME = @indRef@("prs", "mime")
 ; явно не формируем MIME, если флаг установлен, но нет ни картинок, ни колонтитулов
 i isMIME, 'isPic, 'isCol s isMIME = 0

 ; записываем имя файла результата, если
 ; приёмник    - IE, Word, Excel
 ; вариант результата - файл
 ; есть XML
 ; есть XSL
 n isRcvrForRes s isRcvrForRes = (rcvr ?1(1"IE",1"WORD",1"EXCEL"))
 n isResVarValid s isResVarValid = (resVar = "FILE")
 i isRcvrForRes, isResVarValid, isXml, isXsl d
 .; файл
 .i resVar = "FILE" d  q
 ..; определяем расширение результата
 ..n ext s ext = $s(rcvr = "IE" : $s(isMIME = 1 : "mht", 1 : "html"), rcvr = "WORD" : "doc" , rcvr = "EXCEL" : "xls")
 ..; короткое имя файла результата
 ..s resSht = sht_"."_ext
 ..s isRes = 1

 ; если получили результат
 i isRes d
 .; записываем выходной вариант результата
 .s @indResRef = resVarOut
 .; записываем короткое имя файла результата
 .s @indResRef@("file") = resSht

 ; явно не формируем MIME, если не получили результат
 i isMIME, 'isRes s isMIME = 0
 ; записываем значение MIME
 s @indRef@("prs", "mime") = isMIME
 q
]]></Implementation>
</Method>

<Method name="Print2GetXxlCol">
<Description><![CDATA[
Получение xml и xsl колонтитулов - заполнения глобала печати<br/>
Параметры:<br/>
indRef - глобал печати<br/>
view   - код отображения, из которого нужно взять параметры колонтитулов<br/>
set    - номер набора параметров печати<br/>
Возвращаемое значение:
1 - если удалось получить хотя бы 1 колонтитул<br/>
0 - если не удалось получить колонтитулы<br/>]]></Description>
<Internal/>
<FormalSpec>indRef:%Library.String,view:%Library.String,set:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 
 N qqoView,qqview s qqview=view
 S qqoView=$S($g(qqview)'[$C(1):"XView",1:$P($g(qqview),$C(1))) S:$g(qqview)[$C(1) qqview=$P($g(qqview),$C(1),2,255) ;Маслова 06.08.2010    
 
 ; массив с параметрами
 n prs
 ; верхний колонтитул
 s prs("head", "num") = 2           ; номер параметра
 s prs("head", "lab") = "H"         ; метка колонтитула
 s prs("head", "xsl") = "NO"        ; вариант xsl
 s prs("head", "view") = ""         ; отображение, по которому формируется xsl колонтитула
 s prs("head", "set") = ""          ; набор параметор печати в виде код_отображения:номер_набора или просто номер_набора
 ; нижний колонтитул
 s prs("foot", "num") = 3           ; номер параметра
 s prs("foot", "lab") = "F"         ; метка колонтитула
 s prs("foot", "xsl") = "NO"        ; вариант xsl
 s prs("foot", "view") = ""         ; отображение, по которому формируется xsl колонтитула
 s prs("foot", "set") = ""          ; набор параметор печати в виде код_отображения:номер_набора или просто номер_набора

 ; для каждого колонтитула проверяем, где находится xsl-текст
 n region, file, xslVarIn
 f region = "head", "foot" d
 .; получаем вариант xsl
 .s xslVarIn = qARM.GetPar("x36" _ prs(region, "num") _ "0", view)
 .s prs(region, "xsl") = ..Print2GetVar("xsl", xslVarIn, "in", "fld")
 .; вариант xsl задан - выходим
 .i prs(region, "xsl") '= "" q
 .
 .; если вариант не определен:
 .; для совместимости со старым вариантом проверяем параметры X362 (X363) и TB362 (TB363) и устанавливаем вариант самостоятельно
 .
 .; получаем значение параметра "отображение колонтитула" (отображение, имя файла, ссылка на текст xsl)
 .; если значение есть, то обрабатываем только в том случае, если это имя файла, устанавливаем вариант xsl - файл
 .s file = qARM.GetPar("X36" _ prs(region, "num"), view)
 .i file '= "" d  q
 ..; если значение является именем файла (странная проверка!) - устанавливаем вариант xsl
 ..i $tr(file, "\/.") '= file s prs(region, "xsl") = "FILE"
 .
 .; если существует TB362 или TB363, то устанавливаем вариант xsl - текст
 .i $d(^Q(1, qqoView, qqview, "XPrint", set, "TB36" _ prs(region, "num"))) s prs(region, "xsl") = "TEXT" q
 .
 .; иначе устананавливаем вариант xsl - отсутствует
 .s prs(region, "xsl") = "NO"

 ; флаг наличия колонтитулов
 n isCol s isCol = 0
 ; если есть хотя бы 1 колонтитул - устанавливаем флаг
 f region = "head", "foot" d  i isCol q
 .i prs(region, "xsl") '= "NO" s isCol = 1

 ; если колонтитулы не определены - выходим
 i 'isCol q isCol

 ; глобал с информацией o результате
 n indResRef s indResRef = $na(@indRef@("body", "res"))
 ; папка результата
 n dir s dir = @indResRef@("file", "dir")
 ; короткое имя результата без расширения
 n sht s sht = @indResRef@("file", "sht")
 s sht = sht _ "_header"
 ; полное имя результата без расширения
 N fll s fll = dir _ sht

 ; выходной вариант xml, путь к xml-файлу, ссылка на текст xml
 n xmlVarOut, xmlPath, xmlRef
 ; глобал с информацией o xml из основного раздела
 n indXmlRef s indXmlRef = $na(@indRef@("body", "xml"))
 ; глобал с информацией o xml из колонтитула
 n indRegXmlRef
 ; флаг получения xml
 n isXml s isXml = 0

 ; вариант xsl, выходной вариант xsl, путь к xsl-файлу, ссылка на текст xsl, отображения, по которому формируется xsl
 n xslVar, xslVarOut, xslPath, xslRef, xslView
 ; глобал с информацией o xsl из колонтитула
 n indRegXslRef
 ; флаг определяет, является ли вариант xsl допустимым
 n isXslVarValid s isXslVarValid = 0
 ; флаг получения xsl
 n isXsl s isXsl = 0

 ; вариант результата - только файл
 n resVar s resVar = "FILE"
 ; выходной вариант результата
 n resVarOut s resVarOut = ..Print2GetVar("res", resVar, "fld", "out")
 ; короткое имя результата
 n resSht
 ; глобал с информацией o результате из колонтитула
 n indRegResRef
 ; флаг определяет, является ли вариант результата допустимым
 n isResVarValid s isResVarValid = 0
 ; флаг получения результата
 n isRes s isRes = 0

 f region = "head", "foot" d
 .; вариант xsl
 .s xslVar = prs(region ,"xsl")
 .; если колонтитул не определён выходим
 .i xslVar = "NO" q
 .
 .; xml - берём из основной области (body)
 .s isXml = 0
 .; глобал с информацией o xml из колонтитула
 .s indRegXmlRef = $na(@indRef@(region, "xml"))
 .
 .; получаем выходной вариант xml основной области (body)
 .s xmlVarOut = $g(@indXmlRef)
 .i xmlVarOut '= "" d
 ..; формируется - устанавливаем как ссылка на текст (form --> ref)
 ..i xmlVarOut = "form" d  q
 ...; ссылка на глобал, в котором хранится текст xml
 ...s xmlRef = $na(@indXmlRef@(xmlVarOut))
 ...; меняем вариант xml
 ...s xmlVarOut = "ref"
 ...; записываем ссылку на глобал
 ...s @indRegXmlRef@(xmlVarOut) = xmlRef
 ...s isXml = 1
 ..
 ..; ccылка на текст
 ..I xmlVarOut = "ref" d  q
 ...; ссылка на глобал, в котором хранится текст xml
 ...s xmlRef = @indXmlRef@(xmlVarOut)
 ...; записываем ссылку на глобал
 ...s @indRegXmlRef@(xmlVarOut) = xmlRef
 ...s isXml = 1
 ..
 ..; файл
 ..I xmlVarOut = "file" d  q
 ...; имя файла xml
 ...s xmlPath = @indXmlRef@(xmlVarOut)
 ...; записываем имя файла
 ...s @indRegXmlRef@(xmlVarOut) = xmlPath
 ...s isXml = 1
 .
 .; если получили xml
 .i isXml d
 ..; записываем выходной вариант xml
 ..s @indRegXmlRef = xmlVarOut
 .
 .; xsl
 .; выходной вариант xsl
 .s xslVarOut = ..Print2GetVar("xsl", xslVar, "fld", "out")
 .s isXsl = 0
 .; глобал с информацией o xsl из колонтитула
 .s indRegXslRef = $na(@indRef@(region, "xsl"))
 .
 .; вариант XSL - формируется, файл, хранимый текст, ссылка на текст
 .s isXslVarValid = (xslVar ?1(1"FORM",1"FILE",1"TEXT",1"REF"))
 .i isXslVarValid d
 ..; файл
 ..i xslVar = "FILE" d  q
 ...; полный путь к xsl-файлу
 ...s xslPath = qARM.GetPar("X36"_prs(region, "num"), view)
 ...i $e(xslPath) = "@" s @("xslPath = " _ $e(xslPath, 2, $l(xslPath)))
 ...i xslPath = "" q
 ...s xslPath = ..XslPath(xslPath)
 ...s isXsl = 1
 ..
 ..; полный путь к xsl-файлу
 ..s xslPath = fll _ prs(region, "lab") _ ".xsl"
 ..
 ..; формируется - здесь получаем только код отображения и набор параметров печати, формирование выполняем отдельно
 ..i xslVar = "FORM" d  q
 ...; отображение и набор параметров печати
 ...s xslView = qARM.GetPar("X36" _ prs(region, "num"), view)
 ...i $e(xslView) = "@" s @("xslView = " _ $e(xslView, 2, $l(xslView)))
 ...i xslView = "" q
 ...; отображение, по которому формируется xsl колонтитула
 ...s prs(region, "view") = $p(xslView, " ", 1)
 ...s:prs(region,"view")'[$C(1) prs(region, "view")=$s($d(^Q(1,"XView",prs(region, "view") )):prs(region, "view"),1:qUSER.viOrg(prs(region, "view")))
 ...; набор параметров печати в виде код_отображения:номер_набора или просто номер_набора
 ...s prs(region, "set") = $p(xslView, " ", 2)
 ..
 ..; хранимый текст
 ..I xslVar = "TEXT" d  q
 ...; ссылка на глобал, в котором хранится текст xsl
 ...s xslRef = $na(^Q(1, qqoView, qqview, "XPrint", set, "TB36" _ prs(region, "num")))
 ...i '$d(@xslRef) q
 ...; записываем ссылку на глобал
 ...s @indRegXslRef@(xslVarOut) = xslRef
 ...s isXsl = 1
 ..
 ..; ссылка на текст
 ..i xslVar = "REF" d  q
 ...; ссылка на глобал
 ...s xslRef = qARM.GetPar("X36" _ prs(region, "num"), view)
 ...i $e(xslRef) = "@" s @("xslRef = " _ $e(xslRef, 2, $l(xslRef)))
 ...i xslRef = "" q
 ...i '$D(@xslRef) q
 ...; записываем ссылку на глобал
 ...s @indRegXslRef@(xslVarOut) = xslRef
 ...s isXsl = 1
 .
 .; если получили xsl
 .i isXsl d
 ..; записываем выходной вариант xsl
 ..s @indRegXslRef = xslVarOut
 ..; записываем имя xsl-файл
 ..s @indRegXslRef@("file") = xslPath
 .
 .; res
 .s isRes = 0
 .; глобал с информацией o результате из колонтитула
 .s indRegResRef = $na(@indRef@(region, "res"))
 .
 .; записываем имя файла результата, если
 .; вариант результата - файл
 .; есть XML
 .; есть XSL
 .s isResVarValid = (resVar = "FILE")
 .i isResVarValid, isXml, isXsl d
 ..; файл
 ..i resVar = "FILE" d  q
 ...; короткое имя результата
 ...s resSht = sht _ prs(region, "lab") _ ".doc"
 ...s isRes = 1
 .
 .; если получили результат
 .i isRes d
 ..; записываем выходной вариант результата
 ..s @indRegResRef = resVarOut
 ..; записываем короткое имя файла результата
 ..s @indRegResRef@("file") = resSht
 ..; устанавливаем флаг, что получили колонтитул
 ..s isCol = 1


 ; формирование XML-XSL (пока только XSL)
 f region = "head", "foot" d
 .; вариант xsl
 .s xslVar = prs(region, "xsl")
 .; если не формируется - выходим
 .i xslVar '= "FORM" q
 .
 .; xml
 .s isXml = 0
 .; глобал с информацией o xml из колонтитула
 .s indRegXmlRef = $na(@indRef@(region, "xml"))
 .; если получили xml - устанавливаем флаг
 .i $g(@indRegXmlRef) '= "" s isXml = 1
 .
 .; xsl
 .; выходной вариант xsl
 .s xslVarOut = ..Print2GetVar("xsl", xslVar, "fld", "out")
 .s isXsl = 0
 .; глобал с информацией o xsl из колонтитула
 .s indRegXslRef = $na(@indRef@(region, "xsl"))
 .
 .; формируем xsl, если получили код отображения
 .i prs(region, "view") '= "" d
 ..N qqoViewCol,qqviewCol s qqviewCol=prs(region, "view")
 ..S qqoViewCol=$S($g(qqviewCol)'[$C(1):"XView",1:$P($g(qqviewCol),$C(1))) S:$g(qqviewCol)[$C(1) qqviewCol=$P($g(qqviewCol),$C(1),2,255) ;Маслова 06.08.2010
 ..i '$d(^Q(1,qqoViewCol, qqviewCol)) d  q
 ...d qARM.Message("Отсутствует отображение " _ $s(region = "head": "верхнего", region = "foot": "нижнего", 1:"") _" колонтитула " _  prs(region, "view"))
 ..
 ..; полный путь к xsl-файлу
 ..s xslPath = fll _ prs(region, "lab") _ ".xsl"
 ..; ссылка на глобал, в котором будем формировать текст xsl
 ..s xslRef = $na(@indRegXslRef@(xslVarOut))
 ..
 ..; сохраняем состояние отображения
 ..d qARM.SaveView(1, "", prs(region, "view"))
 ..; формируем контекст печати
 ..;;d ..PrintStart($j, xslView_":"_$p(prs(region, "set"), ":", 2) )
 ..; определяем отображение, откуда брать параметры печати
 ..;;s xslView = $s($l(prs(region, "set"), ":") > 1 : $p(prs(region, "set"), ":"), 1 : "")
 ..s xslView = $s($l(prs(region, "set"), ":") > 1 : $p(prs(region, "set"), ":"), 1 : prs(region, "view"))  ;;Маслова 25.08.20010
 ..I xslView '= prs(region, "view") s:xslView'[$C(1) xslView=$s($d(^Q(1,"XView",xslView )):xslView,1:qUSER.viOrg(xslView))
 ..; формируем контекст печати
 ..d ..PrintStart($j, $s(prs(region, "set")="":"",1:   xslView_":"_$p(prs(region, "set"), ":", 2)) )
 ..
 ..; формируем xsl
 ..d ..XSL(, , , , "col" _ prs(region, "lab"), , xslView, "windows-1251", xslRef)
 ..i '$d(@xslRef) q
 ..s isXsl = 1
 .
 .; если получили xsl
 .i isXsl d
 ..; записываем выходной вариант xsl
 ..s @indRegXslRef = xslVarOut
 ..; записываем имя xsl-файла
 ..s @indRegXslRef@("file") = xslPath
 .
 .; res
 .s isRes = 0
 .; глобал с информацией o результате из колонтитула
 .s indRegResRef = $na(@indRef@(region, "res"))
 .
 .; записываем имя файла результата, если
 .; вариант результата - файл
 .; есть XML
 .; есть XSL
 .s isResVarValid = (resVar = "FILE")
 .i isResVarValid, isXml, isXsl d
 ..; файл
 ..i resVar = "FILE" d  q
 ...; короткое имя результата
 ...s resSht = sht _ prs(region, "lab") _ ".doc"
 ...s isRes = 1
 .
 .; если получили результат
 .i isRes d
 ..; записываем выходной вариант результата
 ..s @indRegResRef = resVarOut
 ..; записываем короткое имя файла результата
 ..s @indRegResRef@("file") = resSht
 ..; устанавливаем флаг, что получили колонтитул
 ..s isCol = 1

 q isCol
]]></Implementation>
</Method>

<Method name="Print2HTMLMergeCreate">
<Internal/>
<FormalSpec>mergeObj:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 i $g(mergeObj) = "" q
    
 ; класс
 n mergeCls s mergeCls = "THTMLMerge"
 
 ; флаг наличия объекта
 n isMergeObj s isMergeObj = ..Print2GetGlbObj(mergeCls, mergeObj)
 ; если объекта нет
 i 'isMergeObj d
 .; создаём
 .d qARM.wC(mergeCls, mergeObj)
 .; устанавливаем флаг, что объект существует
 .d ..Print2SetGlbObj(mergeCls, mergeObj, 1)

 q
]]></Implementation>
</Method>

<Method name="Print2HTMLMergeDestroy">
<Internal/>
<FormalSpec>mergeObj:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    
 i $g(mergeObj) = "" q

 ; класс
 n mergeCls s mergeCls = "THTMLMerge"

 ; флаг наличия объекта
 n isMergeObj s isMergeObj = ..Print2GetGlbObj(mergeCls, mergeObj)
 ; если объект уже есть  - удаляем его
 i isMergeObj d
 .; удаляем
 .d qARM.wM(mergeObj, "Destroy")
 .; устанавливаем флаг, что объекта не существует
 .d ..Print2SetGlbObj(mergeCls, mergeObj, 0)
 
 q
]]></Implementation>
</Method>

<Method name="Print2Mes">
<Description><![CDATA[
Вывод сообщения об успешности создания файлов<br/>
Параметры:<br/>
indRef - глобал печати<br/>]]></Description>
<Internal/>
<FormalSpec>indRef:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; приёмник печатной формы
 n rcvr s rcvr = @indRef@("prs", "receiver")

 ; сообщения
 n mes
 s mes("error") = "Не удалось сформировать файлы"
 s mes("success") = ""

 ; вывод сообщения об успехе
 ; если приёмник - файл, внешний XML, TXT
 n isRcvrValid s isRcvrValid = (rcvr?1(1"FILE",1"XML_EXTERNAL",1"TXT_TABULATED",1"TXT_FIXED",1"DBF"))
 i isRcvrValid d 
 .; если приёмник - файл, внешний XML
 .i rcvr?1(1"FILE",1"XML_EXTERNAL") d  q
 ..; глобал с информацией о xml
 ..n indXmlRef s indXmlRef = $na(@indRef@("body","xml"))
 ..; получаем вариант xml
 ..n xmlVar s xmlVar = $g(indXmlRef)
 ..i xmlVar '= "" d
 ...; полное имя xml-файла
 ...n xmlPath s xmlPath = @indXmlRef@("file")
 ...; формируем сообщение
 ...s mes("success") = xmlPath
 ..
 ..; если приёмник - файл
 ..i rcvr = "FILE" d
 ...; глобал с информацией о xsl
 ...n indXslRef s indXslRef = $na(@indRef@("body","xsl"))
 ...; получаем вариант xsl
 ...n xslVar s xslVar = $g(indXslRef)
 ...i xslVar '= "" d
 ....; полное имя xsl-файла
 ....n xslPath s xslPath = @indXslRef@("file")
 ....; формируем сообщение
 ....s mes("success") = mes("success")_$s(mes("success") = "" : "", 1: " и ")_xslPath
 .
 .; если приёмник - TXT
 .i rcvr ?1(1"TXT_TABULATED",1"TXT_FIXED") d  q
 ..; глобал с информацией о txt
 ..n indTxtRef s indTxtRef = $na(@indRef@("body","txt"))
 ..; получаем вариант txt
 ..n txtVar s txtVar = $g(indTxtRef)
 ..i txtVar '= "" d
 ...; получаем имя txt-файл
 ...n txtPath s txtPath = @indTxtRef@("file")
 ...; формируем сообщение
 ...s mes("success") = txtPath
 .
 .; если приёмник - DBF
 .i rcvr ?1(1"DBF") d  q
 ..; глобал с информацией о dbf
 ..n indDbfRef s indDbfRef = $na(@indRef@("body","dbf"))
 ..; получаем вариант dbf
 ..n dbfVar s dbfVar = $g(indDbfRef)
 ..i dbfVar '= "" d
 ...; получаем имя dbf-файл
 ...n dbfPath s dbfPath = @indDbfRef@("file")
 ...; формируем сообщение
 ...s mes("success") = dbfPath

 ; формируем сообщение
 i mes("success") '= "" s mes("success") = "Cформирован(ы) " _ mes("success")
 ; выводим сообщение
 d qARM.Message($s(mes("success") '= "" : mes("success"), 1 : mes("error")))    

 q
]]></Implementation>
</Method>

<Method name="Print2Open">
<Description><![CDATA[
Открытие файла<br/>
Параметры:<br/>
indRef - глобал печати<br/>]]></Description>
<Internal/>
<FormalSpec>indRef:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; приёмник печатной формы
 n rcvr s rcvr = @indRef@("prs", "receiver")
 
 ; действие с файлом результата
 n resAct s resAct = @indRef@("prs", "resAct")
 
 ; принтер
 n printer s printer = @indRef@("prs", "printer")

 ; глобал с информацией o результате
 n indResRef s indResRef = $na(@indRef@("body", "res"))
 ; получаем вариант результата
 n resVar s resVar = $g(@indResRef)
 ; если нет результата - выходим
 i resVar = "" q
 
 ; если результат не файл - выходим
 i resVar '= "file" q

 ; короткое имя результата
 n resSht s resSht = @indResRef@(resVar)
 ; папка результата
 n dir s dir = @indResRef@(resVar, "dir")
 ; полное имя результата
 n resPath s resPath = dir _ resSht
 
 

 ; печатаем/открываем
 ; если приёмник IE,Word,Excel
 n isRcvrValid s isRcvrValid = (rcvr ?1(1"IE",1"WORD",1"EXCEL",1"ODT",1"ODS")) ; @rda 1"ODS"
 i isRcvrValid d
 .; печатаем
 .i ((resAct = "CREATE_PRINT") && (rcvr ?1(1"WORD",1"EXCEL",1"ODT",1"ODS"))) d  q
 ..do qWEB.PrintList(resPath, printer)
 .
 .; флаг - замещать выходную форму
 .n replace,prog s replace = ''$g(qqXBprwr)
 .
 .; запрет редактирования для Excel - открывает через OLE
 .n readOnly s readOnly = ''$g(qqXBPrtReadOnly)
 .i rcvr = "EXCEL", readOnly s replace = 1
 .
 .;sas 20090717 определение типа программы временно закоментировано
 .;s prog=$S($ZCVT($P(resPath,".",2),"U")="XLS":"scalc.exe",$ZCVT($P(resPath,".",2),"U")="HTML":"",1:"swriter.exe")
 .; если не замещать выходную форму
 .i 'replace d  q
 ..;sas 20090717 Если не HTML и установлен флаг OOW временно закоментированно
 ..;i (prog)'="" i $G(qqXBPrttoOOW)=1 d
 ...;d qARM.Wait("d qARM.wM(""-qARM"", ""ShellExecute"", 0, ""open"", """_prog_""", """""""_resPath_""""""", """_dir_""", 1)")
 ..;e  d qARM.Wait("d qARM.wM(""-qARM"", ""ShellExecute"", 0, ""open"", """_resPath_""", """", """_dir_""", 1)")
 ..d qARM.Wait("d qARM.wM(""-qARM"", ""ShellExecute"", 0, ""open"", """_resPath_""", """", """_dir_""", 1)")
 .
 .; замещать выходную форму
 .; разрешено редактирование
 .n editable s editable = @indRef@("prs", "edit")
 .i rcvr = "EXCEL", readOnly s editable = 0
 .d ..Print2DocOpenCreate(resPath, editable)

 q
]]></Implementation>
</Method>

<Method name="Print2SendDbf">
<Internal/>
<FormalSpec>indRef:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; dbf
 ; глобал с информацией o dbf
 n indDbfRef s indDbfRef = $na(@indRef@("body", "dbf"))
 ; вариант dbf, путь к dbf-файлу, ссылка на текст dbf
 n dbfVar, dbfPath, dbfRef
 ; получаем вариант dbf
 s dbfVar = $g(@indDbfRef)
 i dbfVar '= "" d
 .; формируется
 .i dbfVar = "form" d  q
 ..; полный путь к dbf-файлу
 ..s dbfPath = $g(@indDbfRef@("file"))
 ..; ссылка на текст
 ..s dbfRef = $na(@indDbfRef@(dbfVar))
 ..; сохраняем в файл
 ..;d qARM.OpenIE(dbfRef, dbfPath, 0)
 ..d qARM.wM("-qARM", "FileFastSave", dbfRef, dbfPath)
 
 q
]]></Implementation>
</Method>

<Method name="Print2SendOdf">
<Internal/>
<FormalSpec>indRef:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 // формировать xxl
 new isXXL set isXXL = @indRef@("prs", "xxl")
 
 // объект обработчика
 new procObj set procObj = "print2xmlproc"
 
 new item
 new part 
 
 new resArray
 new resDstVar
 
 new partArray
 new partVar
 
 new indPicRef
 new picVar
 new picRef
 
 new resDir set resDir = @indRef@("body","res","file","dir")
 new odfDir
 new zipSht
    
 // если запрет редактирования - добавляем settings
 new itemList set itemList = $listBuild("content", "manifest") _ $select($get(qqXBPrtReadOnly): $listBuild("settings"), 1: "") _ $listBuild("body")
 new itemCnt
 
 for itemCnt = 1: 1: $listLength(itemList) {
     set item = $list(itemList, itemCnt)
     
     kill resArray
     
     if ($data(@indRef@(item, "res", "form"))) {
         set resArray("src", "var") = "form"
         set resArray("src", "mode") = @indRef@(item, "res", "form")
     }
     elseif ($data(@indRef@(item, "res", "ref"))) {
         set resArray("src", "var") = "ref"
         set resArray("src", "ref") = @indRef@(item, "res", "ref")
     }
     
     set (resArray("dst", "var"), resDstVar) = @indRef@(item, "res")
     if (resArray("dst", "var") = "file") {
         set resArray("dst", "dir") =  @indRef@(item, "res", resDstVar, "dir")
         set resArray("dst", "sht") = @indRef@(item, "res", resDstVar)
         
         if (item = "content") {
             set odfDir = resArray("dst", "dir")
         }
     }
     
     if ((resArray("dst", "var") = "file") && (resArray("src", "var") = "form") && (resArray("src", "mode") = "transform_part")) {
         do ..Print2XxlProcCreate(procObj)
         ; do ..Print2XxlProcInit(procObj, 0, resArray("dst", "dir"))
         do ..Print2XxlProcInit(procObj, 0, resDir)
         
         kill partArray
         
         for part = "xml", "xsl" {
             set (partArray(part, "var"), partVar) = $get(@indRef@(item, part))
             if (partVar '= "") {
                 if (partVar = "file") {
                     set partArray(part, "path") = @indRef@(item, part, partVar)
                 }
                 elseif (partVar ?1(1"form",1"ref")) {
                     if (isXXL) {
                         set partArray(part, "path") = @indRef@(item, part, "file")
                     }
                 
                     if (partVar = "form") {
                         set partArray(part, "ref") = $name(@indRef@(item, part, partVar))
                     }
                     elseif (partVar = "ref") {
                         set partArray(part, "ref") = @indRef@(item, part, partVar)
                     }   
                 }
             }
         }
         
         do qARM.wM("-qARM", "ForceDir", resArray("dst", "dir"), "", "")
         do ..Print2XxlProcTrans(procObj, $get(partArray("xml", "ref")), $get(partArray("xml", "path")), $get(partArray("xsl", "ref")), $get(partArray("xsl", "path")), resArray("dst", "dir") _ resArray("dst", "sht"), 1, , 3)
         
         set indPicRef = $name(@indRef@(item, "pic"))
         set picVar = $get(@indPicRef)
         
         if (picVar '= "") {
             if (picVar = "form") {
                 set picRef = $name(@indPicRef@(picVar))
                 do ..Print2XxlProcAddPics(procObj, picRef)
             }
         }
     }
     
     if ((resArray("dst", "var") = "file") && (resArray("src", "var") = "ref")) {
         do qARM.wM("-qARM", "ForceDir", resArray("dst", "dir"), "", "")
         do qARM.wM("-qARM", "FileFastSave", resArray("src", "ref"), resArray("dst", "dir") _ resArray("dst", "sht"))
     }
     
     if ((resArray("dst", "var") = "file") && (resArray("src", "var") = "form") && (resArray("src", "mode") = "join_item")) {
         /*
         del "C:\Program Files\qARM\TDV\qword.odt"
         zip32 -add -dir=relative "C:\Program Files\qARM\TDV\qword.zip" "C:\Program Files\qARM\TDV\odf\*.*"
         ren "C:\Program Files\qARM\TDV\qword.zip" qword.odt
         del "C:\Program Files\qARM\TDV\qword.zip"
         */
         
         set zipSht = $piece(resArray("dst", "sht"), 1, $length(resArray("dst", "sht"), ".") - 1) _ "." _ "zip"
         
         do qARM.wM("-qARM", "ForceDir", resArray("dst", "dir"), "", "")
         do qARM.wM("-qARM", "ChgDir", resArray("dst", "dir"))
         do qARM.wM("-qARM", "ModalExec","cmd /c del " _ resArray("dst", "sht"), 1)
         do qARM.wM("-qARM", "ModalExec","zip32 -add=update -dir=relative -move -silent " _ zipSht _" " _"""" _ odfDir _ "*.*""", 1)
         do qARM.wM("-qARM", "ModalExec","cmd /c del " _ resArray("dst", "sht"), 1)
         do qARM.wM("-qARM", "ModalExec","cmd /c ren " _ zipSht _ " " _ resArray("dst", "sht"), 1)
     }
 }
 
 quit
]]></Implementation>
</Method>

<Method name="Print2SendTxt">
<Description><![CDATA[
Формирование файлов txt, xls<br/>
Параметры:<br/>
indRef - глобал печати<br/>]]></Description>
<Internal/>
<FormalSpec>indRef:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; txt
 ; глобал с информацией o txt
 n indTxtRef s indTxtRef = $na(@indRef@("body", "txt"))
 ; вариант txt, путь к txt-файлу, ссылка на текст txt
 n txtVar, txtPath, txtRef
 ; получаем вариант txt
 s txtVar = $g(@indTxtRef)
 i txtVar '= "" d
 .; формируется
 .i txtVar = "form" d  q
 ..; полный путь к txt-файлу
 ..s txtPath = $g(@indTxtRef@("file"))
 ..; ссылка на текст
 ..s txtRef = $na(@indTxtRef@(txtVar))
 ..; сохраняем в файл
 ..d qARM.OpenIE(txtRef, txtPath, 0)


 ; xls
 ; глобал с информацией o xls
 n indXlsRef s indXlsRef = $na(@indRef@("body", "xls"))
 ; вариант xls, путь к xls-файлу, ссылка на текст xls
 n xlsVar, xlsPath, xlsRef
 ; получаем вариант xls
 s xlsVar = $g(@indXlsRef)
 i xlsVar '= "" d
 .; ссылка на текст
 .i xlsVar = "ref" d  q
 ..; полный путь к xls-файлу
 ..s xlsPath = $g(@indTxtRef@("file"))
 ..; ссылка на текст
 ..s xlsRef = $na(@indTxtRef@(xlsVar))
 ..; сохраняем в файл
 ..d qARM.OpenIE(xlsRef, xlsPath, 0)


 ; res
 ; глобал с информацией o результате
 n indResRef s indResRef = $na(@indRef@("body", "res"))
 ; вариант результата, короткое имя файла результата
 n resVar, resSht
 ; получаем выходной вариант результа
 s resVar = $g(@indResRef)
 i resVar '= "" d 
 .; файл
 .i resVar = "file" d  q
 ..; короткое имя файла результата
 ..s resSht = $g(@indResRef@(resVar))
 ..; файл уже сформировали в разделе xls - ничего не делаем

 q
]]></Implementation>
</Method>

<Method name="Print2SendXxl">
<Description><![CDATA[
Формирование файлов xml, xsl и файла результата<br/>
Параметры:<br/>
indRef - глобал печати<br/>]]></Description>
<Internal/>
<FormalSpec>indRef:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; формировать MIME
 n isMIME s isMIME = @indRef@("prs", "mime")
 ; формировать xml,xsl
 n isXXL s isXXL = @indRef@("prs", "xxl")

 ; объект обработчика
 n procObj s procObj = "print2xmlproc"
 ; создаём обработчик xml-xsl
 d ..Print2XxlProcCreate(procObj)

 ; инициализация
 ; глобал с информацией o результате
 n indResRef s indResRef = $na(@indRef@("body", "res"))
 ; папка результата
 n dir s dir = @indResRef@("file", "dir")
 ; короткое имя результата
 n sht s sht = $g(@indResRef@("file"))
 ; полное имя результата
 N fll s fll = dir _ sht

 d
 .; если вывод в MIME - инициализируем полным именем файла
 .i isMIME d ..Print2XxlProcInit(procObj, 1, fll) q
 .; иначе инициализируем именем папки
 .d ..Print2XxlProcInit(procObj, 0, dir)

 ; глобал с информацией o xml
 n indXmlRef
 ; вариант xml, путь к xml-файлу, ссылка на текст xml
 n xmlVar, xmlPath, xmlRef
 
 ; глобал с информацией o xsl
 n indXslRef
 ; вариант xsl, путь к xsl-файлу, ссылка на текст xsl
 n xslVar, xslPath, xslRef
 
 ; вариант результата, короткое имя файла результата
 n resVar, resSht

 n region
 f region = "body", "head", "foot" d
 .; если нет такой области - выходим
 .i '$d(@indRef@(region)) q
 .
 .; xml
 .; глобал с информацией o xml
 .s indXmlRef = $na(@indRef@(region, "xml"))
 .s xmlPath = ""
 .s xmlRef = ""
 .; получаем вариант xml
 .s xmlVar = $g(@indXmlRef)
 .i xmlVar '= "" d
 ..; файл - получаем полный путь к xml-файлу
 ..i xmlVar = "file" s xmlPath = $g(@indXmlRef@(xmlVar)) q
 ..
 ..; формируется или ссылка на текст - получаем ссылку на текст xml
 ..i xmlVar ?1(1"form",1"ref") d  q
 ...; если необходимо формировать файл xml - получаем полный путь к xml-файлу
 ...i isXXL s xmlPath = $g(@indXmlRef@("file"))
 ...
 ...; формируется
 ...i xmlVar = "form" s xmlRef = $na(@indXmlRef@(xmlVar)) q
 ...; ссылка на текст
 ...i xmlVar = "ref" s xmlRef = @indXmlRef@(xmlVar)
 .
 .; xsl
 .; глобал с информацией o xsl
 .s indXslRef = $na(@indRef@(region, "xsl"))
 .s xslPath = ""
 .s xslRef = ""
 .; получаем вариант xsl
 .s xslVar = $g(@indXslRef)
 .i xslVar '= "" d
 ..; файл - получаем полный путь к xsl-файлу
 ..i xslVar = "file" s xslPath = $g(@indXslRef@(xslVar)) q
 ..
 ..; формируется или ссылка на текст - получаем ссылку на текст xsl
 ..i xslVar ?1(1"form",1"ref") d  q
 ...; если необходимо формировать файл xsl - получаем путь к xsl-файлу
 ...i isXXL s xslPath = $g(@indXslRef@("file"))
 ...
 ...; формируется
 ...i xslVar = "form" s xslRef = $na(@indXslRef@(xslVar)) q
 ...; ссылка на текст
 ...i xslVar = "ref" s xslRef = @indXslRef@(xslVar)
 .
 .; res
 .; глобал с информацией o результате
 .s indResRef = $na(@indRef@(region, "res"))
 .s resSht = ""
 .; получаем вариант результа
 .s resVar = $g(@indResRef)
 .i resVar '= "" d 
 ..; файл - получаем короткое имя файла результата
 ..i resVar = "file" s resSht = $g(@indResRef@(resVar))
 .
 .; выполняем преобразование и формирование результата
 .d ..Print2XxlProcTrans(procObj, xmlRef, xmlPath, xslRef, xslPath, resSht)

 ; картинки
 ; глобал с информацией o картинках
 s indPicRef = $na(@indRef@("pic"))
 ; варинт картинок, ссылка на картинки
 n picVar, picRef
 s picRef = ""
 ; получаем вариант картинок
 s picVar = $g(@indPicRef)
 i picVar '= "" d
 .; формируется
 .i picVar = "form" d
 ..; получаем ссылку на картинки
 ..s picRef = $na(@indPicRef@(picVar))
 ..; добавляем картинки в MIME-файл, либо формируем отдельные файлы картинок
 ..d ..Print2XxlProcAddPics(procObj, picRef)

 ; закрытие MIME-документа (запись последней границы)
 i isMIME d ..Print2XxlProcCloseMIME(procObj)

 q
]]></Implementation>
</Method>

<Method name="Print2SetGlb">
<Description><![CDATA[
Установка глобалных параметров печати<br/>
Вызывается из qSYS.BaseIni()<br/>]]></Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; системый массив, в котором устанавливаются параметры
 n sysRef S sysRef = ..Print2GetGlbRef()

 ; общие параметры
 do ..Print2SetGlbPrsAll(sysRef)
 
 ; объекты Delphi
 do ..Print2SetGlbObjAll(sysRef)

 q
]]></Implementation>
</Method>

<Method name="Print2SetGlbObj">
<Description><![CDATA[
Установка глобальных параметров печати - объекты классов Delphi<br/>
Параметры:<br/>
class   - имя класса<br/>
TOpenDocument - открытие документа с замещением выходной формы<br/>
TOleXMLDOM - обработка XML-XSL в печати версии 1<br/>
TXMLProcessor - обработка XML-XSL в печати версии 2<br/>

object  - имя объекта<br/>
class = TOpenDocument:<br/>
docxml        - печать версия 1<br/>
print2opendoc - печать версия 2<br/>

class = TOleXMLDOM (только версия 1)<br/>
имя объекта не указывается<br/>

class = TXMLProcessor (только версия 2)<br/>
print2xmlproc<br/>

exist   - существование объекта (1 - уставливает, что объект (объекты) класса Delphi существует, 0 - устанавливает, что не существует)<br/>]]></Description>
<Internal/>
<FormalSpec>class:%Library.String,object:%Library.String,exist:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; глобальные параметры печати (glb)
 ; объекты Delphi
 ; @ref@("glb","obj","TOpenDocument","docxml")=1        - объект docxml класса TOpenDocument уже был создан
 ; @ref@("glb","obj","TOpenDocument","print2opendoc")=1 - объект print2opendoc класса TOpenDocument уже был создан
 ; @ref@("glb","obj","TOleXMLDOM")=1                    - объекты класса TOleXMLDOM уже были созданы
 ; @ref@("glb","obj","TXMLProcessor","print2xmlproc")=1 - объект print2xmlproc класса TXMLProcessor уже был создан

 ; проверка значений входных параметров
 ; класс и существование д.б. заданы, объект может отсутствовать
 i $g(class) = "" q
 i $g(exist) = "" q
 s object = $g(object)

 ; допустимые значения входных параметров класс и объект
 n valid
 s valid("TOpenDocument", "docxml") = ""
 s valid("TOpenDocument", "print2opendoc") = ""
 s valid("TOleXMLDOM") = ""
 s valid("TXMLProcessor", "print2xmlproc") = ""
 s valid("THTMLMerge", "print2merge") = ""

 ; если имя класса недопустимо - выходим
 i '$d(valid(class)) q

 ; если объект не указан, но д.б. задан - выходим
 i object = "", $d(valid(class)) = 11 q

 ; если объект указан, и имя объекта недопустимо - выходим
 i object '= "", '$d(valid(class, object)) q

 ; если значение существования недуопустимо - выходим
 i exist '?1(1"0",1"1") q

 ; ссылка на массив с глабальными параметрами печати
 n glbRef s glbRef = ..Print2GetGlbRef()

 ; содержимое - объекты (obj)
 n content S content = "obj"
 d
 .; если объект не указан - устанавливаем по классу
 .i object = "" s @glbRef@(content, class) = exist q
 .; если объект указан - устанавливаем по объекту
 .s @glbRef@(content, class, object) = exist

 q
]]></Implementation>
</Method>

<Method name="Print2SetGlbObjAll">
<Description><![CDATA[
Установка глобалных параметров печати - объекты Delphi<br/>
Все параметры устанавливаются в значение 0<br/>
Выполняется только в том, случае, если значений ещё нет<br/>
Параметры:<br/>
toRef   - системный массив, в котором устанавливаются параметры<br/>]]></Description>
<Internal/>
<FormalSpec>toRef:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; содержимое - объекты (obj)
 n content s content="obj"
 ; если уже есть значения, не устанавливаем - выходим
 i $d(@toRef@(content)) q

 ; классы и объекты
 n clsObj
 ; класс TOpenDocument  - открытие документа с замещением выходной формы
 ; объект docxml - печать версия 1
 s clsObj("TOpenDocument", "docxml") = 0
 
 ; объект print2opendoc - печать версия 2
 s clsObj("TOpenDocument", "print2opendoc") = 0

 ; класс TOleXMLDOM - обработка XML-XSL в печати версии 1
 ; устанавливаем на уровне класса
 s clsObj("TOleXMLDOM") = 0

 ; класс TXMLProcessor - обработка XML-XSL в печати версии 2
 ; устанавливаем на уровне объекта
 ; объект print2xmlproc
 s clsObj("TXMLProcessor", "print2xmlproc") = 0
 
 s clsObj("THTMLMerge", "print2merge") = 0

 ; переписываем параметры
 m @toRef@(content)=clsObj

 q
]]></Implementation>
</Method>

<Method name="Print2SetGlbPrsAll">
<Description><![CDATA[
Установка глобалных параметров печати - общие параметры<br/>
Параметры:<br/>
toRef   - системый массив, в котором устанавливаются параметры<br/>]]></Description>
<Internal/>
<FormalSpec>toRef:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 ; содержимое - общие параметры (prs)
 n content s content = "prs"

 ; параметры
 n prs
 ; версия
 s prs("version") = $s($g(^Q(1, "XBase", 0, "XBPrt2")) = 1 : 2, 1 : 1)
 ; не формировать mime
 s prs("notmime") = ''$g(^Q(1, "XBase", 0, "XBPrt2NotMIME"))
 ; формировать xml, xsl
 s prs("xxl") = ''$g(^Q(1,"XBase",0,"XBPrt2XXL"))
 ; ссылка на глобал печати
 s prs("ref") = $s(prs("version") = 2 : $na(^mtempPrt($j)), 1 : $na($$$tmpGl)) ; 15.12.2008 Kokarev

 ; переписываем параметры
 k @toRef@(content) m @toRef@(content)=prs

 q
]]></Implementation>
</Method>

<Method name="Print2XxlConvertEncoding">
<Internal/>
<FormalSpec>fileFrom:%String,fileTo:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    
 ; объект обработчика
 n procObj s procObj = "print2xmlproc"
 ; создаём обработчик xml-xsl
 d ..Print2XxlProcCreate(procObj)
 
 d qARM.wM(procObj, "LoadXML", fileFrom)
 
 D qARM.wM(,"ReplaceCharset",1,"windows-1251","utf-8",1)

 d qARM.wM(procObj, "SaveXML", fileTo, 1)
 
 quit
]]></Implementation>
</Method>

<Method name="Print2XxlProcAddPics">
<Description><![CDATA[
Добавление картинок в результат<br/>
Если результат MIME-файл, то картинки кодируются с помошью base64 и записываются как разделы<br/>
Иначе картинки записываются как отдельные файлы<br/>
Параметры:<br/>
procObj  - имя объекта класса-обработчика XML-XSL<br/>
picRef  - глобал с картинками<br/>
формат глобала: @picRef@(num)=srs_$C(13)_name_$C(13)<br/>
num    - номер картики<br/>
src    - ссылка на ресурс (F,имя файла; M,ссылка за глобал; R,номер в qARM.dll)<br/>
name   - короткое имя файла картинки со значимым расширением<br/>]]></Description>
<Internal/>
<FormalSpec>procObj:%Library.String,picRef:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; проверяем входныe параметры
 i $s($g(procObj) = "" : 1, $g(picRef) = "" : 1, '$d(@picRef) : 1, 1 : 0) q

 d qARM.wM(procObj, "AddFiles", picRef)

 q
]]></Implementation>
</Method>

<Method name="Print2XxlProcCloseMIME">
<Description><![CDATA[
Закрытие MIME-файла (запись последней границы)<br/>
Параметры:<br/>
procObj  - имя ообъекта класса-обработчика XML-XSL<br/>]]></Description>
<Internal/>
<FormalSpec>procObj:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; проверяем входныe параметры
 i $g(procObj) = "" q

 d qARM.wM(procObj, "CloseMIME")

 q
]]></Implementation>
</Method>

<Method name="Print2XxlProcCreate">
<Description><![CDATA[
Создание объекта класса-обработчика XML-XSL<br/>
Параметры:<br/>
procObj - имя объекта класса-обработчика XML-XSL<br/>]]></Description>
<Internal/>
<FormalSpec>procObj:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; проверяем входныe параметры
 i $g(procObj) = "" q

 ; класс обработчика
 n procCls s procCls = "TXMLProcessor"
 ; флаг наличия объекта
 n isProcObj s isProcObj = ..Print2GetGlbObj(procCls, procObj)
 ; если ещё не существует, создаём объект обработчика
 i 'isProcObj d
 .; создаём
 .d qARM.wC(procCls, procObj)
 .; устанавливаем флаг, что объект существует
 .d ..Print2SetGlbObj(procCls, procObj, 1)

 q
]]></Implementation>
</Method>

<Method name="Print2XxlProcInit">
<Description><![CDATA[
Инициализация объекта класса-обработчика XML-XSL<br/>
Параметры:<br/>
procObj  - имя объекта класса-обработчика XML-XSL<br/>
initType - тип инициализации<br/>
1 - создавать MIME-файл
0 - создавать отдельные файлы
initPar  - параметр инициализации<br/>
имя MIME-файла, если initType = 1
имя папка, куда будут записываться файлы, если initType = 0]]></Description>
<Internal/>
<FormalSpec>procObj:%Library.String,initType:%Library.String,initPar:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; проверяем входныe параметры
 i $g(procObj) = "" q

 d qARM.wM(procObj, "Initialize", initType, initPar)

 q
]]></Implementation>
</Method>

<Method name="Print2XxlProcTrans">
<Description><![CDATA[
Преобразование XML-документа c помощью XSLT-документа c формированием выходящего документа<br/>
Параметры:<br/>
procObj - имя объект класса-обработчика XML и XSL<br/>
xmlRef - ссылка на глобал с XML-документом<br/>
xmlPath  - имя файла XML-документа<br/>
xslRef - ссылка на глобал с XSL-документом<br/>
xslPath  - имя файла XML-документа<br/>
resSht  - короткое имя файла результата<br/>
transType - тип преобразования: 0 - TransformNodeToObject, 1 - TransformNode<br/>]]></Description>
<Internal/>
<FormalSpec>procObj:%Library.String,xmlRef:%Library.String,xmlPath:%Library.String,xslRef:%Library.String,xslPath:%Library.String,resSht:%Library.String,transType:%Library.String,xmlGetMode:%String,xslGetMode:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; тип преобразования
 s transType = ''$g(transType)
 
 s xmlGetMode = $get(xmlGetMode)
 if (xmlGetMode = "") set xmlGetMode = 2
 
 s xslGetMode = $get(xslGetMode)
 if (xslGetMode = "") set xslGetMode = 2

 ; код xml
 ; xmlPath | xmlRef | xmlCode |
 ;    0    |    0   |    0    |
 ;    0    |    1   |    1    |
 ;    1    |    0   |    2    |
 ;    1    |    1   |    3    |
 n xmlCode s xmlCode = $s($g(xmlRef) = "" : 0, '$d(@xmlRef) : 0, 1 : 1) + ($s($g(xmlPath) = "" : 0, 1 : 1) * 2)

 ; код xsl
 ; xslPath | xslRef | xslCode |
 ;    0    |    0   |    0    |
 ;    0    |    1   |    1    |
 ;    1    |    0   |    2    |
 ;    1    |    1   |    3    |
 n xslCode s xslCode = $s($g(xslRef) = "" : 0, '$d(@xslRef) : 0, 1 : 1) + ($s($g(xslPath) = "" : 0 , 1 : 1) * 2)

 ; код результата
 ; resSht  | resCode |
 ;    0    |    0    |
 ;    1    |    1    |
 n resCode s resCode = $s($g(resSht) = "" : 0, 1 : 1)

 ; коды действий
 n act
 s act("DO_NOTHING") = 0
 s act("MAKE_XSL") = 1
 s act("MAKE_XML") = 2
 s act("MAKE_XML_XSL") = 3
 s act("MAKE_RES") = 4

 ; таблица преобразования
 ; определяет код действия в зависимости от кодов xml, xsl и результата
 n trans                                    ;xml|xsl|res
 s trans(0, 0, 0) = act("DO_NOTHING")       ; 0 | 0 | 0 | ничего не делаем
 s trans(0, 0, 1) = act("DO_NOTHING")       ; 0 | 0 | 1 | ничего не делаем
 s trans(0, 1, 0) = act("DO_NOTHING")       ; 0 | 1 | 0 | ничего не делаем
 s trans(0, 1, 1) = act("DO_NOTHING")       ; 0 | 1 | 1 | ничего не делаем
 s trans(0, 2, 0) = act("DO_NOTHING")       ; 0 | 2 | 0 | ничего не делаем
 s trans(0, 2, 1) = act("DO_NOTHING")       ; 0 | 2 | 1 | ничего не делаем
 s trans(0, 3, 0) = act("MAKE_XSL")         ; 0 | 3 | 0 | XSL берём из XSLRef, кладём в XSLFN
 s trans(0, 3, 1) = act("MAKE_XSL")         ; 0 | 3 | 1 | XSL берём из XSLRef, кладём в XSLFN
 s trans(1, 0, 0) = act("DO_NOTHING")       ; 1 | 0 | 0 | ничего не делаем
 s trans(1, 0, 1) = act("DO_NOTHING")       ; 1 | 0 | 1 | ничего не делаем
 s trans(1, 1, 0) = act("DO_NOTHING")       ; 1 | 1 | 0 | ничего не делаем
 s trans(1, 1, 1) = act("MAKE_RES")         ; 1 | 1 | 1 | XML берём из XMLRef, XSL берём из XSLRef, выполняем преобразование
 s trans(1, 2, 0) = act("DO_NOTHING")       ; 1 | 2 | 0 | ничего не делаем
 s trans(1, 2, 1) = act("MAKE_RES")         ; 1 | 2 | 1 | XML берём из XMLRef, XSL берём из XSLFN, выполняем преобразование
 s trans(1, 3, 0) = act("MAKE_XSL")         ; 1 | 3 | 0 | XSL берём из XSLRef, кладём в XSLFN
 s trans(1, 3, 1) = act("MAKE_RES")         ; 1 | 3 | 1 | XML берём из XMLRef, XSL берём из XSLRef, кладём в XSLFN, выполняем преобразование
 s trans(2, 0, 0) = act("DO_NOTHING")       ; 2 | 0 | 0 | ничего не делаем
 s trans(2, 0, 1) = act("DO_NOTHING")       ; 2 | 0 | 1 | ничего не делаем
 s trans(2, 1, 0) = act("DO_NOTHING")       ; 2 | 1 | 0 | ничего не делаем
 s trans(2, 1, 1) = act("MAKE_RES")         ; 2 | 1 | 1 | XML берём из XMLFN, XSL берём из XSLRef, выполняем преобразование
 s trans(2, 2, 0) = act("DO_NOTHING")       ; 2 | 2 | 0 | ничего не делаем
 s trans(2, 2, 1) = act("MAKE_RES")         ; 2 | 2 | 1 | XML берём из XMLFN, XSL берём из XSLFN, выполняем преобразование
 s trans(2, 3, 0) = act("MAKE_XSL")         ; 2 | 3 | 0 | XSL берём из XSLRef, кладём в XSLFN
 s trans(2, 3, 1) = act("MAKE_RES")         ; 2 | 3 | 1 | XML берём из XMLFN, XSL берём из XSLRef, кладём в XSLFN, выполняем преобразование
 s trans(3, 0, 0) = act("MAKE_XML")         ; 3 | 0 | 0 | XML берём из XMLRef, кладём в XMLFN
 s trans(3, 0, 1) = act("MAKE_XML")         ; 3 | 0 | 1 | XML берём из XMLRef, кладём в XMLFN
 s trans(3, 1, 0) = act("MAKE_XML")         ; 3 | 1 | 0 | XML берём из XMLRef, кладём в XMLFN
 s trans(3, 1, 1) = act("MAKE_RES")         ; 3 | 1 | 1 | XML берём из XMLRef, кладём в XMLFN, XSL берём из XSLRef, выполняем преобразование
 s trans(3, 2, 0) = act("MAKE_XML")         ; 3 | 2 | 0 | XML берём из XMLRef, кладём в XMLFN
 s trans(3, 2, 1) = act("MAKE_RES")         ; 3 | 2 | 1 | XML берём из XMLRef, кладём в XMLFN, XSL берём из XSLFN, выполняем преобразование
 s trans(3, 3, 0) = act("MAKE_XML_XSL")     ; 3 | 3 | 0 | XML берём из XMLRef, кладём в XMLFN, XSL берём из XSLRef, кладём в XSLFN
 s trans(3, 3, 1) = act("MAKE_RES")         ; 3 | 3 | 1 | XML берём из XMLRef, кладём в XMLFN, XSL берём из XSLRef, кладём в XSLFN, выполняем преобразование

 ; получаем код действия
 n actCode s actCode = trans(xmlCode, xslCode, resCode)

 ; если ничего не делаем - выходим
 i actCode = act("DO_NOTHING") q

 ; получаем xml
 ; если необходимо создать xml, создать xml и xsl, создать результат
 i $s(actCode = act("MAKE_XML") : 1, actCode = act("MAKE_XML_XSL") : 1, actCode = act("MAKE_RES") : 1, 1 : 0) d
 .; получаем из глобала
 .i xmlCode # 2 = 1 d  q
 ..d qARM.wM(procObj, "GetXML", xmlRef, xmlGetMode)
 ..; пишем в файл
 ..i xmlCode = 3 d qARM.wM(procObj, "SaveXML", xmlPath)
 .; получаем из файла
 .d qARM.wM(procObj, "LoadXML", xmlPath)

 ; выходим, если необходимо было только создать xml
 i actCode = act("MAKE_XML") q

 ; получаем xsl
 d
 .; получаем из глобала
 .i xslCode # 2 = 1 d  q
 ..d qARM.wM(procObj, "GetXSL", xslRef, xslGetMode)
 ..; замена кодировки в теге meta
 ..d qARM.wM(procObj, "XSLReplaceCharset", "utf-8", "windows-1251")
 ..; пишем в файл
 ..i xslCode = 3 d qARM.wM(procObj, "SaveXSL", xslPath)
 .; получаем из файла
 .d qARM.wM(procObj, "LoadXSL", xslPath)
 .; замена кодировки в теге meta
 .d qARM.wM(procObj, "XSLReplaceCharset", "utf-8", "windows-1251")

 ; выходим, если необходимо было только создать xsl либо xml и xsl
 i $s(actCode = act("MAKE_XSL") : 1, actCode = act("MAKE_XML_XSL") : 1, 1 : 0) q

 ; получаем результат
 ; задаём короткое имя файла
 ; для MIME будет указано в разделе Content-Location
 ; для не MIME - просто имя файла
 d qARM.wM(procObj, "New", resSht)

 ; выполняем преобазование и сохранение
 n transName
 s transName(0) = "TransformNodeToObject"
 s transName(1) = "TransformNode"
 
 if (transType=1) d qARM.wM(procObj,"ReplaceCharset",0,"UTF-16","windows-1251",1) ; для правильной работы OpenOffice
 d qARM.wM(procObj, transName(transType)) 

 q
]]></Implementation>
</Method>

<Method name="PrintColl">
<Description>
Метод для обработки отображений, которые описывают наполнение коллонтитулов.
Вызывается при печати отображения (метод SendXML).
Параметры:
qqview - код отображения, из которого нужно взять параметры коллонтитулов.</Description>
<Internal/>
<FormalSpec>qqview:%Library.String=""</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 ;для каждого коллонтитула проверяем, где находится xsl-текст
 ;q2 и q3 - определяют верхний и нижний коллонтитулы
 i $G(qqview)="" s qqview=$g(Vo(qqnump,-1,-1))_$s($g(Vo(qqnump,-1,-1))'="":$C(1),1:"")_Vo(qqnump)
  
 n qqoView
 S qqoView=$S($g(qqview)'[$C(1):"XView",1:$P($g(qqview),$C(1))) S:$g(qqview)[$C(1) qqview=$P($g(qqview),$C(1),2,255) ;Маслова 06.08.2010    
 
 N i,q2,q3 F i=2,3 D  S:@("q"_i)=1 @("q"_i)="" ;1 - отсутствует
 .;определяем вариант xsl для каждого из коллонтитулов
 .S @("q"_i)=qARM.GetPar("x36"_i_"0",qqoView_$C(1)_qqview) Q:@("q"_i)'=""  ;если не "", то дальше не проверяем
 .;если вариант не определен, проверим параметры X362 (X363) и TB362 (TB363) - для совместимости со старым вариантом
 .;если одно из понятий определено, то устанавливаем q2 или q3 как одно из значений варианта xsl (понятие x3620 или x3630)
 .;если определен X362 (X363) - ссылка на файл или отображение; ЕСЛИ ОТОБРАЖЕНИЕ, ТО ПРЕКРАЩАЕМ ОБРАБОТКУ
 .S @("q"_i)=qARM.GetPar("X36"_i,qqoView_$C(1)_qqview) I @("q"_i)'="" S @("q"_i)=$S($TR(@("q"_i),"\/.")'=@("q"_i):2,1:"") Q
 .;если существует TB362 или TB363, то текст
 .S:$D(^Q(1,qqoView,qqview,"XPrint",Vo(qqnump,-1,30),"TB36"_i)) @("q"_i)=3
 ;
 $$$oQuit(q2=""&&(q3=""),"") ;выход, если коллонтитулы не определены
 ;
 N xmlPath,xmlName,xmlDir
 ;полный путь к xml-файлу
 n file s file=qARM.GetPar(368,qqoView_$C(1)_qqview)
 S:$E(file)="@" @("file="_$E(file,2,32000))
 ;20071011 sasha@tdv
 I $E(file)="-" S file=$E(file,2,30000)
 S xmlPath=..xmlPath(file)
 s i=$S($F(xmlPath,"\")'=0:"\",1:"/")
 ;название xml-файла без расширения и полный путь c именем файла (без расширения)
 S xmlName=$P($P(xmlPath,i,$L(xmlPath,i)),"."),xmlDir=$P(xmlPath,".",1,$L(xmlPath,".")-1)
 ;
 ;формируем выходной файл, описывающий связь основного документа xmlName.doc и файлов-коллонтитулов (xmlName_headerH.doc и (или) xmlName_headerF.doc)
 N qqdev S qqdev="" F  S qqdev=$O($$$tmpGl(qqdev),-1) Q:qqdev=+qqdev  ; 15.12.2008 Kokarev
 D ..OpenDev($I(qqdev))
 D ..write("<xml xmlns:o='urn:schemas-microsoft-com:office:office'>")
 D ..write("<o:MainFile HRef='"_xmlName_".doc'/>"_$S(q2="":"",1:"<o:File HRef='"_xmlName_"_headerH.doc'/>")_$S(q3="":"",1:"<o:File HRef='"_xmlName_"_headerF.doc'/>")_"<o:File HRef='"_xmlName_"_filelist.xml'/>")
 D ..write("</xml>")
 D ..CloseDev(qqdev)
 D qARM.OpenIE(qqdev,xmlDir_"_filelist.xml",0)
 ;
 ;q2 или q3 могут быть: 2-файл, 3-тест, 4-ссылка на текст
 F i=2,3 I @("q"_i)'="" D
 .;текст
 .I @("q"_i)=3 S @("q"_i)=xmlDir_"_header"_$S(i=2:"H",1:"F")_".xsl" D qARM.OpenIE($NA(^Q(1,qqoView,qqview,"XPrint",Vo(qqnump,-1,30),"TB36"_i)),@("q"_i),0) Q
 .;ссылка на текст
 .I @("q"_i)=4 N q S q=qARM.GetPar("X36"_i,qqoView_$C(1)_qqview) S:$E(q)="@" q=qARM.Value($E(q,2,32000)) S @("q"_i)=xmlDir_"_header"_$S(i=2:"H",1:"F")_".xsl" D qARM.OpenIE(q,@("q"_i),0) Q
 .;ссылка на файл XSL
 .I @("q"_i)=2 S @("q"_i)=..XslPath(qARM.GetPar("X36"_i,qqoView_$C(1)_qqview)) Q
 .S @("q"_i)="" Q  ;если значение - не 2 (3,4) то устанавливаем его "", чтобы не вызывать обработку xml-файла
 ;вызов создания файлов doc (q2 или q3 - путь к xsl-файлу коллонтитула)
 F i=2,3 I @("q"_i)'="" D
 .D qARM.wM("source","Load",xmlPath),qARM.wM("stylesheet","Load",@("q"_i))
 .D qARM.wM("source","TransformNodeToObject","stylesheet","result")
 .D qARM.wM("result","Save",xmlDir_"_header"_$S(i=2:"H",1:"F")_".doc")
 $$$oQuit(1,"")
]]></Implementation>
</Method>

<Method name="PrintList">
<Description>
Печать списка файлов
fileList - список имён файлов через $char(13)
printer - полное имя принтера, или "" - запрос выбора принтера, или "%DEFAULT"- принтер по умолчанию</Description>
<Internal/>
<FormalSpec>fileList:%Library.String,printer:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 set fileList = $get(fileList)
 if (fileList = "") quit
 
 // set action = $get(action)
 // if (action ?1(1"print",1"open")) quit
 
 new sep set sep = $char(13)
 new fileListLen set fileListLen = $length(fileList, sep)
 
 new fileOutList set fileOutList = ""
 new file
 new cnt
 
 for cnt = 1: 1: fileListLen do
 .set file = $piece(fileList, sep, cnt)
 .if (file = "") quit
 .
 .if (fileOutList '= "") set fileOutList = fileOutList _ sep
 .set fileOutList = fileOutList _ file
 
 if (fileOutList = "") quit
    
 do qARM.wM("-qARM","PrintDocs", fileOutList, $get(printer))
 
 quit
]]></Implementation>
</Method>

<Method name="PrintStart">
<Description>
Старт печати - создание контекста (вызывается из qWEB.Print,qWEB.Print2Col)
Параметры:
Job
X130  - набор параметров печати. Передаётся по ссылке. На выходе в X130 - отображение, откуда брать параметры печати, в Vo(qqnump,-1,30) - номер набора печати
NoWin - печать в текущем контексте</Description>
<Internal/>
<FormalSpec>Job:%Library.String,X130:%Library.String,NoWin:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 I '$G(NoWin) N View S View=$P($$$tmpGl("q",Job)," ",1) ;вызываемое отображение ; 15.12.2008 Kokarev
 I $g(View)="" s View=$g(Vo(qqnump,-1,-1))_$s($g(Vo(qqnump,-1,-1))'="":$C(1),1:"")_Vo(qqnump)
 
 N qqoView,qqoViewX130,ViewX130
 S qqoView=$S($g(View)'[$C(1):"XView",1:$P($g(View),$C(1))) S:$g(View)[$C(1) View=$P($g(View),$C(1),2,255) ;Маслова 06.08.2010  
 
 I $L(X130,":")>1 s ViewX130=$P(X130,":") S qqoViewX130=$S(ViewX130'[$C(1):"XView",1:$P(ViewX130,$C(1))) S:ViewX130[$C(1) ViewX130=$P(ViewX130,$C(1),2,255) ;Маслова 06.08.2010 
 
 I $L(X130,":")>1,'$D(^Q(1,qqoViewX130,ViewX130)) D qARM.Message("Отображения "_ViewX130_" не существует") Q:$Q "" Q  ;@dol 30.12.03 Value
 
 I '$G(NoWin) N %1 S %1=..OpenPrint($P($$$tmpGl("q",Job)," ",2,3),,,,,qqoView_$C(1)_View,Job,X130) Q:%1'="" %1  ; 15.12.2008 Kokarev
 I $G(NoWin) N qqend D:NoWin<10  Q:$G(qqend)'="" qqend ;@Dol 8.01.08 при печати по текущему отображению;@Dol 05.03.10 NoWin<10
 .K Vo(qqnump,-1,3) S:X130'="" Vo(qqnump,-1,30)=X130 ;набор печати по умолчанию
 .N q S q=qARM.GetPar("X325") I q'="" D qARM.Value(q,"X") ;действие по входу
 ;набор печати находится в Vo(qqnump,-1,30) - устанавливается в qWEB.OpenPrint
 ;определяем отображение, откуда брать параметры печати
 S X130=$S($L(X130,":")>1:$P(X130,":"),1:"")
 D qARM.GetPar(366,X130) I $E(Vo(qqnump),1,3)="XXX",Vo(qqnump,-1,3,66)="" S Vo(qqnump,-1,3,66)=1 ;не убирать подчерк (для системных отображений
 ;@Dol 12.05.06 заголовки формы и граф таблицы
 N X369,X3693,X3694,X3696
 S X369=qARM.GetPar("X369",X130),X3693=qARM.GetPar("X3693",X130),X3694=qARM.GetPar("X3694",X130),X3696=qARM.GetPar("X3696",X130) S:$E(X3693)="@" @("X3693="_$E(X3693,2,30000))
 I X369||(X3693'="")||X3694 S:X3694 X3694=qW.oZVs8() D qSYS.CreTitleTab(,1,'X369,X3693,X3694,$S($P(X3696," ",2)="":1,1:$P(X3696," ",2)),$P(X3696," ",1),$P(X3696," ",3,255)) ;@Dol 06.04.10 $P(X3696," ",3,255)
 Q ""
]]></Implementation>
</Method>

<Method name="Query">
<Description>
Выполнить запрос.  Воссстанавливается сохраненный на момент создания запроса контекст
(или имитируется вызов (см. viewquery) нового отображения (без создания окна на экране).
query - код запроса (если задан только он, то берутся параметры из объекта "XQuery", query - код экземпляра этого объекта ).
@Dol 18.03.08   !!! New !!! может иметь вид:
qqoQu:query - где qqoQu - код объекта запроса (не задан - объект "XQuery"), query - код его экземпляра
   В %Список запросов (X169) описания отображения (раздел Действия) добавлено:
   Для организации вызова пользовательских (хранимых в объектах пользователя) запросов.
   @@действие_по_Хcute - выполнение действия
   @@@ - вызов отображения mseQuery   (используется в qMS для выбора запросов)
если $E(query)=$C(1) далее следует идентификатор запроса в qMS , поиск сначала в текущей организации, потом в образце sas 20110303
viewquery - код отображения, в рамках которого выполняется запрос и (через пробел), код запроса 
для взятия состояния.
Если задан, то запрос не портит контекст отображения вызова (имитируется вызов отображения).
find=1 - выполнить поиск . Через пробел 0 -(или пусто) сбросить релевантные, 1 - выбор, 2 - уточнение.
anal=1
diag=1

print -  если задан, то вывод заданной выходной формы
если не задан, а также установлен флаг ^Q(1,qqoQu,query,"XQprint"), то отображение берётся из ^Q(1,qqoQu,query,"XQprintView")
print="1" - отображение берётся из ^Q(1,qqoQu,query,"XQprintView"), но флаг ^Q(1,qqoQu,query,"XQprint") не проверяется
print="0" - не выводить
print="" - текущее отображение

cond - список код_об1,код_пон1 код_об2,код_пон2 ... для диалогово задаваемых условий поискового образа
open -  если задан, то вызов заданного отображения
если не задан, а также установлен флаг ^Q(1,qqoQu,query,"XQopen"), то отображение берётся из
^Q(1,qqoQu,query,"XQopenView")
open="1" - отображение берётся из ^Q(1,qqoQu,query,"XQopenView"), но флаг ^Q(1,qqoQu,query,"XQopen") не проверяется
open="0" - не выводить
open="" - текущее отображение

extrn - вне зависимости от viewquery, имитируется вызов отображения (используется для внешнего
вызова запроса)
notmess=1 - не выводить сообщения об ошибках

Для печати книги Excel:
OpenFile - (1 или пусто) - открывать файл, 0 - нет
Для главного файла указываем 1 или пучто, для файлов листов - 0
qqdev - код устройства
При вызове подряд нескольких запросов  с выводом xml и xsl-файлов необходимо каждый раз
увеличивать значение qqdev на 2

Возвращаемое значение:
1 - если ничего не найдено, иначе ""</Description>
<Internal/>
<FormalSpec>query:%String,viewquery:%String,find:%String,anal:%String,diag:%String,print:%String,extrn:%String,cond:%String,open:%Library.String,notmess:%Library.String,OpenFile:%Library.String,qqdev:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qqoQu S notmess=$G(notmess)
 I $G(query)=1 S query=$G(Vs(qqnump,"UserPar","QueryCode")) S qqoQu=$S(query'[":":"XQuery",1:$P(query,":")) S:query[":" query=$P(query,":",2,255) G QueryCont
 N XQDoBeg K XQDoEnd,nprint,diagfile
 S qqoQu=$S(query'[":":"XQuery",1:$P(query,":")) S:query[":" query=$P(query,":",2,255) ;@Dol 18.03.08
 
 n qMSquery ;@Sas 20110303
 i $E(query)=$C(1)  d  
 .s qMSquery=$P(query,$C(1),2)
 .q:qMSquery="" 
 .s qqoQu="query"
 .s query=qW.FastKey("query","Dquery","",,qMSquery,qW.FastKey(235,"pIDo","",,qARM("Pars",3)))
 .s:query="" query=qW.FastKey("query","Dquery","",,qMSquery,qW.FastKey(235,"pIDo","",,"Образец"))

 S QuEnd=0 ;признак завершения запроса
 I $G(query)'="" D  ;возмем параметры из описания запроса
 .D:'$D(viewquery)
 ..S %1=$G(^Q(1,qqoQu,query,"XQuery"))
 ..S %2=$G(^Q(1,qqoQu,query,"XQView"))
 ..I %1'=""!(%2'="")!$G(extrn) S viewquery=$S(%2="":$P(query,"qq"),1:%2)_" "_$S(%1="":$S(qqoQu="XQuery":query,1:qqoQu_":"_query),1:%1)
 .S XQDoBeg=$G(^Q(1,qqoQu,query,"XQDoBeg"))
 .S XQDoEnd=$G(^Q(1,qqoQu,query,"XQDoEnd"))
 .;I '$D(find),$G(^Q(1,qqoQu,query,"XQfind")) S find=1
 .I '$D(find) S find=$G(^Q(1,qqoQu,query,"XQfind"))_" "_$G(^Q(1,qqoQu,query,"xRel"))_" "_$G(^Q(1,qqoQu,query,"X189"))
 .I '$D(anal),$G(^Q(1,qqoQu,query,"XQanal")) S anal=1
 .I '$D(diag),$G(^Q(1,qqoQu,query,"XQdiag")) S diag=1,diagfile=$G(^Q(1,qqoQu,query,"XQdiagFile"))
 .I ($G(print)="1")||(('$D(print))&&($G(^Q(1,qqoQu,query,"XQprint")))) S print=$G(^Q(1,qqoQu,query,"XQprintView")),nprint=$G(^Q(1,qqoQu,query,"XQNprint")) ; T.D.V 06.03.03 - добавлено $G(print)="1", убран OpenPrint
 .I '$D(cond) S cond=$G(^Q(1,qqoQu,query,"XQcond"))
 .I ($G(open)="1")||(('$D(open))&&($G(^Q(1,qqoQu,query,"XQopen")))) S open=$G(^Q(1,qqoQu,query,"XQopenView")) ; T.D.V 06.03.03 - добавлено $G(open)="1", убран OpenPrint
 I $G(viewquery)="" D  I 1 ;D qARM.RestView(query) I 1
 .S QuEnd=1
 .S Vt(qqnump,"CondFind")=$G($$$CondFind,"") ;@dol 11.06.02 - для сохранения сортировки
 .K Vt(qqnump,"Vs",3) M Vt(qqnump,"Vs",3)=Vs(qqnump,3)
 .K Vs(qqnump) M Vs(qqnump)=^Q(1,qqoQu,query,"XObjStat")
 .K Vt(qqnump,0) M Vt(qqnump,0)=Vs(qqnump,"Vt") ;учет постоянных условий наследуется
 .;S W("Zadm")=+$G(Vs(qqnump,"Zadm")) ;режим администратора наследуется печатной формой
 .S W("ZBtred")=+$G(Vs(qqnump,"ZBtred"))
 .S $$$ReFind=$G($$$ReFind,0)
 .S $$$RelNum=$G($$$RelNum,0)
 .S qqc=$G($$$ID,"")
 .S $$$Relind=$G($$$Relind,0)
 .S $$$CurObj=$G($$$CurObj,"")
 .S $$$CondFind=$G($$$CondFind,"")
 .S:$$$CondFind'="" $$$CondFind=" "_$P($$$CondFind," ",2,6)_"  "_$P($$$CondFind," ",8,11),$P($$$CondFind," ",5)="" ;востановим старый контекст убрав упорядоченность
 .;S:$G(^Q(1,qqoQu,query,"XQanalView"))'="" W("Zar")=^("XQanalView")
 E  D
 .N qviewpre,qviewpre1,qviewpre2 S qviewpre=$G(qview) I qviewpre'="",$P($G(find)," ",3) N qviewpr1,qviewpr2 S qviewpr1=$G($$$Relind),qviewpr2=$G($$$ReFind) ;@dol 9.02.04
 .D ..OpenPrint(,,0,,,$P(viewquery," ")_" "_quser,"Q"_$P(viewquery," ",2)) S $$$ReFind=0
 .I qviewpre'="",$P($G(find)," ",3) D  ;@dol 29.11.02 Наследование релевантных
 ..;S qview=qviewpre,$$$Relind=+$G(Vs($P(qqParent," ",2),"Relind")),$$$ReFind=+$G(Vs($P(qqParent," ",2),"ReFind"))
 ..S qview=qviewpre,$$$Relind=+qviewpr1,$$$ReFind=+qviewpr2 ;@dol 9.02.03
 S:$G(^Q(1,qqoQu,query,"XQanalView"))'="" W("Zar")=^("XQanalView")
 K XQpars,XQparo I $G(^Q(1,qqoQu,query,"XQmod"))'="" D qSYS.SetVsLst("par",1,^("XQmod")) M XQpars=Vs("par") ;список зачеркнутых объектов
 I $G(anal),$G(W("Zar"))'="",$D(^Qa(W("Zar"),"Xc")),$S('$D(print):1,1:print=W("Zar")),$S('$D(open):1,1:open=W("Zar")) K:$G(^Q(1,qqoQu,query,"XQFanalView")) ^Qa(W("Zar"),"Xc") I '$G(^Q(1,qqoQu,query,"XQFanalView")) D qARM.Question("Вывести результаты от "_$ZDT(qW.zCnv(0,^Qa(W("Zar"),"Xc")),4),1,"K ^Qa(W(""Zar""),""Xc"") D qWEB.Query("""_query_""")","D qWEB.QueryAr("""_W("Zar")_""","_$D(diag)_","_$D(print)_","_$D(open)_","_$G(nprint)_","_$G(diagfile)_")") Q:$Q "" Q
 I $G(^Q(1,qqoQu,query,"XQ8copy")),$P($G(Vt(qqnump,"Zparent"))," ",2)'="" M Vs(qqnump,8)=Vs($P(Vt(qqnump,"Zparent")," ",2),8) ;копирование поискового образа из отбражения вызова (чтобы он напечатался при выводе диагаммы в приемник-Word)
 I $G(XQDoBeg)'="" N qqend D  I $G(qqend)=1 Q:$Q 1 Q
 .D qARM.Value(XQDoBeg,"X") Q:$G(qqend)=1  M XQparo=Vo("par"),XQpars=Vs("par") K Vo("par"),Vs("par")

 S Vs(qqnump,"UserPar","QueryCode")=$S(qqoQu="XQuery":query,1:qqoQu_":"_query) ; @Dol 18.03.08 T.D.V 26.02.03 Cохранили код запроса
 S Vs(qqnump,"XQDoFind")=$G(^Q(1,qqoQu,query,"XQDoFind")) ;@Dol 11.01.10 действие перед поиском 
 I $G(cond)'="" D qARM.OpenWindow(,,"200,100,0,11,,1,,,,,3",,,"###sysL") Q:$Q "" Q  ;11 1 ;;@dol передача через cond (см. qSYS.SysView() );"###sysL"_$TR(cond," ","_") - было ;@Dol 06.10.08 "200,100,0,11,,,30,40,,,3"
QueryCont ;точка для продолжения
 M Vo("par")=XQparo,Vs("par")=XQpars K XQpars,XQparo
 I $G(Vs(qqnump,"XQDoFind"))'="" X $TR(Vs(qqnump,"XQDoFind"),$C(13,10),"  ") ;@Dol 11.01.10 действие перед поиском
 I $TR($G(find)," ")'="" Q:..QueryVs8()&find&$Q "" Q:..QueryVs8()&find  D  S:QuEnd QuEnd=10 ;I '$$$RelNum Q "" ;??????;@dol 26.11.02 $Tr и &find - иначе не выполнялся
 .D:$D(^Q($$$Relind_qview))>1
 ..I '$P(find," ",2) K ^Q($$$Relind_qview) S $$$ReFind=0,$$$RelNum=0 Q  ;сброс релевантных ;@dol 9.03.04 $$$RelNum=1
 ..S $$$ReFind=$S($P(find," ",2)=1:0,$P(find," ",2)=2:1,1:0),$$$RelNum=1 ;режим выбор/уточнение
 .I find K:0 Vs(qqnump,808) S %1=qW.qFind(+$G(Vs(qqnump,99,"Find")),+$G(Vs(qqnump,99,"Find",2)),qARM.FindAll()) D  ;@dol 1.12.04 K Vs(qqnump,808) - условия по всем объектам
 ..I (+%1'=%1)&&(notmess'=1) D qARM.Message("Ошибка в условии: "_%1,"Запрос")
 ..S $$$RelNum=''%1
 .;S:$$$RelNum $$$ReFind=1 ;если было уточнение???
 .S $$$ReFind=$$$RelNum ;@dol 15.09.03 если было уточнение и ничего не найдено ???;;@dol 30.1.04 S:$$$ReFind
 .I $G(Vs(qqnump,"XEndFind"))'="" X Vs(qqnump,"XEndFind") ;@Dol 06.11.09 действие после поиска
 I $G(anal),$S($G(find):$$$RelNum,1:1) D  S:QuEnd QuEnd=QuEnd+100
 .I '$D(Vs(qqnump,12)) D:notmess'=1 qARM.Message("Не определен аналитический срез","Запрос") Q
 .I qW.qAnal($G(Vs(qqnump,99,"Anal",0)),+$G(Vs(qqnump,99,"Anal")),,$G(Vs(qqnump,99,"Anal",1)),,$G(Vs(qqnump,99,"Anal",2))),notmess'=1 D qARM.Message("Нет значений по заданной аналитике","Запрос") ;не было последних
 I QuEnd D
 .D qARM.wcro(),qARM.MenuAn("AFD")
 .I QuEnd#100=10 D  ;????был поиск
 ..D:$$$RelNum qARM.wfot(-2)
 ..I '$$$RelNum S qqo=$$$CurObj,qqc=$G($$$ID),$$$CondFind=$G(Vt(qqnump,"CondFind")) M Vs(qqnump,3)=Vt(qqnump,"Vs",3) ;@dol 17.12.03 чтобы не испортить дерево выбора
 ..I $$$RelNum S qqc="" I $G($$$CurObj)'="",'$D(^Q($$$Relind_qview,$$$CurObj)) S $$$CurObj="" 
 ..D:$E($G(W("Zsform")))'=1 qARM.wP(qwin_".TBC.b401","Down",''$$$RelNum),qARM.wP(qwin_".TBC.b402","Down",'$$$RelNum)
 .;D:QuEnd>100 qARM.wcrm("200_1",1,"",''$D(^Q("A"_qview))!($D(Vs(qqnump,12))>1))
 .I QuEnd>100,query'[":",qARM.GetPar("X127")'="--" D qARM.wcrm("200_1",1,"",''$D(^Q("A"_qview))!($D(Vs(qqnump,12))>1)) ;@Dol 12.10.09
 .I $G(W("Zosrt"))'="" D   ;@dol 11.06.02 - для сохранения сортировки
 ..I '$D(^Q($$$Relind_qview,W("Zosrt"))) K W("Zosrt") D qARM.wbut(2) Q
 ..S $$$CondFind=$G(Vt(qqnump,"CondFind")),$$$CurObj=W("Zosrt"),$P($$$CondFind," ",5)="" K W($P($$$CondFind," ")) D:$$$ReFind qW.RelWoc($P($$$CondFind," "),W("Zosrt")) ;D:0 qARM.wfot(W("Zosrt"))
 .D qARM.wcre()
 ;
 I $G(XQDoEnd)'="" N qqend D qARM.Value(XQDoEnd,"X") I $G(qqend) Q:$Q 1 Q
 I $G(find),'$$$RelNum D:(notmess'=1) qARM.Message("Ничего не найдено") Q:$Q 1 Q
 I $G(diag) D  ;ошибки???
 .I '$G(Vs(qqnump,13,"R")) D qARM.OpenCFX(,,,,$G(^Q(1,qqoQu,$S($G(query)="":"---",1:query),"XQName"))) Q
 .I (+$G(Vs(qqnump,13,"R"))=7) D qARM.OpenCFXNEW(,,,,$G(^Q(1,qqoQu,$S($G(query)="":"---",1:query),"XQName"))) Q  //@AKA 08.02.2011
 .I +Vs(qqnump,13,"R")=5 D qARM.OpenOC() Q  ;диаграмма Objective Chart
 .I +$G(Vs(qqnump,13,"R"))=1 S %1=qWEB.DiagVRML(,,,$P(Vs(qqnump,13,"R")," ",2)) Q
 .S %1=qWEB.Diag(Vs(qqnump,13,"R"),,$G(diagfile),$G(OpenFile))  ; tdv 20100901 - добавлен OpenFile
 .;D:%1'="" qARM.Message(%1) Q ""
 ;@dol 19.11.03 далее изменен $P(view," ") на Vo(qqnump)
 I $D(print)&&($G(print)'="0") S:print="" print=Vo(qqnump) D qARM.SaveView(1,"",print) D
 .I $G(^Q(1,qqoQu,query,"XQNpr320")) D qARM.MenuWoc("XU320","x320",qARM.GetPar("x320",$P(print," ")),1,"D qWEB.Print($J,"""_$S('$D(nprint):$G(^Q(1,qqoQu,query,"XQNprint")),1:$G(nprint))_""",$E(qqchoice,7),"""_$G(OpenFile)_""","""_$G(qqdev)_""")") Q  ;@Dol 25.02.05 - вопрос о приемнике
 .D ..Print($J,$S('$D(nprint):$G(^Q(1,qqoQu,query,"XQNprint")),1:$G(nprint)),,$G(OpenFile),$G(qqdev)) ; T.D.V 06.03.03 - добавлено $G(print)="0", убран OpenPrint; T.D.V 15.10.03 - добавлены OpenFile, qqdev
 I $D(open)&&($G(open)'="0") S:open="" open=Vo(qqnump) S:$P($G(find)," ",3) Vo("par",-1,89)=1 D qARM.OpenWindow(,,,,0,open) ;автоматическое наследование перечня релевантных ; T.D.V 06.03.03 - добавлено $G(open)="0", убран OpenPrint
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="QueryAr">
<Internal/>
<FormalSpec>Arg1:%Library.String,diag:%Library.String,print:%Library.String,open:%Library.String,nprint:%Library.String,diagfile:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 D ..OpenPrint(,,0,,,Arg1_" #","Q")
 I $G(diag) D  ;ошибки???
 .I '$G(Vs(qqnump,13,"R")) D qARM.OpenCFX() Q
 .I (+$G(Vs(qqnump,13,"R"))=7) D qARM.OpenCFXNEW() Q  //@AKA 08.02.2011
 .I +Vs(qqnump,13,"R")=5 D qARM.OpenOC() Q  ;диаграмма Objective Chart
 .I +$G(Vs(qqnump,13,"R"))=1 S %1=qWEB.DiagVRML(,,,$P(Vs(qqnump,13,"R")," ",2)) Q
 .S %1=qWEB.Diag(Vs(qqnump,13,"R"),,$G(diagfile))
 .;D:%1'="" qARM.Message(%1) Q ""
 I $G(print) D qARM.SaveView(1,"",Arg1),..Print($J,$G(nprint))
 I $G(open) D qARM.OpenWindow(,,,,0,Arg1)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="QueryCon">
<Description>
Действие по кнопке выхода из собственной формы задания диалоговых условий для продолжения выполнения запроса.
Действии по входу в запрос: Do qARM.OpenWindow(,,,,,свое_отображение) Set qqend=1

Для собственной экранной формы задания диалоговых условий необходимо определить
Действие по входу: Do qWEB.QueryCon(1) ;происходит формирование в qqQueryCon вызова продолжения запроса
По кнопке выполнения запроса: свои действия Do qWEB.QueryCon() ;вызов продолжения и выход
По кнопке отказа: Set qqend=1

Локальная среда запроса доступна через $P(Vt(qqnump,"Zparent")," ",2) или через Vs("Q") - если задано в описании запроса %Отображение запроса.</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Arg1) S qqQueryCon="qWEB.Query(1,"""_$G(viewquery)_""","""_($G(find))_""","_(+$G(anal))_","_(+$G(diag))_$S($D(print):","""_print_"""",1:",")_",,,"_$S($D(open):""""_open_"""",1:"")_","_$G(notmess)_","_$G(OpenFile)_","_$G(qqdev)_")" Q:$Q "" Q  ;T.D.V 27.03.2003 - добавлен notmess; 15.10.2003 - добавлены OpenFile,qqdev
 D qARM.WrWin("",0,"",qqQueryCon) S:$D(qwin("Q0")) qqend=1
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="QueryExt">
<Internal/>
<FormalSpec>viewquery:%Library.String,find:%Library.String,anal:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qSYS,qW,qUSER,qARM ;класс %qWEB иницилизируется в программе %ZMGW2
 S qSYS=##class(%qSYS).%New()
 S qW=##class(%qWORD).%New()
 S qARM=##class(%TqARM).%New()
 X "S qUSER=##class(qUSER).%New()"
 ;
 D ..Init()
 ;
 D ..OpenPrint(,1,,,,viewquery,"Q")
 S $$$ReFind=0,Vs(qqnump,99,"Pic")=1 ;картинки на всякий случай
 I $G(find)'="" Q:..QueryVs8()&$Q "" Q:..QueryVs8()  D
 .D:$D(^Q($$$Relind_qview))>1
 ..I '$P(find," ",2) K ^Q($$$Relind_qview) S $$$ReFind=0 Q  ;сброс релевантных
 ..S $$$ReFind=$S($P(find," ",2)=1:0,$P(find," ",2)=2:1,1:0) ;режим выбор/уточнение
 .I find S $$$RelNum=qW.qFind(+$G(Vs(qqnump,99,"Find")),+$G(Vs(qqnump,99,"Find",2)),qARM.FindAll()),$$$RelNum=$D(^Q($$$Relind_qview))>1
 .S $$$ReFind=''$$$RelNum ;@dol 15.09.03 если было уточнение???
 I $G(anal) D
 .D qW.qAnal($G(Vs(qqnump,99,"Anal",0)),+$G(Vs(qqnump,99,"Anal")),,$G(Vs(qqnump,99,"Anal",1)),,$G(Vs(qqnump,99,"Anal",2))) ;не было последних
 S $$$ID=qqc ;K ^Q("V"_qview,"XObjStat") M ^Q("V"_qview,"XObjStat")=Vs(qqnump) ;временно для отладки
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="QueryFix">
<Description>
Для преддействия Запроса.
Метод устанавливает фиксацию на заданный объект (Arg1-код объекта). Код экземпляра - текущий в отображении вызова запроса.</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S ($$$ID,qqc)=$E(Vs($P(qqParent," ",2),"ID"),1,$$$ObjLqqc(Arg1)),Vs(qqnump,7)=Arg1,$P($$$CondFind," ",10)=qqc
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="QueryVs8">
<Description>
Проверка наличия условий поискового образа (возвращает 1, если нет).</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 Q:'$D(Vs(qqnump,8)) 1
 N qqo,qqw,qqq S qqq=0,qqo="" F  Q:qqq  S qqo=$O(Vs(qqnump,8,qqo)) Q:qqo=""  S qqw=""  F  S qqw=$O(Vs(qqnump,8,qqo,qqw)) Q:qqw=""  S qqq=$G(Vs(qqnump,8,qqo,qqw))'="" Q:qqq
 Q 'qqq
]]></Implementation>
</Method>

<Method name="QueryWeb">
<Description>
Отработка запросов через WebLink.
Массив ^Q(view_" "_quser,"XObjStat") должен быть заполнен.
Параметры:
viewquery=view_" "_quser - код отображения и код пользователя
xsl = 1 - выдача полного XSL отображения и выход (XObjStat не обязательно заполнять)
find =1 - выполнить поиск по поисковому образу
anal =1 - просчитать аналитику
diag=1 - вывести VRML диаграммы и выход
Num - выводимое число экземпляров объектов

Выводится полный (!!! не смотря на состояние отображения) XML.</Description>
<Internal/>
<FormalSpec>viewquery:%String,xsl:%String,find:%String,anal:%String,diag:%String,Num:%String=100</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 ;N qSYS,qW,qUSER,qARM ;класс %qWEB иницилизируется в программе %ZMGW2
 ;S qSYS=##class(%qSYS).%New()
 ;S qW=##class(%qWORD).%New()
 ;S qARM=##class(%TqARM).%New()
 ;
 D ..Init()
 ;
 D ..OpenPrint(,1,,,,viewquery,"W")
 S $$$ReFind=0
 I $G(xsl) D ..XSL(0,1,1,1) Q:$Q "" Q  ;полный XSL браузера
 I $G(find) Q:..QueryVs8()&$Q "" Q:..QueryVs8()  D
 .K ^Q($$$Relind_qview) S $$$RelNum=qW.qFind(+$G(Vs(qqnump,99,"Find")),+$G(Vs(qqnump,99,"Find",2)),,""),$$$RelNum=$D(^Q($$$Relind_qview))>1
 .S:$$$RelNum $$$ReFind=1 ;если было уточнение???
 I $G(anal) D
 .D qW.qAnal($G(Vs(qqnump,99,"Anal",0)),+$G(Vs(qqnump,99,"Anal")))
 S $$$ID=qqc K ^Q("V"_qview,"XObjStat") M ^Q("V"_qview,"XObjStat")=Vs(qqnump) ;временно для отладки
 I $G(diag) D  W:%1'="" !,%1 Q ""
 .;I '$G(Vs(qqnump,13,"R")) D qARM.OpenCFX() Q
 .;I Vs(qqnump,13,"R")=5 D qARM.OpenOC() Q  ;диаграмма Objective Chart
 .;I +$G(Vs(qqnump,13,"R"))=1 
 .S %1=qWEB.DiagVRML(,0,,+$P($G(Vs(qqnump,13,"R"))," ",2)) Q
 .;S %1=qWEB.Diag(+Vs(qqnump,13,"R"))
 D ..XML(0,1,1,0,1,0,Num)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="RusU8">
<Description>
метод для перекодировки руских символов в UTF-8 из WIN1251
для построения VRML-диаграмм</Description>
<Internal/>
<FormalSpec>string2:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 ;----метод для перекодировки руских символов в UTF-8 из WIN1251
 ;----------------для построения VRML-диаграмм-------------------
 ;
 S nstr=""
 ;строка кодировки символов для WRML в UTF-8 по2 символа на 1 WIN1251                                    
 S strrus="РђР‘Р’Р“Р”Р•Р–Р—РР™РљР›РњРќРћРџР РЎРўРЈР¤РҐР¦Р§РЁР©РЄР«Р¬Р­Р®РЇР°Р±РІРіРґРµР¶Р·РёР№РєР»РјРЅРѕРїСЂСБС‚СѓС„С…С†С‡С€С‰СЉС‹СЊСЌСЋСЏ"
 S nstr=""
 F i=1:1:$L(string2) D
 .S code=$A(string2,i) ;                      определение кода символа
 .S smrus=(code-192)*2+1 ;                 определение смещ кирилицы по отсч с 1-го
 .I smrus<0 S nstr=nstr_$C(code) ;       если ЛАТ (см<0) то код не изменяем
 .E  S nstr=nstr_$E(strrus,smrus)_$E(strrus,smrus+1) ;иначе выбор 2х симв из строки
 .Q  ;                                                    кодировки UTF-8
 Q nstr
 ;Метод написан Николаевым Н А 2000г
 ;----------------------------------------------------------------------------
]]></Implementation>
</Method>

<Method name="SAXXML">
<Description>
Разбор XML документа в ^SAX в области %SYS</Description>
<Internal/>
<FormalSpec>SourceType:%Library.Integer,SourceName:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.Integer</ReturnType>
<Implementation><![CDATA[
 n StrXML s StrXML=""
 n NumEvent s NumEvent=0
 i $g(SourceType)="" s SourceType=2
 i $g(SourceName)="" s SourceName="c:\test.xml"
 n Error s Error=0
 n NumSim s NumSim=0
 n TargetDebug s TargetDebug="^|""%SYS""|SAX("_$J_")" k @TargetDebug
 n XPath s XPath=""
 n NodeType s NodeType=""
 n NodeName s NodeName=""
 n NodePrefix s NodePrefix=""
 n NodeValue s NodeValue=""
 n LevelHier s LevelHier=""
 n ErrorName s ErrorName=""
 n att,Attr,n s att=0
 ;
 n aa,paa,ppaa  ;текущий символ,предыдущий и предпредыдущий
 n T,L,FS,X,N,ee
 n NumInnerEvent 
 n FlagSysAtt,FlagExit
 n RefNode,RefPrefix,CheckPrefix
 n StrXMLLen
 s T="?",L=1,FS=0,X=""
 s N=""
 s FlagSysAtt=0,FlagExit=0
 ; старт разбора XML
 ;k ^Qdebug s ^Qdebug(0)="Разбор внутр.событий"
 i SourceType=0 d
 .i $d(@SourceName)=0 s Error=50 q
 .i $d(@SourceName)#10 s StrXML=@SourceName q
 i SourceType=1 d
 .i $g(%request)="" s Error=51 q
 i SourceType=2 d
 .i $zu(68,40,1) Open SourceName:("RF":250):0 q
 .e  s Error=52 q

 s StrXMLLen=$L(StrXML)
 f  d  q:Error
 .i NumSim<StrXMLLen s NumSim=NumSim+1
 .e  d GetStr s NumSim=1,StrXMLLen=$L(StrXML) i StrXML="" d  q
 ..s Error=1,L=1,att=0,NodeType=100
 ..s NodePrefix="",NodeName="EndOfDocument",NodeValue="",LevelHier=L
 ..d LinearModel q
 .s aa=$e(StrXML,NumSim)
 .i FS=0 s aa=$s($a(aa)<32:" ",1:aa)  ; если FS=1,то $c(9,10,13) сохраняются
 .d SimbolStream

 i Error d ErrorWrite d
 .i SourceType=2 Close SourceName q

 q Error

GetStr 
 i SourceType=0 s SourceName=$q(@SourceName) d  q  ;поузельный разбор глобала
 .i SourceName'="" s StrXML=@SourceName q
 .e  s StrXML="" q
 i SourceType=1 s StrXML=%request.Content.Read(250) q  ; CSP-Stream
 i SourceType=2 Use SourceName d  q  ; построчный разбор файла
 .i $zeof<0 s StrXML="" q
 .e  Read StrXML q
 q

SimbolStream 
 ; aa-принятый очередной символ
 ; Перед каждым вызовом 'Go1' имеем:
 ; T-тип получаемого фрагмента узла
 ; L-уровань иерархии
 ; FS-если FS=1,то $c(9,10,13) сохраняются
 ; X-доп.признак, в каком месте читаем узел
 ; N-имя или значение узла
 ;---------------------------------------
 i T="?" d  q  ; находимся вне тегов
 .i aa=" " q  ; отрезаем ведущие пробелы и пр.
 .i aa=$c(13) q  ;
 .i aa=$c(10) q  ;
 .i aa="<" s T="<",N="",FS=0 q
 .e  s T=3,N="#text" d Go1 s T="s3",N=aa q
 i T="s3" d  q  ; текст
 .i aa="<" d Go1 s T=-3,N="" d Go1 s T="<",N="",FS=0 q
 .e  s N=N_aa q

 i T="<" d  q  ; вошли в тег, либо: закрыв.тег, PI, коментарий, CDATA, DTD, откр.тег
 .i aa=" " q
 .i aa="/" s L=L-1,T=-1,N="" q
 .i aa="?" s T=7,X="N",N="" q
 .i aa="!" s T="!",N="" q
 .e  s T=1,X="N",N=aa q
 i T=-1 d  q  ; закрыв.тег (или закрытие пустого тега, тогда N="")
 .i aa=" " q
 .i aa=">" d Go1 s T="?",N="",FS=1 q  ;
 .e  s N=N_aa q
 i T=1,X="N" d  q  ; откр.тег или пустой тег
 .i aa=">" d Go1 s T=0,N="" d Go1 s L=L+1,T="?",N="",FS=1 q
 .i aa="/" d Go1 s T=0,N="" d Go1 s T=-1 q
 .i aa=" " d Go1 s T=1,X="?" q
 .e  s N=N_aa q
 i T=1,X="?" d  q  ; внутри откр.тега возможно есть атрибуты, а возм.нет
 .i aa=" " q
 .i aa=">" s T=0,N="" d Go1 s L=L+1,T="?",N="",FS=1 q
 .i aa="/" s T=0,N="" d Go1 s T=-1 q
 .e  s L=L+1,T=2,X="N",N=aa q

 i T=2,X="N" d  q  ; атрибут со значением, а возможно без
 .i aa=" " d Go1 s T=-2,N="" d Go1 s L=L-1,T=1,X="?" q
 .i aa="/" d Go1 s T=-2,N="" d Go1 s L=L-1,T=0,N="" d Go1 s T=-1 q
 .i aa=">" d Go1 s T=-2,N="" d Go1 s L=L-1,T=0,N="" d Go1 s L=L+1,T="?",N="",FS=1 q
 .i aa="=" d Go1 s T=2,X="?" q
 .e  s N=N_aa q
 i T=2,X="?" d  q  ; атрибут с неизвестной кавычкой у значения
 .i aa=" " q
 .i aa="""" s T="s2",X="q",N="",FS=1 q
 .i aa="'" s T="s2",X="a",N="",FS=1 q
 .e  s Error=102 q
 i T="s2",X="q" d  q  ;атрибут с кавычкой, вошли внутрь значения
 .i aa="""" d  q
 ..d Go1
 ..s T=-2,N="" d Go1 s L=L-1,T=1,X="?",N="",FS=0
 .e  s N=N_aa q
 i T="s2",X="a" d  q  ; атрибут с апострофом, вошли внутрь значения
 .i aa="'" d  q
 ..d Go1
 ..s T=-2,N="" d Go1 s L=L-1,T=1,X="?",N="",FS=0
 .e  s N=N_aa q

 i T=7,X="N" d  q  ; PI
 .i aa=" " d Go1 s T="s7",X=7,N="",paa="" q
 .e  s N=N_aa q
 i T="s7",X=7 d  q  ; PI
 .i aa=">",paa="?" d Go1 s T=-7,N="" d Go1 s T="?",N="",FS=1 q
 .e  s N=N_paa,paa=aa q
 i T="!" d  q  ; либо: коментарий, CDATA, DTD
 .i aa=" " d  q
 ..i N="DOCTYPE" s T=10,N="" q
 ..i N="ENTITY" s T=6,N="" q
 ..i N="NOTATION" s T=12,N="" q
 .i aa="-" s T="-" q
 .i aa="[" s T=4,X="N",N="" q
 .e  s N=N_aa q

 i T=10 d  q
 .i aa=" ",N="" q
 .i aa=" " d Go1 s T="s10",N="" q
 .e  s N=N_aa q
 i T="s10" d  q
 .i aa="[" d Go1 s L=L+1,T="?",N="" q
 .i aa=">" d Go1 s T=-10,N="" d Go1 s T="?",N="",FS=1 q
 .e  s N=N_aa q
 i T=6 d  q
 .i aa=" ",N="" q
 .i aa=" " d Go1 s T="s6",N="",FS=1 q
 .e  s N=N_aa q
 i T="s6" d  q
 .i aa=">" d Go1 s T=-6,N="" d Go1 s T="?D",N="",FS=0 q
 .e  s N=N_aa q
 i T=12 d  q
 .i aa=" ",N="" q
 .i aa=" " d Go1 s T="s12",N="" q
 .e  s N=N_aa q
 i T="s12" d  q
 .i aa=">" d Go1 s T=-12,N="" d Go1 s T="?D" q
 .e  s N=N_aa q
 i T="?D" d  q
 .i aa=" " q
 .i aa="<" s T="<",N="" q
 .i aa="]" s L=L-1,T=-10,N="" q
 .e  s Error=103 q
 i T=-10 d  q
 .i aa=">" d Go1 s T="?",N="",FS=1 q
 .e  s Error=103 q
 i T="-" d  q  ; либо: коментарий, ошибка     
 .i aa="-" s T=8,X="N",N="#comment" d Go1 s T="s8",X=8,N="",paa="",ppaa="",FS=1 q
 .e  s Error=105 q
 i T="s8",X=8 d  q  ; коментарий
 .i aa=">",paa="-",ppaa="-" d Go1 s T=-8,N="" d Go1 s T="?",N="",FS=1 q
 .e  s N=N_ppaa,ppaa=paa,paa=aa q
 i T=4,X="N" d  q  ; CDATA
 .i aa="[" s N="#cdata" d Go1 s T="s4",X=4,N="",paa="",ppaa="",FS=1 q
 .e  s N=N_aa q
 i T="s4",X=4 d  q  ; CDATA
 .i aa=">",paa="]",ppaa="]" d Go1 s T=-4,N="" d Go1 s T="?",N="",FS=1 q
 .e  s N=N_ppaa,ppaa=paa,paa=aa q
 q

Go1 
 ;  'Go1' вызывается когда установлен какой-либо фрагмент узла;
 ;  его содержимое (имя или значение) находится в 'N'
 ;  'T' -тип узла согласно номерам типов MS DOM с дополнениями, 'X'-неважно
 ;  'FS' -если =1, то символы $c(9,10,13) пропускаются, =0, то замен.на пробелы
 ;T=1 -открывающий тег элемента. 
 ;T=0 -закрытие открывающего тега, пустого или нет.
 ;T=-1 -закрывающий тег(N'="") или закрытие пуст.тега(N="") элемента.
 ;T=2,T=-2 - "открытие" и "закрытие" атрибута.
 ;T=3,T=-3 - ...текстового узла.
 ;T=4,T=-4 - ...неразбираемых данных (CDATA).
 ;T=7,T=-7 - ...инструкций процессору (PI).
 ;T=8,T=-8 - ...коментария.
 ;T=10,T=-10 - ...опр.типа документа (DTD).
 ;T=12,T=-12 - ...нотации.
 ;T=6,T=-6 - ...компонент .
 ;
 ;T="s2",T="s3",T="s7",T="s8",T="s4",T="s10",T="s12",T="s6"
 ; -строка значения узлов типа 2,3,7,8,4,10,12,6
 ;i (T=5)!(T=9)!(T=11) q  ; здесь не обрабатываем
 ;d  ; для просмотра внутренних событий парсера
 ;.s NumInnerEvent=$o(^Qdebug(""),-1)+1
 ;.s ^Qdebug(NumInnerEvent,"L")=L
 ;.s ^Qdebug(NumInnerEvent,"T")=T
 ;.s ^Qdebug(NumInnerEvent,"N")=N
 ;.s ^Qdebug(NumInnerEvent)=""
 i (T=1)!(T=-1)!(T=2)!(T=7)!(T=10)!(T=6)!(T=12) d CheckName q:Error

 ; обработка системных xml-атрибутов:
 ; намспейсов,         
 ;------------------------------------------------------------
 ;
 i T=2 d  q  ; атрибут
 .s att=att+1 ; и обычные атрибуты, и системные
 .i $p(N,":",1)="xmlns" d  q  ; обр. нового намспейса
 ..s Attr(att,"Prefix")="xmlns",Attr(att,"Name")=$p(N,":",2)
 ..i Attr(att,"Name")="" s Attr(att,"Name")="@"
 ..s RefPrefix(Attr(att,"Name"))=L-1
 .i $L(N,":")=1 s Attr(att,"Prefix")="@",Attr(att,"Name")=N
 .e  s Attr(att,"Prefix")=$p(N,":",1),Attr(att,"Name")=$p(N,":",2)
 i T="s2" d  q
 .s Attr(att,"Value")=N

 i T=1 d  q  ; элемент
 .i XPath="" s XPath=N
 .e  s $p(XPath,"/",$L(XPath,"/")+1)=N
 .s n="" f  s n=$o(RefPrefix(n)) q:n=""  i L'>RefPrefix(n) k RefPrefix(n)
 i T=0 d  q
 .s N=$p(XPath,"/",L)
 .i $L(N,":")=1 s NodePrefix="@",NodeName=N
 .e  s NodePrefix=$p(N,":",1),NodeName=$p(N,":",2)
 .i $g(RefPrefix(NodePrefix))="" s Error=108 q
 .n n f n=1:1:att i Attr(n,"Prefix")'="xmlns",$g(RefPrefix(Attr(n,"Prefix")))="" s Error=109 q  ;неивестный префикс
 .i Error q
 .s NodeType=1,LevelHier=L
 .d LinearModel 
 .k Attr s att=0 q
 i T=-1 d  q  ; проверка совпадения имен откр.и закр.тегов для элементов
 .i N'="",$p(XPath,"/",L)'=N s Error=107 q
 .s XPath=$p(XPath,"/",1,L-1)

 i (T=3)!(T=4)!(T=8)!(T=6)!(T=7)!(T=10)!(T=12) d  q
 .i $L(N,":")=1 s NodePrefix="",NodeName=N
 .e  s NodePrefix=$p(N,":",1),NodeName=$p(N,":",2)
 .s NodeType=T q

 i (T="s3")!(T="s4")!(T="s8")!(T="s6")!(T="s7")!(T="s10")!(T="s12") d  q
 .s NodeValue=N,LevelHier=L d LinearModel q

 i (T=-3)!(T=-4)!(T=-8)!(T=-6)!(T=-7)!(T=-10)!(T=-12) q
 q

CheckName 
 ; проверка символов в имени
 n n,Sim,SimC
 f n=1:1:$L(N) d  q:Error
 .s Sim=$e(N,n),SimC=$a(Sim)
 .i n=1 d  i 1
 ..i Sim="_" q
 ..i SimC<48 s Error=106 q
 ..i SimC>47,SimC<58 s Error=106 q  ; это цифры
 ..i SimC>57,SimC<65 s Error=106 q
 ..i SimC>90,SimC<97 s Error=106 q
 ..i SimC>122,SimC<191 s Error=106 q
 .e  d
 ..i (Sim=".")!(Sim="-")!(Sim="_")!(Sim=":") q
 ..i SimC<48 s Error=106 q
 ..i SimC>57,SimC<65 s Error=106 q
 ..i SimC>90,SimC<97 s Error=106 q
 ..i SimC>122,SimC<191 s Error=106 q
 i Error s N=$e(N,1,n-1)_"{???}"_$e(N,n,$L(N))
 q
LinearModel 
 ; линейная модель
 n n,nn
 s NumEvent=NumEvent+1
 d
 .f n=L:1 q:$g(RefNode(n))=""  d
 ..s @TargetDebug@(RefNode(n))=NumEvent k RefNode(n)
 .s RefNode(L)=NumEvent
 s @TargetDebug@(NumEvent)=""
 s @TargetDebug@(NumEvent,"LevelHier")=LevelHier
 s @TargetDebug@(NumEvent,"NodeType")=NodeType
 s @TargetDebug@(NumEvent,"NodePrefix")=NodePrefix,NodePrefix=""
 s @TargetDebug@(NumEvent,"NodeName")=NodeName,NodeName=""
 s @TargetDebug@(NumEvent,"NodeValue")=NodeValue,NodeValue=""
 s @TargetDebug@(NumEvent,"Attr")=att
 i NodeType=1 f n=1:1:att d  s NodeType=""
 .s @TargetDebug@(NumEvent,"Attr",Attr(n,"Prefix"),Attr(n,"Name"))=Attr(n,"Value")
 q

ErrorWrite 
 i Error=1 q  ;s ErrorName="Конец данных, чтение успешно завершено." q
 i Error=50 s ErrorName="Нет переменной "_SourceName
 i Error=51 s ErrorName="Нет объекта %request"
 i Error=52 s ErrorName="Проблема с файлом "_SourceName
 i Error=102 s ErrorName="Синтаксис. Ожидалась кавычка."
 i Error=103 s ErrorName="Синтаксис. Ожидалась скобка."
 i Error=105 s ErrorName="Синтаксис. Ожидалось тире."
 i Error=106 s ErrorName="Синтаксис. Недопустимый символ в имени "_N
 i Error=107 s ErrorName="Ожидался закрывающий тег </"_$p(XPath,"/",L)_">, а появился </"_N_">"
 i Error=108 s ErrorName="Неизвестный префикс узла '"_NodePrefix_"'"
 i Error=109 s ErrorName="Неизвестный префикс атрибута '"_Attr(att,"Prefix")_"'"
 s StrXML=$e(StrXML,1,NumSim-1)_"{???}"_$e(StrXML,NumSim)_"{???}"_$e(StrXML,NumSim+1,StrXMLLen)
 s @TargetDebug@("Error")=Error
 s @TargetDebug@("ErrorName")=ErrorName
 s @TargetDebug@("StrXML")=StrXML
 q

NextCode(LastCode)  
 ;выдает следующий код для экземпляра 'qqc'
 n n,s,Flag,Str
 s s=$L(LastCode) f n=1:1:s s s(n)=$e(LastCode,n)
 s n=s,s(0)="",Flag=0
 f  d  q:Flag
 .i s(n)="" s s(n)="A",Flag=1 q
 .i s(n)="Z" s s(n)="a",Flag=1 q
 .i s(n)'="z" s s(n)=$c($a(s(n))+1),Flag=1 q
 .s s(n)="A",n=n-1 q
 s Str="" f n=0:1:s s Str=Str_s(n)
 q Str
]]></Implementation>
</Method>

<Method name="SOAP">
<Description>
Разборка SOAP документа, предварительно разобранного SAXXML в ^SAX области %SYS</Description>
<Internal/>
<FormalSpec>SourType:%Library.Integer,SourName:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; разборка SOAP
 ; 
 n event,n
 n NN,NT,NV,NP,A,PrefArr
 n S,PrefRoot
 n UserCode,TargetType,TargetName
 s TargetType=1 ;SourType  ; 1-тек.устр, 2-файл
 i $g(SourName)'="" s TargetName=$p(SourName,".",1)_"R."_$p(SourName,".",2)
 n saxError,Error,ErrName
 n resultSOAP
 s Error=0
 s S="^|""%SYS""|SAX("_$J_")"


 s saxError=..SAXXML(SourType,SourName)
 ;d BeginWork
 i saxError=1 d root1Node
 i saxError'=1 d
 .d BeginWork
 .w "<env:Fault>"_$c(13,10)
 .w " <env:Code>"_$c(13,10)
 .w "  <env:Value>env:Sender</env:Value>"_$c(13,10)
 .w "  <env:Subcode>"_$c(13,10)
 .w "   <env:Value>rpc:Syntaxis</env:Value></env:Subcode></env:Code>"_$c(13,10)
 .w " <env:Reason>Processing Error</env:Reason>"_$c(13,10)
 .w " <env:Detail>"_$c(13,10)
 .w "  <qw:error qw:code='"_@S@("Error")_"' qw:name='"_@S@("ErrorName")_"'/>"_$c(13,10)
 .w "  <qw:string>"_$c(13,10)_"<![CDATA["_$c(13,10)_$c(13,10)_@S@("StrXML")_$c(13,10)_$c(13,10)_"]]]]><![CDATA[>"_$c(13,10)_"</qw:string></env:Detail></env:Fault>"_$c(13,10)
 i Error d
 .i Error<200 d BeginWork
 .w "<env:Fault>"_$c(13,10)
 .w " <env:Code>"_$c(13,10)
 .w "  <env:Value>env:Sender</env:Value>"_$c(13,10)
 .w "  <env:Subcode>"_$c(13,10)
 .w "   <env:Value></env:Value></env:Subcode></env:Code>"_$c(13,10)
 .w " <env:Reason>Processing Error</env:Reason>"_$c(13,10)
 .w " <env:Detail>"_$c(13,10)
 .w "  <qw:error qw:code='"_Error_"' qw:name='"_ErrName_"'/></env:Detail></env:Fault>"_$c(13,10)
 d EndWork
 q ""

BeginWork       
 i TargetType=2 o TargetName:"WN" u TargetName ; открытие файла на запись
 w "<?xml version='1.0' encoding='windows-1251'?>"_$c(13,10)
 w "<env:Envelope"_$c(13,10)
 w "xmlns:env='http://www.w3.org/2002/06/soap-envelope'"_$c(13,10)
 w "xmlns:qw='http://www.sparm.com/qword_ns/encoding'>"_$c(13,10)
 w "<env:Body>"_$c(13,10)
 q
EndWork 
 w "</env:Body></env:Envelope>"_$c(13,10)
 i TargetType=2 c TargetName
 q

 ; -------------------------------------------------------------------
 ; обход 1-ого уровня иер.и поиск 'Root'

root1Node       
 n e,EndNode s EndNode=$o(@S@(""),-1)
 n Root s Root=""
 s e=1 f  q:(e=EndNode)!(Error)  d  s e=@S@(e)  ; поиск 'Root'
 .s NT=@S@(e,"NodeType")
 .i e=1,(NT'=7)!(@S@(e,"NodeName")'="xml") s Error=151,ErrName="Нет пролога" q
 .i NT=1,Root'="" s Error=152,ErrName="Больше одного корня" q
 .i NT=1 s Root=e
 i Error q
 i Root="" s Error=153,ErrName="Нет корневого тега" q
 d iniVar(Root)
 i NP="env1",NN="Envelope" d env1Node1(Root) q
 i NP="env1" s Error=154,ErrName="имени "_NN_" в пространстве имен env нет" q
 d dataNode(e) q
 q


 ; -------------------------------------------------------------------
 ; обработка узлов пространства имен 'env'

env1Node1(parNode)      ; дети от "Envelope"
 n e s e=parNode+1 f  q:(e=@S@(parNode))!(Error)  d  s e=@S@(e)  ; обход слоя под узлом 'parNode'
 .d iniVar(e)
 .i NT=1,NP="env1",NN="Header" d env1Node2(e) q
 .i NT=1,NP="env1",NN="Body" d BeginWork,env1Node3(e) q
 .i NT=1,NP="env1" s Error=155,ErrName="имени "_NN_" в пространстве имен env нет" q
 q
env1Node2(parNode)      ; дети от "Header"
 n e s e=parNode+1 f  q:(e=@S@(parNode))!(Error)  d  s e=@S@(e)  ; обход слоя под узлом 'parNode'
 .d iniVar(e)
 .i NT=1,NP="env1" q
 .i NT=1,NP="qw1" d  q
 ..s $ec="",$et="d cacheError"
 ..i NN="user" d  q
 ...s UserCode=$g(@A@("code"))
 ..i NN="target" d  q
 ...s TargetType=$g(@A@("type")),TargetName=$g(@A@("name"))
 ..i @A@("MustUnderstand")="yes" s Error=156,ErrName="не обработан обязательный элемент заголовка" q
 q
env1Node3(parNode)      ; дети от "Body"
 n e s e=parNode+1 f  q:(e=@S@(parNode))!(Error)  d  s e=@S@(e)  ; обход слоя под узлом 'parNode'
 .d iniVar(e)
 .i NT=1,NP="env1" q
 .i NT=1,NP="qw1" d  q
 ..s $ec="",$et="d cacheError"
 ..i NN="space" d  q
 ...n id s id="" i $g(@A@("id"))'="" s id=" qw:id='"_@A@("id")_"'"
 ...zn @A@("name")
 ...w "<qw:spaceResp"_id_">"_$c(13,10)
 ...w " <qw:result>Область установлена</qw:result></qw:spaceResp>"_$c(13,10)
 ..i (NN="doc")!(NN="coll") d  q
 ...n id s id="" i $g(@A@("id"))'="" s id=" qw:id='"_@A@("id")_"'"
 ...i $g(@A@("name"))="" s Error=201,ErrName="обязательный атрибут name" q
 ...i $g(@A@("href"))'="" s @(@A@("name"))=@(@A@("href"))
 ...e  s @(@A@("name"))=e+1
 ...w "<qw:docResp"_id_">"_$c(13,10)
 ...w " <qw:result>Документ разобран</qw:result></qw:docResp>"_$c(13,10)
 ..i NN="var" d  q
 ...n id s id="" i $g(@A@("id"))'="" s id=" qw:id='"_@A@("id")_"'"
 ...i $g(@A@("name"))="" s Error=202,ErrName="обязательный атрибут name" q
 ...n CurName s CurName=@A@("name")
 ...i $g(@A@("href"))'="" s @CurName=@(@A@("href"))
 ...i $d(@A@("value"))>0 s @CurName=@A@("value")
 ...d qw1Node1(e,CurName)
 ...w "<qw:varResp"_id_">"_$c(13,10)
 ...w " <qw:result>Переменная создана</qw:result></qw:varResp>"_$c(13,10)
 ..i NN="func" d  q
 ...n id s id="" i $g(@A@("id"))'="" s id=" qw:id='"_@A@("id")_"'"
 ...i $g(@A@("name"))="" s Error=203,ErrName="обязательный атрибут name" q
 ...n st,re,m,Arg s Arg=0,st=@A@("name"),re=$g(@A@("return"))
 ...d qw1Node2(e)
 ...i Arg'=0 s st=st_"("
 ...f m=1:1:Arg s st=st_Arg(m) i m'=Arg s st=st_","
 ...i Arg'=0 s st=st_")"
 ...w "===="_st
 ...i re="" s resultSOAP="Программа выполнена" d @st i 1
 ...e  s resultSOAP="Функция выполнена" s @re=@st
 ...w "<qw:funcResp"_id_">"_$c(13,10)
 ...w " <qw:result>"_resultSOAP_"</qw:result></qw:funcResp>"_$c(13,10)
 ..i NN="obj" d  q
 ...n id s id="" i $g(@A@("id"))'="" s id=" qw:id='"_@A@("id")_"'"
 ...i $g(@A@("name"))="" s Error=204,ErrName="обязательный атрибут name" q
 ...n CurName s CurName=@A@("name")
 ...i $g(@A@("href"))'="" s @CurName=@(@A@("href"))
 ...e  n XX s XX="s "_CurName_"=##class("_@A@("class")_").%New()" x XX
 ...d qw1Node3(e,CurName)
 ...w "<qw:objResp"_id_">"_$c(13,10)
 ...w " <qw:result>Экземпляр класса создан</qw:result></qw:objResp>"_$c(13,10)
 ..i NN="metod" d  q
 ...n id s id="" i $g(@A@("id"))'="" s id=" qw:id='"_@A@("id")_"'"
 ...i $g(@A@("name"))="" s Error=205,ErrName="обязательный атрибут name" q
 ...n st,re,m,Arg s Arg=0,st=@A@("name"),re=$g(@A@("return"))
 ...d qw1Node2(e)
 ...s st=Arg(1)_"."_st
 ...s st=st_"("
 ...f m=2:1:Arg s st=st_Arg(m) i m'=Arg s st=st_","
 ...s st=st_")"
 ...n XX i re="" s resultSOAP="Метод выполнен" s XX="d "_st i 1
 ...e  s resultSOAP="Метод выполнен" s XX="s "_re_"="_st
 ...x XX
 ...w "<qw:metodResp"_id_">"_$c(13,10)
 ...w " <qw:result>"_resultSOAP_"</qw:result></qw:metodResp>"_$c(13,10)
 ..s Error=206,ErrName="имени "_NN_" в пространстве имен qw нет" q
 .i NT=1 s Error=207,ErrName="неизвестное пространство имен" q
 q


 ; -------------------------------------------------------------------
 ; обработка узлов пространства имен 'qw'

qw1Node1(parNode,ParName)       ; дети от 'var'
 n e s e=parNode+1 f  q:(e=@S@(parNode))!(Error)  d  s e=@S@(e)  ; обход слоя под узлом 'parNode'
 .d iniVar(e)
 .i NT=1,NP="qw1" d  q
 ..s $ec="",$et="d cacheError"
 ..i NN="index" d  q
 ...i $g(@A@("name"))="" s Error=208,ErrName="обязательный атрибут 'name'" q
 ...n CurName s CurName=$na(@ParName@(@A@("name")))
 ...i $g(@A@("href"))'="" s @CurName=@(@A@("href"))
 ...i $d(@A@("value"))>0 s @CurName=@A@("value")
 ...d qw1Node1(e,CurName)
 ..s Error=209,ErrName="имени "_NN_" в пространстве имен qw нет" q
 .i NT=1 s Error=210,ErrName="неизвестное пространство имен" q
 q
qw1Node2(parNode)       ; дети от 'func','metod'
 n ee s ee=0
 n e s e=parNode+1 f  q:(e=@S@(parNode))!(Error)  d  s e=@S@(e)  ; обход слоя под узлом 'parNode'
 .d iniVar(e)
 .i NT=1,NP="qw1" d  q
 ..i NN="arg" d  q
 ...s ee=ee+1,Arg=ee
 ...i $g(@A@("href"))'="" s Arg(ee)=@A@("href")
 ...e  s Arg(ee)=""""_$g(@A@("value"))_""""
 ..s Error=211,ErrName="имени "_NN_" в пространстве имен qw нет" q
 .i NT=1 s Error=212,ErrName="неизвестное пространство имен" q
 q
qw1Node3(parNode,ParName)       ; дети от 'obj'
 n e s e=parNode+1 f  q:(e=@S@(parNode))!(Error)  d  s e=@S@(e)  ; обход слоя под узлом 'parNode'
 .d iniVar(e)
 .i NT=1,NP="qw1" d  q
 ..s $ec="",$et="d cacheError"
 ..i NN="prop" d  q
 ...i $g(@A@("name"))="" s Error=213,ErrName="обязательный атрибут 'name'" q
 ...n XX s XX="s "_ParName_"."_@A@("name")_"="
 ...i $g(@A@("href"))'="" s XX=XX_@A@("href")
 ...e  s XX=XX_""""_@A@("value")_""""
 ...x XX
 ..s Error=214,ErrName="имени "_NN_" в пространстве имен qw нет" q
 .i NT=1 s Error=215,ErrName="неизвестное пространство имен" q
 q

 ; -------------------------------------------------------------------
 ; обработка ошибок

cacheError      
 d
 .i $g(NN)="space" d  q
 ..w "<qw:spaceResp"_id_">"_$c(13,10)
 ..w " <qw:cacheError>"_$ec_"</qw:cacheError></qw:spaceResp>"_$c(13,10)
 .i $g(NN)="target" d BeginWork d  q
 ..w "<qw:targetResp>"_$c(13,10)
 ..w " <qw:cacheError>"_$ec_"</qw:cacheError></qw:targetResp>"_$c(13,10)
 .i $g(NN)="doc" d  q
 ..w "<qw:docResp"_id_">"_$c(13,10)
 ..w " <qw:cacheError>"_$ec_"</qw:cacheError></qw:docResp>"_$c(13,10)
 .i $g(NN)="coll" d  q
 ..w "<qw:collResp"_id_">"_$c(13,10)
 ..w " <qw:cacheError>"_$ec_"</qw:cacheError></qw:collResp>"_$c(13,10)
 .i $g(NN)="var" d  q
 ..w "<qw:varResp"_id_">"_$c(13,10)
 ..w " <qw:cacheError qw:type='var'>"_$ec_"</qw:cacheError></qw:varResp>"_$c(13,10)
 .i $g(NN)="index" d  q
 ..w "<qw:varResp"_id_">"_$c(13,10)
 ..w " <qw:cacheError qw:type='index'>"_$ec_"</qw:cacheError></qw:varResp>"_$c(13,10)
 .i $g(NN)="func" d  q
 ..w "<qw:funcResp"_id_">"_$c(13,10)
 ..w " <qw:cacheError qw:type='func'>"_$ec_"</qw:cacheError></qw:funcResp>"_$c(13,10)
 .i $g(NN)="arg" d  q
 ..w "<qw:funcResp"_id_">"_$c(13,10)
 ..w " <qw:cacheError qw:type='arg'>"_$ec_"</qw:cacheError></qw:funcResp>"_$c(13,10)
 .i $g(NN)="obj" d  q
 ..w "<qw:objResp"_id_">"_$c(13,10)
 ..w " <qw:cacheError qw:type='obj'>"_$ec_"</qw:cacheError></qw:objResp>"_$c(13,10)
 .i $g(NN)="prop" d  q
 ..w "<qw:propResp"_id_">"_$c(13,10)
 ..w " <qw:cacheError qw:type='prop'>"_$ec_"</qw:cacheError></qw:propResp>"_$c(13,10)
 .i $g(NN)="metod" d  q
 ..w "<qw:metodResp"_id_">"_$c(13,10)
 ..w " <qw:cacheError qw:type='metod'>"_$ec_"</qw:cacheError></qw:metodResp>"_$c(13,10)
 w "</env:Body></env:Envelope>"_$c(13,10)
 i TargetType=2 c TargetName
 s $ec="",$et=""
 q

iniVar(event)   
 ; инициализация NT,NN,NP,NV,A
 n Pr,SN
 s NT=@S@(event,"NodeType"),NN=@S@(event,"NodeName"),NV=@S@(event,"NodeValue")
 i NT'=1 q  ; ???????????? 
 s SN=$na(@S@(event,"Attr","xmlns"))
 s n="" f  s n=$o(@SN@(n)) q:n=""  d
 .i @SN@(n)="http://www.w3.org/2002/06/soap-envelope" s PrefArr(n)="env1" q
 .i @SN@(n)="http://www.sparm.com/qword_ns/encoding" s PrefArr(n)="qw1" q
 .s PrefArr(n)=n q
 s Pr=@S@(event,"NodePrefix")
 s NP=PrefArr(Pr)        
 s A=$na(@S@(event,"Attr",Pr))       
 q

 ; -------------------------------------------------------------------
 ; обработка узлов данных, произвольного пространства имен 'qw'

dataNode(parNode)       
 q
]]></Implementation>
</Method>

<Method name="SendXML">
<Description>
XSL уже в файле на стороне клиента, XML сформировано по ..write
Пересылка XML-XSL на клиента.
x320=0 - XML
=1 Word
=2 Excel
=3 HTML
=6 txt с ГТ
fileXML - имя файла XML
fileXSL - имя файла XSL или полный путь, если XslAsFile=1
Start =0 просто создать файл (не стартовать)
XslAsFile=1 -путь и имя XSL-файла указаны в параметре fileXSL
=0 - путь к XSL-файлу определяется через qARM("ClientPath")</Description>
<Internal/>
<FormalSpec>qqdev:%String,x320:%String,fileXML:%String,fileXSL:%String,Start:%String=1,XslAsFile:%String=0,qqview:%Library.String=""</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 S:$G(fileXML)="" fileXML=..ClientPath()_"qword."_$S($G(x320)'=6:"xml",1:"txt")
 I fileXML'["." S fileXML=fileXML_$S($G(x320)'=6||($G(x320)'=7):".xml",1:".txt") ;;;;".xml" ;@dol 29.06.04
 I $L(fileXML,"\")=1,$L(fileXML,"/")=1 S fileXML=..ClientPath()_fileXML
 I $G(x320)=6||($G(x320)=7),$P(fileXML,".",2)="xml" S $P(fileXML,".",2)="txt" ;@dol 29.06.04
 // полный путь к xml-файлу без расширения
 N xmlDirFile S xmlDirFile = $P(fileXML, ".",1,$L(fileXML,".")-1)

 I $G(fileXSL)="" S fileXSL=xmlDirFile_".xsl"
 I fileXSL'["." S fileXSL=fileXSL_".xsl"
 I $L(fileXSL,"\")=1,$L(fileXSL,"/")=1 S fileXSL=xmlDirFile_fileXSL
 ;
 ///формирование XML для OOW
 i x320=10 D qARM.OpenIE(qqdev,fileXML,0) q ""
 
 D qARM.OpenIE(qqdev,fileXML,$S('x320:Start,1:0)) Q:'x320||(x320=3)||(x320=6)||(x320=5)||(x320=7) "" ;@dol 22.06.04 - файл (x320=3)
 D:'$D(qwin("TOleXMLDOM"))
 .S qwin("TOleXMLDOM")=1
 .d qARM.wC("TOleXMLDOM","source"),qARM.wP(,"async",0) ;,qARM.wM("source","Load",qARM("ClientPath")_fileXML)
 .d qARM.wC("TOleXMLDOM","stylesheet"),qARM.wP(,"async",0) ;,qARM.wM("stylesheet","Load",qARM("ClientPath")_fileXSL)
 .d qARM.wC("TOleXMLDOM","result"),qARM.wP(,"async",0)
 D:$G(qqXBprwrOp) qARM.wM("docxml","Destroy") K qqXBprwrOp ;@dol 10.11.03
 D qARM.wM("source","Load",fileXML),qARM.wM("stylesheet","Load",fileXSL)
 d qARM.wM("source","TransformNodeToObject","stylesheet","result")
 d qARM.wM("result","Save",xmlDirFile_$S(x320=1:".doc",x320=2:".xls",1:".htm"))
 S:x320=1 %1=..PrintColl(qqview) ; ;обработка коллонтитулов только при выводе в Word
 ;d:Start qARM.Wait("D qARM.wM(""-qARM"",""WinExec"",""start "_qARM("ClientPath")_$P(fileXML,".")_$S(x320=1:".doc",x320=2:".xls",1:".htm")_""",0)") ;-start
 I 'Start Q:$Q "" Q
 N Directory S Directory = $P(fileXML, $S($F(fileXML,"\") '= 0: "\", 1: "/"), 1, $L(fileXML, $S($F(fileXML,"\") '= 0: "\", 1: "/")) - 1)
 ;I '$G(qqXBprwr)||('x320) D qARM.Wait("D qARM.wM(""-qARM"",""ShellExecute"",0,""open"","""_xmlDirFile_$S(x320=1:".doc",x320=2:".xls",1:".htm")_""","""","""_Directory_""",1)") Q:$Q "" Q  ;c:\temp\1 1\ok.doc","","c:",1)
 I '$G(qqXBprwr)||('x320) D qARM.wM("-qARM","ShellExecute",0,"open",xmlDirFile_$S(x320=1:".doc",x320=2:".xls",1:".htm"),"",Directory,1) Q:$Q "" Q  ;c:\temp\1 1\ok.doc","","c:",1)
 D qARM.wC("TOpenDocument","docxml",xmlDirFile_$S(x320=1:".doc",1:".xls")) D:qARM.GetPar("X3642") qARM.wP("docxml","ReadOnly",0) S qqXBprwrOp=x320 Q:$Q "" Q  ;@dol 23.10.06 D:qARM.GetPar("X3696") - разрешение редактирования
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="SendXMLWoc">
<Description>
Выводит словарь в виде XML
qqdev=0 - текущее устройство
="ИмяФайла"
qqlang=1 - русский язык
=3
=5
qorder=1 - прямое направление обхода словаря
=-1 - обратное
zdrl=qqw_" "_НачалЗнач - код понятия, затем пробел, затем строк.выраж. с которой начинать выборку
qqnum=Число - количество выводимых слов
qqt=0 - 
=? -</Description>
<Internal/>
<FormalSpec>qqdev:%String=0,qqlang:%String=1,qorder:%String=1,zdrl:%String,qqnum:%String=1000,qqt:%String=0</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qW,NumWoc S qW=##class(%qWORD).%New()
 D ..OpenDev(qqdev),..write("<?xml version='1.0' encoding='windows-1251'?>")
 D ..write("<Woc>")
 S NumWoc=qW.qWoc(qorder,$P(zdrl," ")_" "_$S(qqnum>$G(^Q(1,"C"_$P(zdrl," "))):"",1:$P(zdrl," ",2))_" "_$P(zdrl," ",3,6),qqnum,qqnum,$G(qqt),"XML")
 D ..write("</Woc>")
 D ..CloseDev(qqdev)
 Q NumWoc
]]></Implementation>
</Method>

<Method name="StartWebXML">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 n Func,Par,PI
 N Job S Job=$J
 K $$$tmpGl(Job) d ..ParserXML("",$NA($$$tmpGl(Job))) ; 15.12.2008 Kokarev
 s PI=$$$tmpGl(Job,2,"v") f n=-1:1:6 s Par(n)=$p(PI,",",n+2)
 ZN Par(0)
 ;инициализация классов
 N qSYS,qW,qUSER,qARM ;класс %qWEB иницилизируется в программе 
 S qSYS=##class(%qSYS).%New()
 S qW=##class(%qWORD).%New()
 X "S qUSER=##class(qUSER).%New()"
 S qARM=##class(%TqARM).%New()
 s Func="StartWebXML"_Par(-1)
 d @Func
 q ""
StartWebXMLGetTreeXML
 ;инициализация локальной среды
 ;w "<?xml version='1.0' encoding='windows-1251'?><roooooooot/>" q
 D ..Init() N q S q=..OpenPrint("",1,"","","",$S($L(Par(1)," ")>1:Par(1),1:Par(1)_" #"),"W") I q'="" W q Q  ;обработка ошибок
 D ..XMLB(0,1) ;формирует полное дерево
 ;w "<?xml version='1.0' encoding='windows-1251'?><rooot/>" q
 Q
StartWebXMLGetExamplesXML
 n qqot
 d StartWebXMLWriteXObjStat2 ;используется Job, возвращается qqot
 ;w "<?xml version='1.0' encoding='windows-1251'?><root>"_Par(1)_Par(2)_Par(3)_Par(4)_Par(5)_Par(6)_"</root>" Q
 ;s Par(6)=50
 s aaa=..QueryWeb(Par(1),Par(2),Par(3),Par(4),Par(5),Par(6))
 ;k ^Q(1,"XViewStat",qqot)
 Q
StartWebXMLGetExamplesXSL
 D ..Init() N q S q=..OpenPrint("",1,"","","",$S($L(Par(1)," ")>1:Par(1),1:Par(1)_" #"),"W") I q'="" W q Q  ;обработка ошибок
 D ..QueryWeb(Par(1),1) ;формирует полное дерево
 Q
StartWebXMLGetWocXML
 ;Par: 1-qqw,2-язык,3-перв.слово,4-кол.сл.,5-реверс
 n NumWoc
 ;w Par(1)_"#"_Par(2)_"#"_Par(3)_"#"_Par(4)_"#"_Par(5)_"#"
 s NumWoc=..SendXMLWoc(0,Par(2),Par(5),Par(1)_" "_Par(3),Par(4),0)
 ;I W("Zldrl")["""" D
 ;.N qqpos S qqpos=1 F  S qqpos=$F(W("Zldrl"),"""",qqpos) Q:'qqpos  S $E(W("Zldrl"),qqpos-1)="""""",qqpos=qqpos+1
 q

StartWebXMLWriteXObjStat
 n x,y,qqPar,name  ;qqot,
 n CodeN,NameN,CodeChN,NameChN,CodeTxt,Txt,NumTxt,CodeAtt,ValAtt
 n refTmpGl s refTmpGl=$na($$$tmpGl(Job)) ; 15.12.2008 Kokarev
 s x="" f  s x=$o(@refTmpGl@(3,"c",x)) q:x=""  d  ;
 .s CodeN=@refTmpGl@(3,"c",x)  ;коды узлов с именем "Node", а также qqot,c0
 .s NameN=@refTmpGl@(CodeN,"n")
 .i NameN="qqot" d  q
 ..s CodeTxt=@refTmpGl@(CodeN,"c",0)
 ..s qqot=@refTmpGl@(CodeTxt,"v")
 ..k ^Q("V"_qqot,"XObjStat",3),^Q("V"_qqot,"XObjStat",4),^Q("V"_qqot,"XObjStat",8),^Q("V"_qqot,"XObjStat",12),^Q("V"_qqot,"XObjStat",13)
 .i NameN="curObj" d  q
 ..s CodeTxt=$g(@refTmpGl@(CodeN,"c",0))
 ..i CodeTxt'="" s ^Q("V"_qqot,"XObjStat","CurObj")=@refTmpGl@(CodeTxt,"v")
 .i NameN="curEx" d  q
 ..s CodeTxt=$g(@refTmpGl@(CodeN,"c",0))
 ..i CodeTxt'="" s ^Q("V"_qqot,"XObjStat","ID")=@refTmpGl@(CodeTxt,"v")
 .i NameN="Node" s y="" f  s y=$o(@refTmpGl@(CodeN,"c",y)) q:y=""  d
 ..s CodeChN=@refTmpGl@(CodeN,"c",y)  ;коды его дочерних узлов
 ..s NameChN=@refTmpGl@(CodeChN,"n")
 ..i NameChN="qStruct" q
 ..s CodeTxt=$g(@refTmpGl@(CodeChN,"c",0))  ;код текстового узла внутри узла "p1"
 ..i CodeTxt'="" s Txt=@refTmpGl@(CodeTxt,"v")
 ..e  s Txt=""
 ..i NameChN="qqPar" s qqPar=Txt q
 ..i NameChN="name" s name=Txt q
 ..i NameChN="p1" d  q
 ...i Txt="empty" q 
 ...i Txt="onobj" s ^Q("V"_qqot,"XObjStat",3,name)=0 q
 ...i Txt="offobj" s ^Q("V"_qqot,"XObjStat",3,name)=1 q
 ..i NameChN="p2" d  q
 ...i Txt="empty" q
 ...i Txt="onatt" s ^Q("V"_qqot,"XObjStat",4,name)=1 q
 ...i Txt="offatt" s ^Q("V"_qqot,"XObjStat",4,name)=0 q
 ..i NameChN="p3" d  q 
 ...i Txt="obj" q 
 ...i Txt="att" q 
 ...i Txt="delobj" s ^Q("V"_qqot,"XObjStat",1,name)=1 q
 ...i Txt="delatt" q 
 ..i NameChN="c1" s ^Q("V"_qqot,"XObjStat",8,qqPar,name)=Txt q
 ..i NameChN="c2" s ^Q("V"_qqot,"XObjStat",12,qqPar,name,2)=Txt q
 ..i NameChN="c3" d  q
 ...s ^Q("V"_qqot,"XObjStat",12)=qqPar_" "_name
 ...s CodeAtt=@refTmpGl@(CodeChN,"a",0)
 ...s ValAtt=@refTmpGl@(CodeAtt,"v")
 ...s ^Q("V"_qqot,"XObjStat",12,qqPar,name,3)="A"_ValAtt
 ..i NameChN="c4" d  q
 ...s NumTxt=$s(Txt="Num":5,Txt="Sum":6,Txt="Min":7,Txt="Max":8,Txt="Mid":9)
 ...s CodeAtt=@refTmpGl@(CodeChN,"a",0)
 ...s ValAtt=@refTmpGl@(CodeAtt,"v")
 ...s ^Q("V"_qqot,"XObjStat",12,qqPar,name,4)="D"
 ...s ^Q("V"_qqot,"XObjStat",13,0,qqPar_" "_name_" "_NumTxt)=ValAtt
 ...s ^Q("V"_qqot,"XObjStat",13,1,ValAtt)=qqPar_" "_name_" "_NumTxt
 ;w "Запрос получен" Q  
 q
StartWebXMLWriteXObjStat2
 n x,y,qqPar,name  ;qqot,
 n CodeN,NameN,CodeChN,NameChN,CodeTxt,Txt,NumTxt,CodeAtt,ValAtt,FlagObj
 n refTmpGl s refTmpGl=$na($$$tmpGl(Job)) ; 15.12.2008 Kokarev
 s x="" f  s x=$o(@refTmpGl@(3,"c",x)) q:x=""  d  ;
 .s CodeN=@refTmpGl@(3,"c",x)  ;коды узлов с именем "Node", а также qqot,c0
 .s NameN=@refTmpGl@(CodeN,"n")
 .i NameN="qqot" d  q
 ..s CodeTxt=@refTmpGl@(CodeN,"c",0)
 ..s qqot=@refTmpGl@(CodeTxt,"v")
 ..s qqot=$TR(qqot," ","_")
 ..s WrGl=$na(^Q(1,"XViewStat",qqot))
 ..k @WrGl
 .i NameN="curObj" d  q
 ..s CodeTxt=$g(@refTmpGl@(CodeN,"c",0))
 ..i CodeTxt'="" s @WrGl@("XCurObj")=@refTmpGl@(CodeTxt,"v")
 .i NameN="curEx" d  q
 ..s CodeTxt=$g(@refTmpGl@(CodeN,"c",0))
 ..i CodeTxt'="" s @WrGl@("XID")=@refTmpGl@(CodeTxt,"v")
 .i NameN="XPict" d  q
 ..s CodeTxt=$g(@refTmpGl@(CodeN,"c",0))
 ..i CodeTxt'=""||1 s @WrGl@("XPict")=1 ;@refTmpGl@(CodeTxt,"v") ;@dol tmp
 .i NameN="X1983" d  q
 ..s CodeTxt=$g(@refTmpGl@(CodeN,"c",0))
 ..i CodeTxt'="" s @WrGl@("X8P",0,"X1983")=@refTmpGl@(CodeTxt,"v")
 .i NameN="X12P" s y="" f  s y=$o(@refTmpGl@(CodeN,"c",y)) q:y=""  d
 ..s CodeChN=@refTmpGl@(CodeN,"c",y)  ;коды его дочерних узлов
 ..s NameChN=@refTmpGl@(CodeChN,"n")
 ..s CodeTxt=$g(@refTmpGl@(CodeChN,"c",0))  ;код текстового узла внутри узла "p1"
 ..i CodeTxt'="" s Txt=@refTmpGl@(CodeTxt,"v")
 ..e  s Txt=""
 ..i NameChN="X19120" s @WrGl@("X12P",0,"X19120")=Txt q
 ..i NameChN="X19121" s @WrGl@("X12P",0,"X19121")=Txt q
 ..i NameChN="X19122" s @WrGl@("X12P",0,"X19122")=Txt q
 .i NameN="X13" s y="" f  s y=$o(@refTmpGl@(CodeN,"c",y)) q:y=""  d
 ..s CodeChN=@refTmpGl@(CodeN,"c",y)  ;коды его дочерних узлов
 ..s NameChN=@refTmpGl@(CodeChN,"n")
 ..s CodeTxt=$g(@refTmpGl@(CodeChN,"c",0))  ;код текстового узла внутри узла "p1"
 ..i CodeTxt'="" s Txt=@refTmpGl@(CodeTxt,"v")
 ..e  s Txt=""
 ..i NameChN="X19134" s @WrGl@("X13",0,"X19134")=Txt q
 ..i NameChN="X19135" s @WrGl@("X13",0,"X19135")=Txt q
 ..i NameChN="X19136" s @WrGl@("X13",0,"X19136")=Txt q
 ..i NameChN="X19137" s @WrGl@("X13",0,"X19137")=Txt q
 ..i NameChN="X19138" s @WrGl@("X13",0,"X19138")=Txt q
 ..i NameChN="X19139" s @WrGl@("X13",0,"X19139")=Txt q
 .i NameN="Node" s y="" f  s y=$o(@refTmpGl@(CodeN,"c",y)) q:y=""  d
 ..s CodeChN=@refTmpGl@(CodeN,"c",y)  ;коды его дочерних узлов
 ..s NameChN=@refTmpGl@(CodeChN,"n")
 ..i NameChN="qStruct" q
 ..s CodeTxt=$g(@refTmpGl@(CodeChN,"c",0))  ;код текстового узла внутри узла "p1"
 ..i CodeTxt'="" s Txt=@refTmpGl@(CodeTxt,"v")
 ..e  s Txt=""
 ..i NameChN="qqPar" s qqPar=Txt q
 ..i NameChN="name" s name=Txt q
 ..i NameChN="p1" d  q
 ...i Txt="empty" q 
 ...i Txt="onobj" s @WrGl@("X3",name,"X593")=0 q
 ...i Txt="offobj" s @WrGl@("X3",name,"X593")=1 q
 ..i NameChN="p2" d  q
 ...i Txt="empty" q
 ...i Txt="onatt" s @WrGl@("X4",name,"X594")=1 q
 ...i Txt="offatt" s @WrGl@("X4",name,"X594")=0 q
 ..i NameChN="p3" d  q 
 ...i Txt="obj" s FlagObj=1 q 
 ...i Txt="att" s FlagObj=0 q 
 ...i Txt="delobj" q
 ...i Txt="delatt" q 
 ..i NameChN="c1",FlagObj=1 s @WrGl@("X8",name,"X598")=1 q
 ..i NameChN="c1",FlagObj=0 s @WrGl@("X8",qqPar,"X8W",name,"X798")=Txt q
 ..i NameChN="c2" q
 ..i NameChN="c3" d  q
 ...s @WrGl@("X12",qqPar,"X5912")=1
 ...s @WrGl@("X12",qqPar,"X12W",name,"X79123")=1
 ...;s CodeAtt=@refTmpGl@(CodeChN,"a",0)
 ...;s ValAtt=@refTmpGl@(CodeAtt,"v")
 ...;s ^Q("V"_qqot,"XObjStat",12,qqPar,name,3)="A"_ValAtt
 ..i NameChN="c4" d  q
 ...s NumTxt=$s(Txt="Num":"X791305",Txt="Sum":"X791306",Txt="Min":"X791307",Txt="Max":"X791308",Txt="Mid":"X791309",1:"")
 ...s CodeAtt=@refTmpGl@(CodeChN,"a",0)
 ...s ValAtt=@refTmpGl@(CodeAtt,"v")
 ...s @WrGl@("X12",qqPar,"X12W",name,"X79124")=1
 ...s @WrGl@("X12",qqPar,"X12W",name,NumTxt)=1
 ;w "Запрос получен" Q  
 q
]]></Implementation>
</Method>

<Method name="TestSOAP2">
<Description>
Тестовый пример метода для вызова его Soap-ом</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 s resultSOAP="Результат, который будет в SOAP-ответе"
 q "Возвращаемое методом знгачение"
]]></Implementation>
</Method>

<Method name="XML">
<Description><![CDATA[
Создание XML текущего отображения.
qqdev - устойство (см. метод write).
full=1 - полное отображение, 1 - текущее состояние дерева объектов (без свернутых
и неактивных узлов).
xsl=1 - не вставлять ссылку на XSL
id=0 - не включать атрибут id=qqc
qOutput - смотри описание в методе XSL
qFlag - если 1, то не выводится строка "<?xml version='1.0' encoding='windows-1251'?>" - используется при выводе csp-страниц
qqview - код отображения, из которого брать параметры печати
xmlRef - глобал, в который записывается текст xml (при этом qqdev не учитывается)
picRef - глобал, в который записываются картинки (при этом qqdev не учитывается)
innerRef - ссылка на глобал, куда пишутся стили для ОО (ширина столбцов встроеных таблиц, встроеная разметка) @rda 20090525]]></Description>
<Internal/>
<FormalSpec>qqdev:%String="qword.xml",full:%String=0,brow:%String=0,xsl:%String=1,id:%String=1,qOutput:%String=0,Num:%String,qFlag:%Library.String,qqview:%Library.String,x320:%Library.String,xmlRef:%Library.String,picRef:%Library.String,picNameHead:%String,innerRef:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 S qqview=$G(qqview) ;если не указано, то параметры печати берутся из текущего отображения ;иначе - из qqview
 
 i $G(qqview)="" s qqview=$g(Vo(qqnump,-1,-1))_$s($g(Vo(qqnump,-1,-1))'="":$C(1),1:"")_Vo(qqnump)
  
 n qqoView
 S qqoView=$S($g(qqview)'[$C(1):"XView",1:$P($g(qqview),$C(1))) S:$g(qqview)[$C(1) qqview=$P($g(qqview),$C(1),2,255) ;Маслова 06.08.2010    
 
 ; если старая печать
 I $G(xmlRef)="" D ..OpenDev(qqdev)
 ///sas 20081204 вставка для ООW + rda 20101001 для OOCalc
 I ($G(x320)<6)||($G(x320)=10)||($G(x320)=11) D:'$G(qFlag) XMLwrite("<?xml version='1.0' encoding='windows-1251'?>") I xsl,$G(x320)'=5 D
 .
 .; полный путь к xml-файлу, обрабатываем: выражение, первый символ "-", номер
 .N XMLPath S XMLPath=qARM.GetPar("X368",qqoView_$C(1)_qqview) S:$E(XMLPath)="@" @("XMLPath="_$E(XMLPath,2,$L(XMLPath))) S:$E(XMLPath)="-" XMLPath=$E(XMLPath,2,$L(XMLPath)) S:XMLPath?1.n XMLPath="" S XMLPath=..xmlPath(XMLPath)
 .
 .; получаем имя xsl-файла
 .; вариант xsl
 .N x322 S x322=qARM.GetPar("x322",qqoView_$C(1)_qqview)
 .N XSLPath
 .D
 ..; есть имя файла - пишем полное имя файл
 ..///sas 20081204 вставка для ООW + rda 20101001 для OOCalc
 ..I (x322=2) i (x320<5)||(x320=10)||(x320=11) S XSLPath=qARM.GetPar("X365",qqoView_$C(1)_qqview) S:$E(XSLPath)="@" @("XSLPath="_$E(XSLPath,2,$L(XSLPath))) S XSLPath=..XslPath(XSLPath) Q
 ..; нет имени - берем короткое без расширения из XMLPath и добавляем расширение
 ..N Sep S Sep=$S(XMLPath["\":"\",1:"/"),XSLPath=$P(XMLPath,Sep,$L(XMLPath,Sep)),XSLPath=$P(XSLPath,".")_".xsl"
 .
 .D XMLwrite("<?xml-stylesheet type='text/xsl' href='"_XSLPath_"'?>")
 N qxmlbaz I $G(x320)=5 S qxmlbaz=$G(Vo(qqnump,-1,101)) S:qxmlbaz="" qxmlbaz=qARM.GetPar("X5101",,-1)  ;@Dol 27.08.04 XML-имя для внешнего файла
 ///sas 20081204 вставка для ООW + rda 20101001 для OOCalc
 D:($G(x320)<6)||(x320=10)||(x320=11) XMLwrite($S($G(qxmlbaz)="":"<baseO"_$S(($G(x320)'=10)&&($G(x320)'=11):"",1:" xmlns:text='urn:oasis:names:tc:opendocument:xmlns:text:1.0' xmlns:table='urn:oasis:names:tc:opendocument:xmlns:table:1.0' xmlns:style='urn:oasis:names:tc:opendocument:xmlns:style:1.0'")_">",qxmlbaz="-":"",1:"<"_qxmlbaz_">")) ;@Dol 22.09.10 qxmlbaz="-"
 ;qql-слой  @rda 20090512 вставка описания namespace в xml для OO (для обработки форматирования в xml) 
 I $G(Num)="" S Num=qARM.GetPar("X360",qqoView_$C(1)_qqview) S Num=$S(Num="":100000000,Num="*":1000000000,'Num:5000,1:+Num) ;кол-во выводимых экземпляров объектов
 /// sas 20081205 вставка для ООW + rda 20101001 для OOCalc
 D qW.gForm(qql,$$$CurObj,qqc,Num,"",$S(($G(x320)>4)&&($G(x320)'=10)&&($G(x320)'=11):x320,1:1+id),full,,,$G(xmlRef),$G(picRef),0,$G(picNameHead),$G(innerRef))
 ;sasha 20080929
 I $G(x320)=9 d dbf()
 ;I brow D  ;добавлено для динамических свойств выходной формы
 ;.D XMLwrite("<base1>") N qqo S qqo=-1 F  S qqo=$O(Vo(qqnump,qqo)) Q:qqo=""  I $S(full:1,1:'$G(Vs(qqnump,3,qqo))) D XMLD(qqo)
 ;.D XMLwrite("</base1>")
 ///sas 20081204 вставка для ООW + rda 20101001 для OOCalc
 D:($G(x320)<6)||($G(x320)=10)||($G(x320)=11) XMLwrite($S($G(qxmlbaz)="":"</baseO>",qxmlbaz="-":"",1:"</"_$P(qxmlbaz," ")_">")) ;@Dol 22.09.10 qxmlbaz="-"
 ; если старая печать
 I $G(refXML)="" D ..CloseDev(qqdev)
 Q:$Q "" Q

XMLwrite(str)
 I $G(xmlRef)'="" S @xmlRef@($I(@xmlRef))=str_$C(13,10) Q
 D ..write(str)
 Q
dbf() //создание заголовка файла
 i $G(Fld(-1))=-1 Q
 n S,I,dataoff,reclen,D
 s S=$tr($j("",32)," ",$c(0))
 s $e(S)=$c(3) ; FoxBASE+/dBASE III +, без memo - 0х03
 s dataoff=(1+Fld)*32+1 ; Положение первой записи с данными
 s reclen=1 f I=1:1:Fld s reclen=reclen+Fld(I,"L") ; Длина одной записи с данными
 O 63 V 0:0:-$l(S):S,4:0:4:Fld("N"),3:0:1:+$P($ZD($H,4,,6),"/") ;$ZD ;AM01+
 V 8:0:2:dataoff,10:0:2:reclen
 V 2:0:1:+$P($ZD($H,4,,6),"/",2) S D=$P($ZD($H,4,,6),"/",3) ;AM01-
 V 1:0:1:$S($L(D)=2:+D,1:+$E(D,3,4))
 S S=$V(0,0,-$L(S)) C 63
 I $G(xmlRef)'="" S @xmlRef@(1)=S Q  ; tdv 20081219 добавлена обработка для печати версии 2 - заголовок пишем в индекс 1
 s $$$tmpGl(qqdev,$J,0)=S ; 15.12.2008 Kokarev
]]></Implementation>
</Method>

<Method name="XMLB">
<Internal/>
<FormalSpec>qqdev:%String,full:%String=1</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 D ..OpenDev(qqdev)
 D ..write("<?xml version='1.0' encoding='windows-1251'?>"_$c(13,10))
 ;D ..write("<?xml-stylesheet type='text/xsl' href='/qWord/tree_xml/brouser/der1.xsl'?>"_$c(13,10))
 D ..write("<Doc>")
 D ..write($c(13,10)_"<qqot>"_$G(qview)_"</qqot>") ;код отображения
 D ..write($c(13,10)_"<c0>"_Vo(qqnump,-1)_"</c0>") ;имя отображения
 D ..write($c(13,10)_"<curWoc/>") ;имя текущего понятия
 D ..write($c(13,10)_"<curObj/>") ;имя текущего объекта
 D ..write($c(13,10)_"<XPict/>") ;вывод картинок    
 D ..write($c(13,10)_"<curEx/>") ;имя текущего экземпляра
 D ..write($c(13,10)_"<X1983/>") ;макс.кол.экз.при поиске
 D ..write($c(13,10)_"<X12P>") ; =======параметры аналитики
 D ..write($c(13,10)_"<X19120/>") ;пословно
 D ..write($c(13,10)_"<X19121/>") ;учет пустых значений
 D ..write($c(13,10)_"<X19122/></X12P>") ;порог по колич.экз.
 D ..write($c(13,10)_"<X13>") ;  =======параметры диаграммы
 D ..write($c(13,10)_"<X19134/>") ;порог вкл.точки в проц.
 D ..write($c(13,10)_"<X19135/>") ;масштабирование
 D ..write($c(13,10)_"<X19136/>") ;сортировка
 D ..write($c(13,10)_"<X19139/>") ;диагр.XYZ
 D ..write($c(13,10)_"<X19137/>") ;приемник.вывода диагр.
 D ..write($c(13,10)_"<X19138/></X13>") ;вариант диагр.
 ;обход отображения
 N qqso,qqz,id
 S qqso=0,id=0 F  S qqso=$O(Vo(qqnump,-1,0,qqso)) Q:qqso=""  S qqz=$G(Vo(qqnump,-1,0,qqso)) D:qqz'="" XMLBO(qqz,1,-1)
 D:0 ..XSL(qqdev,full,"",1)
 D ..write("</Doc>")
 D ..CloseDev(qqdev)
 Q:$Q "" Q
XMLBO(qqo,qqlev,qqpar)  ;обход объекта
 ;qqo  - код объекта
 ;код родителя
 N qqso,qqz,qi,qqw,qqfl
 ;D ..write("<qqCh>"_qqo_"</qqCh>")
 S id=id+1 D ..write($c(13,10,13,10)_"<Node>")
 D ..write($c(13,10)_"<qqc>"_id_"</qqc>")
 D ..write($c(13,10)_"<qqPar>"_qqpar_"</qqPar>")
 D ..write($c(13,10)_"<name>"_qqo_"</name>")
 D ..write($c(13,10)_"<level>"_qqlev_"</level>")
 D ..write($c(13,10)_"<vis />") ;видимость
 ;D ..write("<p1>"_$S('$G(Vs(qqnump,3,qqo)):"onobj",1:"offobj")_"</p1>") ;свернут-развернут empty???
 ;D ..write("<p2>"_$S($G(Vs(qqnump,4,qqo)):"onatt",1:"offatt")_"</p2>") ; папки понятий свернут-развернут empty???
 D ..write($c(13,10)_"<p3>"_$S('$G(Vs(qqnump,1,qqo)):"obj",1:"objdel")_"</p3>") ;зачеркнут (объект)
 ;
 S qqz=Vo(qqnump,qqo)
 S:$E(qqz)="@" qqz=qW.GetWoc("CxObj",qqo)
 n qqzProz s qqzProz=$S($e(qqz)="%":$e(qqz,2,1000),1:qqz)
 D ..write($c(13,10)_"<c0>"_qqzProz_"</c0>") ;имя объекта
 ;D:$G(Vs(qqnump,8,qqo)) ..write("<c1>+</c1>") ;поисковый образ
 ;D:$G(Vs(qqnump,12,qqo)) ..write("<c4>+</c4>") ;ссылка на экземпляр в аналитике
 ;обход строк понятий (если они раскрыты, или full=1)
 S qqfl=0 F qi=1:1:$G(Vo(qqnump,qqo,10)) S qqw=Vo(qqnump,qqo,10,qi) D
 .S qqfl=1 D ..write($c(13,10)_"<qqCh>"_qqw_"</qqCh>")
 D ..write($c(13,10)_"<p2>"_$S('qqfl:"empty",$G(Vs(qqnump,4,qqo)):"onatt",1:"offatt")_"</p2>") ; папки понятий свернут-развернут empty???
 S qqfl=0
 I '$G(Vs(qqnump,3,qqo))!full S qqso="" F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""  D
 .S qqz=$G(Vo(qqnump,qqo,0,qqso)) I qqz'="" D ..write($c(13,10)_"<qqCh>"_qqz_"</qqCh>") S qqfl=1 ;$S(full:1,1:'$G(Vo(qqnump,1,qqz)))
 D ..write($c(13,10)_"<p1>"_$S('qqfl:"empty",'$G(Vs(qqnump,3,qqo)):"onobj",1:"offobj")_"</p1>") ;свернут-развернут empty???
 ;формирование геометрии для объекта(qqo) в виде:
 ;              <qStruct>
 ;                  <qRow qNum=qqso(№ строки)>
 ;                      <qCell colspan=кол-во занимаемых ячеек>qqw(код понятия,если константа($E(qqz)=0),то ""(пусто))</qCell>
 ;                  </qRow>
 ;              </qStruct>
 ;D
 ;.D ..write("<qStruct>")
 ;.N qqso,qqw,qi,qi1,qi2 S qqso="",qi1=Vo(qqnump,-1,9) F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""  D:$G(Vo(qqnump,qqo,0,qqso))=""
 ;..D ..write("<qRow qNum='"_qqso_"'>") F qi=0:1:qi1 S qqw=$G(Vo(qqnump,qqo,0,qqso,qi)) D  D ..write("<qCell"_$S((qi2-qi)=1:"",1:" colspan='"_(qi2-qi)_"'")_">"_$S('qqw:"",$E(qqw)=5:"Zs"_qqso_"c"_qi,1:$TR($E($P(qqw," "),2,255),"@","o"))_"</qCell>") S qi=qi2-1
 ;...F qi2=qi+1:1:qi1+1 Q:$G(Vo(qqnump,qqo,0,qqso,qi2))'=""
 ;..D ..write("</qRow>")
 ;.D ..write("</qStruct>")
 ;
 D ..write("</Node>")
 F qi=1:1:$G(Vo(qqnump,qqo,10)) S qqw=Vo(qqnump,qqo,10,qi) D
 .S id=id+1 D ..write($c(13,10,13,10)_"<Node>")
 .D ..write($c(13,10)_"<qqc>"_id_"</qqc>")
 .D ..write($c(13,10)_"<qqPar>"_qqo_"</qqPar>")
 .D ..write($c(13,10)_"<name>"_qqw_"</name>")
 .D ..write($c(13,10)_"<level>"_(qqlev+1)_"</level>")
 .D ..write("<vis />") ;видимость
 .D ..write($c(13,10)_"<p1>empty</p1>")
 .D ..write($c(13,10)_"<p2>empty</p2>") ; папки понятий свернут-развернут empty???
 .D ..write($c(13,10)_"<p3>att</p3>") ;_$S($G(Vs(qqnump,1,qqo)):"Obj",1:"")_"</p3>") ;зачеркнут (объект)
 .S %1=qW.GetWoc("CxWoc",qqw)
 .n %1Proz s %1Proz=$S($e(%1)="%":$e(%1,2,1000),1:%1)
 .D ..write($c(13,10)_"<c0>"_%1Proz_"</c0>") ;имя
 .S %1=$G(Vs(qqnump,8,qqo,qqw)) i %1'="" D ..write($c(13,10)_"<c1>"_%1_"</c1>") ;поисковый образ
 .D  ;:$D(Vs(qqnump,12,qqo,qqw))
 ..s tagC2=$G(Vs(qqnump,12,qqo,qqw,2))_$S($G(Vs(qqnump,12,qqo,qqw,1))="":"",1:$C(13,10)_Vs(qqnump,12,qqo,qqw,1))
 ..i tagC2'="" D ..write($c(13,10)_"<c2>"_tagC2_"</c2>") ;выражения аналитик
 ..;S %1=$G(Vs(qqnump,12,qqo,qqw,3)) D ..write($c(13,10)_"<c3>"_$S(%1'="":"A"_$E(%1,2,3),1:"")_"</c3>")
 ..;S %1=$G(Vs(qqnump,12,qqo,qqw,4)) D ..write($c(13,10)_"<c4>"_$S(%1'="":"D"_$E(%1,2,3),1:"")_"</c4>")
 ..;N j F j=5:1:9 D ..write("<c"_j_">"_$S($D(Vs(qqnump,13,0,qqo_" "_qqw_" "_j)):"Y"_Vs(qqnump,13,0,qqo_" "_qqw_" "_j)_": ",1:"")_$G(Vs(qqnump,12,qqo,qqw,j))_"</c"_j_">") ;D:$D(Vs(qqnump,13,0,qqo_" "_qqw_" "_j))
 .D ..write("</Node>")
 ;обход строк объектов
 I '$G(Vs(qqnump,3,qqo))!full S qqso="" F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""  D
 .S qqz=$P($G(Vo(qqnump,qqo,0,qqso))," ")
 .I qqz'="" D XMLBO(qqz,qqlev+1,qqo) Q
 Q
]]></Implementation>
</Method>

<Method name="XMLJrn">
<Description>
Метод формирует XML для массива журнала от индекса beg до end ( ^QJ(1,"Xjrn",индекс) )</Description>
<Internal/>
<FormalSpec>qqdev:%Library.String="qwordjrn.xml",beg:%Library.String,end:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqw,qqo S:'$G(beg) beg=$O(^QJ(1,"XJrn","")) S:'$G(end) end=$O(^QJ(1,"XJrn",""),-1)
 D ..OpenDev(qqdev),..write("<?xml version='1.0' encoding='windows-1251'?>")
 D ..write("<baseO>")
 F beg=beg:1:end D ..write("<OXJrn ID='"_beg_"'>") D  D ..write("</OXJrn>")
 .S qqw="" F  S qqw=$O(^QJ(1,"XJrn",beg,qqw)) Q:qqw=""  I qqw'="Xold",qqw'="Xnew" D ..write("<"_qqw_">"_^QJ(1,"XJrn",beg,qqw)_"</"_qqw_">")
 .F qqo="Xnew","Xold" D:$D(^QJ(1,"XJrn",beg,qqo))  ;а T-понятия???
 ..D ..write("<O"_qqo_" ID='1' >")
 ..S qqw="" F  S qqw=$O(^QJ(1,"XJrn",beg,qqo,1,qqw)) Q:qqw=""  D ..write("<"_qqw_">"_^QJ(1,"XJrn",beg,qqo,1,qqw)_"</"_qqw_">")
 ..D ..write("</O"_qqo_">")
 D ..write("</baseO>")
 D ..CloseDev(qqdev)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="XMLO">
<Internal/>
<FormalSpec>qqdev:%String="C:\qwordo.xml",full:%String=0</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 D ..OpenDev(qqdev)
 D ..write("<?xml version='1.0' encoding='windows-1251'?>")
 D ..write("<?xml-stylesheet type='text/xsl' href='qwordo.xsl'?>")
 D ..write("<O>")
 D ..write("<qqo>"_Vo(qqnump)_"</qqo>") ;код отображения
 D ..write("<c0>"_Vo(qqnump,-1)_"</c0>") ;имя отображения
 ;обход отображения
 N qqso,qqz
 S qqso=0 F  S qqso=$O(Vo(qqnump,-1,0,qqso)) Q:qqso=""  S qqz=$G(Vo(qqnump,-1,0,qqso)) D:qqz'="" XMLO1(qqz,1)
 D ..write("</O>")
 D ..CloseDev(qqdev)
 Q:$Q "" Q
XMLO1(qqo,qqlev)  ;обход объекта
 ;qqo  - код объекта
 N qqso,qqz,qi,qqw
 D ..write("<O>") ;"_qqo_">")
 D ..write("<qqo>"_qqo_"</qqo>") ;код объекта
 S qqz=Vo(qqnump,qqo)
 S:$E(qqz)="@" qqz=qW.GetWoc("CxObj",qqo)
 D ..write("<c0>"_qqz_"</c0>") ;имя объекта
 D:$G(Vs(qqnump,8,qqo)) ..write("<c1>+</c1>") ;поисковый образ
 D:$G(Vs(qqnump,12,qqo)) ..write("<c4>+</c4>") ;ссылка на экземпляр в аналитике
 ;обход строк понятий (если они раскрыты, или full=1)
 I $G(Vs(qqnump,4,qqo))!full F qi=1:1:$G(Vo(qqnump,qqo,10)) S qqw=Vo(qqnump,qqo,10,qi) D
 .D ..write("<W>") ;"_qqw_">")
 .D ..write("<qqw>"_qqw_"</qqw>") ;код понятия
 .S %1=qW.GetWoc("CxWoc",qqw)
 .D ..write("<c0>"_%1_"</c0>") ;имя
 .S %1=$G(Vs(qqnump,8,qqo,qqw)) I %1'="" D ..write("<c1>"_%1_"</c1>") ;поисковый образ
 .D:$D(Vs(qqnump,12,qqo,qqw))
 ..D ..write("<c2>"_$G(Vs(qqnump,12,qqo,qqw,2))_$S($G(Vs(qqnump,12,qqo,qqw,1))="":"",1:$C(13,10)_Vs(qqnump,12,qqo,qqw,1))_"</c2>") ;выражения аналитик
 ..S %1=$G(Vs(qqnump,12,qqo,qqw,3)) D:%1'="" ..write("<c3>A"_$E(%1,2,3)_"</c3>")
 ..S %1=$G(Vs(qqnump,12,qqo,qqw,4)) D:%1'="" ..write("<c4>D"_$E(%1,2,3)_"</c4>")
 ..N j F j=5:1:9 D ..write("<c"_j_">"_$S($D(Vs(qqnump,13,0,qqo_" "_qqw_" "_j)):"Y"_Vs(qqnump,13,0,qqo_" "_qqw_" "_j)_": ",1:"")_$G(Vs(qqnump,12,qqo,qqw,j))_"</c"_j_">") D:$D(Vs(qqnump,13,0,qqo_" "_qqw_" "_j))
 .D ..write("</W>") ;"_qqw_">")
 ;обход строк объектов
 S qqso="" F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""  D
 .S qqz=$P($G(Vo(qqnump,qqo,0,qqso))," ")
 .I qqz'="" D:$S(full:1,1:'$G(Vs(qqnump,3,qqo))) XMLO1(qqz,qqlev+1) Q
 D ..write("</O>") ;"_qqo_">")
 Q
 ;
XMLOB(qqo,qqlev)  ;обход объекта
 ;qqo  - код объекта
 N qqso,qqz,qi,qqw
 D ..write("<O>") ;"_qqo_">")
 D ..write($$XMLG(qqlev,1))
 D ..write("<qqo>"_qqo_"</qqo>") ;код объекта
 S qqz=Vo(qqnump,qqo)
 S:$E(qqz)="@" qqz=qW.GetWoc("CxObj",qqo)
 D ..write("<c0>"_qqz_"</c0>") ;имя объекта
 D:$G(Vs(qqnump,8,qqo)) ..write("<c1>+</c1>") ;поисковый образ
 D:$G(Vs(qqnump,12,qqo)) ..write("<c4>+</c4>") ;ссылка на экземпляр в аналитике
 ;обход строк понятий (если они раскрыты, или full=1)
 I $G(Vs(qqnump,4,qqo))!full F qi=1:1:$G(Vo(qqnump,qqo,10)) S qqw=Vo(qqnump,qqo,10,qi) D
 .D ..write("<W>") ;"_qqw_">")
 .D ..write($$XMLG(qqlev+1,2))
 .D ..write("<qqw>"_qqw_"</qqw>") ;код понятия
 .S %1=qW.GetWoc("CxWoc",qqw)
 .D ..write("<c0>"_%1_"</c0>") ;имя
 .S %1=$G(Vs(qqnump,8,qqo,qqw)) I %1'="" D ..write("<c1>"_%1_"</c1>") ;поисковый образ
 .D:$D(Vs(qqnump,12,qqo,qqw))
 ..D ..write("<c2>"_$G(Vs(qqnump,12,qqo,qqw,2))_$S($G(Vs(qqnump,12,qqo,qqw,1))="":"",1:$C(13,10)_Vs(qqnump,12,qqo,qqw,1))_"</c2>") ;выражения аналитик
 ..S %1=$G(Vs(qqnump,12,qqo,qqw,3)) D:%1'="" ..write("<c3>A"_$E(%1,2,3)_"</c3>")
 ..S %1=$G(Vs(qqnump,12,qqo,qqw,4)) D:%1'="" ..write("<c4>D"_$E(%1,2,3)_"</c4>")
 ..N j F j=5:1:9 D ..write("<c"_j_">"_$S($D(Vs(qqnump,13,0,qqo_" "_qqw_" "_j)):"Y"_Vs(qqnump,13,0,qqo_" "_qqw_" "_j)_": ",1:"")_$G(Vs(qqnump,12,qqo,qqw,j))_"</c"_j_">") D:$D(Vs(qqnump,13,0,qqo_" "_qqw_" "_j))
 .D ..write("</W>") ;"_qqw_">")
 ;обход строк объектов
 S qqso="" F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""  D
 .S qqz=$P($G(Vo(qqnump,qqo,0,qqso))," ")
 .I qqz'="" D:$S(full:1,1:'$G(Vs(qqnump,3,qqo))) XMLOB(qqz,qqlev+1) Q
 D ..write("</O>") ;"_qqo_">")
 Q
XMLG(qqlev,q) ;подстановка псевдографики для отображения дерева
 ;N qiiii S qiiii="" F qiii=1:1:qqlev S qiiii=qiiii_"<graf src='"_qqP0_"l1.jpg'/>"
 Q qiiii_"<graf src='"_qqP0_$S(q=0:"otree",q=1:"fldclos",1:"bollb")_".jpg'/>"
]]></Implementation>
</Method>

<Method name="XSL">
<Description><![CDATA[
Создание XSL текущего отображения.
qqdev - устойство (см. метод write).
full=1 - НЕ ИСПОЛЬЗУЕТСЯ
table=1 - бланк (каждая яччейка имеет свой размер и не имеет обрамления), иначе таблица.
brow=1 - признак вывода в XML-броузер; иначе (brow=0) формирование печатной формы.
qOutput - указывает на приемник печатной формы (0-IE,1-Word2000;2-Excel2000 );
если обрабатывается отображение для коллонтитулов, то qOutput=colH - верхний коллонтитул
qOutput=colF - нижнтй коллонтитул
qFlag - если 1, то не выводится строка "<?xml version='1.0' encoding='windows-1251'?>" - используется при выводе csp-страниц
qqview - код отображения, из которого брать параметры печати
encoding - кодировка
xslRef - глобал, в который записывается текст xsl (при этом qqdev не учитывается)
spaceBefore - отступ сверху в основной области печати в мм]]></Description>
<Internal/>
<FormalSpec>qqdev:%String="qword.xsl",full:%String=0,table:%String,brow:%String=0,qOutput:%String=0,qFlag:%Library.String,qqview:%Library.String,encoding:%Library.String,xslRef:%Library.String,spaceBefore:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 /*15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl*/
 ;если не указано, то параметры печати берутся из текущего отображения, иначе - из qqview
 I $G(qOutput)=20 N qOutput1 S qOutput1=20,qOutput=2
 S qqview=$G(qqview)
 i $G(qqview)="" s qqview=$g(Vo(qqnump,-1,-1))_$s($g(Vo(qqnump,-1,-1))'="":$C(1),1:"")_Vo(qqnump)
  
 n qqoView S qqoView=$S($g(qqview)'[$C(1):"XView",1:$P($g(qqview),$C(1))) S:$g(qqview)[$C(1) qqview=$P($g(qqview),$C(1),2,255) ;Маслова 06.08.2010    
 
 N prs ; массив с параметрами печати
 ;comm1
 S prs("main")=qARM.GetPar("X355",qqoView_$C(1)_qqview) ;основной шрифт и размеры шрифта

 I $G(table)="" S table=qARM.GetPar("x321",qqoView_$C(1)_qqview) ; вид печати бланк/таблица - определяет только наличие обрамления

 ; новая/старая печать
 D
 .I $G(xslRef)'="" S @xslRef=0 Q
 .; старая печать
 .D ..OpenDev(qqdev)
 .i qqdev="" s xslRef=$na($$$tmpGl(1,$J)) q  ; 15.12.2008 Kokarev
 .s xslRef=$na($$$tmpGl(qqdev,$J)) ; 15.12.2008 Kokarev

 D:'$G(qFlag) XSLwrite("<?xml version='1.0' encoding='windows-1251'?>")
 ; пространства имён
 D XSLwrite("<xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform' xmlns='http://www.w3.org/TR/REC-html40'"_$S(qOutput?1(1"1",1"2"):" xmlns:v='urn:schemas-microsoft-com:vml' xmlns:o='urn:schemas-microsoft-com:office:office'"_$S(qOutput=1:" xmlns:w='urn:schemas-microsoft-com:office:word'",1:" xmlns:x='urn:schemas-microsoft-com:office:excel'"),1:"")_">")
 ; не выводить xml-декларацию
 D XSLwrite("<xsl:output omit-xml-declaration=""yes""/>")

 ; шаблон для обработки текстов и списков; 
 ; Excel - вставляем теги br
 ; всё остальное - обрамляем <p></p>
 ; атрибут indent(если существует) указывает на наличие красной строки;его значение-размер в сантиметрах
 D XSLwrite("")
 D XSLwrite("<xsl:template match='p'>")
 I qOutput'=2 D XSLwrite("<p>"),XSLwrite("<xsl:if test='@indent'><xsl:attribute name='style'>text-indent:<xsl:value-of select='@indent'/>cm;</xsl:attribute></xsl:if>")
 D XSLwrite("<xsl:copy-of select='./node()'/>")
 I qOutput'=2 D XSLwrite("</p>")
 I qOutput=2 D XSLwrite("<xsl:if test='position()!=last()'><br/></xsl:if>")
 D XSLwrite("</xsl:template>")

 ;описание корневого элемента
 D XSLwrite("")
 D XSLwrite("<xsl:template match='/'>")
 D XSLwrite("<html>")
 D XSLwrite("<head>")
 d XSLwrite("<meta http-equiv='Content-Type' content='text/html; charset="_$S($G(encoding)="":"utf-8",1:encoding)_"'/>")
 I qOutput=1 D XSLwrite("<meta name='ProgId' content='Word.Document'/>")
 I qOutput=2 D XSLwrite("<meta name='ProgId' content='Excel.Sheet'/>")

 ; для Word,Excel получаем короткое имя файл результа без расширения
 N resSht
 I $S(qOutput=1:1,qOutput=2:$G(qOutput1)'=20,1:0) D
 .; полный путь к xml-файлу, обрабатываем: выражение, первый символ "-", номер
 .N XMLPath S XMLPath=qARM.GetPar("X368",qqoView_$C(1)_qqview) S:$E(XMLPath)="@" @("XMLPath="_$E(XMLPath,2,$L(XMLPath))) S:$E(XMLPath)="-" XMLPath=$E(XMLPath,2,$L(XMLPath)) S:XMLPath?1.n XMLPath="" S XMLPath=..xmlPath(XMLPath)
 .; короткое имя без расширения
 .N Sep S Sep=$S(XMLPath["\":"\",1:"/"),resSht=$P(XMLPath,Sep,$L(XMLPath,Sep)),resSht=$P(resSht,".")

 ; ссылка на глобал параметров печати
 n prtRef s prtRef = $na(^Q(1,qqoView,qqview,"XPrint",Vo(qqnump,-1,30)))
 N i,val,res
 ; флаг наличия колонтитулов
 N IsCol S IsCol=0
 ; IsCol("head") - верхний
 ; IsCol("foot") - нижний
 ; только для Word
 I qOutput=1 D
 .F i="head","foot" S IsCol(i)=0 S res=$S(i="head":2,i="foot":3) D  I 'IsCol,IsCol(i) S IsCol=1
 ..; определён параметр "вариант колонтитула" (x36?0) и он не равен "отсутствует" (1)
 ..S val=qARM.GetPar("x36"_res_"0",qqoView_$C(1)_qqview) I val'="" S:$S(val=0:$G(xslRef)'="",1:val'=1) IsCol(i)=1 Q
 ..; определён параметр "отображение колонтитула" (X36?) и он содержит путь к файлу xslt
 ..S val=qARM.GetPar("X36"_res,qqoView_$C(1)_qqview) I val'="" S:$TR(val,"\/.")'=val IsCol(i)=1 Q
 ..; существует текст xslt (TB36?)
 ..I $D(@prtRef@("TB36"_res)) S IsCol(i)=1
 .
 .; если есть колонтитулы
 .I IsCol=1 D
 ..D XSLwrite("")
 ..D XSLwrite("<link rel='File-List' href='"_resSht_"_filelist.xml'/>")
 ..D XSLwrite("<xsl:comment><![CDATA[[if gte mso 9]><xml>")
 ..D XSLwrite("<o:OfficeDocumentSettings><o:DoNotOrganizeInFolder/></o:OfficeDocumentSettings>") ; определяет, что связанные файлы находятся не в папке
 ..D XSLwrite("</xml><![endif]]]]]><![CDATA[></xsl:comment>")

 ; описание стилей
 D XSLwrite("")
 D XSLwrite("<style><xsl:comment>")     ; @KAR 20110328

 ; параметры страницы - создание секции @page
 N X364 S X364=$P(qARM.GetPar("X364",qqoView_$C(1)_qqview),"table ")
 
 ; page - массив с параметрами страницы
 ; page("width") - ширина страницы
 ; page("left")  - левое поле
 ; page("right") - правое поле
 N page
 
 ; col - массив с параметрами колонок
 ; col("fst") - номер первой обрабатываемой колонки
 ; col("lst") - номер последней колонки
 ; col("num",cnt) - размер колонки cnt в px
 ; col("num",cnt,"mm") - размер колонки cnt в mm
 ; col("all") - сумма размеров колонок в px
 ; col("all","mm") - сумма размеров колонок в mm
 N col 
 S col("fst")=-1 ; номер первой колонки
 S col("lst")=Vo(qqnump,-1,9)

 ; pmm - число пикселей на мм страницы. Постоянно при изменении разрешения экрана               ; @KAR  20110328
 ; 1122 - длина страницы формата А4 в пикселях
 ; 297  - длина страницы формата А4 в мм
 N pmm S pmm=$FN(1122/297,"",2)

 N grid,x3697 S grid=qARM.GetPar("X3691",qqoView_$C(1)_qqview) ; сохранять размеры колонок
 S x3697=qARM.GetPar("x3697",qqoView_$C(1)_qqview) ; отступ иерархии
 ; если вывод в Word,Excel,IE и заданы параметры страницы или вывод в Word и есть колонтитулы
 I $S(qOutput=1:$S(X364'="":1,1:IsCol),qOutput?1(1"0",1"2"):X364'="",qOutput?1(1"colH",1"colF"):X364'="",1:"") D
 .; @page
 .D
 ..; если Word,IE - определяем первый раздел Section1
 ..I qOutput?1(1"0",1"1") D XSLwrite("@page Section1{") Q
 ..; Excel - параметры распространяются на все страницы
 ..I qOutput=2 D XSLwrite("@page{")
 .; определение размеров страницы
 .I $P(X364," ")'="" S val=$P(X364," ") D  
 ..S val=$TR(val,"xXхХaAаАbBВ","XXXXAAAABBB")
 ..; если размер страницы задан в виде стандартного обозначения
 ..I val?1(1"A4",1"A5",1"B5") D
 ...S val=$S(val="A4":"210X297",val="A5":"148X210",val="B5":"182X257")
 ...; если ориентация "landscape", то меняем местами ширину и длину, и записываем признак ориентации
 ...I $P(X364," ",2)=1 S val=$P(val,"X",2)_"X"_$P(val,"X") D XSLwrite("mso-page-orientation:landscape;")
 ...; для Excel - сразу записываем ширину страницы в mm
 ...I qOutput=2 S page("width")=..XslTransSize($P(val,"X",1),"mm",1)
 ..; для Excel поддерживаются только стандартные значения
 ..I qOutput=2 Q
 ..; Word,IE
 ..; если указан только один размер - дописываем второй
 ..S val=..XslAddSize(val,"X",2)
 ..S res="" F i=1,2 S res=res_" "_..XslCheckSize($P(val,"X",i))
 ..;если ширина или высота не указаны, то размер не записывается
 ..S $E(res)="" Q:$P(res," ",1)=""  Q:$P(res," ",2)=""
 ..; записываем ширину страницы в mm
 ..S page("width")=..XslTransSize($P(res," ",1),"mm",1)
 ..D XSLwrite("size:"_res_";")
 .
 .; определение отступов
 .I $TR($P(X364," ",3,6)," ")'="" S val=$P(X364," ",3,6) D
 ..; дописываем отсутствующие значения, проверяем
 ..S val=..XslAddSize(val," ",4) F i=1:1:4 S res=..XslCheckSize($P(val," ",i)) I res'="" D
 ...; записываем правый и левый отступы в mm
 ...I $G(page("width")),i?1(1"2",1"4") S page($P("right left"," ",i/2))=..XslTransSize(res,"mm",1)
 ...; для Excel переводим в дюймы
 ...I qOutput=2 S res=..XslTransSize(res,"in")
 ...D XSLwrite("margin-"_$P("top right bottom left"," ",i)_":"_res_";")
 .
 .; определение отступов для колонтитулов
 .I $TR($P(X364," ",7,8)," ")'="" S val=$P(X364," ",7,8) D
 ..; дописываем отсутствующие значения, проверяем
 ..S val=..XslAddSize(val," ",2) F i=1,2 S res=..XslCheckSize($P(val," ",i)) I res'="" D
 ...; для Excel переводим в дюймы
 ...I qOutput=2 S res=..XslTransSize(res,"in")
 ...D XSLwrite("mso-"_$P("header footer"," ",i)_"-margin"_":"_res_";")
 .
 .; для Word - если есть колонтитулы, то вставляем ссылки
 .I qOutput=1 D:IsCol("head") XSLwrite("mso-header:url('"_resSht_"_headerH.doc')h1;") D:IsCol("foot") XSLwrite("mso-footer:url('"_resSht_"_headerF.doc')f1;")
 .
 .; для Excel - вставляем нумерацию страниц     ; @KAR 20110328
 .I qOutput=2,qARM.GetPar("X3699",qqoView_$C(1)_qqview)=1 D XSLwrite("<xsl:text disable-output-escaping=""yes"">mso-header-data:'&amp;П&amp;\0022Times New Roman\0022&amp;7&amp;С';</xsl:text>")
 .
 .D XSLwrite("}") ;закрываем селектор @page
 .; Word,IE
 .I qOutput?1(1"0",1"1") D XSLwrite("div.Section1{page:Section1;}") ;определяем класс для тега <div>
 .; если сохранять размеры - определяем размер основной области вывода
 .I grid,$G(page("width")),$G(page("left")),$G(page("right")) S col("all","mm")=page("width")-page("left")-page("right")

 ; таблица
 D XSLwrite("table{")
 I $G(col("all","mm")) D
 .; Word
 .I qOutput=1 D XSLwrite("mso-table-layout-alt:fixed;") Q
 .; IE,Excel
 .I qOutput?1(1"0",1"2") D XSLwrite("table-layout:fixed;")
 ; отступы для всех ячеек таблицы (padding)
 N X3641 S X3641=$P(qARM.GetPar("X364",qqoView_$C(1)_qqview),"table ",2) S:X3641="" X3641=qARM.GetPar("X3641",qqoView_$C(1)_qqview) ;X3641 или после слова table
 D
 .; если есть хотя бы 1 значение
 .I $TR($P(X3641," ",1,4)," ")'="" S val=$P(X3641," ",1,4) D  Q
 ..; дописываем отсутствующие значения, проверяем
 ..S val=..XslAddSize(val," ",4) F i=1:1:4 S res=..XslCheckSize($P(val," ",i)) I res'="" D XSLwrite("padding-"_$P("top right bottom left"," ",i)_":"_res_";")
 .; если нет значений
 .D XSLwrite("padding:0pt;")
 D XSLwrite("border-collapse:collapse;")  ; иначе границы таблицы и ячейки не совпадают (отдельные линии)
 D XSLwrite("}")

 ; строка
 D XSLwrite("tr{")
 ; Excel - необходимо установить, что высота строк определяется автоматически
 I qOutput=2 D XSLwrite("mso-height-source:auto;")
 D XSLwrite("}")

 ; ячейка
 D XSLwrite("td{")
 ; обрамление
 D XSLwrite("border:"_$S(table:"0.5pt solid;",1:"none;"))
 ; если вывод в Excel, то форматируем ячейку как текст
 I qOutput=2,$G(qOutput1)'=20 D XSLwrite("mso-number-format:'\@';")
 D XSLwrite("}")

 ; абзац
 D XSLwrite("p{")
 D XSLwrite("margin:0mm;")                    ; поля
 D XSLwrite("padding:0mm;")                   ; отступы в ячейке
 ; для MS Word - запрет висячих строк
 I qOutput=1 D XSLwrite("mso-pagination:widow-orphan;")
 D XSLwrite("}")

 ; для Excel - если перевод строки, то вывод в ту же ячейку
 I qOutput=2 D XSLwrite("br{mso-data-placement:same-cell;}")

 D XSLwrite("</xsl:comment></style>")   ; @KAR 20110328

 ; вставка для MS Word
 I qOutput=1 D
 .D XSLwrite("")
 .D XSLwrite("<xsl:comment><![CDATA[[if gte mso 9]><xml>")
 .D XSLwrite("<w:WordDocument>")
 .D XSLwrite("<w:View>Print</w:View>")                           ; определяет вид документа:страница
 .D XSLwrite("<w:AutoHyphenation/>")                             ; автоматическая расстановка переносов
 .D XSLwrite("<w:HyphenationZone>7</w:HyphenationZone>")         ; ширина зоны переноса в pt
 .; запрет редактирования
 .I ''$G(qqXBPrtReadOnly) D
 ..D XSLwrite("<w:DocumentProtection>ReadOnly</w:DocumentProtection>")
 ..D XSLwrite("<w:UnprotectPassword>"_$zhex($random($zhex("FFFFFFFFh"))+1)_"</w:UnprotectPassword>")
 .D XSLwrite("</w:WordDocument></xml><![endif]]]]]><![CDATA[></xsl:comment>")

 ; вставка для MS Excel
 I qOutput=2,$G(qOutput1)'=20 D
 .D XSLwrite("")
 .D XSLwrite("<xsl:comment><![CDATA[[if gte mso 9]><xml>")
 .D XSLwrite("<x:ExcelWorkbook>")
 .D XSLwrite("<x:ExcelWorksheets>")
 .D XSLwrite("<x:ExcelWorksheet>")
 .D XSLwrite("<x:Name>"_resSht_"</x:Name>")                 ; имя листа
 .D XSLwrite("<x:WorksheetOptions>")
 .; явно вписываем в ширину страницы - иначе не получается
 .I grid,$G(col("all","mm")),qARM.GetPar("X3699",qqoView_$C(1)_qqview)'=1 D XSLwrite("<x:FitToPage/>")      ; @KAR 20110328
 .D XSLwrite("<x:Print>")
 .; явно вписываем в ширину страницы
 .I grid,$G(col("all","mm")) D XSLwrite("<x:FitHeight>0</x:FitHeight>")
 .D XSLwrite("<x:ValidPrinterInfo/>")
 .; размер страницы, поддерживаются только стандартные A4,A5,B5(JIS), по умолчанию - A4
 .S val=$P(X364," ") D XSLwrite("<x:PaperSizeIndex>"_$S(val="A4":9,val="A5":11,val="B5":13,1:9)_"</x:PaperSizeIndex>")
 .D XSLwrite("</x:Print>")
 .D XSLwrite("<x:Selected/>")
 .D XSLwrite("</x:WorksheetOptions>")
 .D XSLwrite("</x:ExcelWorksheet>")
 .D XSLwrite("</x:ExcelWorksheets>")
 .D XSLwrite("</x:ExcelWorkbook>")
 .
 .I $P($G(Vs("P","UserPar","ListProp","lastzag"))," ",1)'=""&&($P($G(Vs("P","UserPar","ListProp","lastzag"))," ",2)'="") D  ; @KAR 20110328
 ..D XSLwrite("<x:ExcelName>")
 ..D XSLwrite("<x:Name>Print_Titles</x:Name>")
 ..D XSLwrite("<x:SheetIndex>1</x:SheetIndex>")
 ..D XSLwrite("<x:Formula>=qword!$"_$P($G(Vs("P","UserPar","ListProp","lastzag"))," ")_":$"_$P($G(Vs("P","UserPar","ListProp","lastzag"))," ",2)_"</x:Formula>")
 ..D XSLwrite("</x:ExcelName>")
 .
 .D XSLwrite("</xml><![endif]]]]]><![CDATA[></xsl:comment>") 

 D XSLwrite("</head>")

 N X3695 S X3695=qARM.GetPar("X3695",qqoView_$C(1)_qqview) ;флаг подавления цвета
 N X3698 S X3698=qARM.GetPar("X3698",qqoView_$C(1)_qqview) ; динамические параметры ячеек

 D XSLwrite("")
 D XSLwrite("<body"_$S(brow:" onClick=""parent.frames('menu').examplesClick()"" onResize=""parent.frames('menu').resizeHead()"" onScroll=""parent.frames('menu').scrollHead()""",1:"")_">")
 D XSLwrite("<xsl:apply-templates select='baseO'/>")

 I $G(qOutput1)=20 D  ;@Mike 21.03.03 вставка для Excel с выводом графика
 .N i
 .D XSLwrite("<xsl:comment><![CDATA[[if gte mso 9]><xml>")
 .D XSLwrite("<x:WebChart>")
 .D XSLwrite("<x:Scaling><x:ScaleID>0</x:ScaleID><x:Orientation>MinMax</x:Orientation></x:Scaling><x:Scaling><x:ScaleID>1</x:ScaleID><x:Orientation>MinMax</x:Orientation></x:Scaling>")
 .I +$P(Arg1," ",3)=0 D XSLwrite("<x:Scaling><x:ScaleID>2</x:ScaleID><x:Orientation>MinMax</x:Orientation></x:Scaling>")
 .;количество осей 2 или 3
 .D XSLwrite("<x:Chart><x:Name>Diagram</x:Name><x:Title><x:Caption><x:DataSource>-1</x:DataSource><x:Data>&quot;<x:B>"_$S('$P(QDiag," ",3):"",$P(QDiag," ",3)=1:"(%норм)",$P(QDiag," ",3)=2:"(%взв)",'$P(QDiag," ",4)&(ymax'=1):"(%откл)",1:"(откл)")_$S($P(QDiag," ",5)'="":$P(QDiag," ",5,255),ymax=1:QDiag(1,0)_$P(QDiag," ",5,255),1:"")_"</x:B>&quot;</x:Data></x:Caption></x:Title><x:Left>-5500</x:Left><x:Top>-3350</x:Top><x:Width>16800</x:Width><x:Height>10000</x:Height><x:PlotArea><x:Graph>") ;8 5 24 14
 .D XSLwrite("<x:Type>"_$S(+$P(Arg1," ",2)=0:"Column",$P(Arg1," ",2)=1:"Bar",$P(Arg1," ",2)=2:"Pie",$P(Arg1," ",2)=3:"Line",$P(Arg1," ",2)=4:"Line")_"</x:Type><x:SubType>"_$S(+$P(Arg1," ",3)=0:"3D",$P(Arg1," ",2)=2:"Standard",$P(Arg1," ",2)=3:"Standard", $P(Arg1," ",2)=4:"Standard",1:"Clustered")_"</x:SubType><x:VaryColors/><x:ScaleID>0</x:ScaleID><x:ScaleID>1</x:ScaleID>"_$S(+$P(Arg1," ",3)=0:"<x:ScaleID>2</x:ScaleID>",1:""))
 .;тип графика и его подтип 3D/2D
 .F i=1:1:ymax D XSLwrite("<x:Series><x:Index>"_i_"</x:Index>"_$S(+$P(Arg1," ",6)=0:"<x:Caption><x:DataSource>0</x:DataSource><x:Data>qwordD!$"_$C(65+i)_"$1</x:Data></x:Caption>",1:"")_"<x:Name>A</x:Name>"_$S(+$P(Arg1," ",5)=0:"<x:Category><x:DataSource>0</x:DataSource><x:Data>qwordD!$A$2:$A$"_(xmax+1)_"</x:Data></x:Category>",1:"")_"<x:Value><x:DataSource>0</x:DataSource><x:Data>qwordD!$"_$C(65+i)_"$2:$"_$C(65+i)_"$"_(xmax+1)_"</x:Data></x:Value></x:Series>")
 .;берем все ряды, категории берем из столбца "А", если не нужны подписи данных по х или по у, то выкидываем
 .D XSLwrite("<x:PlotVisible/></x:Graph>")
 .D XSLwrite("<x:Axis><x:Placement>Bottom</x:Placement><x:AxisID>0</x:AxisID><x:ScaleID>0</x:ScaleID><x:CrossingAxis>1</x:CrossingAxis><x:Number><x:SourceLinked/><x:BuiltInFormat>0</x:BuiltInFormat></x:Number>"_$S(+$P(Arg1," ",3)=0:"<x:TickLabelPosition>Low</x:TickLabelPosition><x:TickMarkSkip>1</x:TickMarkSkip>",1:"")_"<x:Type>Automatic</x:Type></x:Axis><x:Axis><x:Placement>Left</x:Placement><x:AxisID>1</x:AxisID><x:ScaleID>1</x:ScaleID><x:MajorGridlines/><x:CrossingAxis>0</x:CrossingAxis><x:CrossesAt>Minimum</x:CrossesAt><x:CrossBetween>Between</x:CrossBetween><x:Number><x:SourceLinked/><x:BuiltInFormat>0</x:BuiltInFormat></x:Number><x:Type>Value</x:Type></x:Axis>"_$S(+$P(Arg1," ",3)=0:"<x:Axis><x:Placement>Right</x:Placement><x:AxisID>2</x:AxisID><x:ScaleID>2</x:ScaleID><x:CrossingAxis>0</x:CrossingAxis><x:CrossesAt>Minimum</x:CrossesAt><x:CrossBetween>Between</x:CrossBetween><x:Number><x:SourceLinked/><x:BuiltInFormat>0</x:BuiltInFormat></x:Number><x:TickLabelPosition>Low</x:TickLabelPosition><x:TickMarkSkip>1</x:TickMarkSkip><x:Type>Series</x:Type></x:Axis>",1:""))
 .;всякая нужная ерунда с заданием осей 2 и 3
 .D XSLwrite("</x:PlotArea>"_$S(+$P(Arg1," ",6)=0:"<x:Legend><x:Placement>Right</x:Placement></x:Legend>",1:"")_"</x:Chart></x:WebChart>")
 .;нужна легенда или нет
 .D XSLwrite("</xml><![endif]]]]]><![CDATA[></xsl:comment>")

 D XSLwrite("</body>")
 D XSLwrite("</html>")
 D XSLwrite("</xsl:template>")

 ; последовательность сортировки
 N sort S sort=$TR(qARM.GetPar("X361",qqoView_$C(1)_qqview),"@","o")

 ;обход отображения 
 do ..XSLObj()

 D XSLwrite("</xsl:stylesheet>")

 ; старая печать
 I $G(xslRef)="" D:'brow ..CloseDev(qqdev)
 Q:$Q "" Q

 Q

XSLwrite(str)
 I $G(xslRef)'="" S @xslRef@($I(@xslRef))=str_$C(13,10) Q
 D ..write(str)
 Q
]]></Implementation>
</Method>

<Method name="XSLO">
<Internal/>
<FormalSpec>qqdev:%String="C:\qwordo.xsl",full:%String=0</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 D ..OpenDev(qqdev)
 D ..write("<?xml version='1.0' encoding='windows-1251'?>")
 D ..write("<xsl:stylesheet xmlns:xsl=""http://www.w3.org/TR/WD-xsl"">")
 D ..write("<xsl:template match=""/"">")
 D ..write("<HTML>")
 ;D ..write("<style>")
 ;D ..write("*{margin:1pt;padding:1pt;}")
 ;D ..write("table,td{border-collapse:collapse;border:1pt solid red;}")
 ;D ..write("</style>")
 D ..write("<script>")
 D ..write("function fff(l1)")
 D ..write("{if (l1.style.display=='none')")
 D ..write("{obj=l1.style; obj.display='block';}")
 D ..write("else {obj=l1.style; obj.display='none';}")
 D ..write("}</script>")
 D ..write("<BODY>")
 d ..write("<a name='c4' href='#c4' onClick='fff(l1)'>hhh</a>")
 D ..write("<table width='100%' border='"_1_"' cellspacing='0' cellpadding='0'>")
 ;заголовок отображения
 D ..write("<tr><td>Объекты/Понятия</td><td>Условие</td><td>Выражение</td><td>A</td><td>D</td><td>Num</td><td>Sum</td><td>Min</td><td>Max</td><td>Mid</td></tr>")
 D ..write("</table>")
 D ..write("<xsl:apply-templates/>")
 D ..write("</BODY></HTML></xsl:template>")
 ;образец объекта
 D ..write("<xsl:template match='O'>")
 D ..write("<div id='l1' style='left:10; display:block;'>")
 ;
 D ..write("<IMG src='C:\qword\bmp\fldclos.jpg' />")
 D ..write("<xsl:value-of select='qqo'/>")
 D ..write("<xsl:value-of select='c0'/>")
 ;
 ;D ..write("<div style='position:absolute; left:300; height:20;'>")
 D ..write("<table width='100%' border='"_1_"' cellspacing='0' cellpadding='0' left='300'>")
 D ..write("<tr>")
 D ..write("<td><xsl:value-of select='c1'/></td>")
 D ..write("<td/><td/><td><xsl:value-of select='c1'/></td><td/><td/><td/><td/><td/></tr>")
 D ..write("</table>") ;</div>")
 ;
 ;D ..write("<xsl:apply-templates/>")
 D ..write("</div>")
 D ..write("</xsl:template>")
 ;образец понятия
 D ..write("<xsl:template match='W'>")
 D ..write("<div style='position:relative; left:10; visibility: visible;'>")
 ;D ..write("<div style='position:absolute; left:10; visibility: hidden;'>")
 D ..write("<IMG src='C:\qword\bmp\bollb.jpg'/>")
 D ..write("<xsl:value-of select='qqw'/>")
 D ..write("<xsl:value-of select='c0'/>")
 ;D ..write("<div style='position:absolute; left:300; height:20;'>")
 D ..write("<table width='100%' border='"_1_"' cellspacing='0' cellpadding='0' style='position:absolute; left:300; height:20;'>")
 D ..write("<tr>")
 F qi=1:1:9 D ..write("<td><xsl:value-of select='c"_qi_"'/></td>")
 D ..write("</tr>")
 D ..write("</table>")
 D ..write("</div>") ;</div>")
 D ..write("</xsl:template>")
 D ..write("</xsl:stylesheet>")
 D ..CloseDev(qqdev)
 Q:$Q "" Q
 ;
 ;
 ;
 D ..OpenDev(qqdev)
 D ..write("<?xml version='1.0' encoding='windows-1251'?>")
 D ..write("<xsl:stylesheet xmlns:xsl=""http://www.w3.org/TR/WD-xsl"">")
 D ..write("<xsl:template match=""/"">")
 D ..write("<HTML>")
 D ..write("<style>")
 D ..write("*{margin:5pt;padding:5pt;}")
 D ..write("table,td{border-collapse:collapse;border:1pt solid red;}")
 D ..write("</style>")
 D ..write("<BODY>")
 D ..write("<table width='100%'>") ; border='"_1_"' cellspacing='0' cellpadding='0'>")
 ;заголовок отображения
 D ..write("<tr><td/><td>Объекты/Понятия</td><td>Условие</td><td>Выражение</td><td>A</td><td>D</td><td>Num</td><td>Sum</td><td>Min</td><td>Max</td><td>Mid</td></tr>")
 D ..write("<xsl:apply-templates/>")
 D ..write("</table></BODY></HTML></xsl:template>")
 ;образец объекта
 D ..write("<xsl:template match='O'>")
 D ..write("<div style='position:relative; left:10; visibility: visible;'>")
 D ..write("<table>")
 D ..write("<tr>")
 D ..write("<td>")
 D ..write("<xsl:for-each select='graf'>")
 ;D ..write("<xsl:apply-templates/>")
 D ..write("<IMG>")
 D ..write("<xsl:attribute name='src' >")
 D ..write("<xsl:value-of select='@src'/>")
 D ..write("</xsl:attribute>")
 D ..write("</IMG>")
 D ..write("</xsl:for-each>")
 D ..write("</td><td><xsl:value-of select='c0'/></td>")
 D ..write("<td><xsl:value-of select='c1'/></td>")
 D ..write("<td/><td/><td><xsl:value-of select='c1'/></td><td/><td/><td/><td/><td/></tr>")
 D ..write("</table>")
 D ..write("<xsl:apply-templates/>")
 D ..write("</div>")
 D ..write("</xsl:template>")
 ;образец понятия
 D ..write("<xsl:template match='W'>")
 D ..write("<div style='position:relative; left:10; visibility: visible;'>")
 D ..write("<table>")
 D ..write("<tr>")
 D ..write("<td>")
 ;картинка
 D ..write("<xsl:for-each select='graf'>")
 ;D ..write("<xsl:apply-templates/>")
 D ..write("<IMG>")
 D ..write("<xsl:attribute name='src' >")
 D ..write("<xsl:value-of select='@src'/>")
 D ..write("</xsl:attribute>")
 D ..write("</IMG>")
 D ..write("</xsl:for-each>")
 ;
 D ..write("</td><td><xsl:value-of select='c0'/></td>")
 F qi=1:1:9 D ..write("<td><xsl:value-of select='c"_qi_"'/></td>")
 D ..write("</tr>")
 D ..write("</table>")
 D ..write("</div>")
 D ..write("</xsl:template>")
 ;графика
 ;D ..write("<xsl:template match='graf'>")
 ;D ..write("<IMG>")
 ;D ..write("<xsl:attribute name='src' >")
 ;D ..write("<xsl:value-of select='@src'/>")
 ;D ..write("</xsl:attribute>")
 ;D ..write("</IMG>")
 ;D ..write("</xsl:template>")
 ;
 D ..write("</xsl:stylesheet>")
 D ..CloseDev(qqdev)
 Q
]]></Implementation>
</Method>

<Method name="XSLObj">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 ; описание разрывов страниц берём из локального массива - tdv 20110126
 n prtRef set prtRef = $name(Vo(qqnump,-1,3))
    
 D XSLObjProc(-1,-1)
 Q

XSLObjProc(qqo,qqlev)
 ;qqo  - код объекта
 ;qqob - уровень иерархии   
 D XSLObjwrite("")
 D XSLObjwrite("<xsl:template match='"_$S(qqo'=-1:"O"_$TR(qqo,"@","o"),1:"baseO")_"'>")

 N i,j,stri,coli,colnext,colspan,rowspan
 N val,res,tr,td
 N qqw, qqwxml
 N childs S childs=""
 n style,color,backColor,fontFormat,fontSize,isPic,scale,required

 ; флаг наличия заголовка таблицы
 n isHead s isHead = 0
 ; является ли текущая строка сквозной
 n isRepStr s isRepStr = 0
 ; есть ли параметр - выводимые строки
 n isOutStrPar s isOutStrPar = $s($g(Vo(qqnump,qqo,249))="":0,1:1)
 ; запрет переноса строки
 n avoidStrBreak set avoidStrBreak = 0

 I qqo=-1 D
 .;если вывод в Word и заданы параметры страницы, то используем класс Section1
 .;если коллонтитулы, то определяем id для тега <div>
 .i qOutput ?1(1"0",1"1",1"2",1"colH",1"colF") d
 ..i qOutput '= 2 d XSLObjwrite("<div"_$S(qOutput ?1(1"0",1"1"):" class='Section1'",qOutput="colH":" style='mso-element:header' id='h1'",qOutput="colF":" style='mso-element:footer' id='f1'",1:"")_">") 
 ..d XSLObjwrite("<table border='0' width='100%' cellspacing='0' cellpadding='0'>")
 .
 .; получаем размеры колонок в px
 .F i=0:1:col("lst") D
 ..D  ; ширина колонки
 ...; если есть динамическое значение, то берём его
 ...I $G(Vs(qqnump,"ColWidth",i))'="" S res=Vs(qqnump,"ColWidth",i) Q
 ...; иначе берём хранимое значение
 ...S val=$P($G(Vo(qqnump,-1,9,i)),",",1)
 ...; размер по умолчанию - 15 символов (1 символ = $P(W("Zfont"),",",3) px)
 ...I val="" S res=15*$P(W("Zfont"),",",3) Q
 ...I val=-1 S res=15*$P(W("Zfont"),",",3) Q
 ...; в символах
 ...I val=+val S res=val*$P(W("Zfont"),",",3) Q
 ...; в процентах
 ...I $TR(val,"1234567890.")="%" S res=qARM("Screen","Width")*(+val)\100 Q
 ...; в px
 ...I $TR(val,"1234567890.")="px" S res=+val Q
 ...; ошибочное значение
 ...S res=15*$P(W("Zfont"),",",3)
 ..
 ..; запоминаем размер в массив col
 ..S col("num",i)=res
 ..; сумма размеров колонок в px
 ..S col("all")=$G(col("all"),0)+res
 ..; сохраняем номер первой колонки с шириной'=0
 ..I res,col("fst")=-1 S col("fst")=i
 .
 .; если удалось определить ширину основной области вывода - переводим размеры колонок из px в mm
 .; выводим элементы col - работает только в Excel
 .I qARM.GetPar("X3699",qqoView_$C(1)_qqview)=1 F i=0:1:col("lst") S col("num",i,"mm")=$J(col("num",i)/pmm,0,1)     ; @KAR 20110328
 .I qARM.GetPar("X3699",qqoView_$C(1)_qqview)'=1,$G(col("all","mm")) F i=0:1:col("lst") S col("num",i,"mm")=$J((col("all","mm")*col("num",i)/col("all")),0,1)
 .
 .; вывод в Word - вставляем дополнительную строку (на случай возможных разрывов страниц и разделов)
 .i qOutput=1 d ..XslAddAction("EMPTY_STRING", xslRef, , , .col, $G(spaceBefore))
 .; вывод в Excel - вставляем размеры колонок <col .../>
 .i qOutput=2,grid,$G(col("all","mm")) d ..XslAddAction("COLUMNS", xslRef, , , .col)

 ; если вывод в Word - обрабатываем разрывы
 i qOutput = 1 d
 .; разрыв до
 .d ..XslAddPageBreak("before", prtRef, qqo, xslRef, .col)

 ; обход строк
 S stri="" F  S stri=$O(Vo(qqnump,qqo,0,stri)) Q:stri=""  D
 .I $G(Vs(qqnump,1,qqo,stri))=2 Q  ; @Dol 24.11.05 зачеркнутые строки не обрабатываются (=2)
 .I $D(Vs(qqnump,1,qqo,stri)) S val=0 D  Q:'val
 ..F coli=0:1:col("lst") I $L($G(Vo(qqnump,qqo,0,stri,coli)))>1,'$G(Vs(qqnump,1,qqo,stri,coli)) S val=1 Q  ; есть содержимое или не зачёркнута - выставляем флаг
 .
 .; определяем, есть ли ссылка на объект-потомок
 .S val=$G(Vo(qqnump,qqo,0,stri))
 .I stri,$G(Vs(qqnump,1,qqo,0))=-2,val=""  Q  ; @Dol 9.11.06 если зачеркнуты все строки кроме первой - не обрабатываем
 .; есть ссылка и объект развёрнут
 .I val'="" Q:$G(Vs(qqnump,3,qqo))  D  Q
 ..
 ..; если вывод в Word - обрабатываем сквозные строки
 ..i qOutput = 1 d
 ...; если не закрыли заголовок таблицы - закрываем
 ...i isHead d ..XslAddHeadAfter(xslRef, .isHead)
 ..
 ..D XSLObjwrite("<xsl:apply-templates select='O"_$TR(val,"@","o")_"'>") 
 ..;учитываем параметры сортировки @mike
 ..F i=1:1:$L(sort," ") I $TR(val,"@","o")=$P($P(sort," ",i),":") F j=1:1:$L($P($P(sort," ",i),":",2),",") D XSLObjwrite("<xsl:sort select='"_$TR($P($P($P(sort," ",i),":",2),",",j),"-#*","")_"'"_$S($E($TR($P($P($P(sort," ",i),":",2),",",j),"#",""))="-":" order='descending'",1:"")_""_$S($E($TR($P($P($P(sort," ",i),":",2),",",j),"-",""))="#":" data-type='number'",1:"")_"/>")
 ..D XSLObjwrite("</xsl:apply-templates>") S childs=childs_val_" "
 .
 .; обход ячеек
 .Q:$G(Vs(qqnump,1,qqo))  ;если текущий объект - зачеркнут, то его ячейки не обрабатываем
 .; если ячейка 0 строки 0 объекта -1 пустая или вывод в браузер - нет заголовков
 .I qqo=-1,stri=0,$E($G(Vo(qqnump,qqo,0,stri,0)),2,255)=""!(brow) Q
 .; параметры строки получаем из параметров нулевой ячейки строки
 .S prs("str")=$G(Vo(qqnump,qqo,0,stri,0,2))
 .; 16. высота строки - если равна 0, строка не выводится
 .S val=$P(prs("str"),",",16) I val=0 Q
 .; если вывод в Word - обрабатываем сквозные строки, запрет разрыва строки
 .i qOutput=1 d
 ..; 17. сквозная строка
 ..s isRepStr = ''$p(prs("str"), ",", 17)
 ..; обработка сквозных строк
 ..d ..XslAddHeadBefore(xslRef, .isHead, isRepStr)
 ..; 18. запрет разравы строки
 ..s avoidStrBreak = ''$p(prs("str"), ",", 18)
 .i isOutStrPar d XSLObjwrite("<xsl:if test=""not(NotOutStr[@num='"_stri_"'])"">")
 .S tr="<tr"
 .s style=""
 .i qOutput=1,avoidStrBreak s style="page-break-inside:avoid;"
 .I val'="" S res=..XslCheckSize(val) I res'="" S style=style_$S(qOutput?1(1"1",1"colH",1"colF"):"mso-height-rule:exactly;",qOutput=2:"mso-height-source:userset;",1:"")_"height:"_res_";"
 .I style'="" s tr=tr_" style='"_style_"'"
 .D XSLObjwrite(tr_">")
 .
 .D:brow
 ..D XSLObjwrite("")
 ..D XSLObjwrite("<xsl:attribute name='name'>O"_qqo_"/<xsl:value-of select='@id'/></xsl:attribute>")
 .
 .F coli=col("fst"):1:col("lst") D  ;было -1
 ..; параметры колонки получаем из параметров ячейки нуловой строки объекта -1
 ..S prs("col")=$G(Vo(qqnump,-1,0,0,coli,2)) ;параметры графы
 ..; определяем номер следующей обрабатываемой ячейки:
 ..; ширина > 0,не пустая,не зачёркнутая
 ..F colnext=coli+1:1:col("lst")+1 I $G(col("num",colnext)),$L($G(Vo(qqnump,qqo,0,stri,colnext)))>1,'$G(Vs(qqnump,1,qqo,stri,colnext)) Q
 ..; получаем тип_содержимое ячейки
 ..S qqw=$S('$D(Vs(qqnump,1,qqo,stri,coli)):$G(Vo(qqnump,qqo,0,stri,coli)),1:"")
 ..S qqwxml=$$XSLObjgetqqwxml(qqw)
 ..; параметры ячейки
 ..S prs("cell")=$G(Vo(qqnump,qqo,0,stri,coli,2))
 ..; параметры констант, выражений, понятий (@ZX* приравнены выражениям)
 ..S prs("def")=$G(Vo(qqnump,-1,$S("067"[$E(qqw):50,$E(qqw)=5:51,$E(qqw,1,4)="2@ZX":51,1:52)))
 ..; если не задан шрифт и его размер - берём из основного
 ..I $TR(prs("main"),",")'="" F i=1,2 S:$P(prs("def"),",",2*i+2)="" $P(prs("def"),",",2*i+2)=$P(prs("main"),",",i) ; 4,6 параметры
 ..; если параметр не задан в ячейке, берём его из prs("def")
 ..I $TR(prs("def"),",")'="" F i=1:1:11 I $P(prs("cell"),",",i)="",$P(prs("def"),",",i)'="" S $P(prs("cell"),",",i)=$P(prs("def"),",",i)
 ..; определяем значение rowspan
 ..S rowspan=$P(prs("cell"),",",20)
 ..D XSLObjwrite("<xsl:choose>")
 ..D  ; динамические параметры не учитываются/учитываются
 ...I ('X3698) D XSLObjwrite("<xsl:when test='"_$S(rowspan=0:"true()",1:"false()")_"'></xsl:when>") Q
 ...D XSLObjwrite("<xsl:when test='"_qqwxml_"/@rowspan and "_qqwxml_"/@rowspan=0'></xsl:when>")
 ...I (rowspan '="") D XSLObjwrite("<xsl:when test='not("_qqwxml_"/@rowspan) and "_$S(rowspan=0:"true()",1:"false()")_"'></xsl:when>")
 ..D XSLObjwrite("<xsl:otherwise>")
 ..S td="<td"
 ..; определяем значение colspan
 ..S colspan=0 F i=coli:1:colnext-1 I col("num",i) S colspan=colspan+1
 ..S td=td_$S(colspan=1:"",1:" colspan='"_colspan_"'")
 ..; 2. горизонтальное выравнивание (0 - лево, 1 - центр, 2 - право)
 ..S val=$P(prs("cell"),",",2) I val S td=td_" align='"_$P("center right"," ",val)_"'"
 ..; 7. вертикальное выравнивание (0 - центр, 1 - верх, 2 - низ)
 ..S val=$P(prs("cell"),",",7) s:val="" val=1 I val S td=td_" valign='"_$P("top bottom"," ",val)_"'"
 ..D XSLObjwrite(td_">")
 ..; rowspan
 ..D XSLObjwrite("<xsl:attribute name='rowspan'>") 
 ..D  ; динамические параметры не учитываются/учитываются
 ...I ('X3698) D  Q
 ....i (rowspan'="") D XSLObjwrite(rowspan)
 ...D XSLObjwrite("<xsl:choose>")
 ...D XSLObjwrite("<xsl:when test='"_qqwxml_"/@rowspan'><xsl:value-of select='"_qqwxml_"/@rowspan'/></xsl:when>")
 ...i (rowspan'="") D XSLObjwrite("<xsl:otherwise>"_rowspan_"</xsl:otherwise>")
 ...D XSLObjwrite("</xsl:choose>")
 ..D XSLObjwrite("</xsl:attribute>")
 ..; если есть другие передаваемые в печатную форму параметры ячейки
 ..S val=0 F i=1,4,5,6,8,9,10,11,14,15,19 I $P(prs("cell"),",",i)'="" S val=1 Q
 ..s (style,color,backColor,fontFormat,fontSize)=""
 ..I $S(val=1:1,grid:$G(col("all","mm")),coli'=col("fst"):0,1:qqlev>0) D
 ...; 1. ширина ячейки - только если сохранять размеры колонок и удалось определить ширину основной области вывода
 ...I grid,$G(col("all","mm")) S style=style_"width:"_$$XSLObjcolwidth(coli,colnext)_"mm;"
 ...; 4. шрифт
 ...S val=$P(prs("cell"),",",4) I val'="" S style=style_"font-family:"_$TR(qW.GetWoc("Cx724",val),"_"," ")_";"
 ...; 6. размер шрифта - если не указаны параметры основного фонта печатной формы, то брать относительные 8
 ...S val=$P(prs("cell"),",",6) I val'="" S fontSize=fontSize_"font-size:"_$S($P(prs("main"),",",2)'="":val_"pt;",1:$J(val/8*100,0,0)_"%;")
 ...; 5. оформление шрифта
 ...S val=$P(prs("cell"),",",5) S fontFormat=fontFormat_$S(val=1:"font-weight:bold;",val=2:"font-style:italic;",val=3:"text-decoration:underline;",val=4:"font-weight:bold;text-decoration:underline;",1:"")
 ...; 8. цвет символов
 ...S val=$P(prs("cell"),",",8) I 'X3695,val'="" S val=$TR($J($ZH(+val),6)," ",0),color=color_"color:#"_$E(val,5,6)_$E(val,3,4)_$E(val,1,2)_";"
 ...; 9. цвет фона
 ...S val=$P(prs("cell"),",",9) I 'X3695,val'="" S val=$TR($J($ZH(+val),6)," ",0),backColor=backColor_"background-color:#"_$E(val,5,6)_$E(val,3,4)_$E(val,1,2)_";"
 ...; 10. обрамление ячейки
 ...S val=$P(prs("cell"),",",10) I val'="",val'=0 S style=style_$S(table&(val=1):"border:none;",'table&(val=2):"border:0.5pt solid;",$L(val)>1:"border-left:"_$S('$E(val,1):"none",1:$S($E(val,1)>4:$E(val,1)/10,1:$E(val,1))_"pt solid")_";border-top:"_$S('$E(val,2):"none",1:$S($E(val,2)>4:$E(val,2)/10,1:$E(val,2))_"pt solid")_";border-right:"_$S('$E(val,3):"none",1:$S($E(val,3)>4:$E(val,3)/10,1:$E(val,3))_"pt solid")_";border-bottom:"_$S('$E(val,4):"none",1:$S($E(val,4)>4:$E(val,4)/10,1:$E(val,4))_"pt solid")_";",1:"") ;@Mike@Dol 02.03.06 val=1 - всегда отсутствует, 2 - всегда присутствует, иначе 4 размера ; tdv 20091217 - если 4 размера и значение > 4 оно делится на 10
 ...; 11. фильтр
 ...S val=$P(prs("cell"),",",11) I val'="" S style=style_"filter:"_val_";"
 ...; 14. отступы в ячейке
 ...S val=$P(prs("cell"),",",14) I val'="",$TR(val," ")'="" D
 ....; дописываем отсутствующие значения, проверяем, пишем
 ....S val=..XslAddSize(val," ",4) F i=1:1:4 S res=..XslCheckSize($P(val," ",i)) I res'="" S style=style_"padding-"_$P("top right bottom left"," ",i)_":"_res_";"
 ...; отображение уровня иерархии - только если не сохранять размеры колонок, первая выводимая колонка
 ...I coli=col("fst"),qqlev>0,$S(x3697'="":x3697,1:'grid) S style=style_"padding-left:"_(10*qqlev)_"pt;"
 ...; 15. отступ первой строки текста - для Excel не учитывается
 ...I qOutput'=2 S val=$P(prs("cell"),",",15) I val'="" S res=..XslCheckSize(val) I res'="" S style=style_"text-indent:"_res_";"
 ...; 19. поворот текста
 ...I qOutput?1(1"1",1"2") S val=$P(prs("cell"),",",19) I val'="",val'=0 S style=style_"mso-rotate:"_$s(val=1:90,val=2:-90,1:"")_";"
 ..
 ..; типы ячеек для Excel
 ..i qOutput=2 s val=$g(Vo(qqnump,qqo,0,stri,coli,10)) i val'="" s scale=$g(Vo(qqnump,qqo,0,stri,coli,88)),required=$g(Vo(qqnump,qqo,0,stri,coli,89)) s:$e(scale)="@" @("scale="_$e(scale,2,$l(scale))) s res=..XslNumberFormat(val, scale, required) i res'="" s style=style_"mso-number-format:"""_res_""";"
 ..
 ..I brow,$E(qqw),"567"'[$E(qqw) D XSLObjwrite(""),XSLObjwrite("<xsl:attribute name='name'>"_$TR($S($E(qqw,2)?1N:"O",1:"")_$E($P($P(qqw," "),"{"),2,255),"@:{}<>()""=/","ooooooooooo")_"</xsl:attribute>")
 ..
 ..D
 ...; есть картинка
 ...S isPic=($G(Vo(qqnump,qqo,0,stri,coli,6))'="")
 ...; понятие
 ...I $E(qqw),"67"'[$E(qqw) D  Q
 ....I $E(qqw,2)'="L" D  Q
 .....; динамические параметры
 .....do ..XslSetStyle(xslRef,style,qqwxml,color,backColor,fontFormat,fontSize,X3695,X3698)
 .....i isPic d XSLObjpic()
 .....; спец. поля
 .....I $P(qqwxml,"_")="oZXXPF" D  Q
 ......I qOutput?1(1"1",1"colH",1"colF") S val=$P(qqwxml,"_",2) d ..XslSetField(xslRef, val)
 .....; тип ячейки - список или тип данных - текст (T) или тип данных - DOCUMENT или многострочность - документ - обрабатываем абзацы
 .....I $E(qqw)=3!($E(qqwxml)="T")!($G(Vo(qqnump,qqo,0,stri,coli,10))=3)!($P(prs("cell"),",",3)=1) D XSLObjwrite("<xsl:apply-templates select='"_qqwxml_"/p'/>") Q
 .....D XSLObjwrite("<xsl:copy-of select='"_qqwxml_"/node()'/>")
 ....
 ....; для списка агрегатов аналитик(временно)
 ....; динамические параметры ячейки
 ....do ..XslSetStyle(xslRef,style,qqwxml,color,backColor,fontFormat,fontSize,X3695,X3698)
 ....i isPic d XSLObjpic()
 ....D XSLObjwrite("<xsl:for-each select='"_qqwxml_"'>")
 ....D XSLObjwrite("Num="),XSLObjwrite("<xsl:value-of select='Num'/>")
 ....D XSLObjwrite("Sum="),XSLObjwrite("<xsl:value-of select='Sum'/>")
 ....D XSLObjwrite("Min="),XSLObjwrite("<xsl:value-of select='Min'/>")
 ....D XSLObjwrite("Max="),XSLObjwrite("<xsl:value-of select='Max'/>")
 ....D XSLObjwrite("Mid="),XSLObjwrite("<xsl:value-of select='Mid'/>")
 ....D XSLObjwrite("</xsl:for-each>")
 ...
 ...; константа
 ...; динамические параметры
 ...do ..XslSetStyle(xslRef,style,qqwxml,color,backColor,fontFormat,fontSize,X3695,X3698)
 ...i isPic d XSLObjpic()
 ...S qqw=$E(qqw,2,30000) I $E(qqw,1)="@" S qqw=$E($P(qqw," "),2,255),qqw=$TR($S(qqw="":qW.GetWoc("CxObj",qqo),1:qW.GetWoc("CxWoc",qqw)),"_%"," ")
 ...D XSLObjwrite($S(qqw=" ":"&#160;",qqw[$C(13,10):$$XSLObjconst(qqw),1:qW.CXML(qqw)))
 ..
 ..D XSLObjwrite("</td>")
 ..D XSLObjwrite("</xsl:otherwise>")
 ..D XSLObjwrite("</xsl:choose>")
 ..S coli=colnext-1 ; пропускаем пустые и зачёркнутые ячейки
 .D XSLObjwrite("</tr>")
 .i isOutStrPar d XSLObjwrite("</xsl:if>")

 ; если вывод в Word - обрабатываем сквозные строки и разрыв после
 i qOutput = 1 d
 .; если не закрыли заголовок таблицы - закрываем
 .i isHead d ..XslAddHeadAfter(xslRef, .isHead)
 .; разрыв после
 .d ..XslAddPageBreak("after", prtRef, qqo, xslRef, .col)

 I qqo=-1 D
 .i qOutput ?1(1"0",1"1",1"2",1"colH",1"colF") d  q
 ..d XSLObjwrite("</table>")
 ..i qOutput'=2 D XSLObjwrite("</div>")
 ..
 ..; если вывод в Word
 ..i qOutput = 1 d
 ...; записываем абзац в конце таблицы
 ...D XSLObjwrite("<p style='font-size:1pt;'>&#160;</p>")

 D XSLObjwrite("</xsl:template>")

 I childs'="" F i=1:1:$L(childs," ")-1 D XSLObjProc($P(childs," ",i),qqlev+1)   
 
XSLObjpic()
 D XSLObjwrite("<xsl:for-each select='Opic"_stri_"c"_coli_"'>")
 D XSLObjwrite("<img src='{@src}'>")
 D XSLObjwrite("<xsl:if test='@height'><xsl:attribute name='height'><xsl:value-of select='@height'/></xsl:attribute></xsl:if>")
 D XSLObjwrite("<xsl:if test='@width'><xsl:attribute name='width'><xsl:value-of select='@width'/></xsl:attribute></xsl:if>")
 D XSLObjwrite("</img>")
 D XSLObjwrite("</xsl:for-each>")
 Q
 
XSLObjgetqqwxml(qqw)
 N qqwxml
 ; понятие
 I $E(qqw),"67"'[$E(qqw) D  Q qqwxml
 .I $E(qqw,2)'="L" D  Q
 ..S qqwxml=$S($E(qqw)=5:"Zs"_stri_"c"_coli,1:$TR($S($E(qqw,2)?1N:"O",1:"")_$E($P($P(qqw," "),"{"),2,255),"@:{}<>()""=/","ooooooooooo"))
 .
 .; для списка агрегатов аналитик
 .s qqwxml=$E($S($E(qqw)=5:"Zs"_stri_"c"_coli,1:$TR($P($P(qqw," "),"{"),"@:{}<>()""=/","ooooooooooo")),2,20)
 
 ; константа
 s qqwxml="Zs"_stri_"c"_coli
 q qqwxml

XSLObjwrite(str)
 I $G(xslRef)'="" S @xslRef@($I(@xslRef))=str_$C(13,10) Q
 D ..write(str)
 Q

XSLObjcolwidth(num,len)
 N i,res S res=0
 F i=num:1:len-1 S res=res+col("num",i,"mm")
 Q res

XSLObjconst(val)
 N res S res=""
 N i F i=1:1:$L(val,$C(13,10)) S res=res_$S(qOutput=2:$S(res="":"",1:"<br/>"),1:"<p>")_qW.CXML($P(val,$C(13,10),i))_$S(qOutput=2:"",1:"</p>")
 Q res
]]></Implementation>
</Method>

<Method name="XSLcom">
<Description>
комментарии в XSL</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 ;;;;;;;;;;;;comm1
 ; prs("main") - основной шрифт и фон
 ; prs("def")  - параметры констант, понятий, выражений по умолчанию
 ; prs("col")  - параметры колонки
 ; prs("str")  - параметры строки
 ; prs("cell") - параметры ячейки
 
 ;;;;;;;;;;comm2
 ; page("width") - ширина страницы
 ; page("left")  - левое поле
 ; page("right") - правое поле
 
 ;;;;;;;;;;comm3
 ; col("fst") - номер первой обрабатываемой колонки
 ; col("lst") - номер последней колонки
 ; col("num",cnt) - размер колонки cnt в px
 ; col("num",cnt,"mm") - размер колонки cnt в mm
 ; col("all") - сумма размеров колонок в px
 ; col("all","mm") - сумма размеров колонок в mm
 q
]]></Implementation>
</Method>

<Method name="XSLcor">
<Internal/>
<FormalSpec>qqdev:%Library.String="qword.xsl",full:%Library.String=0,table:%Library.String,brow:%Library.String=0,qOutput:%Library.String=0,q:%Library.String,qFlag:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N par,par0 ;параметры печати по умолчанию
 S par=qARM.GetPar(355) ;основной фонт и размеры
 S:$G(table)="" table=qARM.GetPar(321) ;D qARM.Message(table)
 D ..OpenDev(qqdev) D:'$G(qFlag) ..write("<?xml version='1.0' encoding='windows-1251'?>")
 d ..write($c(13,10)) D ..write("<xsl:stylesheet xmlns:xsl=""http://www.w3.org/TR/WD-xsl"">")
 ;шаблон для обработки текстов и списков; 
 ;атрибут indent(если существует) указывает на наличие красной строки;его значение-размер в сантиметрах
 d ..write($c(13,10)) D ..write("<xsl:template match='p'>"),..write("<p>")
 D ..write("<xsl:if test='@indent'><xsl:attribute name='style'>text-indent:<xsl:value-of select='@indent'/>cm;</xsl:attribute></xsl:if>")
 D ..write("<xsl:value-of/></p></xsl:template>")
 ;описание корневого элемента
 d ..write($c(13,10)) D ..write("<xsl:template match='/'>")
 d ..write($c(13,10)) D ..write("<HTML"_$S(qOutput=1:" xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'",1:"")_">")
 d ..write($c(13,10)) D ..write("<head><meta http-equiv='Content-Type' content='text/html; charset=utf-8'></meta>") ;указание кодировки обязательно!!!
 I qOutput=1 D  ;вставка для MS Word
 .I qARM.GetPar(362)'=""!(qARM.GetPar(363)'="") D  ;если есть коллонтитулы
 ..D ..write("<link rel='File-List' href='qword_filelist.xml'/>")
 ..D ..write("<xsl:comment><![CDATA[[if gte mso 9]><xml>")
 ..D ..write("<o:OfficeDocumentSettings><o:DoNotOrganizeInFolder/></o:OfficeDocumentSettings>") ;определяет, что связанные файлы находятся не в папке
 ..D ..write("</xml><![endif]")
 ..D ..write("]]]]><![CDATA[></xsl:comment>")
 .;параметры вывода документа в Word: вид-разметка страницы, автоматическая расстановка переносов, ширина зоны переноса
 .D ..write("<xsl:comment><![CDATA[[if gte mso 9]><xml><w:WordDocument>")
 .D ..write("<w:View>Print</w:View>") ;определяет вид документа:страница
 .D ..write("<w:AutoHyphenation/>") ;автоматическая расстановка переносов
 .D ..write("<w:HyphenationZone>7</w:HyphenationZone>") ;ширина зоны переноса в pt
 .D ..write("</w:WordDocument></xml><![endif]")
 .D ..write("]]]]><![CDATA[></xsl:comment>")
 d ..write($c(13,10)) D ..write("<style>")
 d ..write($c(13,10)) D ..write("table{fixed-layout:fixed;border:"_table_"pt solid;padding:0pt;"_$S(qOutput'>0:"",qOutput>2:"",1:"border-collapse:collapse;")_"}") ;для MS_Word и Excel:border-collapse='collapse',иначе границы таблицы и ячейки не совпадают(отдельные линии)
 d ..write($c(13,10)) D ..write("td{border:"_table_"pt solid;}")
 d ..write($c(13,10)) D ..write("p{margin:0;padding:0;}")
 I qOutput=1 N x364 S x364=qARM.GetPar(364) I x364'="" D ..ParStr(x364) ;если вывод в Word и заданы параметры страницы
 D ..write("</style></head>")
 d ..write($c(13,10)) D ..write("<BODY")
 D:brow ..write(" onClick=""parent.frames('menu').examplesClick()"" onResize=""parent.frames('menu').resizeHead()"" onScroll=""parent.frames('menu').scrollHead()""")
 ;если вывод в Word и заданы параметры страницы,
 ;то определяем класс Section1, который был определен в %qWEB.ParStr
 ;если коллонтитулы, то определяем id для тега <div>
 D ..write("><div"_$S(qOutput="colH":" style='mso-element:header' id='h1'",qOutput="colF":" style='mso-element:footer' id='f1'",$G(x364)="":"",qOutput=1:" class='Section1'",1:"")_">")
 d ..write($c(13,10)) D ..write("<FORM action="""_q_"respcor.csp"" method=""post"">")   
 d ..write($c(13,10)) D ..write("<xsl:apply-templates select='baseO'/>")
 d ..write($c(13,10)) D ..write("<INPUT type=""submit"" value=""Обновить""></INPUT>")
 d ..write($c(13,10)) D ..write("</FORM>")
 d ..write($c(13,10)) D ..write("</div></BODY></HTML>")
 D ..write("</xsl:template>")
 ;обход отображения
 D xslo1(-1,"",-1)
 D ..write("</xsl:stylesheet>")
 D:'brow ..CloseDev(qqdev)
 Q:$Q "" Q
xslo1(qqo,qqob,qqlev)  ;обход объекта
 ;qqo  - код объекта
 ;qqob - xml-ссылка на объект
 ;D:qqo'=-1 ..write("<xsl:template match='O"_qqo_"'>")
 d ..write($c(13,10)) D ..write("<xsl:template match='"_$S(qqo'=-1:"O"_$TR(qqo,"@","o"),1:"baseO")_"'>") D:qqo=-1 ..write("<table id='table' width='100%' cellspacing='0' cellpadding='1'>")
 N qqso,qqz,qi,qqw,qqk,qChilds S qChilds=""
 ;обход строк
 S qqso="" F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""  D
 .S qqz=$G(Vo(qqnump,qqo,0,qqso))
 .I qqz'="" D  Q  ;D:$S(full:1,1:'$G(Vs(qqnump,3,qqo))) xslo(qqz,"O"_qqz,qqlev+1) Q
 ..S %1='$G(Vs(qqnump,3,qqo))
 ..I %1!(full) d ..write($c(13,10)) D ..write("<xsl:if expr='"_%1_"'><xsl:apply-templates select='O"_$TR(qqz,"@","o")_"'/></xsl:if>") S qChilds=qChilds_qqz_" "
 .;обход ячеек
 .Q:$G(Vs(qqnump,1,qqo))
 .I qqo=-1,'qqso,$E($G(Vo(qqnump,-1,0,qqso,0)),2,255)=""!(brow) Q  ;если ячейка 0 строки 0 объекта -1 пустая или вывод в браузер - нет заголовков
 .N qqstr S qqstr="" F qi=0:1:Vo(qqnump,-1,9) S qqw=$G(Vo(qqnump,qqo,0,qqso,qi)) I $E(qqw),'$D(Vs(qqnump,1,qqo,qqso,qi)) S qqstr=qqstr_$S($E(qqw)=5:"Zs"_qqso_"c"_qi,1:$TR($E($P(qqw," "),2,255),"@","o"))_"$or$" ;@dol '$D(Vs(qqnump,1,qqo,qqso,qi))
 .d ..write($c(13,10)) D:qqstr'="" ..write("<xsl:if test='.["_$P(qqstr,"$or$",1,$L(qqstr,"$or$")-1)_"]'>")
 .d ..write($c(13,10)) D ..write("<tr valign='top'>") D:brow
 ..;D ..write("<xsl:attribute name='onclick'>sethead(this)</xsl:attribute>")
 ..d ..write($c(13,10)) D ..write("<xsl:attribute name='name'>O"_qqo_"/<xsl:value-of select='@id'/></xsl:attribute>")
 .N qqz1,qi1 F qi=0:1:Vo(qqnump,-1,9) D  ;было -1
 ..F qi1=qi+1:1:Vo(qqnump,-1,9)+1 I $G(Vo(qqnump,qqo,0,qqso,qi1))'="",'$D(Vs(qqnump,1,qqo,qqso,qi1)) Q  ;@dol было Q:$G(Vo(qqnump,qqo,0,qqso,qi1))'=""
 ..S (qiiii,qqw)=$S('$D(Vs(qqnump,1,qqo,qqso,qi)):$G(Vo(qqnump,qqo,0,qqso,qi)),1:"") ;@dol '$D(Vs(qqnump,1,qqo,qqso,qi))
 ..S qqsty=$G(Vo(qqnump,qqo,0,qqso,qi,2))
 ..;умолчания
 ..S par0=$G(Vo(qqnump,-1,$S($E(qiiii)=0:50,$E(qiiii)=5:51,1:52))) ;параметры констант, выражений, понятий
 ..I $TR(par,",")'="" S:$P(par0,",",4)="" $P(par0,",",4)=$P(par,",",1) S:$P(par0,",",6)="" $P(par0,",",6)=$P(par,",",2)
 ..I $TR(par0,",")'="" D
 ...F qiiii=1:1:11 I $P(qqsty,",",qiiii)="",$P(par0,",",qiiii)'="" S $P(qqsty,",",qiiii)=$P(par0,",",qiiii)
 ..S qiiii="<TD"_$S(+qqsty>0:" width='"_(+qqsty)_"%'",1:"")_$S((qi1-qi)=1:"",1:" colspan='"_(qi1-qi)_"'")_$S('$P(qqsty,",",2):"",1:" align='"_$P("center right"," ",$P(qqsty,",",2))_"'")_$S('$P(qqsty,",",7):"",1:" valign='"_$P("center bottom"," ",$P(qqsty,",",7))_"'")
 ..S $P(qqsty,",",7)="" I $TR($P(qqsty,",",4,20),",")'=""!('qi&qqlev>0) D  S qiiii=qiiii_"'"
 ...S qiiii=qiiii_" style='"
 ...S:$P(qqsty,",",4)'="" qiiii=qiiii_"font-family:"_$TR(qW.GetWoc("Cx724",$P(qqsty,",",4)),"_"," ")_";"
 ...S:$P(qqsty,",",6)'="" qiiii=qiiii_"font-size:"_$S($P(par,",",2)'="":$P(qqsty,",",6)_"pt;",1:$J($P(qqsty,",",6)/8*100,0,0)_"%;") ;если не указаны параметры основного фонта печатной формы, то брать относительные 8 (раньше было всегда)
 ...S:$P(qqsty,",",5)=1 qiiii=qiiii_"font-weight:bold;"
 ...S:$P(qqsty,",",5)=2 qiiii=qiiii_"font-style:italic;"
 ...S:$P(qqsty,",",5)=3 qiiii=qiiii_"text-decoration:underline;"
 ...S:$P(qqsty,",",5)=4 qiiii=qiiii_"font-weight:bold; text-decoration:underline;"
 ...S:$P(qqsty,",",8)'="" qqk=$TR($J($ZH(+$P(qqsty,",",8)),6)," ",0),qiiii=qiiii_"color:#"_$E(qqk,5,6)_$E(qqk,3,4)_$E(qqk,1,2)_";" ;???
 ...S:$P(qqsty,",",9)'="" qqk=$TR($J($ZH(+$P(qqsty,",",9)),6)," ",0),qiiii=qiiii_"background-color:#"_$E(qqk,5,6)_$E(qqk,3,4)_$E(qqk,1,2)_";" ;???
 ...S:$P(qqsty,",",10) qqk=$P(qqsty,",",10),qiiii=qiiii_$S('table&(qqk=2):"border:1pt solid;",table&(qqk=1):"border-style:none;",1:"")
 ...S:$P(qqsty,",",11)'="" qqk=$P(qqsty,",",11),qiiii=qiiii_"filter:"_qqk_";"
 ..d ..write($c(13,10)) D ..write(qiiii_">") I brow,$E(qqw),$E(qqw)'=5 d ..write($c(13,10)) D ..write("<xsl:attribute name='name'>"_$TR($E($P(qqw," "),2,255),"@","o")_"</xsl:attribute>")
 ..D:'qi&(qqlev>0) ..write("<p style='margin-left:"_(10*qqlev)_"pt;'>") D  D ..write($S(qi:"",qqlev'>0:"",1:"</p>")_"</TD>") S qi=qi1-1
 ...D:$G(Vo(qqnump,qqo,0,qqso,qi,6))'=""  ;есть картинка
 ....D ..write("<xsl:for-each select='Opic"_qqso_"c"_qi_"'>")
 ....D ..write("<IMG>")
 ....D ..write("<xsl:attribute name='src' >")
 ....D ..write("<xsl:value-of select='@src'/>")
 ....D ..write("</xsl:attribute>")
 ....D ..write("</IMG>")
 ....D ..write("</xsl:for-each>")
 ...I $E(qqw) D  Q  ;понятие
 ....I $E(qqw,2)'="L" D  Q
 .....S %1=$E(qqw),qqw=$S($E(qqw)=5:"Zs"_qqso_"c"_qi,1:$TR($E($P(qqw," "),2,255),"@","o"))
 .....;i $e(qqw)'="Z",$e(qqw)'="o" d           ;с редактированием списка - не работает
 .....i $e(qqw)'="Z",$e(qqw)'="o",+%1'=3,($G(Vo(qqnump,qqo,0,qqso,qi,10))'=3) d      ;исключить из редактирования список
 ......d ..write($c(13,10)) I ($E(qqw)'="T") {D ..write("<INPUT>")} ELSE { D ..write("<TEXTAREA rows=""4"" cols=""30"">")}
 ......d ..write($c(13,10)) D ..write("<xsl:attribute name=""name"">")
 ......d ..write($c(13,10)) D ..write("<xsl:eval>"""_qqo_" "_qqw_" ""+"_"selectSingleNode(""@id"").value")
 ......d ..write($c(13,10)) D ..write("</xsl:eval></xsl:attribute>")
 ......i ($E(qqw)'="T") {d ..write($c(13,10)) D ..write("<xsl:attribute name=""value"">")}
 .....i ($E(qqw)'="T") d
 ......d ..write($c(13,10)) D ..write("<xsl:choose>")
 ......d ..write($c(13,10)) D ..write("<xsl:when test='"_qqw_"'>") D  D ..write("</xsl:when>")
 .......I +%1=3!($G(Vo(qqnump,qqo,0,qqso,qi,10))=3) d ..write($c(13,10)) D ..write("<xsl:apply-templates select='"_qqw_"/p'/>") Q  ;DOCUMENT
 .......d ..write($c(13,10)) D ..write("<xsl:value-of select='"_qqw_"'/>")
 ......d ..write($c(13,10)) D ..write("<xsl:otherwise>&#160;</xsl:otherwise>") ;"&#160"-обязательный пробел(&nbsp)
 ......D ..write("</xsl:choose>")
 .....i ($E(qqw)="T") {d ..write($c(13,10)) D ..write("<xsl:for-each select='"_qqw_"/p'>") D ..write("<xsl:value-of select='.'/>"_$c(13,10)_"</xsl:for-each>") }
 .....;i $e(qqw)'="Z",$e(qqw)'="o"  D ..write("</xsl:attribute>")  D ..write("</INPUT>")    ;с редактированием списка - не работает
 .....i $e(qqw)'="Z",$e(qqw)'="o",+%1'=3,($G(Vo(qqnump,qqo,0,qqso,qi,10))'=3)  D:($E(qqw)'="T") ..write("</xsl:attribute>")  I ($E(qqw)'="T") {D ..write("</INPUT>")} ELSE  {D ..write("</TEXTAREA>")}  ;исключить из редактирования список
 ....;для списка агрегатов аналитик(временно)
 ....d ..write($c(13,10)) D ..write("<xsl:for-each select='"_$E($S($E(qqw)=5:"Zs"_qqso_"c"_qi,1:$TR($P(qqw," "),"@","o")),2,20)_"'>")
 ....D ..write("Num="),..write("<xsl:value-of select='Num'/>")
 ....D ..write("Sum="),..write("<xsl:value-of select='Sum'/>")
 ....D ..write("Min="),..write("<xsl:value-of select='Min'/>")
 ....D ..write("Max="),..write("<xsl:value-of select='Max'/>")
 ....D ..write("Mid="),..write("<xsl:value-of select='Mid'/>")
 ....D ..write("</xsl:for-each>")
 ...S qqw=$E(qqw,2,30000) I $E(qqw,1)="@" S qqw=$E($P(qqw," "),2,255),qqw=$TR($S(qqw="":qW.GetWoc("CxObj",qqo),1:qW.GetWoc("CxWoc",qqw)),"_%"," ")
 ...D ..write($S(qqw="":"&#160;",qqw[$C(13,10):$$XSLconst1(qW.CXML(qqw)),1:qW.CXML(qqw)))
 .D ..write("</tr>")
 .D:qqstr'="" ..write("</xsl:if>")
 D:qqo=-1 ..write("</table>") D ..write("</xsl:template>")
 I qChilds'="" F qqz=1:1:$L(qChilds," ")-1 D xslo1($P(qChilds," ",qqz),"",qqlev+1)
 Q
XSLconst1(str)
 N pos S pos=1 F  S pos=$F(str,$C(13,10),pos) Q:'pos  S $E(str,pos-2,pos-1)="</p><p>"
 Q "<p>"_str_"</p>"
]]></Implementation>
</Method>

<Method name="XslAddAction">
<Description><![CDATA[
Вставка разрыва или заголовка<br/>
Параметры:<br/>
action - тип действия<br/>
xslRef - глобал с текстом xsl<br/>
pageBreakType - тип разрыва страницы<br/>
pageBreakPos - позиция разрыва страницы<br/>
col - размеры колонок<br/>
spaceBefore - отступ сверху в основной области печати в мм]]></Description>
<Internal/>
<FormalSpec><![CDATA[action:%Library.String,xslRef:%Library.String,pageBreakType:%Library.String,pageBreakPos:%Library.String,&col:%Library.String,spaceBefore:%String]]></FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; начальный и конечный теги текста
 n text
 s text("start") = "<xsl:text disable-output-escaping='yes'><![CDATA["
 s text("end") = "]]]]><![CDATA[></xsl:text>" 

 ; действия     

 ; ничего не делаем
 i action = "DO_NOTHING" q

 ; ошибка - ничего не делаем
 i action = "ERROR" q

 ; закрытие таблицы
 i action = "CLOSE_TABLE" d  q
 .; заканчиваем предыдущую таблицу
 .d ..XslWrite(xslRef, text("start")_"</table>"_text("end"))
 .; заканчиваем предыдущий раздел
 .d ..XslWrite(xslRef, text("start")_"</div>"_text("end"))

 ; открытие таблицы
 i action = "OPEN_TABLE" d  q
 .; начинаем следующий раздел
 .d ..XslWrite(xslRef, text("start")_"<div class='Section1'>"_text("end"))
 .; начинаем следующую таблицу
 .d ..XslWrite(xslRef, text("start")_"<table border='0' width='100%' cellspacing='0' cellpadding='0'>"_text("end"))

 ; закрытие заголовка
 i action = "CLOSE_HEAD" d  q
 .; заканчиваем заголовок таблицы
 .d ..XslWrite(xslRef, "</thead>")

 ; открытие заголовка
 i action = "OPEN_HEAD" d  q
 .; начинаем заголовок таблицы
 .d ..XslWrite(xslRef, "<thead>")

 ; пустая строка
 i action = "EMPTY_STRING" d  q
 .d
 ..i ($g(spaceBefore)>0) d ..XslWrite(xslRef, "<tr style='mso-height-rule:exactly;height:"_spaceBefore_"mm;'>") q
 ..d ..XslWrite(xslRef, "<tr style='mso-height-rule:exactly;height:1pt;'>")
 .; colspan
 .; подсчитываем выводимое кол-во колонок
 .n colInd
 .n colAmt s colAmt = 0
 .f colInd=col("fst"):1:col("lst") d
 ..i col("num", colInd) '= 0 s colAmt = $i(colAmt)
 .;
 .n td s td = "<td colspan='" _ (colAmt) _ "'"
 .; обрамления нет
 .s td = td _ " style='border:none;" d  s td = td_"'"
 ..; ширина ячейки - только если удалось определить ширину основной области вывода
 ..i $g(col("all", "mm")) s td = td _ "width:" _ col("all","mm") _ "mm;"
 .d ..XslWrite(xslRef, td _ ">")
 .d ..XslWrite(xslRef, "&#160;")
 .d ..XslWrite(xslRef, "</td>")
 .d ..XslWrite(xslRef, "</tr>")
 
 ; размеры колонок для Excel
 i action = "COLUMNS" d  q
 .i '$g(col("all", "mm")) q
 .; обходим колонки
 .n colInd
 .f colInd=col("fst"):1:col("lst") d
 ..i col("num", colInd)'=0 d ..XslWrite(xslRef, "<col style='width:" _ col("num", colInd, "mm") _"mm;'/>")

 ; разрыв раздела на текущей странице
 i action = "BREAK_SECTION" d  q
 .d ..XslWrite(xslRef, "<br clear='all' style='page-break-before:auto;mso-break-type:section-break'/>")

 ; устанавливаем проверку позиции разрыва
 i action = "IF" d  q
 .i $g(pageBreakPos) '= "" d
 ..d ..XslWrite(xslRef, "<xsl:if test='"_pageBreakPos_"'>")

 ; устанавливаем проверку позиции разрыва
 i action = "END_IF" d  q
 .; устанавливаем позицию разрыва
 .i $g(pageBreakPos) '= "" d
 ..d ..XslWrite(xslRef, "</xsl:if>")

 ; разрыв страницы
 i action = "BREAK_PAGE" d  q
 .
 .; не указан разрыв страницы
 .i $g(pageBreakType) = "" q
 .
 .; неверный тип разрыва страницы
 .i pageBreakType '?1(1"0",1"1",1"2",1"3") q
 .
 .; типы разрывов страниц
 .n pbType
 .s pbType(0) = "NONE"
 .s pbType(1) = "ALWAYS"
 .s pbType(2) = "EVEN"
 .s pbType(3) = "ODD"
 .
 .; определяем тип разрыва
 .s pageBreakType = pbType(pageBreakType)
 .
 .; нет разрыва
 .i pageBreakType = "NONE" q
 .
 .d ..XslWrite(xslRef, "<span style='font-size:1pt'>")
 .
 .d
 ..; на следующую станицу
 ..i pageBreakType = "ALWAYS" d  q
 ...d ..XslWrite(xslRef, "<br clear='all' style='page-break-before:always;mso-break-type:section-break'/>")
 ..
 ..; на следующую чётную страницу
 ..i pageBreakType = "EVEN" d  q
 ...d ..XslWrite(xslRef, "<br clear='all' style='page-break-before:left;mso-break-type:section-break'/>")
 ..
 ..; на следующую нечётную страницу
 ..i pageBreakType = "ODD" d  q
 ...d ..XslWrite(xslRef, "<br clear='all' style='page-break-before:right;mso-break-type:section-break'/>")
 .
 .d ..XslWrite(xslRef, "</span>")

 q
]]></Implementation>
</Method>

<Method name="XslAddHeadAfter">
<Description><![CDATA[
Обработка сквозных строк (после)<br/>
Параметры:<br/>
xslRef - глобал с текстом xsl<br/
isHead - флаг наличия заголовка таблицы<br/>]]></Description>
<Internal/>
<FormalSpec><![CDATA[xslRef:%Library.String,&isHead:%Library.String]]></FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; если нет заголовка - выходим 
 i isHead = 0 

 ; определяем действие
 n action s action = "CLOSE_HEAD"

 ; выполняем действие
 d ..XslAddAction(action, xslRef)
 ; устанавливаем флаг наличия заголовка
 s isHead = 0

 q
]]></Implementation>
</Method>

<Method name="XslAddHeadBefore">
<Description><![CDATA[
Обработка сквозных строк (до)<br/>
Параметры:<br/>
xslRef - глобал с текстом xsl<br/
isHead - флаг наличия заголовка таблицы<br/>
isRepStr - флаг, является ли строка сквозной<br/>]]></Description>
<Internal/>
<FormalSpec>xslRef:%Library.String,isHead:%Library.String,isRepStr:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; разделитель
 n sep s sep = " "

 ; таблица действий
 n act
 ; (isHead, isRepStr)
 s act(0, 0) = "DO_NOTHING"
 s act(0, 1) = "CLOSE_TABLE"_sep_"BREAK_SECTION"_sep_"OPEN_TABLE"_sep_"OPEN_HEAD"
 s act(1, 0) = "CLOSE_HEAD"
 s act(1, 1) = "DO_NOTHING"

 ; определяем действие
 n action s action = act(isHead, isRepStr)

 ; количество частей действия
 n actionLen s actionLen = $l(action, sep)
 ; часть действия
 n actionPart
 ; индекс частей действия
 n actionPartIdx

 ; обходим и выполняем части действия
 f actionPartIdx = 1 : 1 : actionLen d
 .; получаем часть действия
 .s actionPart = $p(action, sep, actionPartIdx)
 .; выполняем чать действия
 .d ..XslAddAction(actionPart, xslRef)
 .; устанавливаем флаг наличия заголовка
 .i actionPart ?1(1"CLOSE_HEAD",1"OPEN_HEAD") d
 ..s isHead = $s(actionPart = "CLOSE_HEAD" : 0, 1 : 1)

 q
]]></Implementation>
</Method>

<Method name="XslAddPageBreak">
<Description><![CDATA[
Вставка разрыва страницы<br/>
Параметры:<br/>
place - положение разрыва<br/>
prtRef - глобал с набором печати<br/>
obj - код объекта<br/>
xslRef - глобал с текстом xsl<br/>
col - массив размеров колонок<br/>]]></Description>
<Internal/>
<FormalSpec><![CDATA[place:%Library.String,prtRef:%Library.String,obj:%Library.String,xslRef:%Library.String,&col:%Library.String]]></FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; таблица кодов положений
 n placeCode
 s placeCode("before") = 0
 s placeCode("after") = 1

 n placeRef

 ; есть нет такого объекта разрыва - выходим
 i '$d(@prtRef@("XPageBreakObj", qqo)) q

 ; есть нет такого положения разрыва - выходим
 s placeRef = $na(@prtRef@("XPageBreakObj", obj, "XPageBreakPlace", placeCode(place)))
 i '$d(@placeRef) q

 ; получаем тип разрыва
 n pageBreakType s pageBreakType = +$g(@placeRef@("xPageBreakType"))
 ; тип не определён - выходим
 i pageBreakType = 0 q

 ; получаем позицию разрыва
 n pageBreakPos s pageBreakPos = ..XslGetPageBreakPos(placeRef)
 ; позиция не определена - выходим
 i pageBreakPos = "" q

 ; разделитель
 n sep s sep = " "

 ; определяем действие
 n action s action = "IF"_sep_"CLOSE_TABLE"_sep_"BREAK_PAGE"_sep_"OPEN_TABLE"_sep_"EMPTY_STRING"_sep_"END_IF"

 ; количество частей действия
 n actionLen s actionLen = $l(action, sep)
 ; часть действия
 n actionPart
 ; индекс частей действия
 n actionPartIdx

 ; обходим и выполняем части действия
 f actionPartIdx = 1 : 1 : actionLen d
 .; получаем часть действия
 .s actionPart = $p(action, sep, actionPartIdx)
 .; выполняем чать действия
 .d ..XslAddAction(actionPart, xslRef, pageBreakType, pageBreakPos, .col)

 q
]]></Implementation>
</Method>

<Method name="XslAddSize">
<Description><![CDATA[
Дописывает отсутствующие значения параметров<br/>
Параметры:<br/>
valueFrom - строка параметров<br/>
sep - разделитель параметров в строке<br/>
len - количество параметров<br/>
Возвращаемое значение:<br/>
строка с дописанными параметрами<br/>]]></Description>
<Internal/>
<FormalSpec>valueFrom:%Library.String,sep:%Library.String,len:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; возвращаемое значение
 n valueTo s valueTo = valueFrom

 ; проверяем входные параметры
 ; строка параметров, разделитель и количество д.б. заданы
 i $s($g(valueFrom) = "" : 1, $g(sep) = "" : 1, $g(len) = "" : 1, 1 : 0) q valueTo
 ; параметров д.б. 2 или 4
 i len '?1(1"2",1"4") q valueTo

 ; промежуточная строка параметров
 n str s str = valueFrom    

 d
 .; 4 параметра
 .i len = 4 d
 ..; если задан только первый параметр - записывем его значения в остальные
 ..i $tr($p(str, sep, 2, 4), sep) = "" d  q
 ...n i f i = 2 : 1 : 4 s $p(str, sep, i) = $p(str, sep ,1)
 ..
 ..; если не задан четвёртый параметр - берём его значение из второго
 ..i $p(str, sep, 4) = "" s $p(str, sep, 4) = $p(str, sep, 2)
 ..
 ..; если не задан третий параметр - берём его значение из первого
 ..i $p(str, sep, 3) = "" s $p(str, sep, 3) = $p(str, sep, 1)
 .
 .; 2 параметра
 .i len = 2 d
 ..; если не задан второй параметр - берём его значение из первого
 ..i $p(str, sep, 2) = "" s $p(str, sep, 2) = $p(str, sep, 1)

 ; получаем возвращаемое значение
 s valueTo = str

 q valueTo
]]></Implementation>
</Method>

<Method name="XslCheckSize">
<Description><![CDATA[
Проверка правильности указания размера<br/>
Параметры:<br/>
value - проверяемое значение с единицами измерения<br/>
Возвращаемое значение:<br/>
правильное значение с единицами измерения<br/>
в случае ошибки возвращает ""<br/>]]></Description>
<Internal/>
<FormalSpec>value:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; возвращаемое значение
 n result s result = ""

 ; проверяем входные параметры
 ; проверяемое значение д.б. задано
 i $g(value) = "" q result

 ; заменяем запятые на точки
 s value = $tr(value, ",", ".")

 ; значение без единиц измерения
 n num s num = +value
 ; единицы измерения
 n meas s meas = $TR(value, "1234567890.")

 ;по умолчанию все размеры в mm
 i meas = "" S meas="mm"

 ; если единицы измерения недопустимы - выходим
 i meas '?1(1"mm",1"cm",1"in",1"pc",1"pt") q result

 ; возвращаемое значение
 s result = num _ meas

 q result
]]></Implementation>
</Method>

<Method name="XslGetPageBreakObjList">
<Description>
Получение списка объектов разрыва</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 n list s list = ""
 ; ссылка на глобал с набором печати
 n ref s ref = $na(@Vo(qqnump, "XPrint", 33)@(qqc))
 ; если нет объектов - возвращаем пусто
 i '$d(@ref@("XPageBreakObj")) q list

 n obj s obj = ""
 f  s obj=$o(@ref@("XPageBreakObj", obj)) q:obj=""  d
 .s list = list _ $s(list = "": "", 1: ",") _ obj

 q list
]]></Implementation>
</Method>

<Method name="XslGetPageBreakPos">
<Description>
Получение позиции разрыва страницы
Параметры:
refPlace - ссылка на положение разрыва</Description>
<Internal/>
<FormalSpec>refPlace:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; обходим позиции
 n refPos s refPos = $na(@refPlace@("XPageBreakPos"))

 ; таблица решений для позиций разрыва
 n pos
 ; (first, last, rest, defined)
 s pos(0, 0, 0, 0) = "NONE"                      ; нет разрава
 s pos(0, 0, 0, 1) = "DEFINED"                   ; определяется пользователем
 s pos(0, 0, 1, 0) = "ANY_WITHOUT_FIRST_LAST"    ; любой кроме первого и последнего
 s pos(0, 0, 1, 1) = "DEFINED"                   ; определяется пользователем
 s pos(0, 1, 0, 0) = "LAST"                      ; последний
 s pos(0, 1, 0, 1) = "DEFINED"                   ; определяется пользователем
 s pos(0, 1, 1, 0) = "ANY_WITHOUT_FIRST"         ; любой кроме первого
 s pos(0, 1, 1, 1) = "DEFINED"                   ; определяется пользователем
 s pos(1, 0, 0, 0) = "FIRST"                     ; первый
 s pos(1, 0, 0, 1) = "DEFINED"                   ; определяется пользователем
 s pos(1, 0, 1, 0) = "ANY_WITHOUT_LAST"          ; любой кроме последнего
 s pos(1, 0, 1, 1) = "DEFINED"                   ; определяется пользователем
 s pos(1, 1, 0, 0) = "FIRST_LAST"                ; первый или последний
 s pos(1, 1, 0, 1) = "DEFINED"                   ; определяется пользователем
 s pos(1, 1, 1, 0) = "ANY"                       ; любой
 s pos(1, 1, 1, 1) = "DEFINED"                   ; определяется пользователем


 ; таблица кодов позиций
 n posCode
 s posCode("first") = 0
 s posCode("last") = 1
 s posCode("rest") = 2
 s posCode("defined") = 3

 ; общая позиция
 n posCommon
 s posCommon = pos(''$g(@refPos@(posCode("first"), "XPageBreakPosCheck")), ''$g(@refPos@(posCode("last"), "XPageBreakPosCheck")), ''$g(@refPos@(posCode("rest"), "XPageBreakPosCheck")), ''$g(@refPos@(posCode("defined"), "XPageBreakPosCheck")))

 ; если нет разрыва - выходим
 i posCommon = "NONE" q ""

 ; XPath-выражение, определяющее позицию
 n exprCommon s exprCommon = ""

 ; если определяется пользователем
 i posCommon = "DEFINED" d  q exprCommon
 .s exprCommon = $g(@refPos@(posCode("defined"),"XPageBreakPosExpr"))

 ; если не определяется пользователем - получаем выражение из таблицы
 ; таблица XPath-выражений
 n expr
 s expr("ANY") = "true()"                                         ; любой
 s expr("FIRST") = "position() = 1"                               ; первый
 s expr("LAST") = "position() = last()"                           ; последний
 s expr("FIRST_LAST") = expr("FIRST")_" or "_expr("LAST")         ; первый или последний
 s expr("ANY_WITHOUT_FIRST") = "not("_expr("FIRST")_")"           ; любой кроме первого
 s expr("ANY_WITHOUT_LAST") = "not("_expr("LAST")_")"             ; любой кроме последнего
 s expr("ANY_WITHOUT_FIRST_LAST") = "not("_expr("FIRST_LAST")_")" ; любой кроме первого и последнего

 s exprCommon = expr(posCommon)

 q exprCommon
]]></Implementation>
</Method>

<Method name="XslNumberFormat">
<Internal/>
<FormalSpec>format:%String,scale:%String,required:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    
 new formatArray
 // DATE
 set formatArray(1) = "dd\/mm\/yyyy"
 // YEARMONTH
 set formatArray(6) = "mm\/yyyy"
 // DATETIME
 set formatArray(7) = "dd\/mm\/yyyy\\ h\:mm\:ss"
 // DATEYY
 set formatArray(10) = "dd\/mm\/yy"
 // DATETIMEns
 set formatArray(70) = "dd\/mm\/yyyy\\ h\:mm"
 // TIME$H
 set formatArray("Ht") = "h\:mm"
 // MONEY
 set formatArray("M") = "0\.00"
 // MONEY4
 set formatArray("M4") = "0\.0000"
 // NUMBER
 set formatArray("N") = "0\.0" _ $translate($justify("", 9), " ", "#")
 // DECIMAL
 set formatArray("DEC") = "0" _ $select(scale = 0: "", scale = "": "", 1: "\." _ $translate($justify("", scale), " ", $select(required = 1: "0", 1: "#")))
 
 new result set result = $get(formatArray(format))
 
 quit result
]]></Implementation>
</Method>

<Method name="XslPath">
<Description>
Метод возвращает полный путь для xsl-файлов.
Путь формируется из ссылки на xsl-файл (объект "Печать" в свойствах отображения) и общей части, которая указывается в "Ссылка на директорию XSL" в объекте "%База".
Общая часть используется только в том случае, если ссылка на xsl-файл указывается как относительный путь (начинается с символов / или \).
А также, если в ссылке на xsl-файл в начале значения указано ComputerName (например, ComputerName/test.xsl).
В данном случае считается, что путь - относительный, а ComputerName заменяется на имя папки, совпадающее с именем компьютера в сети (qARM('ComputerName")).

Значение общей части хранится в  ^Q(1,"XBase",0,"XPasXSL").
Если в начале значения XPasXSL указано ClientPath, то это ссылка на пользовательскую директорию, в которой хранится qArm.exe

Параметры:
path - ссылка на xsl-файл</Description>
<Internal/>
<FormalSpec>path:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 I $G(path)="" Q:$Q "" Q
 ;если имя файла содержит специальную переменную ComputerName, то это ссылка на папку по имени компьютера в сети
 ;при этом считаем, что это относительный путь, начало - в переменной ^Q(1,"XBase",0,"XPasXSL")
 I $E(path,1,$L("ComputerName"))="ComputerName" S $E(path,1,$L("ComputerName"))=$S($G(qARM("ComputerName"))'="":"\"_qARM("ComputerName"),1:"")

 ; относительный путь
 N isRelPath S isRelPath=("\/"[$E(path))&&("/\"'[$E(path,2))
 ; короткое имя
 N isShtName S isShtName=(path'["\")&&(path'["/")
 ; значение переменной XPasXSL
 N pasXSL S pasXSL=$G(^Q(1,"XBase",0,"XPasXSL")) 

 I (isRelPath)||(isShtName) D
 .I isShtName S pasXSL=pasXSL_"\"
 .S path=pasXSL_path 
 .;если содержит специальную переменную ClientPath, то это ссылка на папку пользователя; путь к этой папке - в qARM("ClientPath") в виде, например, C:\qArm\
 .I $E(path,1,$L("ClientPath"))="ClientPath" S $E(path,1,$L("ClientPath"))=$E($G(qARM("ClientPath")),1,$L($G(qARM("ClientPath")))-1)
 Q:$Q path Q
]]></Implementation>
</Method>

<Method name="XslPrcPageBreakObj">
<Description>
Действие после создания объекта разрыва</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 ; если не создание - выходим   
 i qqt '= 1 q

 ; создаём поддерево для объекта    
 n refObj s refObj = Vo(qqnump,"XPageBreakObj",33)
 s refObj = $na(@refObj@(Vs(qqnump,"Virt","XPageBreakObj")))

 ; таблица кодов положений
 n placeCode
 s placeCode("before") = 0
 s placeCode("after") = 1

 ; таблица кодов позиций
 n posCode
 s posCode("first") = 0
 s posCode("last") = 1
 s posCode("rest") = 2
 s posCode("defined") = 3

 ; имя положения, код положения, ссылка на глобал с положением
 n placeName, qqcPlace, refPlace

 ; имя позиции, код позиции, ссылка на глобал с позицией
 n posName, qqcPos, refPos

 ; создаём положения
 f placeName = "before", "after" d
 .s qqcPlace = placeCode(placeName)
 .s refPlace = $na(@refObj@("XPageBreakPlace", qqcPlace))
 .s @refPlace = ""
 .; ; создаём позиции
 .f posName = "first", "last", "rest", "defined" d
 ..s qqcPos = posCode(posName)
 ..s refPos = $na(@refPlace@("XPageBreakPos", qqcPos))
 ..s @refPos = ""

 q
]]></Implementation>
</Method>

<Method name="XslPrcPageBreakPos">
<Description>
Действие после коррекции объекта позиции</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 ; если не коррекция - выходим  
 i qqt '= 2 q

 ; ссылка на глобал с положением
 n refPlace s refPlace = Vo(qqnump,"XPageBreakPlace",33)
 s refPlace = $na(@refPlace@(Vs(qqnump,"Virt","XPageBreakPlace")))

 ; ссылка на глобал с позицией
 n refPos s refPos = $na(@refPlace@("XPageBreakPos"))

 ; таблица кодов позиций
 n posCode
 s posCode("first") = 0
 s posCode("last") = 1
 s posCode("rest") = 2
 s posCode("defined") = 3

 ; код предопределённой позиции, имя предопределённой позиции
 n qqcSys, posNameSys
 ; код определяемой пользователем позиции
 n qqcDef s qqcDef = posCode("defined")

 ; если позиция отмечена
 i $g(@refPos@(qqc, "XPageBreakPosCheck")) = 1 d
 .; если определяется пользователем - сбрасываем предопределённые
 .i qqc = qqcDef d  q
 ..f posNameSys = "first", "last", "rest" d
 ...s qqcSys = posCode(posNameSys)
 ...i $g(@refPos@(qqcSys, "XPageBreakPosCheck")) = 1 d
 ....s @refPos@(qqcSys, "XPageBreakPosCheck") = 0
 .
 .; если предопределённая - сбрасываем определяемый пользователем
 .i $g(@refPos@(qqcDef, "XPageBreakPosCheck")) = 1 d
 ..s @refPos@(qqcDef, "XPageBreakPosCheck") = 0

 ; получаем объектую ссылку для объекта положение
 n orefPos s orefPos = Vc(qqnump)
 n orefPlace s orefPlace = $e(orefPos, 1, $l(orefPos) - 2)

 ; обновляем поддерево объекта положение
 ;                         2 3 4 5
 d qARM.wqqotree(orefPlace, , , , , qqo, qqc)

 q
]]></Implementation>
</Method>

<Method name="XslSetField">
<Internal/>
<FormalSpec>xslRef:%String,val:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; номер страницы
 i val="PAGE" d ..XslWrite(xslRef, "<span style='mso-field-code:""PAGE""'>page</span>") q
 ; количество страниц
 i val="NUMPAGES" d ..XslWrite(xslRef, "<span style='mso-field-code:""NUMPAGES""'>numpages</span>") q
 ; дата
 i val="DATE" d ..XslWrite(xslRef, "<span style='mso-field-code:""DATE  \\\@ \0022dd\.MM\.yyyy\0022""'>date</span>") q
 ; время
 i val="TIME" d ..XslWrite(xslRef, "<span style='mso-field-code:""TIME \\\@ \0022HH\:mm\:ss\0022""'>time</span>") q
 ; полное имя файла
 i val="FILENAME" d ..XslWrite(xslRef, "<span style='mso-field-code:""FILENAME \\p""'>filename</span>") q
 ; короткое имя файла
 i val="FILENAMESHT" d ..XslWrite(xslRef, "<span style='mso-field-code:""FILENAME""'>filenamesht</span>") q
 ; Стр. № из количество_страниц
 i val="PN" d ..XslWrite(xslRef, "Стр. <span style='mso-field-code:""PAGE""'>page</span> из <span style='mso-field-code:""NUMPAGES""'>numpages</span>") q
 q
]]></Implementation>
</Method>

<Method name="XslSetStyle">
<Internal/>
<FormalSpec>xslRef:%Library.String,style:%Library.String,qqwxml:%Library.String,color:%Library.String,backColor:%Library.String,fontFormat:%Library.String,fontSize:%String,X3695:%Library.String,X3698:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 // динамические параметры ячейки добываем из xml-файла - style='@style'
 D ..XslWrite(xslRef, "<xsl:attribute name='style'>") 
 // стили, которые не могут быть динамическими
 D ..XslWrite(xslRef, style)
 
 // стили, которые могут быть динамическими
 // динамические параметры не учитываются
 i ('X3698) d
 .// нет подавление цвета и есть цвет символов и цвет фона
 .i ('X3695),((color'="")||(backColor'="")) do ..XslWrite(xslRef, color_backColor)
 .// есть формат шрифта
 .i (fontFormat'="") do ..XslWrite(xslRef, fontFormat)
 .// есть размер шрифта
 .i (fontSize'="") do ..XslWrite(xslRef, fontSize)
 
 // динамические параметры учитываются
 i (X3698) do
 .// нет подавление цвета
 .i ('X3695) d
 ..D ..XslWrite(xslRef, "<xsl:choose>")
 ..D ..XslWrite(xslRef, "<xsl:when test='"_qqwxml_"/@color'><xsl:value-of select='"_qqwxml_"/@color'/></xsl:when>")
 ..i (color'="") D ..XslWrite(xslRef, "<xsl:otherwise>"_color_"</xsl:otherwise>")
 ..D ..XslWrite(xslRef, "</xsl:choose>")
 ..// цвет фона
 ..D ..XslWrite(xslRef, "<xsl:choose>")
 ..D ..XslWrite(xslRef, "<xsl:when test='"_qqwxml_"/@background-color'><xsl:value-of select='"_qqwxml_"/@background-color'/></xsl:when>")
 ..i (backColor'="") D ..XslWrite(xslRef, "<xsl:otherwise>"_backColor_"</xsl:otherwise>")
 ..D ..XslWrite(xslRef, "</xsl:choose>")
 .
 .// формат шрифта
 .D ..XslWrite(xslRef, "<xsl:choose>")
 .D ..XslWrite(xslRef, "<xsl:when test='"_qqwxml_"/@font-format'><xsl:value-of select='"_qqwxml_"/@font-format'/></xsl:when>")
 .i (fontFormat'="") D ..XslWrite(xslRef, "<xsl:otherwise>"_fontFormat_"</xsl:otherwise>")
 .D ..XslWrite(xslRef, "</xsl:choose>")
 .
 .// размер шрифта
 .D ..XslWrite(xslRef, "<xsl:choose>")
 .D ..XslWrite(xslRef, "<xsl:when test='"_qqwxml_"/@font-size'><xsl:value-of select='"_qqwxml_"/@font-size'/></xsl:when>")
 .i (fontSize'="") D ..XslWrite(xslRef, "<xsl:otherwise>"_fontSize_"</xsl:otherwise>")
 .D ..XslWrite(xslRef, "</xsl:choose>")
 
 D ..XslWrite(xslRef, "</xsl:attribute>")
 Q
]]></Implementation>
</Method>

<Method name="XslTransSize">
<Description><![CDATA[
Выполняет преобразование размеров<br/>
Параметры:<br/>
valueFrom - преобразуемое значение с единицами измерения<br/>
measTo - единицы измерения, в которые осуществляется перевод<br/>
noMeas - не добавлять единицы измерения к возвращаемому значению<br/>
Возвращаемое значение:<br/>
преобразованное значение с единицами измерения<br/>
в случае ошибки возвращает ""<br/>]]></Description>
<Internal/>
<FormalSpec>valueFrom:%Library.String,measTo:%Library.String,noMeas:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; возвращаемое значение
 n valueTo s valueTo = ""

 ; проверяем входные параметры
 ; преобразуемое значение и единицы измерения д.б. заданы
 i $s($g(valueFrom) = "" : 1, $g(measTo) = "" : 1, 1 : 0) q valueTo
 ; флаг не добавлять единицы измерения
 s noMeas = ''$g(noMeas)

 ; таблица преобразования для перевода в mm
 n conv
 s conv("mm", "mm") = "1"
 s conv("cm", "mm") = "10"
 s conv("in", "mm") = "25.4"
 s conv("pc", "mm") = "25.4/6"
 s conv("pt", "mm") = "25.4/72"

 ; точность преобразования (количество знаков после запятой)
 s conv("mm", "dec") = 1
 s conv("cm", "dec") = 2
 s conv("in", "dec") = 2
 s conv("pc", "dec") = 1
 s conv("pt", "dec") = 0

 ; значение без единиц измерения
 n numFrom s numFrom = +valueFrom
 ; единицы измерения
 n measFrom s measFrom = $p(valueFrom, numFrom, 2)
 ; по умолчанию - mm
 i measFrom = "" s measFrom = "mm"

 ; если значение входных единиц измерения недопустимо - выходим
 i '$d(conv(measFrom)) q valueTo
 ; если значение выходных единиц измерения недопустимо - выходим
 i '$d(conv(measTo)) q valueTo

 ; составляем и вычисляем выражение преобразования
 ; сначала преобразуем в mm, потом из mm в требуемые единицы
 n numTo
 s @("numTo = " _ (numFrom _ " * (" _ conv(measFrom, "mm") _ ") / (" _ conv(measTo, "mm") _ ")"))

 ; округляем до заданной точности
 s numTo = $j(numTo, 0, conv(measTo, "dec"))

 ; получаем возвращаемое значение
 s valueTo = numTo _ $s(noMeas : "", 1 : measTo)

 q valueTo
]]></Implementation>
</Method>

<Method name="XslWrite">
<Description><![CDATA[
Запись строки в глобал<br/>
Параметры:<br/>
xslRef - глобал с текстом xsl<br/>]]></Description>
<Internal/>
<FormalSpec>xslRef:%Library.String,str:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(xslRef)'="" S @xslRef@($I(@xslRef))=str_$C(13,10) Q
 D ..write(str)
 q
]]></Implementation>
</Method>

<Method name="getSaxXML">
<Description>
Чтение xml-файла в глобал

Параметры:
fileName - входной файл
ref - имя выходного глобала
 - в @ref@("event") будут записаны события SAX:
      start document         "G"
      end document           "F"
      start element          "S"_nameLen_" "_name
      start element w/attrs  "A"_nameLen_" "_name_attrsNum_" "_ {attrnameLen_" "_attrname_attrvalueLen_" "_attrvalue} attrsNum раз
      end element            "E"_nameLen_" "_name
      text                   "T"_textLen_" "_text
 - в @ref@("data") будут записан результат разбора:
      @ref@("data", element1Name) = element1Count
      @ref@("data", element1Name, element1Position) = text
      @ref@("data", element1Name, element1Position, @attributeName) = attributeValue
      @ref@("data", element1Name, element1Position, element11Name, element11Position) = element11Count
      ...
errorAction - действие по ошибке, в котором определена переменная Error, содержащая текст ошибки
postAction - действие после успешного разбора</Description>
<Internal/>
<FormalSpec>fileName:%String,ref:%String,errorAction:%String,postAction:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 kill @ref
 
 new paramRef set paramRef = $name(@ref@("param"))
 new eventRef set eventRef = $name(@ref@("event"))
 new dataRef set dataRef = $name(@ref@("data"))
 
 new successAction set successAction = "do qWEB.getSaxXMLData(""" _ qSYS.dblqw(paramRef) _ """, """ _ qSYS.dblqw(eventRef) _ """, """ _ qSYS.dblqw(dataRef) _ """, """ _ qSYS.dblqw($get(postAction)) _""")"
 
 do qARM.wM("-qARM", "GetXMLData", fileName, eventRef, $get(errorAction), successAction)
 
 quit
]]></Implementation>
</Method>

<Method name="getSaxXMLData">
<Internal/>
<FormalSpec>paramRef:%String,eventRef:%String,dataRef:%String,postAction:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 /*
 start document         "G"
 end document           "F"
 start element          "S"_nameLen_" "_name
 start element w/attrs  "A"_nameLen_" "_name_attrsNum_" "_ {attrnameLen_" "_attrname_attrvalueLen_" "_attrvalue} attrsNum раз
 end element            "E"_nameLen_" "_name
 text                   "T"_textLen_" "_text
 */
 
 kill @dataRef
 
 new documentLevel set documentLevel = $qlength(dataRef)
 new status set status = ""
 
 new eventId
 
 new elementRef set elementRef = dataRef
 new elementLevel set elementLevel = 0
 new elementPos
 new elementName
 
 new attrAmt
 new attrCnt
 new attrName
 new attrValue
 
 new text
 
 new strNum set strNum = 0
 new colNum set colNum = 1
 
 new sep set sep = " "
 
 for  do  if (status = "end") quit
 .// event
 .set eventId = ..getSaxXMLFieldByLen(eventRef, .strNum, .colNum, 1)
 .
 .// start document         "G"
 .if (eventId = "G") do  quit
 ..set status = "start"
 ..set @paramRef@("status") = status
 ..set @paramRef@("dateTime", status) = $translate($zdatetime($horolog, 8), " :")
 .
 .// end document           "F"
 .if (eventId = "F") do  quit 
 ..set status = "end"
 ..set @paramRef@("status") = status
 ..set @paramRef@("dateTime", status) = $translate($zdatetime($horolog, 8), " :")
 .
 .// start element          "S"_nameLen_" "_name
 .// start element w/attrs  "A"_nameLen_" "_name_attrsNum_" "_ {attrnameLen_" "_attrname_attrvalueLen_" "_attrvalue} attrsNum раз
 .if (eventId ?1(1"S",1"A")) do  quit
 ..set elementLevel = elementLevel + 1
 ..set elementName = ..getSaxXMLField(eventRef, .strNum, .colNum, sep)
 ..set elementPos = $increment(@elementRef@(elementName))
 ..set elementRef = $name(@elementRef@(elementName, elementPos))
 ..set @elementRef = ""
 ..
 ..if (eventId = "S") quit
 ..
 ..// attributes
 ..set attrAmt = ..getSaxXMLFieldBySep(eventRef, .strNum, .colNum, sep)
 ..
 ..for attrCnt = 1: 1: attrAmt do
 ...set attrName = ..getSaxXMLField(eventRef, .strNum, .colNum, sep)
 ...set attrValue = ..getSaxXMLField(eventRef, .strNum, .colNum, sep)
 ...set @elementRef@("@" _ attrName) = attrValue
 .
 .// end element            "E"_nameLen_" "_name
 .if (eventId = "E") do  quit
 ..set elementLevel = elementLevel - 1
 ..set elementName = ..getSaxXMLField(eventRef, .strNum, .colNum, sep)
 ..set elementRef = $name(@elementRef, documentLevel + (elementLevel * 2))
 .
 .// text                   "T"_textLen_" "_text
 .if (eventId = "T") do  quit
 ..set text = ..getSaxXMLField(eventRef, .strNum, .colNum, sep)
 ..set @elementRef = text
 
 if ($get(postAction) '= "") xecute postAction
 
 quit
]]></Implementation>
</Method>

<Method name="getSaxXMLField">
<Internal/>
<FormalSpec>eventRef:%String,strNum:%String,colNum:%String,sep:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 // startColNum  fieldColNum
 // |            |
 // v            v  
 // fieldLen_" "_field
 //                   ^
 //                   | 
 //                   nextColNum
 
 new fieldLen set fieldLen = ..getSaxXMLFieldBySep(eventRef, .strNum, .colNum, sep)
 new field set field = ..getSaxXMLFieldByLen(eventRef, .strNum, .colNum, fieldLen)
    
 quit field
]]></Implementation>
</Method>

<Method name="getSaxXMLFieldByLen">
<Internal/>
<FormalSpec>eventRef:%String,strNum:%String,colNum:%String,len:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    
 new field set field = ""
 new nextColNum
 new find set find = 0
 
 for  do  if (find) quit
 .set nextColNum = colNum + len
 .
 .// все символы в текущей строке
 .if ((nextColNum - 1) '> $length(@eventRef@(strNum))) do  quit
 ..set find = 1
 ..set field = field _ $extract(@eventRef@(strNum), colNum, nextColNum - 1)
 ..
 ..// вышли за пределы строки - переходим на следующую
 ..if (nextColNum > $length(@eventRef@(strNum))) do  quit
 ...set strNum = strNum + 1
 ...set colNum = 1
 ..
 ..// в пределах строки
 ..set colNum = nextColNum
 .
 .// не все символы - продолжаем на след. строке
 .set field = field _ $extract(@eventRef@(strNum), colNum, $length(@eventRef@(strNum)))
 .set len = len - ($length(@eventRef@(strNum)) - colNum + 1)
 .set strNum = strNum + 1
 .set colNum = 1
 
 quit field
]]></Implementation>
</Method>

<Method name="getSaxXMLFieldBySep">
<Internal/>
<FormalSpec>eventRef:%String,strNum:%String,colNum:%String,sep:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    
 new field set field = ""
 new nextColNum
 new find set find = 0
 
 for  do  if (find) quit
 .set nextColNum = $find(@eventRef@(strNum), sep, colNum)
 .
 .// нашли sep в текущей строке
 .if (nextColNum) do  quit
 ..set find = 1
 ..set field = field _ $extract(@eventRef@(strNum), colNum, nextColNum - 2)
 ..
 ..// вышли за пределы строки - переходим на следующую
 ..if (nextColNum > $length(@eventRef@(strNum))) do  quit
 ...set strNum = strNum + 1
 ...set colNum = 1
 ..
 ..// в пределах строки
 ..set colNum = nextColNum
 .
 .// не нашли sep - продолжаем на след. строке
 .set field = field _ $extract(@eventRef@(strNum), colNum, $length(@eventRef@(strNum)))
 .set strNum = strNum + 1
 .set colNum = 1
 
 quit field
]]></Implementation>
</Method>

<Method name="vBLOBInit">
<Internal/>
<FormalSpec>Glb:%String,Node:%String,Arg3:%String,Sp:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
 ; Vol
 ; k refBLOB m refBLOB(..vBLOB)=%obj(..vBLOB)
 ; s ..vBLOB.Data="vvvv"
 s Sp=$TR(Sp,"'",""),Arg3=$TR(Arg3,"'",""),Node=$TR($G(Node),"'","")
 s Glb="^|Sp|"_$S(Arg3:"%",1:"")_$TR(Glb,"~'","""")
 ;S ^NN=$S(Node'="":$NA(@Glb@(Node)),1:$NA(@Glb))
 s ..vBLOBNode=$S(Node'="":$NA(@Glb@(Node)),1:$NA(@Glb)) ;@dol 9.1.04
 s ..vBLOBCurr=0,..vBLOBmk=1
 q ..vBLOBLoad()
]]></Implementation>
</Method>

<Method name="vBLOBLoad">
<Internal/>
<Language>cache</Language>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
 n ref,bf,ok,j s ref=$Na(@..vBLOBNode@(..vBLOBCurr)),ok=0,bf=""
 ; k %obj(..vBLOB) m %obj(..vBLOB)=refBLOB(..vBLOB)
 ; s ..BLOB.Data=$G(@..BLOBNode@(..BLOBCurr)) 
 ; d ..BLOB.Rewind()
 d ..vBLOB.CopyFrom(..vBLOBempt)
 f  q:ok  d
 .i ($G(@ref)="")!($L(bf)=..vBLOBvRLen) s ok=1 q
 .i ..vBLOBmk>$L(@ref) s ..vBLOBmk=1,..vBLOBCurr=..vBLOBCurr+1,ref=$Na(@..vBLOBNode@(..vBLOBCurr)) q
 .s j=..vBLOBmk+..vBLOBvRLen-$L(bf),bf=bf_$E(@ref,..vBLOBmk,j-1),..vBLOBmk=j
 d ..vBLOB.Write(bf),..vBLOB.Write(" ")
 q $L(bf)
]]></Implementation>
</Method>

<Method name="vStringGt">
<Internal/>
<FormalSpec>Arg1:%Integer</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[ q ..vBLOB.Read(Arg1)
]]></Implementation>
</Method>

<Method name="vXecute">
<Internal/>
<FormalSpec>str:%String,OleRsltARM:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 i $E(str)="=" Q @$E(str,2,$L(str)) ;n ret s @("ret="_$E(str,2,$L(str))) q ret
 x str Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="write">
<Description>
Если qqdev="" - Запись строки в массив $$$tmpGl($J)
Иначе, передача на у-во qqdev.  </Description>
<Internal/>
<FormalSpec>str:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
    I qqdev'=0,qqdev?1.N S $$$tmpGl(qqdev,$J,$I($$$tmpGl(qqdev,$J)))=str_$C(13,10) Q:$Q "" Q  ; 15.12.2008 Kokarev
    U:qqdev'=0 qqdev W str,! Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="xmlPath">
<Description>
Метод возвращает полный путь для xml-файлов, а также сооздает директории на этом пути, если их
нет.</Description>
<Internal/>
<FormalSpec>path:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; по умолчанию имя файла qword.xml
 I $G(path)="" S path="qword"_$S($G(qqXBPrtUniqFile):"-"_$TR($ZDT($H,8)," :")_$E($TR($ZDT($ZTS,8,1,3),":. "),15,17),1:"")_".xml"  ; tdv 20110315, 20110513 - уникальное имя файла - добавка даты-времени-миллисекунд
 ; добавляем расширение, если нет
 I path'["." S path=path_".xml"
 N clientPath

 D 
 .; если передано только имя файла
 .I path'["\",path'["/" S clientPath=..ClientPath(),path=clientPath_path Q
 .; если передан относительный путь
 .I ("\/"[$E(path)),("/\"'[$E(path,2)) S clientPath=..ClientPath(),path=$E(clientPath,1,$L(clientPath)-1)_path

 ; получаем имя папки
 N sep S sep=$S(path["\":"\",1:"/")
 N dir S dir=$P(path,sep,1,$L(path,sep)-1)

 ; если указанной папки нет, то она будет создана
 D qARM.wM("-qARM","ForceDir",dir,"","") ;@dima 05.10.05
 Q:$Q path Q
]]></Implementation>
</Method>
</Class>


<Class name="%Library.qWORD">
<IncludeCode>%qWORD</IncludeCode>
<Modified>0</Modified>
<ProcedureBlock>0</ProcedureBlock>
<Super>%Library.RegisteredObject</Super>
<TimeCreated>66787,41897.288653</TimeCreated>

<Method name="AFonFind">
<Description>
Запуск поиска в фоне (через $Job aFonFind^%ooLibrary.qWORD.1())</Description>
<Internal/>
<ClassMethod>1</ClassMethod>
<FormalSpec>qqcnt:%Library.String,qql:%Library.String,qqlang:%Library.String,qviewf:%Library.String,qlistF:%Library.String,qlistFR:%Library.String,qqr0:%Library.String,Nor:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S qW=##class(%qWORD).%New(),qARM=##class(%TqARM).%New(),qSYS=##class(%qSYS).%New()
 X "S qUSER=##class(qUSER).%New()"
 S qA=0,$ET="S xxxZR=$ZR D qW.qFonFindErr() Q:$Q """" Q  "
 I $G(qqnump)="" S qqnump=0 ;@dol 3.03.04
 D qW.qFindN(qqcnt,qql,qqlang,qviewf,qlistF,qlistFR,+$G(qqr0),$G(Nor)) Q
]]></Implementation>
</Method>

<Method name="CRTF">
<Description>
Преобразование тегов XML в RTF ;@Dol 30.01.09
rtf - тег для недельфийской ручной сборки. ;@Sas 20090911
qw=1 - обработка тега qW - вычисление выражения и подстановка</Description>
<Internal/>
<ClassMethod>1</ClassMethod>
<FormalSpec>Str:%String,xmltr:%String,rtf:%String=0,qw:%String=0</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N pos,sym,symi,posi,posi0,teg,Stre,tegx,ci S sym="<>"_$C(9) S:'$D(xmltr) xmltr=$G(qxmltr)
 S:'$D(qqConvXMLRTF) qqConvXMLRTF=$LB("b","<b>","b0","</b>","i","<i>","i0","</i>","ul","<u>","ulnone","</u>","qc","<p_align='center'>","","</p>","qr","<p_align='right'>","","</p>","ql","<p_align='left'>","","</p>","sub","<sub>","nosupersub","</sub>","super","<sup>","nosupersub","</sup>","","<br>","\par","</br>")
 F sym="\","{","}" S posi=1 F  S posi=$F(Str,sym,posi) Q:'posi  S $E(Str,posi-1)="\"_sym,posi=posi+1
 S posi=1 F  S posi=$F(Str,$C(13,10),posi) Q:'posi  S $E(Str,posi-2,posi-1)=$C(13,10)_$S(rtf=1:" \par",1:"")_"\pard ",posi=posi+3
 S posi=1,Stre="" F  S posi=$F(Str,"<",posi) Q:'posi  S teg=$F(Str,">",posi) I teg,posi+1'=teg S tegx=$P($TR($E(Str,posi+($E(Str,posi)="/"),teg-2),"_"," ")," ") I $S($E(tegx,$L(tegx))="/":1,$E(Str,posi)="/":$F(Str,"<"_tegx),1:$F(Str,"</"_tegx_">",teg)),$S($G(qw):1,1:tegx'="qW") D  I ci'=99 S Stre=Stre_$E(Str,$G(posi0,1),posi-$S($E(Str,posi-2)'=" ":2,ci="":3,$E(Str,posi)="/":3,1:2))_ci_$S($TR($E(Str,teg),"<"_$C(13))="":"",$E(Str,teg+1)="<":"",$E(Str,posi)'="/"&&($E(Str,teg)=" "):"",1:" "),posi0=teg ; поиск парных тегов. Пробел перед закрывающим и после открывающего удаляется
 .I tegx="qW" S Stre=Stre_$E(Str,$G(posi0,1),posi-2),(posi0,posi)=$F(Str,"</"_tegx_">",teg),symi=$E(Str,teg,posi-6) S:$E(symi)="=" symi=qUSER.MACRO($E(symi,2,30000)) D  S Stre=Stre_$S($TR($E(Stre,$L(Stre))," ")="":"",1:" ")_symi_$S($TR($E(Str,posi)," ")="":"",1:" "),ci=99 Q  ;@Dol 07.01.10 тег qW ;04.03.10 Stre=Stre_$
 ..I '$G(qqGERROR) N $ET S $ET="S symi=$S($ZE[""DIV"":0,1:$G(symi)_"" ""_$TR($ZE,""<>"")) S:$ZE'[""CLASS REC"" $EC="""" Q:$Q symi Q" ;@Dol 24.08.09 qqGERROR=1 - НЕ подавлять ошибку
 ..S @("symi="_symi)
 .I $E(Str,posi-1,teg-1)="<br/>" S ci="\par" Q
 .I $E(Str,posi-1,teg-1)="</p>" Q:$E(Str,teg)=$C(13)||($E(Str,teg,teg+1)=" "_$C(13))  S ci="\par\pard" Q  ;@Dol 01.03.09
 .S ci=$LF(qqConvXMLRTF,$E(Str,posi-1,teg-1)) I 'ci S ci="" Q
 .S ci=$LI(qqConvXMLRTF,ci-1) S:ci'="" ci="\"_ci
 Q $S('$G(posi0):Str,1:Stre_$E(Str,posi0,33000))
]]></Implementation>
</Method>

<Method name="CXML">
<Description>
Преобразование строки для XML. (Замена спец.символов)
xmltr - пропуск парных тегов. не задан - берется из qxmltr (cm ..GetLine)
qw=1 - обработка тега qW - вычисление выражения и подстановка</Description>
<Internal/>
<ClassMethod>1</ClassMethod>
<FormalSpec>Str:%String,xmltr:%String,qw:%String=1</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N pos,sym,symi,posi,posi0,teg,Stre,tegx S sym="<>"_$C(9) S:'$D(xmltr) xmltr=$G(qxmltr)
 ;;;S:'$G(Vo(qqnump,-1,3,66)) Str=$TR(Str,"_"," ") ;@Dol 07.01.10 перенесено в конец CXMLdo ;Надо переделать ? X762 не работает !!!
 I xmltr S posi=1,Stre="" F  S posi=$F(Str,"<",posi) Q:'posi  S teg=$F(Str,">",posi) I teg,posi+1'=teg S tegx=$P($TR($E(Str,posi+($E(Str,posi)="/"),teg-2),"_"," ")," ") I $S($E(tegx,$L(tegx))="/":1,$E(Str,posi)="/":$F(Str,"<"_tegx),1:$F(Str,"</"_tegx_">",teg)) D:tegx="qW"&&$G(qw)  I tegx'="qW"||'$G(qw) S Stre=Stre_$$CXMLdo($E(Str,$G(posi0,1),posi-2))_$TR($E(Str,posi-1,teg-1),"_"," "),posi0=teg ;@Dol 4.08.08 поиск парных тегов
 .S Stre=Stre_$$CXMLdo($E(Str,$G(posi0,1),posi-2)),(posi0,posi)=$F(Str,"</"_tegx_">",teg),symi=$E(Str,teg,posi-6) S:$E(symi)="=" symi=qUSER.MACRO($E(symi,2,30000),"qW.G") D  S Stre=Stre_$S($TR($E(Stre,$L(Stre))," ")="":"",1:" ")_$$CXMLdo(symi)_$S($TR($E(Str,posi)," ")="":"",1:" ") Q  ;@Dol 07.01.10 тег qW ;04.03.10 Stre=Stre_$
 ..I '$G(qqGERROR) N $ET S $ET="S symi=$S($ZE[""DIV"":0,1:$G(symi)_"" ""_$TR($ZE,""<>"")) S:$ZE'[""CLASS REC"" $EC="""" Q:$Q symi Q" ;@Dol 24.08.09 qqGERROR=1 - НЕ подавлять ошибку
 ..S @("symi="_symi)
 Q $S('$G(posi0):$$CXMLdo(Str),1:Stre_$$CXMLdo($E(Str,posi0,33000)))
CXMLdo(Arg1) Q:Arg1="" "" S pos=1 F  S pos=$F(Arg1,"&",pos) Q:'pos  S:$E(Arg1,pos,pos+1)'?1"#"1n $E(Arg1,pos-1)="&#"_$A("&")_";",pos=pos+4
 S pos=1 F  S pos=$F(Arg1,"'",pos) Q:'pos  S:$E(Arg1,pos,pos+1)'?1"#"1n $E(Arg1,pos-1)="&#"_$A("'")_";",pos=pos+4
 S pos=1 F  S pos=$F(Arg1,"""",pos) Q:'pos  S:$E(Arg1,pos,pos+1)'?1"#"1n $E(Arg1,pos-1)="&#"_$A("""")_";",pos=pos+4
 S pos=1 F  S pos=$F(Arg1,"  ",pos) Q:'pos  S $E(Arg1,pos-1)="&#160;",pos=pos+5 D:$E(Arg1,pos)=" "
 .F  S $E(Arg1,pos)="&#160;",pos=pos+6 Q:$E(Arg1,pos)'=" " 
 F symi=1:1:$L(sym) S pos=1 F  S pos=$F(Arg1,$E(sym,symi),pos) Q:'pos  S $E(Arg1,pos-1)="&#"_$A(sym,symi)_";",pos=pos+4
 S:'$G(Vo(qqnump,-1,3,66)) Arg1=$TR(Arg1,"_"," ") ;@Dol 07.01.10
 I xmltr S Arg1=qW.tagSequenceControl(Arg1)  ;@Mike 30.05.11 Контроль последовательности тэгов. Пытается исправить, если не удается - удаляет неправильно расставленные тэги.
 Q $TR(Arg1,$C(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31))  ;@Mike 30.05.11  ,"?????????????????????????????????")
]]></Implementation>
</Method>

<Method name="CXMLdoc">
<Description><![CDATA[
Вставка тега <p> вместо $C(13,10) в строку]]></Description>
<Internal/>
<FormalSpec>str:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 Q:str="" "" N pos,str1,str2,pos1
 S str1="" F pos=1:1:$L(str,$C(13,10)) S str2=$P(str,$C(13,10),pos),pos1=$S($E(str2)=" ":$F(str2,$E($TR(str2," ")))-2,1:0),str1=str1_"<p"_$S('pos1:">"_..CXML(str2),1:" indent='"_(0.1*pos1)_"'>"_..CXML($E(str2,pos1+1,3000)))_"</p>"
 Q str1
]]></Implementation>
</Method>

<Method name="CXMLnot">
<Description>
@Dol 18.07.08 Убирает в строке Str парные теги
teg=1 - всегда убирать, в противном случае - только при выводе на экран</Description>
<Internal/>
<FormalSpec>Str:%String,teg:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I '$G(teg),$G(qxml) Q Str
 N posi,posi0,Stre,teg,tegx
 S posi=1,Stre="" F  S posi=$F(Str,"<",posi) Q:'posi  S teg=$F(Str,">",posi) I teg,posi+1'=teg S tegx=$P($TR($E(Str,posi+($E(Str,posi)="/"),teg-2),"_"," ")," ") I $S($E(tegx,$L(tegx))="/":1,$E(Str,posi)="/":$F(Str,"<"_tegx),1:$F(Str,"</"_tegx_">",teg)) S Stre=Stre_$E(Str,$G(posi0,1),posi-2),posi0=teg ;@Dol 4.08.08 поиск парных тегов
 ;S posi=1,Stre="" F  S posi=$F(Str,"<",posi) Q:'posi  S teg=$F(Str,">",posi) I teg,posi+1'=teg,$D(^Q(1,"xTagTR",$P($E(Str,posi+($E(Str,posi)="/"),teg-2)," "))) S Stre=Stre_$E(Str,$G(posi0,1),posi-2),posi0=teg
 Q $S('$G(posi0):Str,1:Stre_$E(Str,posi0,33000))
]]></Implementation>
</Method>

<Method name="Cod116">
<Description>
Arg2=0 - Преобразовать число Arg1 в число в вистеме счисления по основанию 116 (английские и русские буквы). Arg3 - размер строки числа
Arg2=1 - Обратное преобразование</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$G(Arg2)  D  Q:'$G(Arg3) Arg2 Q $TR($J("",Arg3-$L(Arg2))," ","A")_Arg2
 .S Arg2="" F  S Arg2=$E($$Cod116s(),Arg1#116+1)_Arg2 Q:Arg1<116  S Arg1=Arg1\116
 S Arg2=0,Arg3=1 F  S Arg2=$F($$Cod116s(),$E(Arg1,$L(Arg1)))-2*Arg3+Arg2 Q:$L(Arg1)=1  S Arg1=$E(Arg1,1,$L(Arg1)-1) Q:$TR(Arg1,"A")=""  S Arg3=Arg3*116
 Q Arg2
Cod116s()   Q "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
]]></Implementation>
</Method>

<Method name="Cod154">
<Description>
Arg2=0 - Преобразовать число Arg1 в число в вистеме счисления по основанию 154 (знаки препинания кроме пробел кавычки *, тильда ~, цифры, английские и русские буквы). Arg3 - размер строки числа
Arg2=1 - Обратное преобразование</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$G(Arg2)  D  Q:'$G(Arg3) Arg2 Q $TR($J("",Arg3-$L(Arg2))," ","!")_Arg2
 .S Arg2="" F  S Arg2=$E($$Cod154s(),Arg1#154+1)_Arg2 Q:Arg1<154  S Arg1=Arg1\154
 S Arg2=0,Arg3=1 F  S Arg2=$F($$Cod154s(),$E(Arg1,$L(Arg1)))-2*Arg3+Arg2 Q:$L(Arg1)=1  S Arg1=$E(Arg1,1,$L(Arg1)-1) Q:$TR(Arg1,"!")=""  S Arg3=Arg3*154
 Q Arg2
Cod154s()   Q "!#$%&'()+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^`abcdefghijklmnopqrstuvwxyz{|}АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
]]></Implementation>
</Method>

<Method name="Cod52">
<Description>
Arg2=0 - Преобразовать число Arg1 в число в вистеме счисления по основанию 52 (английские буквы). Arg3 - размер строки числа
Arg2=1 - Обратное преобразование</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I '$G(Arg2)  D  Q:'$G(Arg3) Arg2 Q $TR($J("",Arg3-$L(Arg2))," ","A")_Arg2
 .S Arg2="" F  S Arg2=$E($$Cod52s(),Arg1#52+1)_Arg2 Q:Arg1<52  S Arg1=Arg1\52
 S Arg2=0,Arg3=1 F  S Arg2=$F($$Cod52s(),$E(Arg1,$L(Arg1)))-2*Arg3+Arg2 Q:$L(Arg1)=1  S Arg1=$E(Arg1,1,$L(Arg1)-1) Q:$TR(Arg1,"A")=""  S Arg3=Arg3*52
 Q Arg2
Cod52s()    Q "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
]]></Implementation>
</Method>

<Method name="CodAdd">
<Description>
функция добавляет +Arg1(+1 по умолчанию)  к коду qqpar1.( A-Z,a-z)
Arg2=1 - компактный код (задействованы русские буквы)

!!!Добавлять можно только небольшое число!!! (см. текст)</Description>
<Internal/>
<FormalSpec>qqpar1:%Library.String,Arg1:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(Arg1)="" Arg1=1
 I $G(Arg2) Q:qqpar1="" $C(33) D  Q qqpar1 ;компактный код (задействованы русские буквы)
 .N i,% F i=$L(qqpar1):-1:1 S %=$A(qqpar1,i)+Arg1,$E(qqpar1,i)=$C($S(%<91:%,%<97:97,%<123:%,%<192:192,%>255:65,1:%)) Q:%'>255  I i=1 S qqpar1="A"_qqpar1 Q
 Q:qqpar1="" "A" Q:qqpar1?1.N qqpar1+Arg1
 N i,% F i=$L(qqpar1):-1:1 S %=$A(qqpar1,i)+Arg1,$E(qqpar1,i)=$C($S(%<91:%,%<97:97,%>122:65,1:%)) Q:%'>122  I i=1 S qqpar1="A"_qqpar1 Q
 Q qqpar1
]]></Implementation>
</Method>

<Method name="CodObj">
<Description>
@Dol 14.02.09 Преобразование кодов экземпляров для объекта Obj в зависимости от заданной системы кодирования (x534)
Arg2=0 - Преобразовать число Arg1 в число в вистеме счисления по основанию 116 (английские и русские буквы). Arg3 - размер строки числа
Arg2=1 - Обратное преобразование</Description>
<Internal/>
<FormalSpec>Obj,Ar1,Ar2,Ar3</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:'$D(Vo(qqnump,Obj,34)) Vo(qqnump,Obj,34)=$G(^Q(1,"CxObj",$S($E(Obj)="v":$E(Obj,3,255),1:Obj),"x534")) ; x534 - основание исчисления
 Q $S(Vo(qqnump,Obj,34)=154:..Cod154(Ar1,$G(Ar2),$G(Ar3)),Vo(qqnump,Obj,34)=116:..Cod116(Ar1,$G(Ar2),$G(Ar3)),1:..Cod52(Ar1,$G(Ar2),$G(Ar3)))
]]></Implementation>
</Method>

<Method name="ConvertTag2OO">
<Description><![CDATA[
Замена тегов для OpenOffice. Подмена тегов <b> <u> <i> и др на аналоги ОО с указанием стиля.
Для корректного отображения стили должны быть описаны отдельно.
так же производится замена задвоеных тегов <p> на одинарные,т.к вложеные теги параграфов отображаться не будут. Стили вложенных параграфов, естественно, игнорируются.
innerRef - ссылка на глобал, куда пишутся стили для ОО (ширина столбцов встроеных таблиц, встроеная разметка)]]></Description>
<Internal/>
<FormalSpec>str,innerRef:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
  ;@rda 2009.05.08 метод для обработки HTML тегов для OpenOffice. Требуется тестирование.
  ;@rda 2010.04.13 добавлена обработка тега <span> со стилем (обрабатываются шрифт, размер шрифта, стиль, цвет(только rgb), вес), исправлена обработка высоты строки таблицы. Задавать через style! 
  ;@rda 2010.10.25 добавлена обработка параметра выравнивания для первого параграфа (раньше параметр съедался)
  ;@rda 2011.02.10 для тега <table> добавлен стиль  table:style-name='TBL' для схлопывания границ таблицы
 n i,k,p,x,StyleNames,pCount,TR
 i str["<table" for i=1:1:$L(str,"</table>")-1  d
 .s p=$P(str,"</table>",i), cCount=$L($P(p,"</tr>"),"</td>")-1,cols="" d
 ..s TR=$P(p,"</tr>"), TR=$E(TR,$F(TR,"<tr"),32000)
 ..for x=2:1:$L(TR,"width:") do
 ...s StyleNames(i,x-1)=..CXML($tr("InnerTblCol"_qqc_qqo_qqpar3_i1_i_(x-1),"{}<>[]()'""@$^&*"))
 ...s @innerRef@("InnerTable",StyleNames(i,x-1))="<style:style style:name='"_StyleNames(i,x-1)_"' style:family='table-column'><style:table-column-properties style:rel-column-width='"_$E($P(TR,"width:",x),1,$F($P(TR,"width:",x),";")-3)_"*'/></style:style>"
 .. for k=1:1:cCount s cols=cols_"<table:table-column table:style-name='"_$G(StyleNames(i,k))_"'/>" ; если стиля с шириной столбца нет, то имя стиля не вставляем
 .s $P(p,"<tr",1)=$P(p,"<tr",1)_cols, $P(str,"</table>",i)=p
 s str=$$Parse(str)
 s str=$S(str="":"",1:"<text:p>"_str_"</text:p>")
 ; убираем лишние пустые параграфы, обрамляющие таблицу
 s str=..zChSym(str,"<text:p></text:p><table:table","<table:table")
 s str=..zChSym(str,"</table:table><text:p></text:p>","</table:table>")
 Q str
Parse(str)
 n i,TagReplace,TR,TagName,style,styleName
 s i=1,pCount=0
 ; теги, которые подлежат замене на ОО аналоги
 s TagReplace("p")="</text:p><text:p>"
 s TagReplace("/p")=" "
 s TagReplace("br")="<text:line-break/>" ;"</text:p><text:p>"
 s TagReplace("br/")="<text:line-break/>" ;"</text:p><text:p>"
 s TagReplace("span")="<text:span>"
 s TagReplace("/span")="</text:span>"
 s TagReplace("b")="<text:span text:style-name='BOLD'>"
 s TagReplace("/b")="</text:span>"
 s TagReplace("u")="<text:span text:style-name='UNDER'>"
 s TagReplace("/u")="</text:span>"
 s TagReplace("i")="<text:span text:style-name='ITALIC'>"
 s TagReplace("/i")="</text:span>"
 s TagReplace("sup")="<text:span text:style-name='SUP'>"
 s TagReplace("/sup")="</text:span>"
 s TagReplace("sub")="<text:span text:style-name='SUB'>"
 s TagReplace("/sub")="</text:span>"
 s TagReplace("table")="</text:p><table:table table:style-name='TBL'>"
 s TagReplace("/table")="</table:table><text:p>"
 s TagReplace("tr")="<table:table-row>"
 s TagReplace("/tr")="</table:table-row>"
 s TagReplace("td")="<table:table-cell><text:p>"
 s TagReplace("/td")="</text:p></table:table-cell>"
 s TagReplace("font")="<text:span>"
 s TagReplace("/font")="</text:span>"
 s TagReplace("h1")=" ",TagReplace("/h1")=" "
 s TagReplace("h2")=" ",TagReplace("/h2")=" "
 s TagReplace("h3")=" ",TagReplace("/h3")=" "
 s TagReplace("h4")=" ",TagReplace("/h4")=" "
 
 ;ищем теги, получаем имя тега и полный тег(вместе со стилем и пр.), убираем лишние переводы строки и параграфы
 for  set i=$F(str,"<",i) Q:'i  d  Q:'i 
 .s i=i-1, TagName=$$TagName($E(str,i,32000)), FullTag=$$FullTag($E(str,i,32000),TagName) if TagName="" s i="" Q
 .s TR=$G(TagReplace(TagName)) If TR="" s i=$F(str,">",i) Q
 .s:(i=1)&(((TagName="p")&&(FullTag'[" "))||(TagName="br")||(TagName="br/")) TR="" 
 .s (style,styleName)=""
 .i TagName="p" s pCount=pCount+1 s:pCount>1 TR=""
 .s:TagName="/p" pCount=pCount-1
 .i FullTag[" " s style=$P(FullTag," ",2,32000), style=$E(style,1,$L(style)-1) ;s ^uuu("style",FullTag)=style
 .s:style'="" styleName=$$GetStyle(TagName, style) 
 .s:(styleName["'P_CENTER'")||(styleName["'P_RIGHT'") TR=$G(TagReplace(TagName))
 .s:styleName'="" pos=$L(TR)-$S(TagName'="td":0,1:$L("<text:p>")), $E(TR,pos)=styleName_$E(TR,pos)
 .s $E(str,i,$F(str,">",i)-1)=TR, i=i+$L(TR) 
 .;s ^uuu($I(^uuu),"Parse","styleName",FullTag)=styleName
 .;s ^uuu($I(^uuu),"Parse","styleName",3)=TR
 .;s ^uuu($I(^uuu),"Parse","str")=str
  q str
TagName(str) q:str="" "" 
 n start,end,space s start=$F(str,"<") s space=$F(str," ",start) s end=$F(str,">",start) s end=$S((end>space)&space:space,end:end,1:32000)-4
 Q $E(str,start,start+end)
FullTag(str,TagName) q:str="" "" 
 new start,end s TagName=$G(TagName)
 set start=$F(str,"<"_TagName)-($L(TagName)+1), end=$F(str,">",start)-1
 Q $E(str,start,end)
GetStyle(tagName,style) Q:style="" ""
 n stName,border,align,indent,height,fontColor,i s stName=""
 ;s:(style["height") height=$E(style,$F(style,"height:"),$F(style,"'",$F(style,"height:"))-3) 
 s:(style["height") height=$P(style,$F(style,"height:"),$F(style,"'",$F(style,"height:"))-3) 
 if tagName="p" d 
 .s:(style["align")&&(style["right") stName="P_RIGHT"
 .s:(style["align")&&(style["center") stName="P_CENTER"
 .i (style["indent") d 
 ..s indent=$E(style,$F(style,"indent='"),32000), indent=$E(indent,1,$F(indent,"'")-2)
 ..s stName="P_indent_"_indent, OOstyle="<style:style style:name='"_stName_"' style:family='paragraph'><style:paragraph-properties fo:text-indent='"_indent_"cm'/></style:style>"
 ..s @innerRef@("InnerTable",stName)=OOstyle
 .s stName=" text:style-name='"_stName_"'"
 
 if tagName="td" s (border,align)="" d 
 . s:(style["border") border=$E(style,$F(style,"border:"),$F(style,";",$F(style,"border:"))-2) 
 . ;s:($G(border)'="")&&(border["pt") border=$E((+$P(border,"pt")/2),1,4)_"pt"_$P(border,"pt",2) ; границы для встроеных таблиц в два раза уже
 . s:(style["text-align") align=$E(style,$F(style,"text-align:"),$F(style,";",$F(style,"text-align:"))-2)
 . if (border'="")||(align'="") s stName="TD_"_border_align do 
 .. s OOstyle="<style:style style:name='"_stName_"' style:family='table-cell'><style:table-cell-properties fo:border='"_$S(border="":"none",1:border)_"'/><style:paragraph-properties fo:text-align='"_$S(align="":"left",1:align)_"'/></style:style>"
 .. s @innerRef@("InnerTable",stName)=OOstyle
 .. s stName=" table:style-name='"_stName_"'"
 . s:(style["colspan") stName=stName_" table:number-columns-spanned='"_$E(style,$F(style,"colspan='"),$F(style,"'",$F(style,"colspan='")))
 
 ; обработка только параметра style.
 s style=$P(style,"style=",2)
 s style=$P(style,$E(style),2)
 f i=1:1:$L(style,";") do:$P(style,";",i)'=""
 . s par=$P($P(style,";",i),":",1),val=$P($P(style,";",i),":",2)
 . s:par'="" style(par)=val

 i (tagName="tr")&($G(style("height"))'="") s stName="TR_"_style("height") d 
 .s @innerRef@("InnerTable",stName)="<style:style style:name='"_stName_"' style:family='table-row'><style:table-row-properties style:row-height="""_style("height")_"""/></style:style>"
 .s stName=" table:style-name='"_stName_"'"
 
 i (tagName="font") s fontColor="" d
 .s fontColor=$E(style,$F(style,"color='"),$F(style,"'",$F(style,"color='"))-2)
 .i $L(fontColor)>1 d 
 ..s stName="fontColor_"_fontColor 
 ..s @innerRef@("InnerTable",stName)="<style:style style:name='"_stName_"' style:family='text'><style:text-properties fo:color='"_fontColor_"' /></style:style>"
 ..s stName=" text:style-name='"_stName_"'"
 
 i tagName="span" do
 . n par,val,i,stOO
 . s stName="span"
 . s i="" f  s i=$O(style(i)) q:i=""  do
 .. s par=$ZCVT(i,"l"),val=style(i)
 .. if par="font-family" s stName=stName_"Ft"_$P(val," "),stOO(par)="'"_val_"'" q
 .. if par="font-size" s stName=stName_"Sz"_(+$P(val," ")),stOO(par)="'"_val_"'" q
 .. if par="font-color" s stName=stName_"Cl"_(+$P(val," ")),stOO(par)="'"_val_"'" q
 .. if par="font-style" s stName=stName_"St"_(+$P(val," ")),stOO(par)="'"_val_"'" q
 .. if par="font-weight" s stName=stName_"Wt"_(+$P(val," ")),stOO(par)="'"_val_"'" q
 . i stName="span" s stName="" q
 . s @innerRef@("InnerTable",stName)="<style:style style:name='"_stName_"' style:family='text'>"
 . s i="" f  s i=$O(stOO(i)) q:i=""  s @innerRef@("InnerTable",stName)=@innerRef@("InnerTable",stName)_"<style:text-properties fo:"_i_"="_stOO(i)_"/>"
 . s @innerRef@("InnerTable",stName)=@innerRef@("InnerTable",stName)_"</style:style>"
 . s stName=" text:style-name='"_stName_"'"
 
 Q stName
]]></Implementation>
</Method>

<Method name="CreSortV">
<Description>
Создание локального словаря  сортировки для понятия qqw объекта qqo
Value - выражение для вычисления слова словаря. Не задано - для словаря используется значение понятия qqw
qqc0 - текущая общая часть кода экземпляра
SortV - индекс словаря (переносится в Vs(qqnump,"SortV") ). По умолчанию - ссылка на текущий перечень релевантных
SortVn =1 - НЕ создавать ссылки на экземпляры( переносятся в Vs(qqnump,"SortVn") ). Будут использоваться ссылки словаря понятия qqw
!!! для виртуальных объектов ссылки создаются всегда
New=1 - обновить словарь. Иначе, если он уже есть, то не строится.
Up=1 - преобразовать в большие буквы; @Dol 04.03.09

Массив локального словаря:
^Qi(qqw,SortV) = кол-во слов
^Qi(qqw,SortV ,значение_слова [,qqo,qqc])=Номер слова в значении

Предназначен для вызова в действии по Обработке сортировки (X785). 
См. qARM.T2ColHButtonDo, qARM.Sort

Работает и по ссылочным объектам. В этом случае можно указать и предыдущий объект(первым в qqo через запятую):
qqo=предыдущий_","_текущий
Создаются правильные Vs(qqnump,"Virt")</Description>
<Internal/>
<FormalSpec>qqw:%Library.String,qqo:%Library.String,Value:%Library.String,qqc0:%Library.String,SortV:%Library.String,SortVn:%Library.String,New:%Library.String,Up</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqc,qqco,qqz,qqzi,qqzw,qql0,qqop,qqReFind S qqop=$S(qqo[",":$P(qqo,","),1:"") S:qqop'="" qqo=$P(qqo,",",2) S:'$D(Up) Up=$G(Vo(qqnump,-1,1990))
 S:$G(SortV)="" SortV=$$$Relind_qview S Vs(qqnump,"SortV")=SortV,Vs(qqnump,"SortVn")=$G(SortVn),SortVn=$G(SortVn) I '$G(New),$D(^Qi(qqw,SortV))>1 Q:'$Q  Q $G(^Qi(qqw,SortV)) ;Словарь существует
 S qql0=$S($$$ReFind:$$$Relind_qview,1:1) I qql0'=1,$D(^Q(qql0,qqo))<10 S qql0=1 
 S qqReFind=$$$ReFind ;05.11.08 для учета X540 - сброс уточнения в qW.gOrder
 S qqc0=$G(qqc0),qqc=qqc0 K ^Qi(qqw,SortV)
 I $G(Vo(qqnump,qqo,2))>1 K Vs(qqnump,"SortV"),Vs(qqnump,"SortVn"),W("Zosrt") D  S Vs(qqnump,"SortV")=SortV,$$$ReFind=qqReFind Q:'$Q  Q $G(^Qi(qqw,SortV)) ;@Dol 17.08.06 для виртуальных
 .D:qqop=""  Q:qqop=""  N qqcp0 S qqcp0=qqc0,qqc0="" F  S qqc0=..gOrder(1,qqop,qqc0,qqcp0) Q:qqc0=""  S Vs(qqnump,"Virt",qqop)=qqc0 D
 ..S qqc="" F  S qqc=..gOrder(1,qqo,qqc,qqc0) Q:qqc=""    D  I qqzw'="" S ^Qi(qqw,SortV,qqzw,qqo,qqc)=$S(qqop="":"",1:qqop_" "_qqc0) I $I(^Qi(qqw,SortV))
 ...S Vs(qqnump,"Virt",qqo)=qqc 
 ...I $G(Value)'="" S @("qqzw="_Value) S:qqzw="" qqzw=" " S qqzw=$TR(qqzw," ","_") S:$G(Up) qqzw=$ZCVT(qqzw,"U") Q
 ...I qqc[" ",$G(Vo(qqnump,qqo,870)) S qqzw=qARM.GetPar("X75",,qqo,qqw) I qqzw'="",$E(qqzw)="@" S @("qqzw="_$E(qqzw,2,255)) S:qqzw="" qqzw=" " S qqzw=$TR(qqzw," ","_") S:$G(Up) qqzw=$ZCVT(qqzw,"U") Q  ;значения по умолчанию для отсутствующих экземпляров
 ...S qqzw=..GG(qqo,qqw,qqc) S:qqzw="" qqzw=" " S qqzw=$TR(qqzw," ","_") S:$G(Up) qqzw=$ZCVT(qqzw,"U") Q  ;а пустые значения?
 I qqc0="",$G(Vt(qqnump,0)) N qqob,qqoi D  I qqob="" K Vs(qqnump,"SortVn") Q:'$Q  Q $G(^Qi(qqw,SortV))
 .S qqob=$G($$$ObjRef(qqo),qqo) F qqoi=$L(qqob,","):-1:1 I $G(Vo(qqnump,$P(qqob,",",qqoi),27))'=""||($G(Vo(qqnump,-1,67))'="") S qqob="" Q
 .Q:qqob'=""
 .S qqc="" F  S qqc=..gOrder(1,qqo,qqc,qqc0) Q:qqc=""  D
 ..I $G(Value)'="" S @("qqzw="_Value) S:qqzw="" qqzw=" " S ^Qi(qqw,SortV,qqzw,qqo,qqc)="" I $I(^Qi(qqw,SortV)) Q
 ..I "MXZL@HxR"[$E(qqw)||(qqw[":") S qqzw=..GG(qqo,qqw,qqc)  I qqzw'="" S:$G(Up) qqzw=$ZCVT(qqzw,"U") S ^Qi(qqw,SortV,qqzw,qqo,qqc)="" I $I(^Qi(qqw,SortV)) Q
 ..S qqzw=$G(^Q(1,qqo,qqc,qqw)) I qqzw'=""  F qqzi=1:1:$L(qqzw," ") S qqz=$P(qqzw," ",qqzi) S:$E(qqw)'="D" qqz=^Q(qqlang,"C"_qqw,qqz) S:$G(Up) qqz=$ZCVT(qqz,"U") S:'SortVn ^Qi(qqw,SortV,qqz,qqo,qqc)=qqzi-1 S:SortVn ^Qi(qqw,SortV,qqz)="" I $I(^Qi(qqw,SortV))
 .S $$$ReFind=qqReFind
 I $G(Value)'="" D  K Vs(qqnump,"SortVn") Q:'$Q  Q $G(^Qi(qqw,SortV))
 .F  S qqc=$O(^Q(qql0,qqo,qqc)) Q:qqc=""  Q:$E(qqc,1,$L(qqc0))'=qqc0  S @("qqzw="_Value) S:qqzw="" qqzw=" " S:$G(Up) qqzw=$ZCVT(qqzw,"U") S ^Qi(qqw,SortV,qqzw,qqo,qqc)="" I $I(^Qi(qqw,SortV))
 I "MXZL@HxR"[$E(qqw)||(qqw[":") D  K Vs(qqnump,"SortVn") Q:'$Q  Q $G(^Qi(qqw,SortV))
 .F  S qqc=$O(^Q(qql0,qqo,qqc)) Q:qqc=""  Q:$E(qqc,1,$L(qqc0))'=qqc0  S qqzw=..GG(qqo,qqw,qqc)  I qqzw'="" S:$G(Up) qqzw=$ZCVT(qqzw,"U") S ^Qi(qqw,SortV,qqzw,qqo,qqc)="" I $I(^Qi(qqw,SortV))
 S qqco=qqc0 F  S qqco=$O(^Q(qql0,qqo,qqco)) Q:qqco=""  Q:$E(qqco,1,$L(qqc0))'=qqc0  S qqzw=$G(^Q(1,qqo,qqco,qqw)) I qqzw'=""  F qqzi=1:1:$L(qqzw," ") S qqz=$P(qqzw," ",qqzi) S:$E(qqw)'="D" qqz=^Q(qqlang,"C"_qqw,qqz) S:$G(Up) qqz=$ZCVT(qqz,"U") S:'SortVn ^Qi(qqw,SortV,qqz,qqo,qqco)=qqzi-1 S:SortVn ^Qi(qqw,SortV,qqz)="" I $I(^Qi(qqw,SortV))
 Q:'$Q  Q $G(^Qi(qqw,SortV))
]]></Implementation>
</Method>

<Method name="FastKey">
<Description>
Быстрый вариант qW.Key
РАБОТАЕТ С 20081106 ДЛЯ ПУСТЫХ ЗНАЧЕНИЙ кодируемых понятий (или D*-понятий)), КРОМЕ ПЕРВОГО В qqwl          ;;РАБОТАЕТ ТОЛЬКО ДЛЯ НЕПУСТЫХ ЗНАЧЕНИЙ кодируемых понятий (или D*-понятий))
Поиск следующего экземпляра объекта qqo для строки кодов понятий qqwl
Возвращает код экземпляра или пусто.
qorder - направление перемещения (1 или -1 ;0 - проверка наличия - возвращает 0 или 1 а не qqc!!!)
qqc0 - общее начало кодов экземпляра
listz - список значений понятий (через ~)
Если заданы iObj iqqc, то это объект и экземпляр из которых нужно взять значения. listz в этом случае может содержать список кодов замещающих qqwl понятий, если не указан - те же, что и в qqwl.
qqpar4 - условие, которому должен удовлетворять найденный код. Можно пользоваться qqo, qqc

!!! При наличии R*-понятия для первого из списка qqwl в том же объекте требуется задать qqpar4 вида """ ""_qW.G(qqw0)_"" ""[("" ""_qqz0_"" "")"
( раньше была ошибка   "qW.G(qqw0)[qqz0" )
!!!или задать в qqpar4 "NR"

!!!New 
qqwpass=1 - проход по словарю первого понятия из списка qqwl. В этом случае его значение из listz - общая часть слова.
qqwpass=2 - проход по словарю первого понятия из списка qqwl по списку  его значений из listz (через пробел) 
Значения в экземплярах должны быть только из ОДНОГО слова.
qqwsum - суммировать по заданному коду понятия (относительно обьекта qqo. Но можно использовать синтаксис qqo:qqw для взятия понятия из другого объекта). В этом случае обходятся все подходящие экземпляры и возвращается сумма. ;@Dol 04.11.09
raz - если задан и задано qqwsum, то возвращается не сумма, а список значений понятия qqwsum через разделитель raz</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqwl:%Library.String,qqc:%Library.String,qorder:%Library.String=1,listz:%Library.String,qqc0:%Library.String,iobj:%Library.String,iqqc:%Library.String,qqpar4:%Library.String,qqwpass:%Library.String,qqwsum,raz</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqw,qqw0,qqwi,qqz,qqz0,qqzi,qqcc,qend,order,qqcb,sum I qorder=0 S order=1,qorder=1 ;qorder=0 - тестирование наличия
 S:$E(qqo)="v" qqo=$E(qqo,3,255) ;@Dol 17.06.05
 I $G(iobj)'="" D  S listz=qend
 .F qqwi=1:1:$L(qqwl," ") S qqw=$P($G(listz)," ",qqwi) S:qqw="" qqw=$P(qqwl," ",qqwi) S $P(qend,"~",qqwi)=qW.GG(iobj,qqw,iqqc)
 S (qqcb,qqc)=$G(qqc) I $G(qqc0)'="" S qqc=$S(qqc="":qqc0_$S(qorder=-1:"яяяяя",1:""),$E(qqc,1,$L(qqc0))=qqc0:qqc,1:"") I qqc="" Q:$Q "" Q
 D
 .I qqwl'[" ",listz'[" " S qqz0=listz,listz="",qqw0=qqwl,qqwl="" Q
 .I qqwl'[" " S qqz0=$P(listz," "),listz=$P(listz," ",2,255),qqw0=qqwl Q
 .S qqz0=$P(listz,"~"),qqw0=$P(qqwl," ") I qqz0'[" " S listz=$P(listz,"~",2,255),qqwl=$P(qqwl," ",2,255) Q
 .S listz=$P(qqz0," ",2,255)_"~"_$P(listz,"~",2,255) s qqz0=$p(qqz0," ")  ; tdv 20090504 - добавлено s qqz0=$p(qqz0," ")
 S:$E(qqw0)="C" qqz0=$G(^Q(1,qqw0,qqz0)),qqw0=$E(qqw0,2,255) ;@Dol 18.11.06
 I "HRYMLXTx@Z"[$E(qqw0,1)||(..rWocx711(qqw0,qqo)) D qARM.Message("Error qW.FastKey. "_qqw0_" - несловарное понятие") Q:$Q "" Q  ;@Dol 07.12.09
 S:$G(qqpar4)="NR" qqpar4=""" ""_qW.G(qqw0)_"" ""[("" ""_qqz0_"" "")"  S:$D(qqwsum)&&($G(qqpar4)="") qqpar4=1 S:$G(qqwpass)=2&&($P(listz,"~",1)="") qqwpass=0 G:$G(qqwpass) FastKeyZ Q:qqz0="" ""
FastKey0 F  S qqc=$O(^Q(1,qqw0,qqz0,qqo,qqc),qorder),qqc=$S(qqc="":"",$G(qqc0)="":qqc,$E(qqc,1,$L(qqc0))'=qqc0:"",1:qqc) Q:qqc=""  S qend=1 D:qqwl'=""  I qend Q:$G(qqpar4)=""  I @qqpar4 Q:'$D(qqwsum)  S:$G(raz)'="" sum=$S($G(sum)="":"",1:sum_raz)_qW.G(qqwsum) I $G(raz)="",$I(sum,..G(qqwsum))  ;@Dol 04.11.09 sum; 29.03.10 raz
 .F qqwi=1:1:$L(qqwl," ") S qqz=$P(listz,"~",qqwi) D  Q:'qend
 ..I "HRYMLXTx@Z"[$E($P(qqwl," ",qqwi),1)||(..rWocx711($P(qqwl," ",qqwi),qqo))  S qend=..G($P(qqwl," ",qqwi))=qqz Q  ;@Dol 07.12.09 несловарные понятия
 ..I qqz="" S:qqwi'=1 qend='$D(^Q(1,qqo,qqc,$P(qqwl," ",qqwi))) Q  ;@Dol 3.11.08 обязательное отсутствие значения
 ..F qqzi=1:1:$L(qqz," ") I $P(qqz," ",qqzi)=""||('$D(^Q(1,$P(qqwl," ",qqwi),$P(qqz," ",qqzi),qqo,qqc))) S qend=0 Q
 Q:$Q $S($G(order):qqc'="",$D(qqwsum):$G(sum),1:qqc) Q
   
 ;Проход по значениям понятия (qqz0 - общее начало) или по списку значений; 05.11.09
FastKeyZ S:qqwpass=2 qqz0=qqz0_" "_$P(listz,"~",1),$P(listz,"~",1)="" S qqwpass=qqz0 I qqcb'="" S qqz0=qW.GG(qqo,qqw0,qqcb) D:qqz0[" " qARM.Message("qW.FastKey режим qqwpass=1. Значение из нескольких слов (qqo="_qqo_" qqc="_qqcb_" qqz="_qqz0_")") Q:qqz0[" " "" S:qqwpass'[" "&&(" "_qqz0'[(" "_qqwpass)) qqz0=qqwpass S:qqwpass[" "&&(" "_qqwpass_" "'[(" "_qqz0_" ")) qqz0=$S(qorder<0:$P(qqwpass," ",$L(qqwpass," ")),1:$P(qqwpass," "))
 S:qqcb="" qqz0=""  ;@Dol 4.07.09
 D:0 qARM.Message("*"_qqz0_" "_qqcb_" "_qW.GG(qqo,qqw0,qqcb)) I qqz0'="",$D(^Q(1,qqw0,qqz0,qqo)) D FastKey0 Q:qqc'="" qqc
 F  S qqz0=$S(qqwpass'[" ":..qOrd($NA(^Q(1,qqw0)),qqz0,qqwpass,qorder),qqz0="":$S(qorder<0:$P(qqwpass," ",$L(qqwpass," ")),1:$P(qqwpass," ")),qorder<0:$P($P(" "_qqwpass_" "," "_qqz0_" ")," ",$L($P(" "_qqwpass_" "," "_qqz0_" ")," ")),1:$P($P(" "_qqwpass_" "," "_qqz0_" ",2)," ")) Q:qqz0=""  S:qqc=""&&($G(qqc0)'="") qqc=qqc0_$S(qorder=-1:"яяяяя",1:"") D FastKey0 Q:qqc'=""  ;@Dol 4.07.09
 Q $S($D(qqwsum):$G(sum),qqz0="":"",1:qqc)
 
 ;Проход по значениям понятия (qqz0 - общее начало)
 ;FastKeyZ S qqwpass=qqz0 I qqcb'="" S qqz0=qW.GG(qqo,qqw0,qqcb) D:qqz0[" " qARM.Message("qW.FastKey режим qqwpass=1. Значение из нескольких слов (qqo="_qqo_" qqc="_qqcb_" qqz="_qqz0_")") Q:qqz0[" " "" S:" "_qqz0'[(" "_qqwpass) qqz0=qqwpass
 ;S:qqcb="" qqz0=""  ;@Dol 4.07.09
 ;I qqz0'="",$D(^Q(1,qqw0,qqz0,qqo)) D FastKey0 Q:qqc'="" qqc
 ;F  S qqz0=..qOrd($NA(^Q(1,qqw0)),qqz0,qqwpass,qorder) Q:qqz0=""  S:qqc=""&&($G(qqc0)'="") qqc=qqc0_$S(qorder=-1:"яяяяя",1:"") D FastKey0 Q:qqc'=""  ;@Dol 4.07.09
 ;Q $S(qqz0="":"",1:qqc)
]]></Implementation>
</Method>

<Method name="ForTTips">
<Description>
Для всплывающих подсказок (понятие X7102).;@Dol 03.03.10 с учетом типов данных
Возвращает спискок  в виде строк: имя понятие - значение
qqwl - список кодов понятий ( или qqo:qqw) через пробел
All=1 - выводить пустые значения
Non=1 - без имени понятия
Значения понятий вычисляются относительно текущего объекта</Description>
<Internal/>
<FormalSpec>qqwl:%Library.String,All:%Library.String,Non:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqwi,qqwzz,qqww,qqwii,qqwz,qqwt F qqwi=1:1:$L(qqwl," ") S qqww=$P(qqwl," ",qqwi) I qqww'="" S qqwzz=qW.G(qqww) I qqwzz'=""||$G(All) S qqwt=qARM.GetPar("x710",,qqo,$S(qqww'[":":qqww,1:$P(qqww,":",2))),$P(qqwz,$C(13,10),$I(qqwii))=$S('$G(Non):qARM.GetName(,qqo,$S(qqww'[":":qqww,1:$P(qqww,":",2)))_": ",1:"")_$S(qqwt:qW.GtoExt(qqwt,qqwzz),1:qqwzz) ;@Dol 03.03.10
 Q $G(qqwz)
]]></Implementation>
</Method>

<Method name="G">
<Description>
             Получить значение понятия qqpar1 для текущего qqc экземпляра объекта qqo.</Description>
<Internal/>
<ClassMethod>1</ClassMethod>
<FormalSpec>qqw:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I qqw[":",$E(qqw)'="L",$E(qqw,1,3)'="@ZL" Q qW.Get(qqw) ;@Dol 25.03.06
 Q:qqw="" "" N qqw1,qqwvvv,qqot,qqoo ;?????? S qqo=qqoo для некоторых? типов виртуальных
 i $g(qqnump)="" n qqnump s qqnump=99
 I $G(Vo(qqnump,qqo,41)),$E(qqw)?1N S qqwvvv=qqc N qqc S qqc=$P(qqwvvv,"~",$E(qqw,1,2)),qqw=$E(qqw,3,30000)
 S qqoo=qqo,qqot=$S('$D(Vo(qqnump,qqo)):$S($G($$$Tree):2,1:+qARM.GetPar("x52",,qqo)),1:+$G(Vo(qqnump,qqo,2))),qqw1=$E(qqw) I '$G(qqGERROR) N $ET S $ET="S qqw=$G(qqw)_"" ""_$TR($ZE,""<>"") S:$ZE'[""CLASS REC"" $EC="""" Q:$Q qqw Q" ;@Dol 24.08.09 qqGERROR=1 - НЕ подавлять ошибку
 S:qqot=9 qqot=0
 I $E(qqo)="v" N qqo S qqo=$E(qqoo,3,255)
 I $G($$$Tree),$S($D(qqref):$P(qqref,"(")'="^Q"&($P(qqref,"(")'="^Qa"),1:$P($$$GloRef,"(")'="^Q"&($P($$$GloRef,"(")'="^Qa")) D  Q:qqw1'="T" qqwvvv Q:$Q $D(W(qqw)) Q  ;для потока
 .I qqw1'="T" S qqwvvv=$G(@$S($D(qqref):qqref,1:$$$GloRef)@(qqo,qqc,qqw)) Q:qqw'="C"  Q:qqwvvv'=""  S qqwvvv="<"_qqc_">" Q
 .K W(qqw) M W(qqw)=@$S($D(qqref):qqref,1:$$$GloRef)@(qqo,qqc,qqw)
 I qqot=1 S qqot=$S($G($$$ObjRef(qqoo))="":qqoo,1:$P($$$ObjRef(qqoo),",",$L($$$ObjRef(qqoo),",")-1)) N qqo S qqo=$S($E(qqot)'="v":qqot,1:$E(qqot,3,255)),qqot=0 ;предыдущий объект для встроенного;@Dol 9.04.09 $S($G($$$ObjRef(qqoo))=""
 I qqot>2,"Z@"'[qqw1,$S(qqw1="H":qqot=8,1:1) D  S:qARM.GetPar(741,,qqo,qqw) qqwvvv=$TR(qqwvvv," ","_") Q:$Q qqwvvv Q  ;???Q:qqw="C" qqc D ???Q:qqot=3 $G(W(qqw)) D  Q qqwvvv
 .I qqot=8 N qqNS,qqNSN S qqNS=$ZU(5) D:'$D(Vo(qqnump,qqo,29)) qARM.GetPar(529,,qqo) S:'$D(Vt(qqnump,"mas",qqo,qqw)) Vt(qqnump,"mas",qqo,qqw)=qARM.GetPar("X753",,qqo,qqw) S Vo(qqnump,qqo,2)=0 ZN $S($P(Vo(qqnump,qqo,29)," ")="":qqNameSpace,1:$P(Vo(qqnump,qqo,29)," ")) S:Vt(qqnump,"mas",qqo,qqw)="" qqwvvv=$S($P(Vo(qqnump,qqo,29)," ",2)="":..G(qqw),1:..GG($P(Vo(qqnump,qqo,29)," ",2),qqw,qqc)) S:Vt(qqnump,"mas",qqo,qqw)'="" @("qqwvvv="_Vt(qqnump,"mas",qqo,qqw)) ZN qqNS S Vo(qqnump,qqo,2)=8 Q
 .I qqot=6 S qqo=qqoo D  S:$G(qqWinDos) qqwvvv=(qW.windos(qqwvvv)) S:$G(Vt(qqnump,"mas",qqo,qqw,41)) qqwvvv=$TR(qqwvvv," ","_") S:$G(Vt(qqnump,"mas",qqo,qqw,42)) qqwvvv=$S(Vt(qqnump,"mas",qqo,qqw,42)<3:$ZCVT(qqwvvv,$S(Vt(qqnump,"mas",qqo,qqw,42)=1:"U",1:"L")),1:$ZCVT($E(qqwvvv),"U")_$ZCVT($E(qqwvvv,2,30000),"L")) S:$E(qqw)="x"&&(qqwvvv'="") qqwvvv=qW.GetWoc("C"_qqw,qqwvvv) Q  ; tdv 20110302 было qqwvvv=$G(^Q(1,"C"_qqw,qqwvvv)) ;@Dol 3.3.05 :$E(qqw)="x" - для отображений XXXXNV
 ..S:'$D(qqWinDos) qqWinDos=+$G(^Q(1,"XBase",0,"XFVDos")) ;флаг перекодировки DOS->Win
 ..I qqw="C" S qqwvvv=qqc Q
 ..S:'$D(Vt(qqnump,"mas",qqo,qqw)) Vt(qqnump,"mas",qqo,qqw)=qARM.GetPar("X753",,qqo,qqw),Vt(qqnump,"mas",qqo,qqw,41)=qARM.GetPar("741",,qqo,qqw),Vt(qqnump,"mas",qqo,qqw,42)=qARM.GetPar("742",,qqo,qqw) I '$D(Vo(qqnump,qqo,33)) S Vo(qqnump,qqo,33)=qARM.GetPar("X533",,qqo) S:$E(Vo(qqnump,qqo,33),1,2)="@@" Vo(qqnump,qqo,33)=qARM.Value($E(Vo(qqnump,qqo,33),3,2555)) S:$E(Vo(qqnump,qqo,33))="@" Vo(qqnump,qqo,33)=$E(Vo(qqnump,qqo,33),2,2555),Vo(qqnump,qqo,33,1)="" ;если прямая ссылка
 ..I qqoo'=qqo,Vo(qqnump,qqo,33)="" S qqo=qqoo S Vt(qqnump,"mas",qqo,qqw)=qARM.GetPar("X753",,qqo,qqw) S Vo(qqnump,qqo,33)=qARM.GetPar("X533",,qqo) S:$E(Vo(qqnump,qqo,33))="@" Vo(qqnump,qqo,33)=$E(Vo(qqnump,qqo,33),2,2555),Vo(qqnump,qqo,33,1)="" ;???Для синонима
 ..I qqo=-1 S qqwvvv=$G(@(Vo(qqnump,qqo,33))@(qqw)) Q  ;спец.вариант для понятий вершины (для аналитики ^Qa(qql))
 ..I qqw="CC" S qqwvvv=$G(@(Vo(qqnump,qqo,33))@(qqc)) Q
 ..I $G(Vt(qqnump,"mas",qqo,qqw))="" D   Q  ;код понятия-индекс узла
 ...I $E(qqw)="T" K W(qqw) M W(qqw)=@(Vo(qqnump,qqo,33))@(qqc,qqw) S qqwvvv="" Q  ;@dol 28.07.04
 ...S qqwvvv=$G(@(Vo(qqnump,qqo,33))@(qqc,$S($E(qqw,1,2)="Cx":$E(qqw,2,255),qqw1'="X"||$G(Vo(qqnump,-1,993)):qqw,$G(Vo(qqnump))["XXXXNV":qqw,1:$E(qqw,2,255)))) ;05.03.11 X1993
 ..I $L(Vt(qqnump,"mas",qqo,qqw)," ")=1,$E(Vt(qqnump,"mas",qqo,qqw))'="$" D  Q
 ...I $E(qqw)="T" K W(qqw) M W(qqw)=@(Vo(qqnump,qqo,33))@(qqc,Vt(qqnump,"mas",qqo,qqw)) S qqwvvv="" Q  ;@dol 3.5.04
 ...S qqwvvv=$G(@(Vo(qqnump,qqo,33))@(qqc,Vt(qqnump,"mas",qqo,qqw))) Q
 ..I $E($P(Vt(qqnump,"mas",qqo,qqw)," ",2))="@" N Z S Z=$S($P(Vt(qqnump,"mas",qqo,qqw)," ")="":"",$P(Vt(qqnump,"mas",qqo,qqw)," ")="C":qqc,$P(Vt(qqnump,"mas",qqo,qqw)," ")="CC":$G(@Vo(qqnump,qqo,33)@(qqc)),1:$G(@Vo(qqnump,qqo,33)@(qqc,$P(Vt(qqnump,"mas",qqo,qqw)," ")))),@("qqwvvv="_$E($P(Vt(qqnump,"mas",qqo,qqw)," ",2,255),2,1000)) Q
 ..;I Vt(qqnump,"mas",qqo,qqw)?1.n1" "1.e S:$G(W("C"))'=qqc W("CC")=$G(@(Vo(qqnump,qqo,33))@(qqc)),W("C")=qqc S qqwvvv=$P(W("CC"),$P(Vt(qqnump,"mas",qqo,qqw)," ",2,255),+Vt(qqnump,"mas",qqo,qqw)) Q  ;значение в узле через разделитель
 ..I Vt(qqnump,"mas",qqo,qqw)?1.n1" "1.e S qqwvvv=$P(Vt(qqnump,"mas",qqo,qqw)," ",2,255) S:qqwvvv?1.N qqwvvv=$C(qqwvvv) S qqwvvv=$P($G(@(Vo(qqnump,qqo,33))@(qqc)),qqwvvv,+Vt(qqnump,"mas",qqo,qqw)) Q  ;значение в узле через разделитель
 ..S @("qqwvvv="_Vt(qqnump,"mas",qqo,qqw)) ;произвольное выражение
 .I qqw="C" S qqwvvv=qqc Q
 .I qqot=7 S qqo=qqoo D  Q  ;SQL
 ..N qqwtab S qqwvvv="???",qqwtab=$G(Vt(qqnump,"sql",qqo,"qqw",qqw))
 ..I qqwtab="" S qqwvvv=$G(Vs(qqnump,"Virt",qqo,$E(qqw,2,2000))) Q
 ..D  Q:qqwvvv=""  ;Q:$D(Vt(qqnump,"sql",qqo,"qqw",qqw))<10
 ...I $L(qqwtab," ")=1 S qqwvvv=$G(Vs(qqnump,"Virt",qqo,$P(qqwtab," "))) Q
 ...I $E($P(qqwtab," ",2))="@" N Z S Z=$G(Vs(qqnump,"Virt",qqo,$P(qqwtab," "))),@("qqwvvv="_$E($P(qqwtab," ",2,255),2,1000)) Q
 ...I $L(qqwtab," ")=3 S qqwvvv=qUSER.GetSQL($G(Vs(qqnump,"Virt",qqo,$P(qqwtab," "))),$P(qqwtab," ",2),$P(qqwtab," ",3)) Q
 ..I $G(Vt(qqnump,"sql",qqo,"qqw",qqw,10))=1 d  Q  ;дата
 ...S:qqwvvv[" " qqwvvv=$TR($P(qqwvvv," "),"-")
 ...S:qqwvvv'[" " qqwvvv=$p(qqwvvv,".",3)_$p(qqwvvv,".",2)_$p(qqwvvv,".",1)
 ..S:$G(Vt(qqnump,"sql",qqo,"qqw",qqw,41)) qqwvvv=$TR(qqwvvv," ","_") ;режим одного слова
 ..S:$G(Vt(qqnump,"sql",qqo,"qqw",qqw,42)) qqwvvv=$S(Vt(qqnump,"sql",qqo,"qqw",qqw,42)<3:$ZCVT(qqwvvv,$S(Vt(qqnump,"sql",qqo,"qqw",qqw,42)=1:"U",1:"L")),1:$ZCVT($E(qqwvvv),"U")_$ZCVT($E(qqwvvv,2,30000),"L")) ;преобразование
 ..I $E(qqw)="T" K W(qqw) D  S qqwvvv=""
 ...F qqot=1:1:$L(qqwvvv,$C(13,10)) S W(qqw,qqot-1)=$TR($P(qqwvvv,$C(13,10),qqot),$C(147,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31),"'????????? ????????????????????????")
 .I qqot=3 D:$G(Vs(qqnump,"Virt",qqo))'=qqc qW.gOrder(0,qqo,qqc) S qqwvvv=$G(W(qqw)) Q  ;для виртуальных - вызов gOrder чтобы заполнить W(qqw) если вызов не из вывода дерева или поиска
 .I qqot=5 S:'$D(Vt(qqnump,qqw)) Vt(qqnump,qqw)=qARM.GetPar("X79",,qqo,qqw) S:$G(W("C"))'=qqc W("CC")=$G(@("^"_$E(qqo,2,255))@(qqc)),W("C")=qqc S qqwvvv=$P(W("CC"),"^",Vt(qqnump,qqw)) Q
 .S:$E(qqw,1,2)="q4" qqw=$E(qqw,3,100) S qqwvvv=$G(@("^"_qqo)@(qqc,qqw)) Q:$E(qqw,1,3)="zzd"  N j F j=1:1:$L(qqwvvv," ") S:$P(qqwvvv," ",j)'="" $P(qqwvvv," ",j)=$G(^QW(1,qqw,1,$P(qqwvvv," ",j)))
 G:"@ZCTYH"'[qqw1 Gbeg I qqw1="@" D  Q qqwvvv
 .I '$D(VXRef($P(qqw,"."))) S VXRef($P(qqw,"."))=$P($G(^Q(1,"CxWoc",$P(qqw,"."),"XRef")),";;") ;@Dol 16.08.06 теперь для всех @* - было только для @ZX* @XH*
 .I $E(qqw,2,3)="ZX" D  S:qqwvvv="" qqwvvv=qW.GetWoc("CxWoc",qqw) S qqwvvv=$TR(qqwvvv,"_%"," ") S:qqwvvv=" " qqwvvv="" S qqw1=qARM.GetPar(175) S:qqw1_" "[(","_qqw_" ") qqw1=$P(qqw1_" ",","_qqw_" "),qqwvvv=$E($P(qqw1," ",$L(qqw1," ")))_"."_qqwvvv Q  ;имя в качестве значения (с учетом идентификации горячих клавиш);имя может вычислятся (как у @ZH*)
 ..S qqwvvv=VXRef(qqw) S:qqwvvv'="" @("qqwvvv="_qqwvvv) Q
 .I $E(qqw,2,3)="XH" S qqwvvv=VXRef(qqw) S:qqwvvv'="" @("qqwvvv="_qqwvvv) Q  ;непосредственно вычисляемые обобщения
 .I qqw'["." S @("qqwvvv="_$S("XZx"[$E(qqw,2):"qW.o",VXRef(qqw)="":"qUSER.o",1:VXRef(qqw)_".o")_$E(qqw,2,31)_"()") Q  ;@Dol 14.08.06 - в характеристике - ссылка на класс
 .I $G(W($P(qqw,".")))'=qqc||('$D(W($P(qqw,".")))) D   ;коллекция еще не вычислена
 ..S qqZN=qqw N qqw S qqw=$P(qqZN,".") S @("qqwvvv="_$S("XZx"[$E(qqw,2):"qW.o",VXRef(qqw)="":"qUSER.o",1:VXRef(qqw)_".o")_$E(qqw,2,31)_"()")
 .S qqwvvv=$S($L(qqw,".")=2:$G(W($P(qqw,"."),$P(qqw,".",2))),1:$G(W($P(qqw,"."),$P(qqw,".",2),$P(qqw,".",3)))) ;@Dol 13.12.06 элемент коллекции м.б. двумерным
 I qqw1="Z" D  Q qqwvvv
 .;I $E(qqw,1,4)="ZTMP",'$G($$$Tree),$G(qqc)'="" S qqwvvv=$S(qqw'="ZTMPFRel":$G(^Q($S('$D(qFindDO):$$$Relind,1:'$$$Relind)_qview,qqo,qqc,qqw)),1:''$D(^Q($S('$D(qFindDO):$$$Relind,1:'$$$Relind)_qview,qqo,qqc))) Q  ;@Dol 3.02.06 ZTMPRel ;временное понятие (существует только в перечне релевантных)
 .I $E(qqw,1,4)="ZTMP",'$G($$$Tree),$G(qqc)'="" S qqwvvv=$S(qqw'="ZTMPFRel":$G(^Q($S('$D(qFindDO):$$$Relind,1:'$$$Relind)_qview,qqoo,qqc,qqw)),1:''$D(^Q($S('$D(qFindDO):$$$Relind,1:'$$$Relind)_qview,qqoo,qqc))) Q  ;@Dol 3.02.06 ZTMPRel ;временное понятие (существует только в перечне релевантных) ;@Dol 20.08.10 qqoo
 .I $E(qqw,1,4)="ZMAS" S qqwvvv=qARM.SetZMAS(qqo,,qqw) Q  ;@Dol 08.08.10S:'$D(Vt(qqnump,"mas",qqo,qqw)) Vt(qqnump,"mas",qqo,qqw)=qARM.GetPar("X753",,qqo,qqw) S @("qqwvvv=$G("_Vt(qqnump,"mas",qqo,qqw)_")") Q  ;@Dol 22.07.05;@Dol 10.07.06 S @("
 .I qqw'?1"Zs"1.N1"c"1.N S qqwvvv=$G(W(qqw)) Q  ;для Z-понятий значения уже в W(qqw) ;ZsNcN - значение выражения или содержимое ячейки
 .S qqwvvv=$G(Vo(qqnump,qqoo,0,+$P($E(qqw,3,5),"c"),+$P(qqw,"c",2))) Q:qqwvvv=""  I 5'=$E(qqwvvv) S qqwvvv=$E(qqwvvv,2,30000) Q  ;не выражение - код понятия ячейки или константа
 .S @("qqwvvv="_$E(qqwvvv,2,30000)) Q  ; значение выражения
 Q:$G(qqc)="" ""
 I qqw1="C" Q:qqw="C" qqc Q:qqw="CC" $S('$G($$$Tree):$S($E(qqo)'="D":$G(^Q(1,qqo,qqc)),1:qqc),qqot'=2:$G(@qqref@(qqoo,qqc)),1:$G(^Q(1,qqo,qqc))) S qqw=$E(qqw,2,20) G Gbeg ;код экземпляра или значение для кода
 I qqw1="T" D  Q:$Q "" Q
 .K W(qqw)
 .I $G($$$Tree),qqot'=2 M W(qqw)=@$S($D(qqref):qqref,1:$$$GloRef)@(qqoo,qqc,qqw) Q
 .I $E(qqw,1,2)'="TB" M W(qqw)=^Q(qqlang,qqo,qqc,qqw) Q:$D(W(qqw))  Q:qqlang=1  M W(qqw)=^Q(1,qqo,qqc,qqw) Q
 .M W(qqw)=^QT($E(qqw,2,255),qqlang,qqo,qqc) Q:$D(W(qqw))  Q:qqlang=1  M W(qqw)=^QT($E(qqw,2,255),1,qqo,qqc) Q
 I qqw1="Y" K W(qqw) D   Q:$Q "" Q  ;произвольная структура (поддерево)
 .I qqw="Y" M W(qqw)=^Q(1,qqo,qqc) Q  ;структура записи фрейма
 .M W(qqw)=^Q(1,qqo,qqc,qqw)
 I qqw1="H" N qqw2 D  Q $S($TR(qqwvvv," ")'="":qqwvvv,1:"") ;;Характеристика (ссылка)
 .I $E(qqw,2)="T" K W(qqw) S qqwvvv=$G(^Q(1,qqo,qqc,$E(qqw,3,255))) Q:qqwvvv=""  M W(qqw)=^Q(1,"C"_$E(qqw,3,255),qqwvvv,"Thlp") S qqwvvv="" Q  ;@Dol 6.12.06 Thlp словаря
 .S qqw2=$S($E(qqw,2)?1N:$E(qqw,2),1:"") I qqw2="" S:'$D(Vt(qqnump,qqw)) Vt(qqnump,qqw)=$G(^Q(1,"CxWoc",$E(qqw,2,30),"XRef")) I Vt(qqnump,qqw)'="" S qqw=$E(qqw,2,30) N Z S (qqwvvv,Z)=..G(qqw) Q:Z=""  S @("qqwvvv="_Vt(qqnump,"H"_qqw)) Q  ;выражение
 .S qqw=$E(qqw,2+(qqw2'=""),255) D  ;@Dol 12.01.08 чтобы работало для виртуальных
 ..I qqot>2,qqot'=8 S qqwvvv=..G(qqw) S:qqwvvv'="" qqwvvv=$G(^Q(1,qqw,qqwvvv)) Q  ;@Dol 24.05.08 qqwvvv'=""
 ..S qqwvvv=..G("C"_qqw)
 .Q:qqwvvv=""  S:$E(qqw)="R" qqw=$E(qqw,3,255) N j F j=1:1:$L(qqwvvv," ") S:$P(qqwvvv," ",j)'="" $P(qqwvvv," ",j)=$G(^Q(1,"C"_qqw,$P(qqwvvv," ",j),"XRef"_qqw2)) ;@Dol 4.08.08 S:$E(qqw)="R"
Gbeg I qqo=-1,'$G($$$Tree) Q $G(W(qqw)) ;@dol 23.02.05
 S qqwvvv=$S(qqc="":"",'$G($$$Tree):$G(^Q(1,qqo,qqc,qqw)),qqo=-1:$G(@$S($D(qqref):qqref,1:$$$GloRef)@(qqw)),qqot'=2:$G(@$S($D(qqref):qqref,1:$$$GloRef)@(qqoo,qqc,qqw)),1:$G(^Q(1,qqo,qqc,qqw))) ;всегда главный слой; дерево в аналитике;$E(qqo)'?1N ???
 Q:qqwvvv="" "" Q:"CXDLMO"[qqw1 $S(qqwvvv'="NULL":qqwvvv,$G(W("Zadm"))||$G(qFindDO)||$G(qAnalDO)||$G(qrCopy)||$G(qStreem)||($E($G(Vo(qqnump)),1,3)="XXX"):qqwvvv,1:"") ;@Dol 26.02.05 NULL
 S:'$D(Vx713(qqw)) Vx713(qqw)=+$G(^Q(1,"CxWoc",qqw,"x713")) Q:$G(Vx713(qqw)) qqwvvv ;@Dol 14.11.06 модификация словаря
 I qqw1="R" S qqw=$E(qqw,3,20) Q:"XDLMO"[$E(qqw) qqwvvv ;@dol 9.08.04 O и R*-некодируемые
 ;;;;;S:qqw1="R" qqw=$E(qqw,3,20),qqwl=$E(qqw) ;;;; I $E(qqw)="O" S:$E(qqw,1,2)="OZ"||($E(qqw,1,3)="OOZ") qqw1=$E($P(qqw,"Z",2)),qqw1=$S(qqw1?1N:qqw1,1:$A(qqw1)-64),qqwvvv=$E(qqc,1,qqw1)_qqwvvv Q qqwvvv ;@dol 13.08.04 O*,OO*,OZ*,OOZ*
 I qqlang'=1,'$D(^Q(qqlang,qqw)) N qqlang S qqlang=1 ;основной язык - русский
 ;;;Q:qqwvvv'[" " $G(^Q(qqlang,"C"_qqw,qqwvvv)) N j 
 S qqw1=$G(^Q(qqlang,"C"_qqw,$P(qqwvvv," "))) I qqwvvv[" " F qqot=2:1:$L(qqwvvv," ") S qqw1=qqw1_" "_$G(^($P(qqwvvv," ",qqot)))
 I " "_$G(qqwListPriv)_" "[(" "_qqw_" ") F qqot=1:1:$L(qqw1) I qqot'=1,$E(qqw1,qqot)'?1P,$E(qqw1,qqot-1)'?1P||($E(qqw1,qqot-1)="*") S $E(qqw1,qqot)="*" ;@Dol 08.07.09
 Q $S(qqw1'="NULL":qqw1,$G(W("Zadm"))||$G(qFindDO)||$G(qAnalDO)||$G(qrCopy)||$G(qStreem)||($E($G(Vo(qqnump)),1,3)="XXX"):qqw1,1:"") ;@Dol 26.02.05 NULL
]]></Implementation>
</Method>

<Method name="GC">
<Description>
Получить коды значения или значения по списку кодов. Только для кодируемых понятий !!!
qqw - код понятия
qqz - список кодов через пробел (если qqw начинается на C) или значений</Description>
<Internal/>
<FormalSpec>qqw:%Library.String,qqz:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 Q:$TR(qqz," ")="" "" N iii F iii=1:1:$L(qqz," ") S:$P(qqz," ",iii)'="" $P(qqz," ",iii)=$G(^Q(qqlang,qqw,$P(qqz," ",iii)))
 Q qqz
]]></Implementation>
</Method>

<Method name="GE">
<Description>
Взять значение понятия редактируемого экземпляра объекта.
Если значение понятия было отредактировано, то его значение берется из W(qqw), в противном случае - из базы.</Description>
<Internal/>
<FormalSpec>qqw:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ Q $S(" "_$G(qqwchg)_" "_$G(qqred)_" "[(" "_qqw_" "):$G(W(qqw)),1:..G(qqw)) ;@dol 24.12.02 про qqred было забыто
]]></Implementation>
</Method>

<Method name="GG">
<Description>
Взять значение понятия Arg2 для объекта Arg1 с кодом экземпляра Arg3.
Если не задан qqc, то используются текущий контекст (значения qqo,qqc) для определения qqc в рамках текущего поддерева. Если объект выше, то однозначно, ниже - код первого (!!!) экземпляра. 
fcont - позволяет игнорировать текущий контекст отображения.
=0 логическое дерево
=qqref - текущая ссылка на объект в физическом дереве. </Description>
<Internal/>
<ClassMethod>1</ClassMethod>
<FormalSpec>qqoo:%String,qqw:%String,qqcc:%String,fcont:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $D(qqcc),qqcc="",qqoo'=-1 Q "" ;@dol 6.8.03
 I $G(qqoo)'="" N qqo S qqo=qqoo ;???
 I $G(qqcc)'="" N qqc S qqc=qqcc I 1
 E  S:$G(qqcc)="" qqcc=qqc N qqc S qqc=qqcc I '$G($$$Tree),qqo'=-1 D:'$D($$$ObjLqqc(qqo)) qARM.GetPar("X50",,qqo) I $G($$$ObjLqqc(qqo),255)'=255 S qqc=$S($$$ObjLqqc(qqo)>$L(qqc):$$$UserOrd(1,qqo,qqc,qqc),1:$E(qqc,1,$$$ObjLqqc(qqo))) ;???'$G(Vo(qqnump,qqo,2))
 I qqo'=-1,qqc="" Q "" ;раньше проверки не было. Выдавался <SUBSCR> ;@dol 6.03.03 qqo=-1 !!!!! 
 Q:$G(fcont)="" ..G(qqw)
 I fcont=0 S fcont=+$G($$$Tree),$$$Tree=0,qqw=..G(qqw),$$$Tree=fcont Q qqw ;принудительно логическое дерево
 N qqref S qqref=fcont,fcont=+$G($$$Tree),$$$Tree=1,qqw=..G(qqw),$$$Tree=fcont Q qqw ;принудительно физическое дерево
]]></Implementation>
</Method>

<Method name="GGdef">
<Description>
Взять значение понятия qqw для объекта qqoo с кодом экземпляра qqcc. Если пусто, взять def - не указано - вычислить значение по умолчанию (X75) понятия qqw
Если def начинается с @, то вычисляется как выражение (если необходимо вернуть) ;29.10.09
Если не задан qqc, то используются текущий контекст (значения qqo,qqc) для определения qqc в рамках текущего поддерева. Если объект выше, то однозначно, ниже - код первого (!!!) экземпляра. 
red=1 - учет режима Редактирование ( значение может содержаться в W(qqw) если qqwchg[qqw - дбыча значния через qW.GE) ;16.06.10</Description>
<Internal/>
<ClassMethod>1</ClassMethod>
<FormalSpec>qqoo:%String,qqw:%String,qqcc:%String,def:%String,red</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N zt I $D(qqcc),qqcc="",qqoo'=-1 Q "" ;@dol 6.8.03
 I $G(qqoo)'="" N qqo S qqo=qqoo ;???
 I $G(qqcc)'="" N qqc S qqc=qqcc I 1
 E  S:$G(qqcc)="" qqcc=qqc N qqc S qqc=qqcc I '$G($$$Tree),qqo'=-1 D:'$D($$$ObjLqqc(qqo)) qARM.GetPar("X50",,qqo) I $G($$$ObjLqqc(qqo),255)'=255 S qqc=$S($$$ObjLqqc(qqo)>$L(qqc):$$$UserOrd(1,qqo,qqc,qqc),1:$E(qqc,1,$$$ObjLqqc(qqo))) ;???'$G(Vo(qqnump,qqo,2))
 I qqo'=-1,qqc="" Q "" ;раньше проверки не было. Выдавался <SUBSCR> ;@dol 6.03.03 qqo=-1 !!!!! 
 S zt=$S('$G(red):qW.G(qqw),1:qW.GE(qqw)) Q:zt'="" zt I $D(def) S:$E(def)="@" @("def="_$E(def,2,3000)) Q def
 S def=$S(qqw'[":":qARM.GetPar("X75",,qqo,qqw),1:qARM.GetPar("X75",,$P(qqw,":"),$P($P(qqw,":",2),"{"))) S:$E(def)="@" @("def="_$E(def,2,3000)) Q def
]]></Implementation>
</Method>

<Method name="GH">
<Description>
Взять значение характеристики.
qqw - код понятия характеристики ("H"_[0-9]_кодпонятия)
Z - значение понятия. Не задано - текущий экземпляр (аналог qW.G("H"...) )
Значение может состоять из нескольких слов; тогда возвращается несколько характеристик.
cv =1 - в качестве Z используется код слова ;@Dol 07.11.09</Description>
<Internal/>
<FormalSpec>qqw:%Library.String,Z:%Library.String,cv</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Z)="" Q ..G(qqw)
 N qqw2,qqwvvv,j
 I $E(qqw,2)="T" Q $S($G(Z)="":"",1:..GT("C"_$E(qqw,3,255),"Thlp",$S('$G(cv):$G(^Q(1,$E(qqw,3,255),Z)),1:Z))) ;@Dol 6.12.06 Thlp словаря
 S qqw2=$S($E(qqw,2)?1N:$E(qqw,2),1:"") I qqw2="" S:'$D(Vt(qqnump,qqw)) Vt(qqnump,qqw)=$G(^Q(1,"CxWoc",$E(qqw,2,30),"XRef")) I Vt(qqnump,qqw)'="" S qqw=$E(qqw,2,30),@("qqwvvv="_Vt(qqnump,"H"_qqw)) Q qqwvvv ;выражение
 S qqw=$E(qqw,2+(qqw2'=""),255) F j=1:1:$L(Z," ") S qqwvvv=$P(Z," ",j) I qqwvvv'="" S $P(Z," ",j)=$G(^Q(1,"C"_qqw,$S('$G(cv):$G(^Q(1,qqw,qqwvvv),"???"),1:qqwvvv),"XRef"_qqw2))
 Q Z
]]></Implementation>
</Method>

<Method name="GMFileExp">
<Internal/>
<FormalSpec>ListTop:%Library.String,view:%Library.String,Rel:%Library.String,Flview:%Library.String,desobj:%Library.String,ListMas:%Library.String,ExcepObjs:%Library.String,cond:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ;S $et="S ^SSS1=$ZE"
 s %I=$g(%gNd),%gVl=""
 I $G(%I712)'="" S %I=%I712 ;K %I712
 I $TR($G(%LstWoc)," ","")'="",$G(%Iold)'="" S qqo0=$QS(%Iold,2),qqc0=$QS(%Iold,3) G InLstWoc
 I $TR($G(%LstWoc)," ","")="",$G(%Iold)'="" D  K %Iold G Start ; $O(@%I@(""))
 .S %I="^Q(1)" F i=2:1:3 S %I=$NA(@%I@($QS(%Iold,i)))
 .S qqw1=$O(@%I@(""),-1),%I=$NA(@%I@(qqw1))
 ;s %I=$g(%gNd),%gVl=""
 I $G(ListMas)'="" I '$D(%lmas) S %lmasnum=1 F i=1:1  q:$P(ListMas," ",i)=""  S %lmas(i)=$P(ListMas," ",i)
 ;
 I $D(%lmas) S GS=%lmas(%lmasnum) I GS'="^Q" F  D SavMas Q:%I'=""  I %I="" K %lmas(%lmasnum) S %lmasnum=%lmasnum+1 Q:'$D(%lmas)  S GS=%lmas(%lmasnum) Q:GS="^Q"
 I $G(ListMas)'="" I GS'="^Q" Q ""
 ; !!!!!!!!  S qqoP=$P($G(^Q(1,"CxObj",%O,"XORef")),",",$L($G(^Q(1,"CxObj",%O,"XORef")),",")-1)
 S GS="^Q(1)"  ; сохранение базы qWORDа
 ;;;;; вершины отображения (в qqc - код отображения) 
 ;;;;I $G(Flview) I %I="" N view S view=qqc S y=$O(^Q(1,"XView",view,"CxObj",-1,"Xy","")) I y="" S qqo=$G(^(y,"X60")) D:qqo'=""
 ;;;;.S qqrn=$S(view=$G(Vo(qqnump)):$S($G(qview)="":1,'$G($$$RelNum):1,1:$$$Relind_qview),$G(Rel):$$$Relind_view_" "_$P(qview," ",2),1:1)
 ;;;;.S qqcR=$O(^Q(qqrn,qqo,"")),qqc=qqcR 
 ; список заданных вершин
 ;S ListTop=qqo 
 ;;I %I="" S qqo=$P($P(ListTop," "),":"),qqc=$P($P(ListTop," "),":",2),%lstop=$P(ListTop," ",2,$L(ListTop," ")) S:qqc["*" %qqcbeg=$P(qqc,"*"),qqc=$$$UserOrd(1,qqo,"",%qqcbeg)
 ; значимые коды понятий
 I $G(%I)'="",$G(%I712)="","CDHTYMX"'[$E($QS(%I,4)) S:'$D(Vqqw712($QS(%I,4))) Vqqw712($QS(%I,4))=$G(^Q(1,"CxWoc",$S($E($QS(%I,4))'="R":$QS(%I,4),1:$E($QS(%I,4),3,255)),"X712")) I Vqqw712($QS(%I,4)) S %I712=%I,%Z=@%I,%I=$NA(@GS@($QS(%I,2),$QS(%I,3),"C"_$QS(%I,4))) S %gNd=%I,%gVl=$g(%Z) Q "" ;@ref@(qqo,qqc,"C"_qqw)=^Q(1,qqo,qqc,qqw)
 K %I712
 ; по отображению
 ;I %I="" I ListTop="" I view'="" S ListTop=^Q(1,"XView",view,"CxObj",-1,"xObj") F i=1:1:$L(ListTop," ") S qqc=$O(^Q(1,$P(ListTop," ",i),"")),ListTop=$P(ListTop," ",1,i)_":"_qqc_" "_$P(ListTop,i+1,$L(ListTop," "))
 I %I="" I ListTop="" I view'="" S ListTop=^Q(1,"XView",view,"CxObj",-1,"xObj") F i=1:1:$L(ListTop," ") S qqc=$O(^Q(1,$P(ListTop," ",i),"")) S:$G(qqc)="" $P(ListTop," ",i)="" S:$G(qqc)'="" ListTop=$P(ListTop," ",1,i)_":"_qqc_" "_$P(ListTop," ",i+1,$L(ListTop," "))
 I %I="" I $G(view)'="" s ListTop=qW.qConv(ListTop)
 I %I="" D  I $D(^Q(1,qqo,qqc))>0 S:$G(%qqcbeg)'="" %qqcbeg("qqo")=qqo,%qqcbeg("qqc")=qqc  
 .F  S qqo=$P($P(ListTop," "),":"),qqc=$P($P(ListTop," "),":",2),%lstop=$P(ListTop," ",2,$L(ListTop," ")) S:qqc["*" %qqcbeg=$P(qqc,"*"),qqc=$$$UserOrd(1,qqo,"",%qqcbeg) Q:%lstop=""  I qqc'="",$D(^Q(1,qqo,qqc))>0 Q
 ; перечень релевантных заданного объекта qqo
 I $G(Rel) I %I="" S qqrn=$S('$G($$$RelNum):1,1:$$$Relind_qview)   ; !!!!! refRel
 I $G(Rel)=1 I %I="" S qqoR=qqo,qqcR=$O(^Q(qqrn,qqoR,"")),qqc=qqcR
 I $G(Rel)=2 I %I="" S qqoR=qqo,qqcR=$O(^Q(qqrn,qqoR,"")),%I=$NA(@GS@(qqoR,qqcR)) ;D SavRel2
 I $G(Rel)=2 D  G End
SavRel2 .F  s %I=$Q(@%I) Q:%I=""  Q:$QS(%I,3)'=""
 .Q:$QS(%I,2)=qqoR&($QS(%I,3)=qqcR)
 .;I %I'="" I $QS(%I,2)=qqoR&($QS(%I,3)=qqcR) G End
 .S qqcR=$O(^Q(qqrn,qqoR,qqcR)) I qqcR'="" S %I=$NA(@GS@(qqoR,qqcR)) G SavRel2
 .S %I=""
 ;
Start I $g(%I)="" K Tree S Tree(qqo)="" S %TR="Tree",%TR=$NA(@%TR@(qqo)),@%TR=qqc S %I=$NA(@GS@(qqo,qqc))

 N qqo0,qqc0,ind0
 S qqo0=$QS(%I,2),qqc0=$QS(%I,3),ind0=$QL(%I) ;^Q(1)
 F  s %I=$Q(@%I) Q:%I=""  Q:$QS(%I,3)'="" 
 ;S a=$I(a) S ^AA(a)=%I_$G(%LstWoc)
 I $G(Rel),%I="" S qqcR=$O(^Q(qqrn,qqoR,qqcR)),qqc=qqcR G:qqcR'="" Start
 Q:%I="" ""
 I " XView CxWoc CxObj "[(" "_$QS(%I,2)_" "),$QS(%I,3)=qqc0 G End
 I " XView CxWoc CxObj "[(" "_$QS(%I,2)_" ") D  G:$G(qqcR)'="" Start G End 
 .I $G(Rel),$QS(%I,3)'=qqc0 S qqcR=$O(^Q(qqrn,qqoR,qqcR)),qqc=qqcR S:0 ^AB(aa)=$G(qqrn)_" "_$G(qqcR) S:qqcR="" %I="" q
 .S:$QS(%I,3)'=qqc0 %I=""
 N qqo1,qqc1,lst,i,end,qqw1
 I $QS(%I,2)=qqo0&($QS(%I,3)=qqc0) D:$G(cond)'="" ChObj(qqo0,,1) G End
InLstWoc 
 I $TR($G(%LstWoc)," ","")'="" D  S %Z=$S($D(VV):$G(VV(qqw1)),1:qW.GG(qqo0,qqw1,qqc0)),$E(%LstWoc,1,$F(%LstWoc_" "," ")-1)="",%I=$NA(@GS@(qqo0,qqc0,qqw1)) S %gNd=%I,%gVl=$g(%Z) K:$D(VV) VV(qqw1) Q ""
 .;S %Iold=%I
 .F i=1:1:$L(%LstWoc," ")  Q:$P(%LstWoc," ",i)'=""
 .S qqw1=$P(%LstWoc," ",i)

ContWrk S end=0 I $QS(%I,2)'=qqo0!($QS(%I,3)'=qqc0) F  D CurrPnt(qqo0) Q:end  Q:%I=""
 G End 
 ;  
End
 I %I="" I $G(%qqcbeg)'="" S qqc=$$$UserOrd(1,%qqcbeg("qqo"),%qqcbeg("qqc"),%qqcbeg) I qqc'="" S qqo=%qqcbeg("qqo"),%qqcbeg("qqc")=qqc G Start
 I %I="" I %lstop'="" D  I qqo'="",(qqc'=""),$D(^Q(1,qqo,qqc))>0 S %qqcbeg("qqo")=qqo,%qqcbeg("qqc")=qqc G Start  
 .K %qqcbeg F  S qqo=$P($P(%lstop," "),":"),qqc=$P($P(%lstop," "),":",2),%lstop=$P(%lstop," ",2,$L(%lstop," ")) S:qqc["*" %qqcbeg=$P(qqc,"*"),qqc=$$$UserOrd(1,qqo,"",%qqcbeg) S:0 ^asr(ss,$S(%lstop="":"end",1:%lstop))=$G(qqo)_"/"_$G(qqc)_"/"_$G(%qqccbeg) Q:%lstop=""  I qqc'="",$D(^Q(1,qqo,qqc))>0 Q
 .;возможно заданы несуществующие вершины в %lstop
 I $G(Flview) I %I="" S qqcR=$O(^Q(qqrn,qqo,qqcR)) G:qqcR'="" Start S y=$O(^Q(1,"XView",view,"CxObj",-1,"Xy",y)) I y="" S qqo=$G(^(y,"X60")) D:qqo'=""
 .S qqcR=$O(^Q(qqrn,qqo,"")),qqc=qqcR G:qqc'="" Start  
 I $G(Rel)=1,%I="",qqcR'="" S qqcR=$O(^Q(qqrn,qqoR,qqcR)),qqc=qqcR,qqo=qqoR G:qqc'="" Start
 I %I=""  I $D(%lmas) K %lmas(%lmasnum) S %lmasnum=%lmasnum+1 I '$D(%lmas) S %gNd=%I,%gVl=$g(%Z) Q ""
 ;I $G(Rel) I %I'=""
 I %I'="" I " XView CxWoc CxObj "[(" "_$QS(%I,2)_" ") S %Z=@%I S %gNd=%I,%gVl=$g(%Z) Q ""
 ; для этих обЪектов - что с понятиями ?
 I %I'="" I $G(desobj) I $G(%LstWoc)="" S %LstWoc=^Q(1,"CxObj",$QS(%I,2),"xWoc")_" ",%LstWoc=qW.zReplace(" "_%LstWoc," C ",""),$E(%LstWoc)=""  
 I %I'="" I $G(Flview) I $G(%LstWoc)="" S %LstWoc=^Q(1,"XView",view,"CxObj",$QS(%I,2),"xWoc")_" ",%LstWoc=qW.zReplace(" "_%LstWoc," C ",""),$E(%LstWoc)=""
 I %I'="" I $G(%LstWoc)'="" S $E(%LstWoc,1,$F(%LstWoc," ")-1)="" S:$G(%Iold)="" %Iold=%I ; 
 I %I'="" D:"TXMY"'[$e($QS(%I,4))  S:"TXMY"[$e($QS(%I,4)) %Z=@%I
 .I $E($QS(%I,2),1,2)="ww" I $G(%LstWoc)'[("H"_$QS(%I,4)) S %LstWoc=$G(%LstWoc)_" H"_$QS(%I,4),%Iold=%I S:$E(%LstWoc)=" " $E(%LstWoc)=""
 .I $D(VV) S %Z=$G(VV($QS(%I,4))) Q
 .N qqz S %Z="",qqz=@%I Q:qqz=""
 .I $e($QS(%I,4))="D" S %Z=@%I q  
 .F i=1:1:$L(qqz," ") S %Z=%Z_$G(^Q(1,"C"_$QS(%I,4),$P(qqz," ",i)))_$S(i=$L(qqz," "):"",1:" ")
 ;;S ^AA(a,1)=%I
 S %gNd=%I,%gVl=$g(%Z)
 Q ""
CurrPnt(qqo1)
 N lst,qqc10,tr,qqc1,Iprf  ; Iprf временно хранить предыдущее, если пропускается экземпляр
 S b=$I(b)
 I $QS(%I,2)=qqo0 I $QS(%I,3)'=qqc0 S lst=$S($G(view)'="":^Q(1,"XView",view,"CxObj",qqo0,"xObj"),1:$G(^Q(1,"CxObj",qqo0,"xObj"))) I lst="" D:$QL(%TR)>1  Q:end
 .S TR="Tree" F i=1:1:$QL(%TR)-1 S TR=$NA(@TR@($QS(%TR,i)))
 .S qqc10=@TR I $G(qqc10)="" S ^ERRsw(qqo0)=TR Q 
 .I $E($QS(%I,3),1,$L(qqc10))=qqc10 D  I $QS(%I,2)=qqo0 I $E($QS(%I,3),1,$L(qqc10))=qqc10 I $QS(%I,3)'="" S end=1 Q
 ..F  D ChObj(qqo0,,1) Q:$QS(%I,3)'=""  s %I=$Q(@Iprf) Q:%I=""  Q:$QS(%I,3)=""  Q:$QS(%I,2)'=qqo0  Q:$E($QS(%I,3),1,$L(qqc10))'=qqc10
 ; по экземплярам объекта с проверкой условия
 S qqo1=$O(@%TR@("")) I qqo1'="" S %TR=$NA(@%TR@(qqo1)) D ChObj(qqo1) I $QS(%I,3)'="" S end=1 Q 
 I qqo1="" S lst=$S($G(view)'="":^Q(1,"XView",view,"CxObj",qqo0,"xObj"),1:$G(^Q(1,"CxObj",qqo0,"xObj"))) I lst'="" D  I $QS(%I,3)'="" S end=1 Q
 .S lst=$S($G(view)'="":^Q(1,"XView",view,"CxObj",qqo0,"xObj"),1:$G(^Q(1,"CxObj",qqo0,"xObj"))) F i=1:1:$L(lst," ") S:$P(lst," ",i)'="" @%TR@($P(lst," ",i))="" 
 .S qqo1=$O(@%TR@("")),%TR=$NA(@%TR@(qqo1)) D ChObj(qqo1) ;I $QS(%I,3)'="" S end=1 Q
 //sasha 20080607 ^Q(1,"XView",view,"CxObj",qqo0,"xObj")
 S lst=$S($G(view)'="":$G(^Q(1,"XView",view,"CxObj",qqo0,"xObj")),1:$G(^Q(1,"CxObj",qqo0,"xObj"))) I lst=""!($QS(%I,3)="") S qqo1=$O(@%TR) D  I $S(%I="":1,1:$QS(%I,3)'="") S end=1 Q
 .I qqo1'="" D ChObj(qqo1,1) Q
 .I qqo1="" S TR="Tree" F  D  Q:qqo1'=""  Q:%I=""
 ..I $QL(%TR)>1 S TR="Tree" F i=1:1:$QL(%TR)-1 S TR=$NA(@TR@($QS(%TR,i)))
 ..I $QL(TR)'>1 S %I="" Q  ; ?????   ..I $QL(TR)<1 S %I="" Q
 ..S qqo1=$QS(TR,$QL(TR)) S %TR=TR D ChObj(qqo1) I $QS(%I,3)'="" S end=1 Q
 ..S:0 %TR=TR S qqo1=$O(@%TR) D:qqo1'="" ChObj(qqo1,1)
 ;.I qqo1'="" D ChObj(qqo1) I $QS(%I,3)'="" S end=1 Q
 Q
 ;
ChObj(qqoN,f0,f1)   ;
 ; f0=1 
 I $G(f1) S qqc1=$QS(%I,3) S %I=$NA(@GS@(qqoN)) G FstObj
 N qqc1,qqw1,TR,qqc10 ;W !,"///"_qqoN_"///"_$G(f0)_"}}}"
 ; L - 
 S %I=$NA(@GS@(qqoN)),qqo0=qqoN,qqc10=""
 D:$G(f0)=1  ; 
 .S TR="Tree" F i=1:1:$QL(%TR)-1 S TR=$NA(@TR@($QS(%TR,i)))
 .S %TR=$NA(@TR@(qqoN))
 ; список исключенных объектов
 Q:(" "_$G(ExcepObjs)_" ")[(" "_qqo0_" ")
 S qqc1=@%TR I $QL(%TR)>1 F n=1:1 D  Q:$QL(TR)=1  Q:$G(qqc10)'=""
 .S TR="Tree" F i=1:1:$QL(%TR)-n S TR=$NA(@TR@($QS(%TR,i)))
 .S qqc10=@TR
 I qqc10="" S ^ERRsw(qqoN)=qqo_" "_$G(qqc1) ;Q
 S qqc1=$S($G(qqc1)="":qqc10,$E(qqc1,1,$L(qqc10))'=qqc10:qqc10,1:qqc1)
 S qqc1=$$$UserOrd(1,$QS(%I,2),$S(qqc1=qqc10:"",1:qqc1),qqc10) S Iprf=$NA(@%I@(qqc1)) Q:qqc1=""
FstObj  ; 
 N rcond I $G(cond)'="" K VV S @("rcond="_cond) D  Q:$G(rcond)'=1
 .I $G(rcond)'=1 S Iprf=$NA(@%I@(qqc1)) S qqw1=$O(@Iprf@(""),-1) S:$G(qqw1)'="" Iprf=$NA(@Iprf@(qqw1)) Q
 .I $D(VV) S (i,%LstWoc)="" F  S i=$O(VV(i)) Q:i=""  S %LstWoc=$S(%LstWoc="":i,1:%LstWoc_" "_i)
 .I $D(VV) S %LstWoc=%LstWoc_" "
 ;Проверка на общее начало
 I $G(%qqcbeg)'=""  I $E(qqc1,1,$L($G(%qqcbeg)))'=$G(%qqcbeg) S Iprf=$NA(@%I@(qqc1)) Q
 S %I=$NA(@%I@(qqc1)) S:0 qqo0=qqoN S qqc0=qqc1 
 ;S qqw1=$O(@%I@("")) S:$G(qqw1)'="" %I=$NA(@%I@(qqw1)) D:"TY"[$e(qqw1)
 ;;;
 I $G(desobj) I $G(%LstWoc)="" S %LstWoc=^Q(1,"CxObj",$QS(%I,2),"xWoc")_" ",%LstWoc=qW.zReplace(" "_%LstWoc," C ",""),$E(%LstWoc)=""
 I $G(Flview) I $G(%LstWoc)="" S %LstWoc=^Q(1,"XView",view,"CxObj",$QS(%I,2),"xWoc")_" ",%LstWoc=qW.zReplace(" "_%LstWoc," C ",""),$E(%LstWoc)=""
 I $TR($G(%LstWoc)," ","")'="" D  S:"TY"'[$e(qqw1) %I=$NA(@%I@(qqw1)) S:"TY"[$e(qqw1) %I=$Q(@%I) S @%TR=qqc1 Q
 .S qqw1=$O(@%I@("")) S %Iold=$NA(@%I@(qqw1))
 .F i=1:1:$L(%LstWoc," ")  Q:$P(%LstWoc," ",i)'=""
 .S qqw1=$P(%LstWoc," ",i)
 ;;; 
 S qqw1=$O(@%I@("")) I $G(qqw1)'="" S:"TY"'[$e(qqw1) %I=$NA(@%I@(qqw1)) S:"TY"[$e(qqw1) %I=$Q(@%I)
 S @%TR=qqc1
 Q
 ;
SavMas I %I="" S %I=$NA(@GS) I $G(@%I)'="" S %Z=@%I S %gNd=%I,%gVl=%Z Q
 S %I=$Q(@%I)
 S:%I'="" %Z=@%I
 S %gNd=%I,%gVl=$g(%Z)
 Q
 ;
 ;I "CD"'[$E(qqw) S:'$D(Vqqw712(qqw)) Vqqw712(qqw)=$G(^Q(1,"CxWoc",qqw,"X712")) S:Vqqw712(qqw) @ref@(qqo,qqc,"C"_qqw)=^Q(1,qqo,qqc,qqw) ;@Dol 16.03.06 Флаг Значимые коды слов
]]></Implementation>
</Method>

<Method name="GMFileImp">
<Internal/>
<FormalSpec>Rel:%Library.String,qqo:%Library.String,qqc:%Library.String,Nbegqqc:%Library.String,cqqc0:%Library.String,qqcbeg:%Library.String,Xec:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ;Q:%gNd=""         
 ; !!!!!!!!!  для массива номера индексов   S %gNd=%I,%gVl=$g(%Z)
 ; %O - текущий объект 
 ; %С - текущий экземпляра
 S:'$D(cqqc) cqqc=+$G(cqqc0) ;@Dol 03.09.06 cqqc надо будет переустанавливать при поиске по X5220
 S %I=%gNd,%Z=$G(%gVl) ;;;S aa=$I(aa) ;s ^aaa(aa)=$G(%I)_" "_$G(%Z) ;s ^aa(aa)=$G(%Z)
 G:%I="" RecGMImp
 I %I[("^DoX") X %Z Q
 I $P(%I,"(")'="^Q" S @%I=%Z Q
 ;;sas 20090409
 I $D(%ClVirt) I $P(%I,"(")'["%ClVirt" D     ;CompCls
 .D setIncs^%GMan00x7(.%ClVirtInc)
 .D setClss^%GMan00x7(.%ClVirt)
 .D cmpClss^%GMan00x7(.%ClVirt)
 .K %ClVirt,ClVirtInc
 ;Q
 I $G(%O)="",$G(%C)="" K W S %O=$QS(%I,2),%C=$QS(%I,3),W=$G(%C)
 I $QS(%I,2)="XView" S @%I=%Z Q
 I " CxWoc CxObj "[(" "_$QS(%I,2)_" ") D  Q
 .S @%I=%Z
 .I $QS(%I,3)'="",$G(%Z)'="" S GS="^Q(1)" S GS=$S($QS(%I,2)="CxObj":$NA(@GS@("xObj",%Z)),1:$NA(@GS@("xWoc",%Z))) S @GS=$QS(%I,3)
 I $G(%O)=$QS(%I,2),$G(%C)=$QS(%I,3) S:$QS(%I,4)'="" @("W("_$E($NA(@%I),$L($NA(@%I,3))+1,30000)_"=$G(%Z)") Q
RecGMImp D:($G(%O)'=""&($G(%C)'="")) 
 .S (Lqqw,qqw)="" F  S qqw=$O(W(qqw)) Q:qqw=""  S Lqqw=Lqqw_$S(Lqqw="":"",1:" ")_qqw
 .;;;;???N qqc,qqoP,qqcP 
 .S XORef=$G(^Q(1,"CxObj",%O,"XORef")) S qqoP=$P(XORef,",",$L(XORef,",")-1) S:XORef="" qqoP=%O D
 ..S qqcP=$S(qqoP=%O:%C,1:$e(W,1,$$$ObjLget(qqoP)))
 ..;S qqc=%C 
 ..S X5220=$G(^Q(1,"CxObj",%O,"X5220"))
 ..I X5220'="" S qqc=..Key(%O,X5220,"") S:qqc="" X5220="" S:qqc'="" cqqc=1 ;; @Dol 3.09.06 если не найден по ключевым, действуем как будто их нет !!!;S:qqc="" qqc=$P(qW.rNew(%O,qqcP,0)," ")
 ..D:X5220=""
 ...I '$G(cqqc) I $G(qqcbeg)="" S qqc=$P(qW.rNew(%O,qqcP,0)," ") Q  ;@Dol 3.09.06 ????$G(qqcc)=0
 ...I '$G(cqqc) D  Q
 ....I $E(%O)'="C",$$$ObjLget(%O)'>$L(qqcbeg) S qqc=$P(qW.rNew(%O,qqcbeg,0)," ") Q  ;@Dol 02.09.06 S:'$D(^Q(1,%O,qqcbeg)) qqc=$P(qW.rNew(%O,qqcbeg,0)," ") Q
 ....S qqc=$P(qW.rNew(%O,qqcP,0)," ") 
 ....;I $E(%O)'="C",$L(qqcP)<$L(qqcbeg),$E(qqcbeg,1,$L(qqcP))=qqcP S qqcP=$E(qqcbeg,1,$$$ObjLqqc(%O))
 ...I $G(cqqc) S qqc=qqcP_$E(%C,$L(qqcP)+1,1000) S:'$D(^Q(1,%O,qqc)) qqc=$P(qW.rNew(%O,qqc,0)," ")
 ..I $G(W("Xch")),$D(^Q(1,%O,qqc)) D ..rDel(%O,qqc,,1) ; ?
 ..S:qqc="" qqc=%C   ; ??????
 ..X:$G(Xec)'="" Xec
 ..D:Lqqw'="" qW.rCor(%O,qqc,Lqqw) K W S W=qqc
 Q:%I=""
 S %O=$QS(%I,2),%C=$QS(%I,3) S:$QS(%I,4)'="" @("W("_$E($NA(@%I),$L($NA(@%I,3))+1,30000)_"=$G(%Z)") Q
]]></Implementation>
</Method>

<Method name="GT">
<Description>
Взять текстовое понятие в виде строки с разделителями $C(13,10).
nmax - максимальное кол-во строк. Если -1, то возвращается глобальная ссылка на текст.

leer - замещающие пустое значение символы (~ - исчезнет ячейка в режиме Вывод пустых)
noind - не преобразовывать ведущие пробелы в отступ</Description>
<Internal/>
<ClassMethod>1</ClassMethod>
<FormalSpec>qqoo:%String,qqw:%String,qqc:%String,nmax:%String,xml:%String=0,leer:%Library.String,noind:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 Q:$G(qqc)="" "" N ref,val,jval,nval I $G(qqoo)'="" S ref=$G(qqo)'=qqoo N qqo S qqo=qqoo
 I $E(qqo)="v" S val=qqo N qqo S qqo=$E(val,3,255) ;а виртуальные ?????
 I $G($$$Tree),qqo'?1.N,'$G(ref) S ref=$NA(@$S($D(qqref):qqref,1:$$$GloRef)@(qqo,qqc,qqw)) I 1
 E  D  ;логическое дерево или ссылка из физического дерева
 .S val=qARM.GetPar("x52",,qqo) I val=3||(val=8)||(val=6)||(val=7) D:val'=3 ..G(qqw) S ref=$NA(W(qqw)) Q  ;если объект - виртуальный, то текст в массиве W ;@dol 3.5.04 val=6
 .I $E(qqw,1,2)="TB" D  Q
 ..I qqlang'=1,'$D(^QT($E(qqw,2,255),qqlang,qqo,qqc)) N qqlang S qqlang=1
 ..S ref=$NA(^QT($E(qqw,2,255),qqlang,qqo,qqc))
 .I qqlang'=1,'$D(^Q(qqlang,qqo,qqc,qqw)) N qqlang S qqlang=1
 .S ref=$NA(^Q(qqlang,qqo,qqc,qqw))
 Q:$G(nmax)=-1 ref
 S val="",nval=$O(@ref@(""),-1) Q:nval="" $S($G(leer)'="":leer,1:"") I $G(nmax),nval>nmax S nval=nmax,nmax=-1
 I 'xml D  Q val_$S($G(nmax)'=-1:"",1:$C(13,10)_"................") 
 .F jval=0:1:nval D  Q:'nval
 ..S xml=$G(@ref@(jval)) I $L(val)+$L(xml)>25000 S xml=$E(xml,1,25000-$L(val)),nval=0,nmax=-1
 ..S val=$S('jval:"",1:val_$C(13,10))_xml
 N pos1 F jval=0:1:nval D  Q:'nval
 .S xml=$G(@ref@(jval)) I $L(val)+$L(xml)>30000 S xml=$E(xml,1,30000-$L(val)),nval=0,nmax=-1
 .; tdv 7.6.2006 - если $G(noind)'="", то ведущие пробелы выводятся как есть
 .S pos1=0 I '$G(noind) S pos1=$S($E(xml)=" ":$F(xml,$E($TR(xml," ")))-2,1:0)
 .S val=val_"<p"_$S(pos1:" indent='"_(.1*pos1)_"'>"_..CXML($E(xml,pos1+1,30000)),1:">"_..CXML(xml))_"</p>" ;атрибут indent указывает размер красной строки в сантиметрах
 ;F jval=0:1:nval S xml=..CXML($G(^(jval))),val=val_"<p"_$S($E(xml,1)=" ":" indent='0.5'>",1:">")_xml_"</p>" 
 Q val_$S($G(nmax)'=-1:"",1:"<p>................</p>")
]]></Implementation>
</Method>

<Method name="GTab">
<Description>
Взять параметр текущей закладки
qqnumpT - номер окна закладки (не задано - текущее)
ngr - номер группы (по умолчанию -0)
par - параметр закладки (см. описание закладок). Например, X43 - имя, Thlp - пояснения, X40 - код,0 - список qqnump вызванных (!!!) окон</Description>
<Internal/>
<FormalSpec>qqnumpT:%Library.String,ngr:%Library.String,par:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N parz S qqnumpT=$G(qqnumpT,qqnump),ngr=+$G(ngr),par=$G(par,"X43")
 S parz=+$G(Vs(qqnumpT,"Tabs",ngr,+$G(Vs(qqnumpT,"Tabs",ngr)))) ;номер текущей закладки по описанию
 I par=0 Q $G(Vs(qqnumpT,"Tabs",ngr,+$G(Vs(qqnumpT,"Tabs",ngr)),0)) ;03.12.09 список qqnump вызванных окон
 Q:par'="Thlp" $G(^Q(1,"XView",Vo(qqnumpT),"XTabs",ngr,"XTab",parz,par))
 N parzz S (parzz,par)="" F  S par=$O(^Q(1,"XView",Vo(qqnumpT),"XTabs",ngr,"XTab",parz,"Thlp",par)) Q:par=""  S parzz=parzz_$C(13,10)_^(par)
 Q $E(parzz,3,30000)
]]></Implementation>
</Method>

<Method name="GW">
<Description>
Создание массива W для списка понятий (Arg1) относительно экземпляра текущего объекта (используется qW.GG).
Arg1 список через пробел элементов вида: код_пон_для_W,код_об:код_пон
Если код_об пропущен, берется текущий
Если код_пон пропущен, берется код_пон_для_W
Если Arg1="*", то список всех понятий из описания объекта (!!! не текущего отображения).
Возвращает список помещенных в W понятий
Например,
S %1= qW.GW("p1 p2,p3 p4,7:p5")
эквивалентно
S W("p1")=qW.GG(qqo,"p1"),W("p2")=qW.GG(qqo,"p3"),W("p4")=qW.GG(7,"p5")
%1 будет содержать "p1 p2 p4"

Если задан ZZ, то значения берутся из него (разделитель ~).  Если ввод, добавляется в qqwchg. Для использования в методе qARM.wwww в правиле проверки.</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,ZZ:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqw,qqwo,qqoo,qqwi,qqwlist S qqwlist="" S:$G(Arg1)="*" Arg1=$G(^Q(1,"CxObj",qqo,"xWoc"))
 F qqwi=1:1:$L(Arg1," ") S qqw=$P(Arg1," ",qqwi) D:qqw'=""
 .S qqwo=$P(qqw,",",2),qqw=$P(qqw,",",1),qqoo=qqo,qqwlist=qqwlist_" "_qqw I qqwo[":" S qqoo=$P(qqwo,":"),qqwo=$P(qqwo,":",2)
 .S:qqwo="" qqwo=qqw
 .I '$D(ZZ) S W(qqw)=..GG(qqoo,qqwo) Q  ;K:$E(qqw)="C"&&(qqw'="C")&&(qqw'="CC") W($E(qqw,2,255)) Q
 .I $G(W("ZBtred"))," "_qqwchg_" "'[(" "_qqwo_" ") S qqwchg=qqwchg_" "_qqwo
 .S W(qqwo)=$P(ZZ,"~",qqwi) ;K:$E(qqw)="C"&&(qqw'="C")&&(qqw'="CC") W($E(qqw,2,255))
 S qqwlist=$E(qqwlist,2,3000)
 Q:$Q qqwlist Q
]]></Implementation>
</Method>

<Method name="GWlist">
<Description>
Занести в массив W значения списка понятий qqwl (через пробел) для экземпляра qqcl объекта qqol</Description>
<Internal/>
<FormalSpec>qqol:%Library.String,qqwl:%Library.String,qqcl:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqwi F qqwi=1:1:$L(qqwl," ") S W($P(qqwl," ",qqwi))=$S($D(qqcl):..GG(qqol,$P(qqwl," ",qqwi),qqcl),1:..GG(qqol,$P(qqwl," ",qqwi)))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="GZ">
<Description>
Найти значение понятия qqw в объекте qqoo через общие значения списка qqwl (через пробел) значений понятий текущего объекта.
Выполняется поиск первого (!!!) подходящего экземпляра объекта. Используется метод qW.Key.
zn=0 или отсутствует - значения понятий qqwl берутся из текущего экземпляра (из базы);
zn=1 - из массива W;
zn=2 - из параметра ZZ. Если несколько понятий, то их значения через ~.
refqqw =1 - найденное значение записывается в W(qqw), возвращается код понятия. Если ввод, добавляется в qqwchg. Для использования в методе qARM.wwww в правиле проверки.
!!!! Значения массива W для понятий списка qqwl "портятся" (заполняются значениями понятий для поиска).
qqc0 - общая часть кода</Description>
<Internal/>
<FormalSpec>qqoo:%Library.String,qqw:%Library.String,qqwl:%Library.String,zn:%Library.String,ZZ:%Library.String,retqqw:%Library.String,qqc0:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 N qqco D
 .I '$G(zn) S qqco=..FastKey(qqoo,qqwl,"",1,,$G(qqc0),qqo,qqc) Q
 .I zn=1 S qqco=..Key(qqoo,qqwl,"",,,1) Q
 .S qqco=..FastKey(qqoo,qqwl,"",1,ZZ,$G(qqc0))
 .;N i F i=1:1:$L(qqwl," ") S W($P(qqwl," ",i))=$P(ZZ,"~",i)
 .;S qqco=..Key(qqoo,qqwl,"",,,1) Q
 I '$D(Vo(qqnump,qqoo)) S Vo(qqnump,qqoo,2)=0 ;@dol 12.05.04 всегда хранимый
 I '$G(retqqw) Q:qqco="" "" Q ..GG(qqoo,qqw,qqco)
 S W(qqw)=$S(qqco="":"",1:..GG(qqoo,qqw,qqco))
 I $G(W("ZBtred"))," "_qqwchg_" "'[(" "_qqw_" ") S qqwchg=qqwchg_" "_qqw
 Q:$Q qqw Q
]]></Implementation>
</Method>

<Method name="Get">
<Description>
Добыча значения понятия qqw объекта qObj из других объектов . Если значение понятия в поддереве - выдается список значений (через $C(13,10) , - для  поиск/аналитика - через пробел). Аналогично методу qW.zList.
qObjt - код текущего объекта (не задан - qqo)
qqct - код экзепляра текущего объекта (не задан - qqc)
Учитывается темпоральность.
qObj можно задавать в формате qqo_":"_qqw. Параметр qqw в этом случае не нужен.

Val - выражение обработки значения (относительно Z- значение qqw) 
Cond - дополнительное условие для списка значений (относительно qqo и qqc) 
Можно задать qqo_":"_qqw{Cond}{=Val}

Метод выполняется аналогично qW.GG(qqo,qqw), но с учетом темпоральности и виртуальных объектов.</Description>
<Internal/>
<FormalSpec>qObj:%Library.String,qqw:%Library.String,qObjt:%Library.String,qqct:%Library.String,Val:%Library.String,Cond:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N Z S:qObj[":" qqw=$P(qObj,":",2) D:qObj["{"  ;@Dol 07.07.06 пока без синтаксической чистоты
 .S qqw=$P(qqw,"{") S Z=$P($P(qObj,"{",2),"}") S:$E(Z)="=" Val=$E(Z,2,10000) S:$E(Z)'="=" Cond=Z
 .I qObj["}{" S Z=$P($P(qObj,"}{",2),"}") S:$E(Z)="=" Val=$E(Z,2,10000) S:$E(Z)'="=" Cond=Z
 S qObj=$P(qObj,":",1)
 S:'$D(qObjt) qObjt=$G(qqo) S:'$D(qqct) qqct=$G(qqc) ;@Dol 16.05.06 $$$CurObj вместо qqo нельзя!!!
 I $G(Vo(qqnump,qObjt,2))=1,$E(qObjt)="v",$D(Vo(qqnump,$E(qObjt,3,255))) S qObjt=$E(qObjt,3,255) ;@Dol 25.09.08 текущий объект - встроенный
 I qObjt=qObj,qqct=$G(qqc) D  Q Z
 .I '$D(Val),'$D(Cond) S Z=$S($G(qqw)="":qqct,1:..GG(qObj,qqw,qqc)) Q
 .N qqo S Z="",qqo=qObj,Cond=$G(Cond,1) I @Cond S Z=$S($G(qqw)="":qqc,1:..G(qqw)) S:$D(Val) @("Z="_Val)
 ;??? почему не здесь - есть нюанс с qObjt="" I $G(Vo(qqnump,qObjt,2))=1,$E(qObjt)="v",$D(Vo(qqnump,$E(qObjt,3,255))) S qObjt=$E(qObjt,3,255) ;@Dol 25.09.08 текущий объект - встроенный
 S:'$D(qqTempList) qqTempList=$G(^Q(1,"XBase",0,"XBTempList"))
 I ","_$P(qqTempList,":",3)_","[(","_qObj_",") N qqoT,qqoTT,tmp D   Q tmp  ;объект вершины темпоральной коррекции
 .S qqoT=$P(qqTempList,":",1),qqoTT=$P(qqTempList,":",2)
 .D:'$D($$$ObjLqqc(qqoT)) qARM.GetPar("X50",,qqoT) D:'$D($$$ObjLqqc(qqoTT)) qARM.GetPar("X50",,qqoTT)
 .I $L(qqct)<$$$ObjLqqc(qqoT) S qqct=$$$UserOrd(1,qqoT,"",qqct) I qqct="" S tmp="" Q
 .S tmp=$G(^Q(1,qqoT,$E(qqct,1,$$$ObjLqqc(qqoT)),"YT",qObj)) Q:tmp=""  ;;;,"?") Q:tmp="" I tmp="?" S tmp=$$$UserOrd(-1,qObj,"",$E(qqct,1,$$$ObjLqqc(qqoTT))) Q:tmp=""!($G(qqw)="")  S tmp=..GG(qObj,qqw,tmp) Q  ;возьмем последний экземпляр, если нет YT,qObj)
 .S tmp=$E(qqct,1,$$$ObjLqqc(qqoTT))_tmp Q:$G(qqw)=""
 .N qqo,qqc S qqo=qObj,qqc=tmp
 .I '$D(Val),'$D(Cond) S tmp=$S($G(qqw)="":tmp,1:..G(qqw)) Q
 .S Cond=$G(Cond,1),tmp="" I @Cond S Z=$S($G(qqw)="":qqc,1:..G(qqw)) S:$D(Val) @("Z="_Val) S tmp=Z
 ;I $G(Vs(qqnump,"Virt",qObj))'="" S qqo=qObj,qqc=Vs(qqnump,"Virt",qObj) Q:$G(qqw)="" qqc S qqct=..G(qqw) Q qqct
 N ObjRef,ObjReft,qqzz
 S ObjRef=$$GetObjRef(qObj),ObjReft=$$GetObjRef(qObjt)
 I ","_ObjRef_","[(","_qObjt_",") Q $$GetList(ObjRef,qObjt,qqct) ;лежит ниже
 I ","_ObjReft_","[(","_qObj_",") D  Q Z ;лежит выше
 .S qqct=$S('$D(Vt(qqnump,111)):$E(qqct,1,$$$ObjLget(qObj)),'$D(Vt(qqnump,111,1,qObj))&&'$D(Vt(qqnump,111,1,qObjt)):$E(qqct,1,$$$ObjLget(qObj)),$G(Vs(qqnump,"Virt",qObj))="":$E(qqct,1,$$$ObjLget(qObj)),1:Vs(qqnump,"Virt",qObj)) ;Vt(qqnump,111,0,qqo) - лежат выше первого ссылочного
 .I '$D(Val),'$D(Cond) S Z=$S($G(qqw)="":qqct,1:..GG(qObj,qqw,qqct)) Q
 .N qqc,qqo S Z="",qqo=qObj,qqc=qqct,Cond=$G(Cond,1) I @Cond S Z=$S($G(qqw)="":qqc,1:..G(qqw)) S:$D(Val) @("Z="_Val)
 ;поиск общей вершины (все очень сомнительно но может быть только нижележащий объект)
 Q:$L(ObjReft,",")=1 ""
 N tmpi F tmpi=$L(ObjReft,","):-1:0 Q:'tmpi  Q:","_ObjRef_","[(","_$P(ObjReft,",",tmpi)_",")
 Q:'tmpi "" S qObjt=$P(ObjReft,",",tmpi) Q $$GetList(ObjRef,qObjt,$S($G(Vs(qqnump,"Virt",qObjt))'="":Vs(qqnump,"Virt",qObjt),1:$E(qqct,1,$$$ObjLget(qObjt))))
 ;объектная ссылка (список объектов до вершины). Если объекта нет в отображении, берется из описания объекта.
GetObjRef(Obj)   Q $S($G($$$ObjRef(qObj))=""||($G($$$ObjRef(qObjt))=""):$G(^Q(1,"CxObj",$S($E(Obj)'="v":Obj,1:$E(Obj,3,255)),"XORef")),$G($$$ObjRef(Obj))'="":$G($$$ObjRef(Obj)),1:$G(^Q(1,"CxObj",$S($E(Obj)'="v":Obj,1:$E(Obj,3,255)),"XORef")))
 ;поиск значений нижележащих объектов (относительно текущего qqo).Возвращает список значений, если несколько экземпляров
 ;???? релевантные никак не учитываются
GetList(ObjRefT,ObjT,qqcT)  N qqzL ;,ReFindL,Cond S Cond=+$G(Vt(qqnump,0)) S Vt(qqnump,0)=1 ;на всякий случай установим учет постоянных условий
 ;I $$$ReFind,$D(^Q($S($G(qFindDO):'$$$Relind,1:$$$Relind)_qview,qObj))<10 N qqReFind,qFindDO,qql S qql=1,ReFindL=1,$$$ReFind=0 ;если режим Уточнения и искомого объекта нет в релевантных, временно уберем режим (qqReFind - см. qW.gForm - флаг сброса уточнения)
 S qqzL="",Cond=$G(Cond,1) D GetListOrder($P($P(","_ObjRefT,","_ObjT_",",2),","),qqcT)
 ;S Vt(qqnump,0)=Cond S:$G(ReFindL) $$$ReFind=1 
 Q qqzL
GetListOrder(qqo,qqc0)  N qqc S:'$D(Vo(qqnump,qqo,27)) Vo(qqnump,qqo,0)=$G(^Q(1,"CxObj",qqo,"X50"),255),Vo(qqnump,qqo,27)=$G(^("X527")),Vo(qqnump,qqo,28)=$G(^("X528")) ;дозапись параметров в локальную среду (длина кода, условие вывода и флаг только последний) 
 ;S qqc="" F  S qqc=..gOrder(1,qqo,qqc,qqc0) Q:qqc=""  D  Q:$G(Vo(qqnump,qqo,28))  ;если только последний то один
 S qqc="" F  S qqc=$$$UserOrd($S($G(Vo(qqnump,qqo,28)):-1,1:1),qqo,qqc,qqc0) Q:qqc=""  I @$S($G(Vo(qqnump,qqo,27))="":1,1:Vo(qqnump,qqo,27)) D  Q:$G(Vo(qqnump,qqo,28))  ;если только последний то один
 .I qqo=qObj D  Q
 ..I @Cond S Z=qW.G(qqw) S:$D(Val) @("Z="_Val) S:Z'="" qqzL=qqzL_$S($G(qFindDO)||$G(qAnalDO):$S(qqzL="":"",1:" ")_Z,1:$S(qqzL="":"",1:$C(13,10))_Z) Q  ;0&&$G(qxml)&&($G(qxml)<6):"<p>"_..CXML(qqzz)_"</p>",1:$S(qqzL="":"",1:$C(13,10))_qqzz) Q  ;$S($E(qqw)="@":$C(13,10),1:" ")_qW.GG(Obj,qqw,qqcObj) Q
 .D GetListOrder($P($P(","_ObjRefT,","_qqo_",",2),","),qqc)
 Q
]]></Implementation>
</Method>

<Method name="GetLine">
<Description>
взять данные для строки объекта
;qqc - код экземпляра
;qqo - код объекта
;qqpar3 - строка
вернуть с разделителем $C(31) или (если qxml=1) в виде XML-тегов
picRef  - глобал, в который записываются картинки (при этом qqdev не учитывается)
innerRef - ссылка на глобал, куда пишутся стили для ОО (ширина столбцов встроеных таблиц, встроеная разметка) @rda 20090525</Description>
<Internal/>
<FormalSpec>qqc:%String,qqo:%String,qqpar3:%String,qxml:%String=0,picRef:%Library.String,picNameHead:%String,innerRef:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qi1,qoo2,qoo,j,qqw,qqpic,qlist,qoo3,qqwxml,picVar,picSrc,picType,picNode,picName,picNameTail,picIndTemp,picIndMain,qqz,size,align,transp,qqGetLine,qxmltr,x710
 s picNameHead = $G(picNameHead)
 n realSize,scaleSize,scale
 S qqGetLine=1 ;@Dol 12.08.07
 ; новый вариант печати картинок - если задано имя picRef
 I $G(picRef)'= "" D
 .S picIndTemp = "temp"
 .S picIndMain = qWEB.Print2GetVar("pic", "FORM", "fld", "out")
 ; структура
 ; @picRef@(picIndTemp,picVar_","_picSrc)=picName                ; вспомогательная
 ; @picRef@(picIndMain)=picVar_","_picSrc_$C(13)_picName_$C(13)  ; основная
 
 // X3695 - подавление цвета
 n X3695 s X3695 = ""
 // X3698 - учёт динамические параметры ячеек
 n X3698 s X3698 = ""
 i ((qxml)&&(qxml<5)) s X3695 = qARM.GetPar("X3695") s X3698 = qARM.GetPar("X3698")
 
 ; tdv 11.01.2008 - массив динамических параметров ячеек
 n dinParam s dinParam=0

 ;@Dol 12.08.07 I $E(qqo)?1N N qql S qql=1 ;????????
 I $G(Vo(qqnump,qqo,39))'="",@Vo(qqnump,qqo,39) S j=$I(^QT("BXPeek",1,qqo,qqc)),^(qqc,j)=$S(qxml:"P ",1:"L ")_qview_" "_$ZDT($H,8)_" "_quser ;слежение
 ;если ячейка - в списке зачеркнутых и вывод в xml, то она не обрабатывается
 ; tdv 11.01.2008
 ; cтрока S qoo=$S('qxml:$S('i1:qoo2,1:qoo_$C(31)_qoo2),qxml=7:qoo_$S('$G(Vo(qqnump,qqo,0,qqso,i1,45)):qoo2,1:qoo2_$J("",Vo(qqnump,qqo,0,qqso,i1,45)-$L(qoo2))),qxml=6:$S('i1:qoo2,1:qoo_$C(9)_qoo2),qxml=5&&($E($G(qoo2))="~"):$E(qoo2,2,31000),$G(x710)="XML":qoo_qoo2,qxml=5&&($G(qqwxml)'=""):"<"_qqwxml_">"_qoo2_"</"_qqwxml_">",1:qoo_qqpic_$S($G(qoo2)'=""&($G(qqw)'=""):"<"_$TR($S($E(qqw)?1N:"O",1:"")_qqw,"@:{}<>()""=/","ooooooooooo")_">"_qoo2_"</"_$TR($S($E(qqw)?1N:"O",1:"")_qqw,"@:{}<>()""=/","ooooooooooo")_">",1:""))
 ; заменена на вызов D GetLineCrStr()
 S qoo="",qqpic="",(qqBut,qqff)="" F i1=0:1:$O(Vo(qqnump,qqo,0,qqpar3,""),-1) I 'qxml||'$G(Vs(qqnump,1,qqo,qqpar3,i1)) D  D GetLineCrStr()
 .S qoo2=$G(Vo(qqnump,qqo,0,qqpar3,i1)) I $G(qqocolm) N qqc S qqc=$P(Vc(qqnump,qqciobj),"~",+$E(qoo2,2,3)) S:$L(Vc(qqnump,qqciobj),"~")'=qqocolm $P(Vc(qqnump,qqciobj),"~",+$E(qoo2,2,3))=qqc S qoo2=$E(qoo2)_$E(qoo2,4,3000) I qqc="" S qoo2="" Q
 .I $D(Vs(qqnump,1,qqo)),"2345"[$E(qoo2) S qqw=$E(qoo2,2,2000) I qqw'="",$G(Vs(qqnump,1,qqo,qqw))||$G(Vs(qqnump,1,qqo,qqpar3,i1)) S qoo2="" Q  ;@Dol 17.07/05 ||$G(Vs(qqnump,1,qqo,qqpar3,i1)) ;зачеркнутое понятие 
 .I qxml,$G(Vs(qqnump,99,"Pic")),qxml<5 S qqpic=$G(Vo(qqnump,qqo,0,qqpar3,i1,6)) D:qqpic'=""  ;обработка картинки для XML
 ..S qqw=$E(qoo2,2,2000)
 ..;грубая обработка ошибки
 ..D  Q:qqpic=""
 ...N $ET S $ET="S ($EC,qqpic)=""""" S qqpic=$S($E(qqpic)="@":qARM.Value($E(qqpic,2,30000)),"FMR"[$E(qqpic):qqpic,1:qARM.Value(qqpic))
 ..; старая обработка картинок
 ..; tdv 16.04.2008 в адрес добавлен порт - должно работать в Cache 4 - $tr($P($P(qARM("CntStr"),":",2),"]"),"[",":")
 ..I $G(picRef)="" D  Q
 ...I $E(qqpic,1,2)="F," S qqpic="<Opic"_qqpar3_"c"_i1_" src='"_$S($E(qqpic,4)=":":"",1:qARM("ClientPath")_"F\")_$P(qqpic,",",2)_"'/>" Q
 ...I $E(qqpic,1,2)="M," S qqpic=$E(qqpic,4,30000),qqpic=$S($E(qqpic,$L(qqpic))=")":qqpic,1:$P(qqpic,")",1,$L(qqpic,")")-1)_")"),qqpic=$NA(@qqpic),qqpic="<Opic"_qqpar3_"c"_i1_" src=""http:\\"_$tr($P($P(qARM("CntStr"),":",2),"]"),"[",":")_"\csp\samples\%25Library.qWEB.cls?R='"_$TR(qqpic,"""","~")_"'&amp;N=''&amp;A='0'&amp;S='"_$ZU(5)_"'""/>" Q  ;@dol 26.02.04
 ...I '$E(qqRES,2) S qqpic="<Opic"_qqpar3_"c"_i1_" src='"_$S($G(qqP1)="":qqpic,1:qqP1_$P(qqpic,"\",$L(qqpic,"\")))_"'/>" Q
 ...S qqpic="<Opic"_qqpar3_"c"_i1_" src=""http:\\"_$tr($P($P(qARM("CntStr"),":",2),"]"),"[",":")_"\csp\samples\%25Library.qWEB.cls?R='QRes'&amp;N='"_$S($G(qqP1)="":qqpic,1:qqP1_$P(qqpic,"\",$L(qqpic,"\")))_"'&amp;A='0'&amp;S='"_$ZU(5)_"'""/>"
 ..
 ..; tdv 13.03.2006 - новая обработка картинок
 ..; берём первый ресурс в варианте ресурс0 ресурс1
 ..S qqpic=$P(qqpic," ") ; ??? имя может содержать пробелы и запятые, узлы могут содержать пробелы и запятые
 ..I $E(qqpic,1,2)?1(1"F",1"M",1"R")1"," S picVar=$E(qqpic) D  Q
 ...set qqz = qqpic
 ...; выравнивание
 ...S align = $S($E(qqz,1,2)'="M,":$P(qqz,",",4),$E(qqz,$L(qqz))=")":"",1:$P($RE($P($RE(qqz),")")),",",3))
 ...; прозрачность
 ...S transp = $S($E(qqz,1,2)'="M,":$P(qqz,",",3),$E(qqz,$L(qqz))=")":"",1:$P($RE($P($RE(qqz),")")),",",2))
 ...; размеры картинки
 ...K size S size = $S($E(qqz,1,2)'="M,":$P(qqz,",",5,6),$E(qqz,$L(qqz))=")":"",1:$P($RE($P($RE(qqz),")")),",",5,6))
 ...; tdv 20080514 - вписывание в прямоульник и масштабирование обрабатываются в qARMProj; 20090115 - для М ресурсов - в приёмнике
 ...s scale = 0 d 
 ....i ($e(size) = ">") s scale = 1 q
 ....i size [ "-1" s scale = 1 q
 ....; высота и ширина
 ....s size("height") = $piece(size, ",", 1)
 ....s size("width") = $piece(size, ",", 2)
 ....s size=""
 ...
 ...S picNameTail=""
 ...; файл F
 ...I picVar="F" D
 ....S picSrc=$P(qqpic,",",2),picSrc=$S($E(picSrc,2)=":":"",1:qARM("ClientPath")_"F\")_picSrc I picSrc="" Q
 ....;S picName=picSrc
 ....; получаем расширение файла
 ....S picType=$ZCVT($P(picSrc,".",$L(picSrc,".")),"L") I picType="" S picSrc="" Q
 ....I picType'?1(1"bmp",1"gif",1"jpg",1"png",1"jpeg") S picSrc="" Q
 ....I picType="bmp" S picType="png"   ; bmp qARMProj преобразует в png
 ...; структура M
 ...I picVar="M" D
 ....S picSrc=$E(qqpic,3,30000)
 ....S picSrc=$S((picSrc'[")")||($E(picSrc,$L(picSrc))=")"):picSrc,1:$P(picSrc,")",1,$L(picSrc,")")-1)_")")   ; tdv 20090114 добавлена проверка (picSrc'[")")
 ....S picSrc=$NA(@picSrc)
 ....I $D(@picSrc)<1 S picSrc="" Q
 ....; получаем первый узел и берём из него 2 первых символа
 ....S picNode=$O(@picSrc@("")) I picNode="" S picType="",picSrc="" Q
 ....S picType=$E(@picSrc@(picNode),1,2) I picType="" S picSrc="" Q
 ....S picNameTail=$P($G(@picSrc),".") S:picNameTail="TMP" picNameTail=""
 ....; bmp
 ....I picType="BM" S picType="png" Q  ; bmp qARMProj преобразует в png
 ....; jpg
 ....I picType="яШ" S picType="jpg" Q
 ....; gif
 ....I picType="GI" S picType="gif" Q
 ....; png
 ....I picType="‰P" S picType="png" D  Q 
 .....i scale d  ; tdv 20090115 - определение размеров и масштабирование картинки
 ......s realSize = ..getPicSize(picSrc, picType)
 ......s scaleSize = ..scalePicSize(realSize, size)
 ......s size("height") = $piece(scaleSize, " ", 1)
 ......s size("width") = $piece(scaleSize, " ", 2)
 ......s size = ""
 ....S picSrc=""
 ....;S picName=$TR(picSrc,"\/:?""<>|","~~~~~~~~")
 ...; ресурс R
 ...I picVar="R" S picSrc=$P(qqpic,",",2),picType="png" ;,picName=picSrc
 ...I picSrc="" S qqpic="" Q
 ...; получаем имя и делаем запись
 ...D
 ....; нет записи
 ....I '$D(@picRef@(picIndTemp,picVar_","_picSrc_","_size)) D  Q
 .....; получаем имя
 .....S picName=$TR($J($I(@picRef@(picIndMain)),4)," ",0)
 .....s picName=picNameHead_$S(picNameHead="":"",1:"-")_picName_$S(picNameTail="":"",1:"-")_picNameTail
 .....S picName=picName_"."_picType
 .....; вспомогательная запись - чтобы не писать много раз
 .....S @picRef@(picIndTemp,picVar_","_picSrc_","_size)=picName
 .....; запись в требуемом для qARMProj формате
 .....set @picRef@(picIndMain,@picRef@(picIndMain))=picVar_","_picSrc_$C(13)_picName_$C(13)_size_$C(13)
 ....; есть запись
 ....S picName=@picRef@(picIndTemp,picVar_","_picSrc_","_size)
 ...
 ...S qqpic="<Opic"_qqpar3_"c"_i1_" var="""_picVar_""" src="""_picName_""""
 ...i ($get(size("height")) '= "") set qqpic = qqpic _ " height=""" _ size("height") _ """"
 ...i ($get(size("width")) '= "") set qqpic = qqpic _ " width=""" _ size("width") _ """"
 ...s qqpic = qqpic _ "/>"
 .
 .S qqw="" I "67"[$E(qoo2) S $E(qoo2)=$S($E(qoo2,2,4)="@ZX":2,1:0) I qxml S qoo2="" Q  ;???xml @dol 17.03.04 qqw=""
 .I $e(qoo2)=0 S qqw="Zs"_qqpar3_"c"_i1 S qoo2="" Q  ; tdv 20081120 получаем имя ячейки (qqw) для константы, чтобы учесть динамические параметры в печатной форме; 20090116 - 'qoo2 заменено на $e(qoo2)=0, не учитывались числовые константы
 .I $G(Vo(qqnump,qqo,0,qqso,i1,84))'="" N qqend D qARM.GetPar("x710",,qqo,qqso,i1) I $G(qqend) S qoo2=$E(qqend,2,30000) Q  ;@Dol 20.07.04 Образец;@Dol 25.12.04 qqend
 .S x710=$G(Vo(qqnump,qqo,0,qqso,i1,10))
 .I qxml D:'$D(Vo(qqnump,qqo,0,qqso,i1,64)) qARM.GetPar("X764",,qqo,qqso,i1) S qxmltr=Vo(qqnump,qqo,0,qqso,i1,64)||(x710="RX") ;@Dol 4.
 .I qxml=7,'$D(Vo(qqnump,qqo,0,qqso,i1,45)) D qARM.GetPar("X745",,qqo,qqso,i1) ;@dol 16.09.04 Ограничение поля ввода
 .I qxml=5,"2345"[$E(qoo2) S qqwxml=$G(Vo(qqnump,qqo,0,qqso,i1,101)) S:qqwxml="" qqwxml=qARM.GetPar("X7101",,qqo,qqso,i1) ;@Dol 27.08.04 XML-имя для внешнего файла
 .I "234"[$E(qoo2) S qqw=$E(qoo2,2,2000) D  D:$Tr(qoo2,"~ ")=""&&$G(Vo(qqnump,qqo,870)) GetLineE S:$G(Vo(qqnump,-1,65))=2&&($E(qqw,1,3)'="@ZX")&&($TR(qoo2,"~")="")&&(x710'="RX") qoo2=$S(qoo2="":" ",qoo2="~":"",1:qoo2) S:'qxml&&(x710="RX")&&($A(qoo2)'=1) qoo2=..CRTF(qoo2) Q  ; @Dol 31.01.09 RX;@Dol 28.06.10 $A()=1 уже RTF
 ..I qqw="@ZXXadd"||(qqw="@ZXXmove") S qoo2=" " Q  ;Q:qxml||'W("ZBtred")  S:qqc'[" " W(qqw,qqo)=qqc Q  ;@dol 18.05.03 спец обработка кнопки ввода
 ..I qqw="@ZXXPntr" S qoo2="" Q  ;@Dol 24.08.05
 ..I $E(qoo2)=4 S qoo3=..G(qqw) D  Q  ;флаг
 ...I qoo3="",$G(Vo(qqnump,qqo,870))=2,qqc'[" " D  S:qoo2'="" qoo3=qoo2,qoo2=10 ;умолчания для существующих
 ....S qoo2=qARM.GetPar("X75",,qqo,qqso,i1) Q:qoo2=""  S:$E(qoo2)="@" @("qoo2="_$E(qoo2,2,30000))
 ...S qoo3=+qoo3 S:$L(qoo3)>1||(qoo3'?1.N) qoo3=''qoo3 S:'$D(Vt(qqnump,9,"PP",qqo,+qqso,i1)) qqff=qqff_" "_qoo3_i1 S qoo2=$S(qoo2'=10:..GtoExt("F",qoo3,+qqso_" "_i1,qqo,qxml),1:"["_$S($TR(..GtoExt("F",qoo3,+qqso_" "_i1,qqo,qxml),"10")="":$P("нет да"," ",qoo3+1),1:..GtoExt("F",qoo3,+qqso_" "_i1,qqo,qxml))_"]") ;@Dol 06.11.09 нет да
 ..I 'qxml,$E(qqw,1,2)="TB" S qoo2=..GT(qqo,qqw,qqc,2) Q
 ..I $E(qqw)="L" S qoo2=..GtoExt("L",..G(qqw),qqw,,qxml) Q
 ..I $E(qqw)="Y" S qoo2=..GtoExt("Y",,qqw,,qxml) Q
 ..I x710'="","1678HMP"[$E(x710)||(x710["(") S qoo2=..GtoExt(x710,$S($E(qoo2)'=3:..G(qqw),1:..zChSym(..G(qqw)," ",$C(13,10))),qqw,qqo,qxml) Q  ;@Dol 20.05.09 "HMP" ;04.08.09 списки; @dol 22.09.10 ||(x710["(") для произволных типов ( выражение)
 ..I x710'="",x710="DEC" S qoo2=..GtoExt(x710,$S($E(qoo2)'=3:..G(qqw),1:..zChSym(..G(qqw)," ",$C(13,10))),qqw,qqo,qxml,$G(Vo(qqnump,qqo,0,qqso,i1,810))) Q  ;sas 20100714 для DEC включение групп разрядов
 ..I $E(qoo2)=3 S qoo2=..GtoExt(2,..G(qqw),,,qxml,$G(Vo(qqnump,-1,66)))  Q  ;список;@dol 17.01.03 - при режиме одного слова - убрать подчерк
 ..;????I $E(qqw,1,3)="@ZL",$P(qoo2,$C(13,10),5)'="" S @("qoo2="_$E($P(qoo2,$C(13,10),5),2,511)) Q
 ..; tdv 7.6.2006 - передаём флаг, задан ли параметр  "Отступ в ячейке" (X7215), если задан, то ведущие пробелы выводятся как есть
 ..I $E(qqw,1,2)="HT" S qoo2=..G("C"_$E(qqw,3,255)) Q:qoo2=""  S qoo2=..GT("C"_$E(qqw,3,255),"Thlp",qoo2,,qxml,,''$P($G(Vo(qqnump,qqo,0,qqso,i1,2)),",",15)) Q  ;@Dol 6.12.06 - Характеристика-пояснения
 ..I $E(qqw)="T" S qoo2=..GT(qqo,qqw,qqc,,qxml,,''$P($G(Vo(qqnump,qqo,0,qqso,i1,2)),",",15)) Q  ;текст
 ..S qoo2=..G(qqw) S:$G(Vo(qqnump,-1,66))&&'$G(Vo(qqnump,qqo,0,qqso,i1,62)) qoo2=$TR(qoo2,"_"," ") Q:'qxml||(qxml>5)  Q:qoo2["<p>"  I ((x710=3)||($P($G(Vo(qqnump,qqo,0,qqso,i1,2)),",",3)=1)||(qoo2[$C(13,10))) S qoo2=$$GetLineDoc(qoo2) Q  ;@Dol 21.04.06 ["<p> $C(13,10) ;@Dol 20.12.05 X762 ;@Dol 16.05.06 Q:'qxml||(qxml>4)
 ..S:x710'="XML" qoo2=..CXML(qoo2) Q
 .;для выражения - специальное имя для правильного формирования XSL
 .I $E(qoo2)=5 S qqw="Zs"_qqpar3_"c"_i1,qoo2=$E($P(qoo2,$C(13,10)),2,32000) D:qoo2'=""  S:$G(Vo(qqnump,-1,65))=2&&($TR(qoo2,"~")="") qoo2=$S(qoo2="":" ",qoo2="~":"",1:qoo2) Q  ;@dol 24.09.10 511-> 32000
 ..;N $ET S $ET="S qoo2=$E($P($ZE,"">""),2,255)_qoo2,$EC="""" Q:$Q qqo2 Q  "
 ..S @("qoo2="_qoo2) Q:qoo2=""  I qxml>4 Q:qxml=6  Q:$E(qoo2)="~"  ;@dol 27.08.04 внешний XML-файл
 ..I qxml,((x710=3)||($P($G(Vo(qqnump,qqo,0,qqso,i1,2)),",",3)=1)||(qoo2[$C(13,10))) S qoo2=$$GetLineDoc(qoo2) Q
 ..;;I qxml,x710'="XML" S qoo2=..CXML(qoo2) ;@Dol 27.04.07 XML
 ..I x710'="","167"[$E(x710),qoo2'="" S qoo2=..GtoExt(x710,qoo2,,,qxml) Q  ;@Pav 11.07.09 для всех дат @Dol 27.10.07 @dol 23.08.03 выражение-дата
 ..I $E(x710)="M" S qoo2=..GtoExt(x710,qoo2,,,qxml) Q  ;@Dol 29.05.09 Mony
 ..I 'qxml,x710="RX",$A(qoo2)'=1 S qoo2=..CRTF(qoo2) Q  Q  ; @Dol 31.01.09 RX ;$A()=1 уже RTF
 ..I qxml,x710'="XML" S qoo2=..CXML(qoo2) ;@Dol 27.04.07 XML
 ..I x710="F" S qoo3=..G(qqw) D  Q  ;(тип данных флаг) флаг @sas 20101122
 ...I qoo3="",$G(Vo(qqnump,qqo,870))=2,qqc'[" " D  S:qoo2'="" qoo3=qoo2,qoo2=10 ;умолчания для существующих
 ....S qoo2=qARM.GetPar("X75",,qqo,qqso,i1) Q:qoo2=""  S:$E(qoo2)="@" @("qoo2="_$E(qoo2,2,30000))
 ...S qoo3=+qoo3 S:$L(qoo3)>1||(qoo3'?1.N) qoo3=''qoo3 S:'$D(Vt(qqnump,9,"PP",qqo,+qqso,i1)) qqff=qqff_" "_qoo3_i1 S qoo2=$S(qoo2'=10:..GtoExt("F",qoo3,+qqso_" "_i1,qqo,qxml),1:"["_$S($TR(..GtoExt("F",qoo3,+qqso_" "_i1,qqo,qxml),"10")="":$P("нет да"," ",qoo3+1),1:..GtoExt("F",qoo3,+qqso_" "_i1,qqo,qxml))_"]") ;@Dol 06.11.09 нет да
 // tdv 11.01.2008 - запись динамических параметров в XML-строку
 i ((qxml)&&(qxml<5)&&(dinParam)) do GetLineSetDinParam()
 
 Q:$TR(qoo,$C(31))'="" qoo Q ""
 
 ;для XML обработка типа DOCUMENT
GetLineDoc(str)
 Q:str="" "" N pos,str1,str2,pos1
 I $G(qqw)="Xcode" N ns S ns=+qARM.GetPar("X72",,qqo,qqw)-8 S:'ns ns=70 D  S str=str1 ;спец.обработка для понятия с М-кодом ;||($G(qqw)="Xdescription")
 .S str1="" F pos=1:1:$L(str,$C(13,10)) S str2=$P(str,$C(13,10),pos) F pos1=1:ns:$L(str2) S str1=$S(str1="":"",1:str1_$C(13,10))_$S(pos1'=1:"...",1:"")_$E(str2,pos1,pos1+(ns-1))
  ;@tdv 7.6.2006 - если задан параметр "Отступ в ячейке" (X7215), то ведущие пробелы выводятся как есть
 S pos1=0 S str1="" F pos=1:1:$L(str,$C(13,10)) S str2=$P(str,$C(13,10),pos) S:$P($G(Vo(qqnump,qqo,0,qqso,i1,2)),",",15)="" pos1=$S($E(str2)=" ":$F(str2,$E($TR(str2," ")))-2,1:0) S str1=str1_"<p"_$S('pos1:">"_..CXML(str2),1:" indent='"_(0.1*$S($G(qqw)="Xcode":10,1:pos1))_"'>"_..CXML($E(str2,pos1+1,3000)))_"</p>"
 S str1="" F pos=1:1:$L(str,$C(13,10)) S str2=$P(str,$C(13,10),pos),pos1=$S($E(str2)=" ":$F(str2,$E($TR(str2," ")))-2,1:0) s str1=str1_"<p"_$S(('pos1):">"_..CXML(str2),1:" indent='"_(0.1*$S($G(qqw)="Xcode":10,1:pos1))_"'>"_..CXML($E(str2,pos1+1,3000)))_"</p>"
 Q str1
 ;@Dol 17.10.07 обработка выводимого значения при наличии вывода значений по умолчанию (X5870)
GetLineE I Vo(qqnump,qqo,870)=1,qqc'[" " Q
 S qoo2=qARM.GetPar("X75",,qqo,qqso,i1) Q:qoo2=""  S:$E(qoo2)="@" @("qoo2="_$E(qoo2,2,30000)) Q:qoo2=""
 S qoo2=$S($E(Vo(qqnump,qqo,0,qqso,i1))=3:..GtoExt(2,qoo2,,,qxml,$G(Vo(qqnump,-1,66))),x710="":qoo2,1:..GtoExt(x710,qoo2,$E(Vo(qqnump,qqo,0,qqso,i1),2,1000),qqo,qxml)) ;@Dol 08.12.09 для P ; Было ..GtoExt(x710,qoo2,,,qxml)
 S:$G(Vo(qqnump,-1,66))&&'$G(Vo(qqnump,qqo,0,qqso,i1,62)) qoo2=$TR(qoo2,"_"," ") ;@Dol 19.07.09
 S:Vo(qqnump,qqo,870)=2 qoo2="["_qoo2_"]" Q
 
 // tdv 11.01.2008 - формирование строки XML
GetLineCrStr()
 i $G(Vo(qqnump,qqo,0,qqso,i1,104)) s:$g(XBLocal) qoo2=qSYS.getLocal(qoo2,2) ;@pav если элемент интерфейса то переводим по словарю
 d  S qqwxml="" ;@Dol 11.01.09 qqwxml=""
 .// вывод не в XML
 .i ('qxml) s qoo=$S('i1:qoo2,1:qoo_$C(31)_qoo2) q
 .// TXT-файл с фиксированной шириной полей
 .i (qxml=7) s qoo=qoo_$S('$G(Vo(qqnump,qqo,0,qqso,i1,45)):qoo2,1:qoo2_$J("",Vo(qqnump,qqo,0,qqso,i1,45)-$L(qoo2))) q
 .// TXT-файл c ГТ
 .i (qxml=6) s qoo=$S('i1:qoo2,1:qoo_$C($G(Vs(qqnump,"CodTab"),9))_qoo2) q  ;@Dol 10.06.09 CodTab
 .// dbf файл foxpro sasha 20080929
 .S:'$D(x710) x710=$G(Vo(qqnump,qqo,0,qqso,i1,10)) ;@Dol 31.01.09
 .i (qxml=9) d zag() q
 .// внешний XML и значение начинается с ~
 .i ((qxml=5)&&($E($G(qoo2))="~")) s qoo=qoo_$E(qoo2,2,31000) q  ;@Dol 11.01.09 =qoo_
 .// тип данных XML
 .i (x710="XML") s qoo=qoo_qoo2 q
 .// внешний XML и задано XML имя понятия
 .i ((qxml=5)&&($G(qqwxml)'="")) s qoo=qoo_"<"_qqwxml_">"_qoo2_"</"_qqwxml_">" q  ;@Dol 11.01.09 =qoo_
 .// в остальных случаях
 .s qoo=qoo_qqpic
 .i (($G(qqw)'="")&&(($G(qoo2)'="")||(X3698 && ($e(Vo(qqnump,qqo,0,qqpar3,i1))=0)))) d  ; tdv 20081020 учёт динамических параметров для константы; ; 20090116 - 'Vo(qqnump,qqo,0,qqpar3,i1) заменено на $e(Vo(qqnump,qqo,0,qqpar3,i1)=0, не учитывались числовые константы
 ..// получаем XML имя понятия
 ..s qqwxml=$TR($S($E(qqw)?1N:"O",1:"")_$P(qqw,"{"),"@:{}<>()""=/","ooooooooooo") ;@Dol 04.05.06 $P(qqw,"{")
 ..s qoo=qoo_"<"_qqwxml_">"
 ..// tdv 11.01.2008 - динамические параметры ячейки
 ..i ((qxml<5)&&(X3698)) do GetLineGetDinParam(.dinParam, $length(qoo))
 ..// @rda 20101001 вывод в OpenOffice - замена тегов, тест
 ..s qoo=qoo_$S(($g(x320)=10)||($g(x320)=11):qW.ConvertTag2OO(qoo2,innerRef),1:qoo2)_"</"_qqwxml_">"
 q
 
 // tdv 11.01.2008 - формирование массива динамических паметров ячеек строки в формате XML 
GetLineGetDinParam(dinParam, position)
 // dinParam = 0/1 - отсутвие/наличие дин. параметров в строке
 // dinParam(colNum, "position") - позиция в выходной строке для вставки формируемого атрибута style 
 // dinParam(colNum, "style", "color") - стиль для цвета символа
 // dinParam(colNum, "style", "background-color") - стиль для цвета фона
 // dinParam(colNum, "style", "fontFormat") - стиль для формата шрифта
 // dinParam(colNum, "style", "font-size") - размер шрифта

 new window set window = qqnump 
 new obj set obj = qqo
 new inst set inst = qqc
 new strNum set strNum = qqpar3
 new colNum set colNum = i1
 
 new colBegin
 new colAmt
 
 new sep set sep = ","
 
 new param set param = qARM.GetPar("X720",,obj,strNum,colNum) ;$get(Vo(window, obj, 0, strNum, colNum, 20))
 if (param = "") set dinParam(colNum, "position") = position quit 
  
 // выражение
 if ($extract(param) = "@") do  if (param = "") set dinParam(colNum, "position") = position quit
 .set @("param="_$extract(param,2,$length(param)))
 
 do
 .// вся строка
 .if ($extract(param) = "*") do  quit
 ..set param = $extract(param,2,$length(param))
 ..set colBegin = 0
 ..set colAmt = ""
 .
 .// диапазон
 .if (param [ ">") do  quit
 ..set colBegin = $piece(param, ">", 1)
 ..if (colBegin = "") set colBegin = colNum
 ..set colAmt = $piece(param, ">", 2)
 ..set param = $piece(param, ">", 3)
 .
 .// текущая ячейка
 .set colBegin = colNum
 .set colAmt = 1
 
 if (colAmt = "") set colAmt = $order(Vo(window, obj, 0, strNum, ""), -1) + 1
 
 new xmlParam
 
 new colorParamArray
 set colorParamArray(1) = "color"
 set colorParamArray(2) = "background-color"
 new colorParamId
 new colorParamName
 new color
 new xmlColor
 new red
 new green
 new blue
 new ooStyle,styleName,temp ;@rda 21052009
 set ooStyle=""

 
 // цвет символов и цвет фона
 if ('X3695) do
 .set colorParamId = ""
 .for  set colorParamId = $order(colorParamArray(colorParamId)) quit:(colorParamId="")  do
 ..set color = $piece(param, sep, colorParamId)
 ..if (color = "") quit
 ..// переводим в 16-ричный формат
 ..set color = $ZH(+color)
 ..// 6 значимых символов
 ..set color = $TR($J(color,6)," ",0)
 ..set red = $E(color,5, 6)
 ..set green = $E(color, 3, 4)
 ..set blue = $E(color, 1, 2)
 ..set colorParamName = colorParamArray(colorParamId)
 ..set xmlColor = colorParamName _":#" _ red _ green _ blue _";"         
 ..set xmlParam(colorParamName) = xmlColor
 ..set:colorParamId=1 ooStyle=ooStyle_"<style:text-properties fo:"_colorParamName_"='#"_ red _ green _ blue _"'/>"
 ..set:colorParamId=2 ooStyle=ooStyle_"<style:table-cell-properties fo:"_colorParamName_"='#"_ red _ green _ blue _"'/>"

 // формат шрифта
 new fontFormat set fontFormat = $piece(param, sep, 5)
 if (fontFormat '= "") do
 .new xmlFontFormatArray
 .set xmlFontFormatArray(1) = "font-weight:bold;"
 .set xmlFontFormatArray(2) = "font-style:italic;"
 .set xmlFontFormatArray(3) = "text-decoration:underline;"
 .set xmlFontFormatArray(4) = xmlFontFormatArray(1) _ xmlFontFormatArray(3)  
 .new xmlFontFormat set xmlFontFormat = $get(xmlFontFormatArray(fontFormat))
 .set xmlParam("font-format") = xmlFontFormat
 .set ooStyle=ooStyle_"<style:text-properties " set:xmlFontFormat["underline" ooStyle=ooStyle_"style:text-underline-style='solid' "
 .set:xmlFontFormat["bold" ooStyle=ooStyle_"fo:font-weight='bold' " set:xmlFontFormat["italic" ooStyle=ooStyle_"fo:font-style='italic'" set ooStyle=ooStyle_"/>"
 
 // размер шрифта
 new fontSize set fontSize = $piece(param, sep, 6)
 if (fontSize '= "") do
 .set xmlParam("font-size") = "font-size:" _ fontSize _ "pt;"
 .set ooStyle=ooStyle_"<style:text-properties fo:font-size='"_fontSize_"'/>"
 
 // rowspan
 new rowspan set rowspan = $piece(param, sep, 7)
 if (rowspan '= "") set xmlParam("rowspan") = rowspan
 
 // @rda 21052009 если приемник печати OpenOfficeWriter(x320=10), то сохраняем динамический стиль для ячейки в innerRef,
 //  для записи его в qWEB.OOXSL, а в параметрах xml узла сохраняем название сохраненного стиля.
 if (ooStyle'="") & ($get(x320)=10) d
 .; проверяем, есть ли уже такой стиль. Если стиль есть, берем его название
 .set styleName = "", temp = ""  for  set temp=$O(@innerRef@("DinamicStyle",temp)) quit:(temp = "")  d  quit:(styleName '= "") 
 ..if (@innerRef@("DinamicStyle",temp) = ooStyle) & ((@innerRef@("DinamicStyle",temp,"cell")) = (obj_" "_strNum_" "_colNum)) set styleName=temp
 . ; если такого стиля еще нет, то его надо записать
 .if temp="" do
 ..set styleName = $TR("DinamicStyle"_qqc_strNum_colNum,"{}<>[]()'""@$^&*")
 ..set @innerRef@("DinamicStyle",styleName) = ooStyle
 ..set @innerRef@("DinamicStyle",styleName,"cell")=obj_" "_strNum_" "_colNum
 .set xmlParam("styleName") = styleName ;записываем название стиля в параметры
 
  
 if ($data(xmlParam)) do
 .// только текущая колонка
 .if ((colBegin = colNum) && (colAmt = 1)) do  quit
 ..set dinParam(colNum, "position") = position
 ..merge dinParam(colNum, "style")=xmlParam
 ..set dinParam = 1
 .
 .// диапазон
 .new col
 .for col = colBegin: 1: (colBegin + colAmt - 1) do
 ..if (col = colNum) set dinParam(col, "position") = position
 ..merge dinParam(col, "style")=xmlParam
 ..set dinParam = 1
  
 quit

 // tdv 11.01.2008 - запись динамических параметров в XML-строку
GetLineSetDinParam()
 new addLen s addLen = 0
 
 new position
 
 new styleId, style
 new styleList
 
 new colNum set colNum = ""
 for  set colNum = $order(dinParam(colNum)) quit:(colNum="")  do
 .; позиция, в которую производится вставка
 .set position = $get(dinParam(colNum, "position"))
 .if (position = "") quit
 .
 .; формируем атрибут style
 .if ('$data(dinParam(colNum, "style"))) quit
 .
 .set styleList = ""
 .set styleId = ""
 .for  set styleId = $order(dinParam(colNum, "style", styleId)) quit:(styleId="")  do
 ..set style = dinParam(colNum, "style", styleId)
 ..set styleList = styleList _ " " _ styleId _ "=" _ "'" _ style _ "'"
 .
 .if (styleList = "") quit
 .
 .; вставка
 .set $extract(qoo, position + addLen) = styleList _ $extract(qoo, position + addLen)
 .
 .; накапливаем смещение
 .set addLen = addLen + $length(styleList)
 
 quit
 
zag()
 n qqtrdec
 //2008107 имя столбца берется по X7101, если нет значения из qqw если оно есть 
 s qqwxml=qARM.GetPar("X7101",,qqo,qqso,i1),qqwxml=$S(qqwxml'="":qqwxml,1:qqw)
 s:$G(Fld(-1))="" Fld(-1)=qqo_qqc
 i $G(Fld(-1))=-1 Q
 i $G(Fld(-1))=(qqo_qqc) i (qqwxml'="") d
 .s Fld=$i(ColDBF)
 .///вставка для DECIMAL определения знаков после запятой sas 20081201 
 .i x710="DEC" S:'$D(Vo(qqnump,qqo,0,qqso,i1,88)) Vo(qqnump,qqo,0,qqso,i1,88)=qARM.GetPar("X788",,qqo,qqso,i1) S qqtrdec=$G(Vo(qqnump,qqo,0,qqso,i1,88)) S:$E(qqtrdec)="@" @("qqtrdec="_$E(qqtrdec,2,3000))
 .s Fld(ColDBF,"F")=$S(x710="M":2,x710="M4":4,x710="DEC":+qqtrdec,1:0)
 .s Fld(ColDBF,"L")=$S($P($G(Vo(qqnump,qqo,0,qqso,i1,2)),",")="":15,1:$P($G(Vo(qqnump,qqo,0,qqso,i1,2)),","))
 .s Fld(ColDBF,"N")=qqwxml
 .s Fld(ColDBF,"O")=0
 .s Fld(ColDBF,"T")=$S(x710="N":"N",x710="DEC":"N",x710="M":"N",x710="M4":"N",x710=1:"D",x710="F":"L",1:"C")  ;;20101112 sas добавлено поле типа L(Logical) получаемое из типа данных F(FLAG)
 .i Fld(ColDBF,"T")="D" s Fld(ColDBF,"L")=8
 s:(qqwxml'="") qoo=$S('i1:qoo2,1:qoo_"*****"_qoo2)
]]></Implementation>
</Method>

<Method name="GetObjRuls">
<Internal/>
<FormalSpec>ruls:%Library.String,view:%Library.String,Obj:%Library.String,Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(ruls)="" ruls=$G(qruls) Q:ruls="" ""
 S:$G(view)="" view=$G(Vo($G(qqnump,"?")),"?")
 Q:'$D(^Q(1,"XRuls",ruls,"XViewStat",view,"CxObj",Obj)) ""
 ;далее вместо XRef - Ref (специфика понятий виртуального объекта Массив)
 N qqq S qqq=+$G(^Q(1,"XRuls",ruls,"XViewStat",view,"CxObj",Obj,"Ref0"))_(+$G(^("Ref1")))_(+$G(^("Ref2")))_(+$G(^("Ref3")))
 Q:'$G(Arg1) qqq  N qqw,qqq1,qqq2 S (qqq1,qqq2,qqw)="" F  S qqw=$O(^Q(1,"XRuls",ruls,"XViewStat",view,"CxObj",Obj,"CxWoc",qqw)) Q:qqw=""  S:$G(^(qqw,"Ref0")) qqq1=qqq1_" "_qqw S:$G(^("Ref2")) qqq2=qqq2_" "_qqw
 Q:Arg1=1 qqq_"~"_qqq1_"~"_qqq2 
 ;Q $S($E(qqq):"удален из отображения"_$C(13,10),$TR($P(qqq,"~"),0)="":"",1:"запрет: "_$S($E(qqq,2):"запись ",1:"")_$S($E(qqq,3):"коррекция ",1:"")_$S($E(qqq,4):"удаление ",1:""))_
 Q $S($E(qqq):"удален из отображения"_$C(13,10),1:"")_$S(qqq1="":"",1:"удалены понятия/строки: "_qqq1) ;_$S(qqq2="":"",1:$C(13,10)_"запрещена коррекция: "_qqq2)
]]></Implementation>
</Method>

<Method name="GetWoc">
<Description>
Получить значения по их кодам.
Arg1 - код понятия
Arg2 - код (или коды через пробел) значения
@Dol 05.09.08
Arg3 - разделитель для вывода(если список кодов). По умолчанию - пробел
Arg4 - вывод пар код - значение (через - )
Можно использовать как всплывающую подсказку для хранимого списка кодов понятий или выражение вывода.
Пример X57 - понятие (НЕ КОДИРУЕМОЕ) для хранения списка кодов понятий:
235:X57{qW.GetWoc("CxWoc",Z,,1)} - выводит пары код-имя
@qW.GetWoc("CxWoc",qW.G("X57"),$C(13,10),1) - для всплывающей подсказки</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%String,Arg3:%String,Arg4:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 Q:Arg1=""!(Arg2="") "" 
 N qqA,qqz,qqzi S qqz=$$GetWocF($P(Arg2," ")) S:$G(Arg4) qqz=$P(Arg2," ")_"-"_qqz F qqzi=2:1:$L(Arg2," ") S qqz=qqz_$S($G(Arg3)="":" ",1:Arg3)_$S('$G(Arg4):"",1:$P(Arg2," ",qqzi)_"-")_$$GetWocF($P(Arg2," ",qqzi))
 Q qqz
GetWocF(Arg2)   Q:Arg2="" "" S qqA="" I Arg1="CxWoc"!(Arg1="CxObj") D  Q:qqA="" Arg2 S:qqA=" " qqA=""
 .I Arg2[":" S qqA=" ",Arg2=$P($P(Arg2,":",2),"{") Q  ;qqA=$P(Arg2,":")_":"
 .I Arg2["{" S qqA=" ",Arg2=$P(Arg2,"{") Q
 .I $E(Arg2)="A" S qqA="Аналитика_",Arg2=$E(Arg2,2,31) Q
 .I $E(Arg2)="O" S qqA="Ссылка_",Arg2=$E(Arg2,2,31),Arg1="CxObj" S:$E(Arg2)="O" Arg2=$E(Arg2,2,255) Q
 .I $E(Arg2)="H",'$D(^Q(1,Arg1,Arg2)) D  Q
 ..I $E(Arg2,2)="T" S qqA="Характеристика_Пояснение_",Arg2=$E(Arg2,3,31) Q
 ..I $E(Arg2,2)'?1N S qqA="Характеристика_",Arg2=$E(Arg2,2,31) Q
 ..S qqA="Характеристика_"_$E(Arg2,2)_"_",Arg2=$E(Arg2,3,31)
 .I $E(Arg2,1,2)="LA" S qqA="Агрегаты_",Arg2=$E(Arg2,3,31) Q
 .I $E(Arg2,1,3)="McO",$L(Arg2)>3 S Arg2="Счетчик_для_"_$G(^Q(1,"CxObj",$E(Arg2,4,31)),"?"),qqA="" Q
 .I $E(Arg2,1,3)="qls",$L(Arg2)>3 n name,qqcTest s qqA="",Arg2=$E(Arg2,4,31) d  Q   ;@rda 20100128 для вывода названий тестов qls-понятия
 ..s qqcTest=qW.FastKey("qlsTest","qlsTID","",,Arg2,$E($G(qARM("Pars",5,244)),1,3)) i qqcTest=""  s qqA=" ",Arg2="qls"_Arg2 q
 ..s name=qW.GG("qlsTest","qlsTName",qqcTest) s:name'="" Arg2=name Q
 .I $E(Arg2,1,2)="Xt" S qqA="Образец_для_",Arg2=$E(Arg2,3,31) Q
 .I $E(Arg2,1,5)="@ZLAY" S qqA=$P("Num Sum Min Max Mid Dmid"," ",$P(Arg2,".",3)-$S($P(Arg2,".",3)>4:4,1:0))_"_" S Arg2=$P(Arg2,".",2) S:Arg2="" Arg2="???" Q  ;@Dol 28.03.11 агрегаты аналитик
 .I $E(Arg2,1,4)="@ZLA" S qqA="%Агрегаты_",Arg2=$E(Arg2,6,31) S:Arg2="" Arg2="???" Q
 .I $E(Arg2)="@",Arg2[".",'$D(^Q($G(qqlang,1),Arg1,Arg2)),$D(^Q($G(qqlang,1),Arg1,$P(Arg2,"."))) S Arg2=^($P(Arg2,"."))_"_"_$P(Arg2,".",2,255) Q  ;@dol 22.01.03 точечные обобщения
 .I '$D(^Q($G(qqlang,1),Arg1,Arg2)) D  Q  ;@dol 22.01.03 нет имени в словаре
 ..I Arg1="CxWoc" D  Q:qqA'=""
 ...I $E(Arg2)="C",$D(^Q($G(qqlang,1),Arg1,$E(Arg2,2,255))) S qqA="Код_",Arg2=$E(Arg2,2,255) Q
 ...I $E(Arg2,1,2)="XX" S Arg2=$E(Arg2,2,255) I $D(^Q($G(qqlang,1),Arg1,Arg2)) S qqA=" " Q  ;спец.вариант для понятий на X в виртуальном объекте типа Массив
 ..S Arg2=$S(Arg1="CxWoc":"?Понятие ",1:"?Объект ")_Arg2
 .S qqA=" "
 I $E(Arg1)="R"||($E(Arg1,1,2)="CR") S Arg1=$S($E(Arg1)="R":$E(Arg1,3,255),1:"C"_$E(Arg1,4,255)) ;R-понятия
 Q qqA_$G(^Q($G(qqlang,1),Arg1,Arg2))
]]></Implementation>
</Method>

<Method name="Glob">
<Description>
Метод выдает имя массива для объекта типа Массив (%Имя Массива в описании объекта @@qW.Glob(... )
Level - уровень иерархии (не задан - по последней цифре кода объекта)
Mas - Имя массива (не задано - берется из Vs(qqnump,"Glob")

Метод используется в системном отображении XXXXGlob.</Description>
<Internal/>
<FormalSpec>Level:%Library.String,Mas:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(Level)="" Level=$E(qqo,$S($E(qqo,$L(qqo)-1)?1N:$L(qqo)-1,1:$L(qqo)),$L(qqo)) ;по двум последним цифрам кода объекта
 S:$G(Mas)="" Mas=Vs(qqnump,"Glob")
 N qqref,qqlref S qqref=$$$ObjRef(qqo),qqlref=$L(qqref,",")-Level
 Q:Level=1 Mas
 S Mas=$S($E(Mas,$L(Mas))=")":$E(Mas,1,$L(Mas)-1)_",",1:Mas_"(") F Level=1:1:Level-1 S Mas=Mas_"Vs(qqnump,""Virt"","""_$P(qqref,",",qqlref+Level)_"""),"
 Q $E(Mas,1,$L(Mas)-1)_")"
]]></Implementation>
</Method>

<Method name="GtoExt">
<Description>
Преобразование формата хранения во внешнее представление.
dtype - тип данных 
value -  значение

Arg - дополнительный параметр спец. обработки:
Для списка (dtype=3) - Arg=1 - замена подчерка пробелом

Специальные варианты:
dtype="D" - преобразование даты или даты-времени в нормализованный вид (в хранимый вид)
dtype="I" - преобразование интервала даты-времени в упакованный  вид (в хранимый вид)</Description>
<Internal/>
<FormalSpec>dtype:%String,value:%String,qqw:%String,Obj:%String,qxml:%String=0,Arg:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $G(value)[$C(13,10),$G(dtype)'="","D2LP"'[dtype N va,vi,vv D  Q vv ;@Dol 18.05.06 преобразование списков
 .S vv="" F vi=1:1:$L(value,$C(13,10)) S va=..GtoExt(dtype,$P(value,$C(13,10),vi),$G(qqw),$G(Obj),qxml,$G(Arg)) D
 ..I qxml,qxml<6 S vv=vv_"<p>"_va_" </p>" Q
 ..S $P(vv,$C(13,10),vi)=va
 I $G(dtype)["(" D  Q value ;@Dol 22.09.10 свой тип данных на выводе - выражение обработки
 .N Z S Z=value I $G(Obj)'="" N qqo S qqo=Obj
 .S @("value="_dtype)
 G:$G(dtype)'?1(1"",1"T") @("GtoExt"_dtype)
 I $G(qqw)'="" G @("GtoExt"_$S($E(qqw)="L":"L",$E(qqw)="Y":"Y",1:0))
 ;
GtoExtN
GtoExtT   ; tdv 20100326
GtoExt0 Q value

GtoExtDEC  ;sas 20100714
 
 i +$G(Arg)=0 Q value
 n tmp,t,t1,l,i
 s tmp=$S(value="":"",$TR(value,"1234567890-+.")="":value,1:value)
 q:tmp="" ""
 i $TR(value,"1234567890-+.")="" d
 .s t=$p(tmp,".")
 .s l=$l(t)\3
 .q:'l
 .s t1=""
 .s:$l(t)>(l*3) t1=$e(t,1,$l(t)-(l*3))_" ",t=$e(t,$l(t)-(l*3)+1,$l(t))  
 .f i=1:1:l s t1=t1_$e(t,1,3)_$s(i=l:"",1:" "),t=$e(t,4,$l(t))  
 .s tmp=t1_$S($p(tmp,".",2)'="":".",1:"")_$p(tmp,".",2)  
 q tmp

GtoExtRX Q value ;Q:$G(qxml) value Q ..CRTF(value) ;@Dol 31.01.09
 ;Преоразование даты в нормализованную
GtoExtDf(value) 
GtoExtD I $L(value,".")=3,value'[" " Q $S($L($P(value,".",3))=4:$P(value,".",3),1:20_$P(value,".",3))_$P(value,".",2)_$P(value,".",1)
 I $L(value,".")=2,value'[" " Q $P(value,".",2)_$P(value,".",1)_00
 Q $P($P(value," "),".",3)_$P(value,".",2)_$P(value,".",1)_$TR($P(value," ",2),":")
 ;нормализованная дата ГГГГММДД ;@dol 23.08.04 не преобразуются даты с точкой
GtoExt1 S:value?8.N value=$E(value,1,8) ;@Dol 15.01.09
 Q $S(value="":"",value[".":value,value'?8N:value,1:$E(value,7,8)_"."_$E(value,5,6)_"."_$E(value,1,4))
GtoExt10 S:value?8.N value=$E(value,1,8) ;@Dol 15.01.09
 Q $S(value="":"",value[".":value,value'?8N:value,1:$E(value,7,8)_"."_$E(value,5,6)_"."_$E(value,3,4))
 ;нормализованная дата ГГГГММ
GtoExt6 S:value?6.N value=$E(value,1,6) ;@Dol 15.01.09
 Q $S(value="":"",value[".":value,value'?6N:value,1:$E(value,5,6)_"."_$E(value,1,4))
 ;нормализованная дата-время ГГГГММДДhhmmss ;TDV 3.08.05    
GtoExt7 S:value?8.N value=$E(value_"000000",1,14) ;@Dol 15.01.09
 Q $S(value="":"",value[".":value,value'?14N:value,1:$E(value,7,8)_"."_$E(value,5,6)_"."_$E(value,1,4)_" "_$E(value,9,10)_":"_$E(value,11,12)_":"_$E(value,13,14))
 ;без секунд
GtoExt71 ;@Dol 21.05.10 YY
GtoExt70 S:value?8.N value=$E(value_"000000",1,14) ;@Dol 15.01.09
 Q $S(value="":"",value[".":value,value'?12N.N:value,1:$E(value,7,8)_"."_$E(value,5,6)_"."_$E(value,$S(dtype=71:3,1:1),4)_" "_$E(value,9,10)_":"_$E(value,11,12)) ;@Dol 21.05.10 dtype=71
 ;интервал дата-время упакованный (без секунд)
GtoExt81 ;обратный
GtoExt80 Q $S(value="":"",1:$$GtoExt80f($E(value,1,6))_$S(dtype=81:"<<",1:">>")_$$GtoExt80f($E(value,7,12)))
GtoExt80f(value,norm)   S value=$E(36+$A(value,1),2,3)_$E(36+$A(value,2),2,3)_$E(36+$A(value,3),2,3)_$E(36+$A(value,4),2,3)_$E(36+$A(value,5),2,3)_$E(36+$A(value,6),2,3) Q:$G(norm) value G GtoExt70
 ;интервал дата-время внешнее представление ;@Dol 07.03.10
GtoExt81v ;обратный
GtoExt80v Q:value="" "" S value=$S(+dtype=80:$$GtoExt80f($E(value,1,6))_"-"_$$GtoExt80f($E(value,7,12)),1:$$GtoExt80f($E(value,7,12))_"-"_$$GtoExt80f($E(value,1,6))) S $E(value,7,8)="",$E(value,22,23)="" S:$P(value," ")=$P($P(value,"-",2)," ") value=$P(value,"-")_"-"_$P($P(value,"-",2)," ",2) Q value ;@Dol 07.03.10
 ;преобразование нормализованный интервал (без секунд)
GtoExt8N Q $S(value="":"",1:$$GtoExt80f($E(value,1,6),1)_$$GtoExt80f($E(value,7,12),1))
 ;преобразование интервала (прямого и обратного) в хранимое значение
GtoExtI Q:value[">>" $$GtoExt80fi($P(value,">>",1),0)_$$GtoExt80fi($P(value,">>",2),1) Q $$GtoExt80fi($P(value,"<<",1),1)_$$GtoExt80fi($P(value,"<<",2),0)
 ;упаковка даты-времени без секунд
GtoExt80fi(value,b) S:value="" value=$S('b:"0000",1:3000) S:value["." value=$$GtoExtDf(value)
 ;I $L(value)<12 S value=value_$S('b:$S($L(value)=10:"00",$L(value)=8:"0000",$L(value)=6:"010000",1:"01010000"),1:$S($L(value)=10:"59",$L(value)=8:"2359",$L(value)=4:"12312359",$E(value,5,6)'="02":$S("01 03 05 07 08 10 12 "[($E(value,5,6)_" "):"312359",1:"302359"),$E(value,1,4)#4:"282359",1:"292359")) ;Умолчания для начала-конца интервала при частично заданных значениях
 I $L(value)<12 S value=value_$E($S('b:"000001010000",1:$S($L(value)>7:"        2359",$L(value)<5:"299912312359",$L(value)=7:"299912992359",$E(value,5,6)'="02":$S("01 03 05 07 08 10 12 "[($E(value,5,6)_" "):"299912312359",1:"299912302359"),$E(value,1,4)#4:"299912282359",1:"299912292359")),$L(value)+1,12) ;Умолчания для начала-конца интервала при частично заданных значениях
 Q $C(64+$E(value,1,2))_$C(64+$E(value,3,4))_$C(64+$E(value,5,6))_$C(64+$E(value,7,8))_$C(64+$E(value,9,10))_$C(64+$E(value,11,12))
 ;деньги
GtoExtM Q $S(value="":"",$TR(value,"1234567890-+.")="":$J(value,0,2),1:value)
GtoExtM4 Q $S(value="":"",$TR(value,"1234567890-+.")="":$J(value,0,4),1:value)
 ;список
GtoExt2 I value'[" " S:$G(Arg) value=$TR(value,"_"," ") Q $S('qxml:value,1:"<p>"_..CXML(value)_"</p>")
 N j,qv,qvv S qv="" F j=1:1:$L(value," ") S qvv=$P(value," ",j) S:$G(Arg) qvv=$TR(qvv,"_"," ") S qv=qv_$S('qxml:qvv_$C(13,10),1:..CXML(qvv)_"</p><p>") ;qxml=1-вывод в формате XML ;@dol 17.01.03 qvv
 S qv=$P(qv,$S('qxml:$C(13,10),1:"</p><p>"),1,$L(qv,$S('qxml:$C(13,10),1:"</p><p>"))-1)
 Q $S('qxml:qv,1:"<p>"_qv_"</p>")
 ;флаг
GtoExtF N qv S qv=$TR(qARM.GetPar(73,,Obj,$P(qqw," ",1),$P(qqw," ",2)),"~"," ") I qv[" " S qv=$P(qv," ",value+1) Q $TR(qv,"_"," ") ;@Dol 06.11.09 $TR(
 I qv="",qxml S qv=value
 Q $TR(qv,"_"," ")
 ;Cache-список
GtoExtL N qv,j S qv="" D  Q qv
 .N $ET S $ET="S qv=value,$EC="""" Q:$Q qv Q  "
 .I value="" S qv="???" Q
 .I 'qxml F j=1:1:$LL(value) S:$LG(value,j)'="" qv=qv_$S(j=1:"",1:$C(13,10))_$S($E(qqw,2)'="A":"",1:$P("Num Sum Min Max Mid Dmid"," ",j)_"=")_$LG(value,j)
 .I qxml N qv1 F j=1:1:$LL(value) S:$LG(value,j)'="" qv1=$S($E(qqw,2)'="A":"L"_j,1:$P("Num Sum Min Max Mid Dmid"," ",j)),qv=qv_"<"_qv1_">"_$LG(value,j)_"</"_qv1_">"
 ;набор параметров
GtoExtP N qv S qv=qARM.GetPar(73,,Obj,qqw)
 N sep,iw,qqq S sep=$P(qv,"/",2),qv=$P(qv,"/") S:sep="" sep=" "
 S qqq="" F iw=1:1:$L(value,sep) I $P(value,sep,iw)'="" S $P(qqq,sep,iw)=..GetWoc("C"_$P(qv," ",iw),$P(value,sep,iw)) S:$P(qqq,sep,iw)="" $P(qqq,sep,iw)=$P(value,sep,iw)
 Q qqq
 ;структура (произвольное поддерево)
GtoExtY N ref,reff,val,vall,iv ;S a=1/0
 S val="",ref=$S('$G($$$Tree):"^Q(qql)",$D(qqref):qqref,1:$$$GloRef),(ref,reff)=$S($G(qqw)="Y":$NA(@ref@(qqo,qqc)),1:$NA(@ref@(qqo,qqc,qqw)))
 F  D:$D(@reff)#2   S reff=$Q(@reff) Q:$E(reff,1,$L(ref)-1)'=$E(ref,1,$L(ref)-1)
 .S vall=$E(reff,$L(ref)+1,$L(reff)-1)_" = "_$G(@reff) I vall?.e1c.e F iv=1:1 I $A(vall,iv)<32 S $E(vall,iv)="$C("_$A(vall,iv)_")" Q:vall'?.e1c.e
 .S val=val_$S(qxml:"<p>",val="":"",1:$C(13,10))_vall_$S(qxml:"</p>",1:"")
 Q val
 ;время
GtoExtt I value'[":" Q:value="" $S($G(Arg):"б/в",1:"") S:$L(value)<2 value="00"_value S $E(value,$L(value)-1)=":"_$E(value,$L(value)-1)
 Q $E(100+$P(value,":"),2,3)_":"_$E($P(value,":",2)_"00",1,2)
 ;Время $H
GtoExtHt Q $S(value="":"",value[":":value,value'?1.n:value,1:$E(value\3600+100,2,3)_":"_$E(value#3600\60+100,2,3)) ;@Dol 20.04.07 1:$P($P($ZDT(100_","_value)," ",2),":",1,2)) ;\216000_":"_(value#216000\3600)_":"_(value#3600\60)) ;_":"_(value#60))
]]></Implementation>
</Method>

<Method name="Key">
<Description>
Поиск следующего экземпляра объекта для строки кодов понятий  (значения в массиве W).
Возвращает код экземпляра или пусто.
qqpar4 - выполяемый для найденных метод ( в этом случае проходятся все подходящие значения)
qorder - направление перемещения (1 или -1)
ext =1 - строгий вариант (значения понятий не должны быть пусты)
Если заданы iObj iqqc, то это объект и экземпляр из которых нужно взять значения. iqqwl в этом случае может содержать список кодов замещающих qqwl понятий, если не указан - те же, что и в qqwl.
Если iObj="", то iqqwl может содержать список значений (через ~) для понятий из списка qqwl.

qqc0 - общее начало кодов экземпляра

!!!! Значения массива W для понятий списка qqwl "портятся" (заполняются значениями понятий для поиска).
!!!! Если nomas=1 - сохраняются прежними.

!!!Если для первого понятия из списка qqwl в объекте qqo есть R*-понятия, то  для корректной работы метода это понятие должно быть еще раз включено в список ( например, "pID pID" вместо "pID" если есть R1pID)</Description>
<Internal/>
<ClassMethod>1</ClassMethod>
<FormalSpec>qObj:%String,qqwl:%String,qqc:%String,qqpar4:%String,qorder:%Library.String=1,ext:%Library.String=0,iObj:%Library.String,iqqc:%Library.String,iqqwl:%Library.String,nomas:%Library.String,qqc0:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qqw,i,qqz,qqzz,qqzzz,qqqq4,qqqq5,qqcount N:$G(nomas) WKey
 S:$E(qObj)="v" qObj=$E(qObj,3,255) ;@Dol 17.06.05
 I $G(qqpar4)'="" N qqo S qqo=qObj S:'$D(Vo(qqnump,qqo,2)) Vo(qqnump,qqo,2)=0 ;@dol 13.05.04 явно хранимый
 S qqc=$G(qqc) I $G(qqc0)'="" S qqc=$S(qqc="":qqc0_$S(qorder=-1:"яяяяя",1:""),$E(qqc,1,$L(qqc0))=qqc0:qqc,1:"") I qqc="" Q:$Q "" Q
 S qqz="",qqzz=0 K N
 F i=1:1:$L(qqwl," ") S qqw=$P(qqwl," ",i) I qqw'="" D  Q:qqzz
 .M:$G(nomas) WKey(qqw)=W(qqw) D
 ..I $G(iObj)'="" S W(qqw)=..GG(iObj,$S($P($G(iqqwl)," ",i)="":qqw,1:$P(iqqwl," ",i)),iqqc) Q
 ..I $G(iqqwl)'="" S W(qqw)=$P($G(iqqwl),"~",i)
 .I ext,$G(W(qqw))="" S qqzz=1 Q
 .I qqw="C" S qqz=W(qqw) S qqqq4=qqw Q  ;@dol 21.04.04 
 .I $E(qqw)="D"!($E(qqw)="R"&($E(qqw,3)="D")) S N(qqw)=$G(W(qqw))
 .I $E(qqw)'="C"  S:qqz="" qqz=$G(W(qqw)),qqqq4=qqw S:$G(N(qqw))="" qqzz=..rWoc() Q
 .N qqzzc S qqw=$E(qqw,2,255),$P(qqwl," ",i)=qqw,qqzzc=$G(W("C"_qqw)) I qqzzc="" S $P(qqwl," ",i)="" Q  ;1
 .I $G(N(qqw))="" S qqzzc1=qW.GetWoc("C"_qqw,qqzzc) S:qqzzc1="" qqzz=1 Q:qqzz  S:$G(W(qqw))'=""&($G(W(qqw))'=qqzzc1) qqzz=1 Q:qqzz  S N(qqw)=qqzzc,W(qqw)=qqzzc1
 .S:qqz="" qqz=W(qqw) S qqqq4=qqw Q
 G:qqz=""!qqzz KeyEnd0 S qqz=$P(qqz," ") G:qqz="" KeyEnd0 S qqzzz=0,qqwl=$P(qqwl," ",2,255),qqqq5=$S($E(qqqq4)="R":$E(qqqq4,3,255),1:qqqq4)
 I qqqq5="C" D  D:$G(nomas) KeyEndM Q:$Q qqc Q  ;@dol 21.04.04
 .I qqc'="" S qqc="" Q
 .S qqc=qqz I $G(qqpar4)'="" D
 ..N qqo S qqo=qObj I @qqpar4 Q
 ..S qqc="" Q
 F  Q:qqzzz  S qqc=$O(^Q(1,qqqq5,qqz,qObj,qqc),qorder),qqc=$S(qqc="":"",$G(qqc0)="":qqc,$E(qqc,1,$L(qqc0))'=qqc0:"",1:qqc) Q:qqc=""  D
 .I $L(W(qqqq4)," ")>1 S qqzzc=1 D  Q:'qqzzc
 ..F i=2:1:$L(W(qqqq4)," ") S qqzzc=$D(^Q(1,qqqq5,$P(W(qqqq4)," ",i),qObj,qqc)) Q:'qqzzc
 .F qqzz=1:1:$L(qqwl," ") S qqw=$P(qqwl," ",qqzz),qqzzz=$S(qqw="":1,$G(N(qqw))="":1,1:$G(^Q(1,qObj,qqc,qqw))=$G(N(qqw))) Q:'qqzzz    ;если не существует, то подходит
 .I qqzzz,$G(qqpar4)'="" D
 ..I @qqpar4 Q
 ..S qqzzz=0 Q
 D:$G(nomas) KeyEndM Q:$Q qqc Q
KeyEnd0 D:$G(nomas) KeyEndM Q:$Q "" Q
KeyEndM F i=1:1:$L(qqwl," ") S qqw=$P(qqwl," ",i) K:qqw'="" W(qqw)
 M W=WKey Q
]]></Implementation>
</Method>

<Method name="Key4">
<Internal/>
<FormalSpec>qObj:%Library.String,qqwl:%Library.String,qqc:%Library.String,qqpar4:%Library.String,qorder:%Library.String=1,ext:%Library.String=0,iObj:%Library.String,iqqc:%Library.String,iqqwl:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 N qqw,i,j,qqz,qqzz,qqzzz,qqqq4,qqqq5,qqcount
 I $G(qqpar4)'="" N qqo S qqo=qObj
 S qqc=$G(qqc),qqz="",qqzz=0 K N
 F i=1:1:$L(qqwl," ") S qqw=$P(qqwl," ",i) I qqw'="" D  Q:qqzz
 .S:$G(iObj)'="" W(qqw)=..GG(iObj,$S($P($G(iqqwl)," ",i)="":qqw,1:$P(iqqwl," ",i)),iqqc)
 .I ext,$G(W(qqw))="" S qqzz=1 Q 
 .I $E(qqw,1,3)="zzd" S N(qqw)=$G(W(qqw))
 .S:qqz="" qqz=$G(W(qqw)),qqqq4=qqw I $G(N(qqw))="" D  S:qqzz="" qqzz=1
 ..F j=1:1:$L(qqz," ") S qqzz=$G(^QW(1,$S($E(qqw,1,2)="q4":$E(qqw,3,100),1:qqw),0,$P(W(qqw)," ",j))) Q:qqzz=""  S $P(N(qqw)," ",j)=qqzz
 Q:qqz=""!qqzz "" S qqz=$P(qqz," "),qqzzz=0,qqwl=$P(qqwl," ",2,255),qqqq5=qqqq4
 F  Q:qqzzz  S qqc=$O(^QW(1,$S($E(qqqq5,1,2)="q4":$E(qqqq5,3,100),1:qqqq5),0,qqz,$E(qObj,2,255),qqc),qorder) Q:qqc=""  D
 .I $L(W(qqqq4)," ")>1 S qqzzc=1 D  Q:'qqzzc
 ..F i=2:1:$L(W(qqqq4)," ") S qqzzc=$D(^QW(1,$S($E(qqqq5,1,2)="q4":$E(qqqq5,3,100),1:qqqq5),0,$P(W(qqqq4)," ",i),$E(qObj,2,255),qqc)) Q:'qqzzc
 .F qqzz=1:1:$L(qqwl," ") S qqw=$P(qqwl," ",qqzz),qqzzz=$S(qqw="":1,$G(N(qqw))="":1,1:$G(@("^"_qObj)@(qqc,$S($E(qqw,1,2)="q4":$E(qqw,3,100),1:qqw)))=$G(N(qqw))) Q:'qqzzz    ;если не существует, то подходит
 .I qqzzz,$G(qqpar4)'="" D
 ..I @qqpar4 Q
 ..S qqzzz=0 Q
 Q qqc
]]></Implementation>
</Method>

<Method name="KeyNum">
<Description>
Возвращает кол-во экземпляров объекта для строки кодов понятий  содержащих такие же значения, как  в массиве W
Если задано qqc0 - желаемая общая часть кода экземпляра</Description>
<Internal/>
<FormalSpec>qObj:%Library.String,qqwl:%Library.String,qqc0:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N count,cond S cond=$S($G(qqc0)'="":"$E(qqc,1,"_$L(qqc0)_")="""_qqc0_""",",1:"")_"'$I(count)"
 S:$G(qqc0)'="" qqc0=qqc0_$C(255,255,255)
 D qW.Key(qObj,qqwl,$G(qqc0),cond,-1)
 Q +$G(count)
]]></Implementation>
</Method>

<Method name="LikeSymb">
<Description>
Преобразование похожих</Description>
<Internal/>
<FormalSpec>str:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[ Q $TR(str,"EHXBAPOCMTexapoc","ЕНХВАРОСМТехарос")
]]></Implementation>
</Method>

<Method name="MACRO">
<Description>
!!!    ПРИМЕР макрообработки значения по умолчанию редактирования ячейки (X75).  Должно начинаться знаком =
!!!    Метод должен быть перенесен в класс qUSER прикладной системы

Обработка макроподстановок для вычисляемых значений по умолчанию.  Заменяет переменные на вызов метода 
(Используется в статусах qMS)</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N str,str1,stri,sn S str1=$TR(Arg1,"+-/\*()'!|[]&#<>=,:_",$C(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)) ;знаки операций
 S str1=$TR(str1,"1234567890",$C(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)) ;числа
 S str="" F stri=1:1:$L(str1) D
 .I $E(str1,stri)=$C(0) S str=str_$E(Arg1,stri) Q
 .I $E(str1,stri)="$" S sn=$F(str1_$C(0),$C(0),stri),str=str_$E(Arg1,stri,sn-2),stri=sn-2 Q  ;функции пропустим
 .I $E(str1,stri)="""" S sn=$F(str1_$C(0),""""_$C(0),stri+1),str=str_$E(Arg1,stri,sn-2),stri=sn-2 Q  ;пропустим все в кавычках
 .I $P($E(str1,stri,30000),$C(0))["." S sn=$F(str1_$C(0),$C(0),stri),str=str_$E(Arg1,stri,sn-2),stri=sn-2 Q  ;ссылка на метод класса
 .I $E(str1,stri)=$C(1),$TR($P($E(str1,stri,30000),$C(0)),$C(1)_".")="" S sn=$F(str1_$C(0),$C(0),stri),str=str_$E(Arg1,stri,sn-2),stri=sn-2 Q  ;пропустим числа
 .S str=str_"qUSER.SgetZTMP("""_$E(Arg1,stri,stri+$L($P($E(str1,stri,30000),$C(0)))-1)_""")",stri=$F(str1_$C(0),$C(0),stri)-2
 Q str
]]></Implementation>
</Method>

<Method name="Message">
<Internal/>
<FormalSpec>Arg1:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ D qARM.Message(Arg1) Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="ObjLget">
<Description>
Длина кода экземпляра объекта Obj</Description>
<Internal/>
<FormalSpec>Obj:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ Q $$$ObjLget(Obj)
]]></Implementation>
</Method>

<Method name="ObjRefT">
<Description>
Проверяет, является ли ObjP предком/родителем  для Obj.
Если Arg1=1 - проверка по общей схеме базы (по CxObj)
Возвращает 1 - родитель, -1 - Obj=ObjP, число - поколений для предка

Если ObjP не задан, возвращает код объекта-родителя</Description>
<Internal/>
<FormalSpec>Obj:%Library.String,ObjP:%Library.String,Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 Q:Obj=$G(ObjP) -1 N qqobj S qqobj=$S('$G(Arg1):$G($$$ObjRef(Obj)),1:$G(^Q(1,"CxObj",Obj,"XORef")))
 Q:qqobj="" "" I $G(ObjP)="" Q $P(qqobj,",",$L(qqobj,",")-1)
 Q $S(","_qqobj_","'[(","_ObjP_","):0,1:$L($P(","_qqobj_",",","_ObjP_",",2),",")-1)
]]></Implementation>
</Method>

<Method name="RefVirt">
<Description>
Определяет, есть ли для объекта qqo виртуальные предки (до объекта qqop)</Description>
<Internal/>
<FormalSpec>qqop:%Library.String,qqo:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 N ObjRef,qnumqqc,qqco S ObjRef=$$$ObjRef(qqo)_"," I $G(qqop)'="" Q:$G(Vo(qqnump,qqop,2))>1 1 S ObjRef=$P(","_ObjRef,","_qqop_",",2) Q:ObjRef="" 0
 F qnumqqc=1:1:$L(ObjRef,",")-1 I $G(Vo(qqnump,$P(ObjRef,",",qnumqqc),2))>1 S qqco=1 Q
 Q +$G(qqco)
]]></Implementation>
</Method>

<Method name="RelWoc">
<Description>
Создать альтернативный словарь для сортировки по перечню релевантных
Value - выражение для значения понятия. Позволяет сделать сортировку по вычисляемым значениям.
Up=1 - преобразовать в большие буквы; @Dol 04.03.09</Description>
<Internal/>
<FormalSpec>qqw:%String,qqo:%String,Value:%Library.String,qqc0:%Library.String,SortV:%Library.String,SortVn:%Library.String,Up</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqc,qqco,qqz,qqzi,qqzw,qql,qql0 S:'$D(Up) Up=$G(Vo(qqnump,-1,1990))
 S:$G(SortV)'="" Vs(qqnump,"SortV")=SortV S SortVn=$G(SortVn),qql=$S($G(SortV)="":$$$Relind_qview,1:SortV),qql0=$S($$$ReFind:$$$Relind_qview,1:1) ;@Dol 21.12.04 qql0
 S qqc0=$G(qqc0),qqc=qqc0 ;@Dol 28.07.05 Q:$E(qqc,1,$L(qqc0))'=qqc0
 I $G(Value)'="" D  Q:$Q "" Q
 .K ^Q(qql,qqw) ;@Dol 28.07.05 ???? не было
 .F  S qqc=$O(^Q(qql0,qqo,qqc)) Q:qqc=""  Q:$E(qqc,1,$L(qqc0))'=qqc0  S @("qqzw="_Value) S:qqzw="" qqzw=" " S:$G(Up) qqzw=$ZCVT(qqzw,"U") S ^Q(qql,qqw,qqzw,qqo,qqc)="" ;I qqzw'=""
 I qqw[":",qql0=1,$G(SortV)="",..TestSort(qqw,qqo) Q:$Q "" Q  ;@Dol 25.09.08
 I $S("MXZL@HxR"[$E(qqw):1,1:qqw[":") D  Q:$Q "" Q
 .K ^Q(qql,qqw) ;?????
 .F  S qqc=$O(^Q(qql0,qqo,qqc)) Q:qqc=""  Q:$E(qqc,1,$L(qqc0))'=qqc0  S qqzw=..GG(qqo,qqw,qqc)  I qqzw'="" S:$G(Up) qqzw=$ZCVT(qqzw,"U") S ^Q(qql,qqw,qqzw,qqo,qqc)="" ;I qqzw'="" ;S:qqzw="" qqzw=" "
 I qql0=1,$G(SortV)="" Q:$Q "" Q  ;@Dol 21.12.04
 K ^Q(qql,qqw) I $G(Vo(qqnump,qqo,2))=4 D  Q:$Q "" Q
 .S qqco="" F  S qqco=$O(^Q(qql0,qqo,qqco)) Q:qqco=""  S qqzw=$G(@("^"_qqo)@(qqco,qqw)) I qqzw'=""  F qqzi=1:1:$L(qqzw," ") S qqz=$P(qqzw," ",qqzi) S:$E(qqw,1,3)'="zzd" qqz=^QW(1,qqw,1,qqz) S:$G(Up) qqz=$ZCVT(qqz,"U") S ^Q(qql,qqw,qqz,qqo,qqco)=qqzi-1
 S:SortVn Vs(qqnump,"SortVn")=1
 S qqco=qqc0 F  S qqco=$O(^Q(qql0,qqo,qqco)) Q:qqco=""  Q:$E(qqco,1,$L(qqc0))'=qqc0  S qqzw=$G(^Q(1,qqo,qqco,qqw)) I qqzw'="" F qqzi=1:1:$L(qqzw," ") S qqz=$P(qqzw," ",qqzi) S:$E(qqw)'="D" qqz=^Q(qqlang,"C"_qqw,qqz) S:$G(Up) qqz=$ZCVT(qqz,"U") S:'SortVn ^Q(qql,qqw,qqz,qqo,qqco)=qqzi-1 S:SortVn ^Q(qql,qqw,qqz)=""
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="SQLClose">
<Description><![CDATA[
Arg2=1-> Закрытие SQL соединения (по умолчанию  Arg2=0)
Arg2=0->Закрытие ResultSet (требуется если ..NextB не доходит до последней записи)]]></Description>
<Internal/>
<FormalSpec>Con:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 s Arg2=$G(Arg2,$C(0)) i Arg2=0 s Arg2=$C(0)
 d ..SQLSend("Z"_Con_"|"_Arg2) 
 s %SQLCODE=..SQLRec() q ""
]]></Implementation>
</Method>

<Method name="SQLCloseTcp">
<Description><![CDATA[
Arg1=1-> Разрыв TCP соединения и выход из Gateway.exe
Arg1=2-> Разрыв TCP соединения и перевод  Gateway.exe в режим ожидания]]></Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 d ..SQLSend("C"_Arg1) h 2 c %qGWd 
 k %SQLCODE,%qGWcon,%qGWd,%qGWN,%qGWF,%qGWD,%qGWdp,%qGWS,%qGWC,%qGWM,%qGWT
 q
]]></Implementation>
</Method>

<Method name="SQLCon">
<Description>
Открытие ADO соединения </Description>
<Internal/>
<FormalSpec>DSN:%Library.String,user:%Library.String,pwd:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ q ..SQLConEx("ADO Provider=MSDASQL.1;Persist Security Info=True;Data Source="_DSN_";User ID="_user_";Password="_pwd)
]]></Implementation>
</Method>

<Method name="SQLConEx">
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 d ..SQLSend("S"_Arg1)
 s %SQLCODE=..SQLRec() i $E(%SQLCODE)="0" s Arg1=$E(%SQLCODE,2,$L(%SQLCODE)),%SQLCODE=0 q Arg1
 q ""
]]></Implementation>
</Method>

<Method name="SQLConTcp">
<Description><![CDATA[
Arg1=1 -> полный выход из Gateway.exe
Arg1=2 ->разрыв текущего соединения и перевод Gateway.exe в режим ожидания]]></Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 n p,d
 i $g(%qGWcon) s %SQLCODE=0 q
 s d=$IO
 k %qGWcon
 u %qGWd
 r p:15 e  s %SQLCODE=-999 u d c %qGWd q
 s %SQLCODE=0,%qGWcon=1 u d q
]]></Implementation>
</Method>

<Method name="SQLExec">
<Description>
Выполнение SQL-запроса
SQL - запрос SQL</Description>
<Internal/>
<FormalSpec>Con:%Library.String,SQL:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 n i,l,k,e,ret
 s %SQLCODE=0
 d ..SQLSend("E"_Con_"|"_SQL) s %SQLCODE=..SQLRec()
 i $F(%SQLCODE,"|") s ret=$P(%SQLCODE,"|",2),%SQLCODE=$P(%SQLCODE,"|")
 i %SQLCODE<0 q ""
 d ..SQLGB(ret) i '$L($G(%qGWD(ret))) q ""
 s %qGWM(ret)=$F(%qGWD(ret)," ") s %qGWC(ret)=$E(%qGWD(ret),1,%qGWM(ret)-1)
 k %qGWN(ret)
 f i=1:1:%qGWC(ret) s k=$F(%qGWD(ret)," ",%qGWM(ret)),l=$E(%qGWD(ret),%qGWM(ret),k-2) s:l'=+l %SQLCODE=-1 i l s %qGWN(ret,i)=$E(%qGWD(ret),k,k+l-1),%qGWM(ret)=k+l+1
 q $G(ret)
]]></Implementation>
</Method>

<Method name="SQLExecBf">
<Description>
 отложенное выполнение</Description>
<Internal/>
<FormalSpec>Con:%Library.String,SQL:%Library.String,mod:%Library.String=0</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 n k,b,w
 s k=$L(SQL),b=$L($G(%qGWE(Con))),w=16000
 i mod d:b ..SQLExec(Con,%qGWE(Con)) d:k ..SQLExec(Con,SQL) s %qGWE(Con)="" q ""
 i (k+b)<w s %qGWE(Con)=$G(%qGWE(Con))_SQL_$C(7) q ""
 i k>w d:b ..SQLExec(Con,%qGWE(Con)) s %qGWE(Con)="" d ..SQLExec(Con,SQL) q ""
 d ..SQLExec(Con,%qGWE(Con)) s %qGWE(Con)=SQL_$C(7)
 q ""
]]></Implementation>
</Method>

<Method name="SQLGB">
<Description>
Используется при организации обмена информацией с SQL</Description>
<Internal/>
<FormalSpec>Con:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 i $G(Arg2,1) d ..SQLSend("B"_Con_"|") i 1
 e  d ..SQLSend("X|") ;
 s %qGWD(Con)=..SQLRec()
 q
]]></Implementation>
</Method>

<Method name="SQLGetF">
<Description>
Получение списка полей таблицы tbl текущего соединения в %qGWF</Description>
<Internal/>
<FormalSpec>Con:%Library.String,tbl:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n %qGWC,%qGWD,%qGWN,%qGWM,i
 s %SQLCODE=0 k %qGWN,%qGWF(Con)
 d ..SQLSend("F"_Con_"|"_tbl) s %qGWD=..SQLRec()
 s %qGWM=$F(%qGWD," ") s %qGWC=$E(%qGWD,1,%qGWM-1)
 f i=1:1:%qGWC s k=$F(%qGWD," ",%qGWM),l=$E(%qGWD,%qGWM,k-2) s:l'=+l %SQLCODE=-1 i l s %qGWN(i)=$E(%qGWD,k,k+l-1),%qGWM=k+l+1
 m %qGWF(Con)=%qGWN
 q
]]></Implementation>
</Method>

<Method name="SQLGetT">
<Description>
Получение списка таблиц текущего соединения в %qGWT</Description>
<Internal/>
<FormalSpec>Con:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n %qGWC,%qGWD,%qGWN,%qGWM,i
 s %SQLCODE=0 k %qGWN,%qGWT(Con)
 d ..SQLSend("T"_Con_"|") s %qGWD=..SQLRec()
 s %qGWM=$F(%qGWD," ") s %qGWC=$E(%qGWD,1,%qGWM-1)
 f i=1:1:%qGWC s k=$F(%qGWD," ",%qGWM),l=$E(%qGWD,%qGWM,k-2) s:l'=+l %SQLCODE=-1 i l s %qGWN(i)=$E(%qGWD,k,k+l-1),%qGWM=k+l+1
 m %qGWT(Con)=%qGWN
 q
]]></Implementation>
</Method>

<Method name="SQLNextB">
<Description><![CDATA[
Перемещение SQL курсора на следующую позицию
Arg2=0 -> Более быстрое перемещение SQL курсора на следующую позицию при условии, что 
не было вызовов SQL функций с другим значением парамета Сon
gref -> cсылка на формируемый массив, по умолчанию %qGWS(Con)]]></Description>
<Internal/>
<FormalSpec>Con:%Library.String,Arg2:%Library.String,gref:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n i,z,k,r,qf k %qGWS(Con) s %SQLCODE=0
 s i=1,gref=$G(gref)
NextB0
 ;w:$D(dfgdfg)=0 %qGWD s dfgdfg=1
 s k=$F(%qGWD(Con)," ",%qGWM(Con)) i k=0 d  q:$G(qf)  g NextB0
 .s r=$E(%qGWD(Con),%qGWM(Con),65535)
 .s:(r="0")&&(i'=1) %qGWS(Con,i)="",i=i+1
 .i i>%qGWC(Con) s qf=1 q
 .d ..SQLGB(Con,$G(Arg2,1)) s %qGWM(Con)=2
 s z=$E(%qGWD(Con),%qGWM(Con),k-2) i z=-100 d ..SQLClose(Con) s %SQLCODE=-100 q 
 ;i z=0 b "s"
 i $L(gref) s @gref(i)=$E(%qGWD(Con),k,k+z-1)
 e  s %qGWS(Con,i)=$E(%qGWD(Con),k,k+z-1) 
 s %qGWM(Con)=$S(z>0:k+z+1,1:%qGWM(Con)+2)
 ;i z=0 s %qGWM=%qGWM+1
 i z'=+z d ..SQLClose(Con) s %SQLCODE=-100 q  ;b "s" ; b:i=5 "s"
 s i=i+1 i i>%qGWC(Con) q
 g NextB0
]]></Implementation>
</Method>

<Method name="SQLNextBQ">
<Description><![CDATA[
Перемещение SQL курсора на следующую позицию
Arg2=0 -> Более быстрое перемещение SQL курсора на следующую позицию при условии, что 
не было вызовов SQL функций с другим значением парамета Сon
gref -> cсылка на формируемый массив, по умолчанию %qGWS(Con)]]></Description>
<Internal/>
<FormalSpec>Con:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n i,z,k,r,qf,e,p k %qGWS(Con) s %SQLCODE=0
 s i=1,e=1
NextB1
 ;w:$D(dfgdfg)=0 %qGWD s dfgdfg=1
 s k=$F(%qGWD(Con)," ",%qGWM(Con)) i k=0 d  q:$G(qf)  g NextB1
 .s r=$E(%qGWD(Con),%qGWM(Con),65535)
 .s:(r="0")&&(i'=1) Vs(qqnump,"Virt",qqo,$P(Vt(qqnump,"sql",qqo,"qqwR"),",",i))="",i=i+1
 .i i>%qGWC(Con) s qf=1 q
 .d ..SQLGB(Con,$G(Arg2,1)) s %qGWM(Con)=2
 s z=$E(%qGWD(Con),%qGWM(Con),k-2) i z=-100 d ..SQLClose(Con) s %SQLCODE=-100 q 
 ;i z=0 b "s"
 ;s %qGWS(Con,i)=$E(%qGWD(Con),k,k+z-1) 
 S Vs(qqnump,"Virt",qqo,$P(Vt(qqnump,"sql",qqo,"qqwR"),",",i))=$S($G(qqWinDos):$ZCVT($ZSTRIP($E(%qGWD(Con),k,k+z-1),"<>W"),"I","CP866"),1:$ZSTRIP($E(%qGWD(Con),k,k+z-1),"<>W"))
 i e i $L(Vs(qqnump,"Virt",qqo,$P(Vt(qqnump,"sql",qqo,"qqwR"),",",i)))'=0 s e=0
 ;d qARM.Message(Vs(qqnump,"Virt",qqo,$P(Vt(qqnump,"sql",qqo,"qqwR"),",",i)))
 s %qGWM(Con)=$S(z>0:k+z+1,1:%qGWM(Con)+2)
 ;i z=0 s %qGWM=%qGWM+1
 i z'=+z d ..SQLClose(Con) s %SQLCODE=-100 q  ;b "s" ; b:i=5 "s"
 s i=i+1 i i>%qGWC(Con) s:e %SQLCODE=-100 q
 g NextB1
]]></Implementation>
</Method>

<Method name="SQLRec">
<Description>
Используется при организации обмена информацией с SQL</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 n z,bfo,d,b
 s d=$IO,bfo=""
 u %qGWd r b#7 s z=+b-7 i z f  r b#z s bfo=bfo_b i $L(bfo)=z q
 u d q bfo
]]></Implementation>
</Method>

<Method name="SQLSend">
<Description>
Используется при организации обмена информацией с SQL</Description>
<Internal/>
<FormalSpec>bf:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 n d s d=$IO
 s bf=$L(bf)_$TR($J("",6-$L($L(bf)))," ","x")_" "_bf
 u %qGWd w bf,# 
 u d q
]]></Implementation>
</Method>

<Method name="SQLSetActRst">
<Description>
Устанавливает активным указанный ResultSet. 
Вызов функции необходим перед выполнением SQLNextB(Con,0)</Description>
<Internal/>
<FormalSpec>Con:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ d ..SQLSend("0"_Con_"|") s %SQLCODE=..SQLRec() q ""
]]></Implementation>
</Method>

<Method name="StreemCnv">
<Description>
Преобразование потока (НЕ ДОДЕЛАНО)</Description>
<Internal/>
<FormalSpec>refn:%Library.String,refo:%Library.String,ObjLn:%Library.String,ObjLo:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N Obj
 S Obj="" F  S Obj=$O(@ref@(Obj)) Q:Obj=""  D StreemC(Obj,ref,refn)  
StreemC(Obj,ref,refn)
 N ORef,qqw,Lqqw
 S ORef="" F  S ORef=$O(@ref@(Obj,ORef)) Q:ORef=""  D
 .S (Lqqw,qqw)="" F  S qqw=$O(@ref@(Obj,ORef,qqw)) Q:qqw=""  D
 ..I $S(qqw?1.N:1,"YT"[$E(qqw):0,1:$D(^(qqw))>1) D StreemC(qqw,$NA(@ref@(Obj,ORef))) Q  ;объект нижнего уровня
 ..S Lqqw=Lqqw_" "_qqw ;список понятий
 .F qqwi=2:1:$L(Lqqw," ") S qqw=$P(Lqqw," ",qqwi) M W(qqw)=@ref@(Obj,ORef,qqw) I qqw="YT" S W(qqw)=0 K Vt(qqnump,"ZTmpYT") M Vt(qqnump,"ZTmpYT")=W(qqw)  ;@dol 24.12.03 иначе не записывалось в базу
]]></Implementation>
</Method>

<Method name="StreemExp">
<Description>
Создание массива потока
ref - ссылка на массив
qqo - код объекта. Если qqo="" сохранять  поддеревья вершины отображения qqc
qqc - код экземпляра (или qqc_"*" - тогда qqc -общее начало кода) 
Rel =1 - сохранять по перечню релевантных полные поддеревья (если пуст, всю базу)
Rel =2 - сохранять только (!!!) по перечню релевантных
cordtu=1 - сохранять дату время пользователь создания/коррекции
ext=1 - внешний вызов
Set qW=##class(%qWORD).%New() D qW.StreemExp("^QS(1)",153,"",1,1,1) - сохранит поддеревья объекта 153 всей базы.

extdo - действие (по Xcute) перед внешним вызовом.
Set qW=##class(%qWORD).%New() D qW.StreemExp("^QS(1)","XView","mseAct",1,1,1,"S Vo(qqnump)=""XXXX"" D qSYS.RelView(""XView"",""mseAct"") S Vs(qqnump,""RelNum"")=1") - сохранить описание отображения mseAct и всех его объектов и понятий.
S Vo(qqnump)="XXXX" - имитация вызова из проводника

В варианте сохранения по отображению (qqo="" ) ПУСТЫЕ ЗНАЧЕНИЯ понятий переносятся в поток.

Nopar=1 - не сохранять родителей
NoC=1 - не сохранять значение qqс (понятие C)
desobj=1 - сохранять понятия по описанию объекта (Список сохраняемых понятий берется из xWoc объекта CxObj). В этом случае сохранятся характеристики и C*-понятия (если они попали в список понятий объекта).
В этом варианте ПУСТЫЕ ЗНАЧЕНИЯ понятий переносятся в поток (аналогично сохранению по отображению)
=2 - сохранять только имеющиеся в экземпляре (даже если сохранение по отображению). Пустые значения и характеристики НЕ сохраняются.</Description>
<Internal/>
<FormalSpec>ref:%String,qqo:%String,qqc:%String,Rel:%String,cordtu:%String=0,ext:%Library.String,extdo:%Library.String,Nopar:%Library.String,NoC:%Library.String,desobj:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 ;словари ? физ деревья ??
 N qqMasLst,qqAddqqw,qqz,qqwi,qStreem,ww,wwi ;массив хранения ссылок на потомков и дополнительных понятий (пока H*)
 I $G(ref)="" Q:$Q "" Q
 I $P(ref,"(")="^Q" S a=1/0 ;катастрофа
 S qStreem=1 I $G(ext) S qqz=$G(qview) N qqnump,qview  D  ;внешний вызов. qW должно быть
 .S qARM=##class(%TqARM).%New()
 .S qWEB=##class(%qWEB).%New()
 .S qSYS=##class(%qSYS).%New()
 .;S qW=##class(%qWORD).%New()
 .X "S qUSER=##class(qUSER).%New()" ;заморочки с контролем для V4
 .S qqnump="S",$$$Tree=0 K Vs(qqnump),Vo(qqnump),Vt(qqnump) D qSYS.BaseIni() ;K @ref ;?????? ;K V* @dol 21.10.03
 .S $$$ReFind=0,$$$RelNum=0,$$$Relind=0,$$$CurObj="",$$$CondFind="" S:$G(qqo)="" Vo(qqnump)=$G(qqc) ;@dol 13.02.04 S:$G(qqo)=""
 .I $G(extdo)'="" D qARM.Value(extdo,"X")
 ;
 I $G($$$Tree) D  Q:$Q "" Q  ;для физического дерева
 .M @ref@(qqo,qqc)=@$$$GloRef@(qqo,qqc)
 .D StreemAdd ;CC ???
 I $G(Vo(qqnump))="XXXX" D  Q:$Q "" Q  ;специальный вариант для копирования из проводника
 .I '$G(Rel) D StreemXXXX(qqo,qqc) Q
 .N qqrn S qqrn=$S('$$$RelNum:1,1:$$$Relind_qview) 
 .N qqo F qqo="XView","XQuery","CxObj","CxWoc" D StreemXXXX(qqo,"")
 I $G(Vo(qqnump))="XXXqWClass" Q:'$D(^Q($$$Relind_qview)) "Нет релевантных" N qqrn S qqrn=$G($$$ReFind),$$$ReFind=1 D  S $$$ReFind=qqrn Q:$Q "" Q  ;специальный вариант для копирования методов классов (только релевантные)
 .N qqc1,qqc2 S qqc1="" F  S qqc1=..gOrder(1,"XClass",qqc1,"") Q:qqc1=""  D
 ..S qqc2="" F  S qqc2=..gOrder(1,"XClassMetod",qqc2,qqc1) Q:qqc2=""  D
 ...;K @ref@("XClass",qqc1,"method",qqc2) M @ref@("XClass",qqc1,"method",qqc2)=^oddDEF(qqc1,"method",qqc2)
 ...K @ref@("XClass",qqc1_" "_qqc2) M @ref@("XClass",qqc1_" "_qqc2)=^oddDEF(qqc1,"method",qqc2) ;чтобы было видно при просмотре потока
 N qqrn I '$G(Rel),qqo'="",$G(qqc)'["*"  D StreemT(qqo,qqc,1,ref,1) Q:$Q "" Q  ;для логического дерева
 ;перечень релевантных
 S qqrn=$S('$G($$$RelNum):1,1:$$$Relind_qview)
 I qqo'="" D  Q:$Q "" Q  ;поддеревья текущего объекта
 .N qqc0 S qqc0=$S($G(qqc)["*":$P(qqc,"*"),1:"") ;@dol 9.12.03
 .S qqc=qqc0 F  S qqc=$O(^Q(qqrn,qqo,qqc)) Q:$S(qqc="":1,qqc0="":0,1:$E(qqc,1,$L(qqc0))'=qqc0)  D StreemT(qqo,qqc,1,ref,$S($G(Rel)=2:qqrn,1:1))
 ;вершины отображения (в qqc - код отображения)
 N view,y,qFlview S qFlview=1,view=qqc,y="" F  S y=$O(^Q(1,"XView",view,"CxObj",-1,"Xy",y)) Q:y=""  S qqo=$G(^(y,"X60")) D:qqo'=""
 .S qqrn=$S(view=$G(Vo(qqnump)):$S($G(qview)="":1,'$G($$$RelNum):1,1:$$$Relind_qview),$G(Rel):$$$Relind_view_" "_$P(qview," ",2),1:1)
 .S qqc="" F  S qqc=$O(^Q(qqrn,qqo,qqc)) Q:qqc=""  D StreemT(qqo,qqc,1,ref,$S($G(Rel)=2:qqrn,1:1))
 Q:$Q "" Q
StreemXXXX(qqo,qqc)
 I qqc'="" M @ref@(qqo,qqc)=^Q(1,qqo,qqc) D StreemAdd Q
 S qqc="" F  S qqc=$O(^Q(qqrn,qqo,qqc)) Q:qqc=""  M @ref@(qqo,qqc)=^Q(1,qqo,qqc) D StreemAdd
 Q
StreemAdd
 S @ref@(qqo,qqc,"C")=qqc S:$E(qqo)="C" @ref@(qqo,qqc,"CC")=$G(^Q(1,qqo,qqc))
 I cordtu S qqq=..oZcordtu() S:qqq'="" @ref@(qqo,qqc,"@Zcordtu")=qqq set qqq=..oZdtudel() s:qqq'="" @ref@(qqo,qqc,"@Zdtudel")=qqq  ; tdv 20080602 добавлено сохранение даты логического удаления
 I qqo="CxObj" K @ref@(qqo,qqc,"xWoc"),^("xObj") ;иначе при восстановлении возникают сложности с объектами и понятиями
 I qqo'="CxObj",qqo'="CxWoc" Q  ;Для объектов и понятий сделаем правильные значения кодированных понятий (а для X-объектов - ???? отображение, запросы)
 N qqw S qqw="" F  S qqw=$O(@ref@(qqo,qqc,qqw)) Q:qqw=""  S:$E(qqw)="x" @ref@(qqo,qqc,qqw)=..GetWoc("C"_qqw,$G(@ref@(qqo,qqc,qqw)))
 Q
StreemP(qqo,qqc) ;сохранение родителей (без понятий !!!)
 Q:$G(Nopar)  ;@dol 10.09.04 без родителей
 N qqob,qqobi,qObj,qqc0 S qqob=$G(^Q(1,"CxObj",qqo,"XORef"))
 F qqobi=1:1:$L(qqob,",")-1 S qObj=$P(qqob,",",qqobi) D
 .S qqc0=$E(qqc,1,$G(^Q(1,"CxObj",qObj,"X50"),255))
 .S ref=$NA(@ref@(qObj,qqc0)),@ref@("C")=qqc0
 Q
StreemT(qqo,qqc0,one,ref,qqrn) ;сохранение экземпляров с заданным кодом (one=1)
 N qqolst,qqolsti,qqc,qqq,qqw D:'$D(qqMasLst(qqo))  S qqolst=qqMasLst(qqo) ;объекты-потомки
 .S qqMasLst(qqo)=$S('$G(qFlview):$G(^Q(1,"CxObj",qqo,"xObj")),1:$G(^Q(1,"XView",view,"CxObj",qqo,"xObj")))
 .I $G(qFlview),$G(^Q(1,"XView",view,"CxObj",qqo,"x52"))=9 S qqMasLst(qqo,1)=$G(^Q(1,"XView",view,"CxObj",qqo,"X529")),qqMasLst(qqo)=$G(^Q(1,"XView",qqMasLst(qqo,1),"CxObj",qqo,"xObj")) ;@dol 19.06.03 ссылка на описание в другом отображении
 .I $G(qFlview) S qqAddqqw(qqo)=$G(^Q(1,"XView",$G(qqMasLst(qqo,1),view),"CxObj",qqo,"xWoc")) ;список понятий (если по отображению)
 .I $G(desobj)=1 S qqAddqqw(qqo)=$G(^Q(1,"CxObj",qqo,"xWoc")) ;@Dol 11.11.04 список понятий 
 .I qqMasLst(qqo)'="",qqrn'=1 S qqolst=qqMasLst(qqo),qqMasLst(qqo)="" D  S qqMasLst(qqo)=$E(qqMasLst(qqo),2,30000) ;уберем лишние
 ..F qqolsti=1:1:$L(qqolst," ") I $P(qqolst," ",qqolsti)'="",$D(^Q(qqrn,$P(qqolst," ",qqolsti))) S qqMasLst(qqo)=qqMasLst(qqo)_" "_$P(qqolst," ",qqolsti) ;только объекты из релевантных
 I one D StreemP(qqo,qqc0) ;K @ref@(qqo,qqc0) ;@dol 22.07.03 зачем удалять-то - вдруг добавление
 S qqc=qqc0 D:one  Q:one  F  S qqc=$O(^Q(qqrn,qqo,qqc)) Q:$E(qqc,1,$L(qqc0))'=qqc0  D
 .S:'$G(NoC)||($E(qqo)="C") @ref@(qqo,qqc,"C")=qqc S:$E(qqo)="C" @ref@(qqo,qqc,"CC")=$G(^Q(1,qqo,qqc))
 .I cordtu S qqq=..oZcordtu() S:qqq'="" @ref@(qqo,qqc,"@Zcordtu")=qqq set qqq=..oZdtudel() s:qqq'="" @ref@(qqo,qqc,"@Zdtudel")=qqq  ; tdv 20080602 добавлено сохранение даты логического удаления
 .I $S($G(desobj)=2:1,1:'$G(qFlview)&'$G(desobj)) S qqw="" F  S qqw=$O(^Q(1,qqo,qqc,qqw)) Q:qqw=""  D  ;@Dol 12.10.11 S($G(desobj)=2
 ..I $E(qqw,1,2)="TB" M @ref@(qqo,qqc,qqw)=^QT($E(qqw,2,255),1,qqo,qqc) Q
 ..I $D(^Q(1,qqo,qqc,qqw))>1 M @ref@(qqo,qqc,qqw)=^Q(1,qqo,qqc,qqw) Q  ; 20100830 maslova+tdv - перенос структурированных понятий
 ..I "TLMYX"[$E(qqw) Q:qqw="X"!(qqw="Xc")!(qqw="Xd")  M @ref@(qqo,qqc,qqw)=^Q(1,qqo,qqc,qqw) Q  ;.M @ref@(qqo,qqc,qqw)=^QT($E(qqw,2,255),1,qqo,qqc) А что делать с TB*  ; tdv 20080602 добавлена обработка даты логического удаления (Xd)
 ..S @ref@(qqo,qqc,qqw)=..GG(qqo,qqw,qqc)
 ..I "CD"'[$E(qqw) S:'$D(Vqqw712(qqw)) Vqqw712(qqw)=$G(^Q(1,"CxWoc",$S($E(qqw)'="R":qqw,1:$E(qqw,3,255)),"X712")) S:Vqqw712(qqw) @ref@(qqo,qqc,"C"_qqw)=^Q(1,qqo,qqc,qqw) ;@Dol 16.03.06 Флаг Значимые коды слов;@Dol 27.12.07 R*
 ..;I qqo="w"||(qqo="o")," "_$G(^Q(1,"CxObj",qqo,"xWoc"))_" "[(" C"_qqw_" ") S @ref@(qqo,qqc,"C"_qqw)=..GG(qqo,"C"_qqw,qqc) ;@Dol 10.11.04 
 ..I $E(qqo,1,2)="ww",$E(qqw)'="H" D  ;@Dol 31/10/03 Для объектов-словарей всегда сохранять характеристику понятия
 ...S @ref@(qqo,qqc,"H"_qqw)=..GG(qqo,"H"_qqw,qqc) S:'$D(ww) ww=" "_$G(^Q(1,"CxObj","ww","xWoc"))_" " ;@Dol 30.10.06
 ...S @ref@(qqo,qqc,"H0"_qqw)=..GG(qqo,"H0"_qqw,qqc) ;@Dol 16.07.07 для qMS обязательна
 ...S wwi=..GG(qqo,"HT"_qqw,qqc) M @ref@(qqo,qqc,"HT"_qqw)=W("HT"_qqw) ;@Dol 6.12.06 HT* ;???I $D(W("HT"_qqw))>1
 ...F wwi=1:1:9 I ww[("H"_wwi_qqw) S @ref@(qqo,qqc,"H"_wwi_qqw)=..GG(qqo,"H"_wwi_qqw,qqc)
 .I $S($G(desobj)=2:0,1:$G(qFlview)||$G(desobj)) F qqwi=1:1:$L(qqAddqqw(qqo)," ") S qqw=$P(qqAddqqw(qqo)," ",qqwi) I qqw'="",$E(qqw)'="Z" D  ;@Dol 10.11.04 Z*-понятия
 ..I $E(qqw,1,2)="TB" M @ref@(qqo,qqc,qqw)=^QT($E(qqw,2,255),1,qqo,qqc) S @ref@(qqo,qqc,qqw)=$G(@ref@(qqo,qqc,qqw)) Q  ;@Dol 25.11.04 пустые TB*
 ..I $D(^Q(1,qqo,qqc,qqw))>1 M @ref@(qqo,qqc,qqw)=^Q(1,qqo,qqc,qqw) Q  ; 20100830 maslova+tdv - перенос структурированных понятий
 ..I "TLMYX"[$E(qqw) Q:qqw="X"!(qqw="Xc")!(qqw="Xd")  D  Q  ;@dol 14.05.04 пустые значения ; tdv 20080602 добавлена обработка даты логического удаления (Xd)
 ...I '$D(^Q(1,qqo,qqc,qqw)) S @ref@(qqo,qqc,qqw)="" Q
 ...M @ref@(qqo,qqc,qqw)=^Q(1,qqo,qqc,qqw)
 ..S @ref@(qqo,qqc,qqw)=..GG(qqo,qqw,qqc)
 ..I "CD"'[$E(qqw) S:'$D(Vqqw712(qqw)) Vqqw712(qqw)=$G(^Q(1,"CxWoc",$S($E(qqw)'="R":qqw,1:$E(qqw,3,255)),"X712")) I Vqqw712(qqw),$D(^Q(1,qqo,qqc,qqw)) S @ref@(qqo,qqc,"C"_qqw)=^Q(1,qqo,qqc,qqw) ;@Dol 16.03.06 Флаг Значимые коды слов;@Dol 27.12.07 R*
 ..I $E(qqo,1,2)="ww",$E(qqw)'="H" S @ref@(qqo,qqc,"H"_qqw)=..GG(qqo,"H"_qqw,qqc) ;@Dol 31/10/03 Для объектов-словарей всегда сохранять характеристику понятия
 .I qqolst'="" F qqolsti=1:1:$L(qqolst," ") D:$P(qqolst," ",qqolsti)'=""
 ..I $G(qqMasLst(qqo,1))'="" N view S view=qqMasLst(qqo,1) ;@dol 19.06.03 для ссылочных
 ..D StreemT($P(qqolst," ",qqolsti),qqc,0,$NA(@ref@(qqo,qqc)),qqrn)
 Q
 ;!!!!!!C виртуальными - только наметка
StreemTvir(qqo,qqc0,one,ref,qqrn) ;сохранение экземпляров с заданным кодом (one=1) для виртуальных объектов только по отображению!!!
 N qqolst,qqolsti,qqc,qqq,qqw D:'$D(qqMasLst(qqo))  S qqolst=qqMasLst(qqo) ;объекты-потомки
 .S qqMasLst(qqo)=$G(^Q(1,"XView",view,"CxObj",qqo,"xObj"))
 .S qqAddqqw(qqo)=$G(^Q(1,"XView",view,"CxObj",qqo,"xWoc")) ;список понятий (если по отображению)
 .I qqMasLst(qqo)'="",qqrn'=1 S qqolst=qqMasLst(qqo),qqMasLst(qqo)="" D  S qqMasLst(qqo)=$E(qqMasLst(qqo),2,30000) ;уберем лишние
 ..F qqolsti=1:1:$L(qqolst," ") I $P(qqolst," ",qqolsti)'="",$D(^Q(qqrn,$P(qqolst," ",qqolsti))) S qqMasLst(qqo)=qqMasLst(qqo)_" "_$P(qqolst," ",qqolsti) ;только объекты из релевантных
 S qqc="" D:one  Q:one  F  S qqc=..gOrder(1,qqo,qqc,qqc0) Q:qqc=""  D
 .S @ref@(qqo,qqc,"C")=qqc
 .F qqwi=1:1:$L(qqAddqqw(qqo)," ") S qqw=$P(qqAddqqw(qqo)," ",qqwi) D:qqw'=""
 ..I $E(qqw,1,2)="TB" M @ref@(qqo,qqc,qqw)=^QT($E(qqw,2,255),1,qqo,qqc) Q
 ..I "TLMYXF"[$E(qqw) Q:qqw="X"!(qqw="Xc")!(qqw="Xd")  M @ref@(qqo,qqc,qqw)=^Q(1,qqo,qqc,qqw) Q  ;??? осмысленно для ссылочных ; tdv 20080602 добавлена обработка даты логического удаления (Xd)
 ..S qqz=..GG(qqo,qqw,qqc) I qqz'="" S @ref@(qqo,qqc,qqw)=qqz
 .I qqolst'="" F qqolsti=1:1:$L(qqolst," ") D:$P(qqolst," ",qqolsti)'="" StreemTvir($P(qqolst," ",qqolsti),qqc,0,$NA(@ref@(qqo,qqc)),qqrn)
 Q
]]></Implementation>
</Method>

<Method name="StreemImp">
<Description>
Восстановить массив потока
ref - ссылка на массив
Rel =1 - записать восстановленные в релевантные
qqo, qqc - для частичного восстановления
qqo - код восстанавливаемого объекта вершины потока . Если qqo="" - все вершины в потоке
qqc - код экземпляра восстанавливаемого объекта

Nbegqqc=1 - игнорировать диапазон кодов при замещении
Nbegqqc=2 - игнорировать диапазон кодов при замещении и порождениии
cqqc=1 - замещать одинаковые коды, 0 - всегда порождать новые

qqcbeg - желаемое начало кодов востанавливаемых экземпляров (!!!всех объектов)

Восстановленные экземпляры убираются из потока

При восстановлении, если есть понятие "C" у экземпляра объекта, то предполагается, что оно содержит желаемый код экземпляра (если cqqc=1)
В этом случае анализируется понятие Xch экземпляра. Если 1 - удаление всех потомков.

В описание объекта (CxObj - %Объекты) добавлен %Список ключевых понятий потока.
Обрабатывается при восстановлении потока для поиска замещаемого потоком экземпляра объекта (вне зависимости от значения понятия С в потоке !!!).
!!! Работает вне зависимости от cqqc!!!
Если не найден:
- берется из понятия С, если такового нет в базе;
- или создается новый

Xec - действие перед коррекцией экземпляра информацией потока.
В действии доступны:
qObj - код объекта
qqc - код экземпляра
Lqqw - список кодов понятий (через пробел) значения которых  помещены в W(qqw)
В результате действия Lqqw и соответствующие W(qqw) могут быть измены/добавлены.

Возможен вызов из постдействия после восстановления файла через gmaneger:
S qa=##class(%TqARM).%New(),qARM("Pars",9)="D qW.StreemImp(......) S qqend=1" D qa.Create()

!!! В методе использована своя обработка ошибок. Если возникает ошибка при восстановлении потока, временно отключить для отладки обработку ошибок в методе</Description>
<Internal/>
<FormalSpec>ref:%String,Rel:%String=0,cordtu:%String=1,Obj:%String,qqc:%String,Nobegqqc:%Library.String=1,cqqc:%Library.String=1,qqcbeg:%Library.String,Xec:%Library.String,LineChObj:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $G(ref)="" Q:$Q "No Ref" Q
 I '$D(@ref) D qARM.Message(ref_" не существует") Q:$Q "" Q
 I $G(qview)="" N qview S qview="XXXStreemImp"
 N qqrn,qqClass,qqo,qqwchg,qqcret,qStreemImp 
 N $ET S $ET="S qqcret=$ZE Q:$Q qqcret Q  " ;ОТКЛЮЧИТЬ (закоментировать) ДЛЯ ОТЛАДКИ
 S qqrn=$S($G(qqnump)="":0,1:+$G($$$Relind))_qview,Xec=$G(Xec) ;@dol 7.10.04 $G(qqnump)
 N qqnumpo S qqnumpo=$G(qqnump,0) N qqnump
 S qqnump="S" ;псевдоотображение для потока
 S qStreemImp=1 ;Флаг для триггеров
 K Vo(qqnump),Vs(qqnump) S Vo(qqnump)=$P($G(qview,"####")," ") S LineChObj=$G(LineChObj)
 S $$$Tree=0 ;только логическое дерево
 I $G(Obj)'="" D StreemI(Obj,ref,$G(qqc),1,cqqc) G StreemIend ;qqc????
 S Obj="" F  S Obj=$O(@ref@(Obj),-1) Q:Obj=""  D StreemI(Obj,ref,"",1,cqqc)
StreemIend I Rel,$D(^Q(qqrn)) S Vs(qqnumpo,"RelNum")=1,Vs(qqnumpo,"ReFind")=1
 I $D(qqClass) N error,er,qq,qqq S er="" D  Q:$Q er Q  ;компиляция обновленных классов
 .S qqClass="" F  S qqClass=$O(qqClass(qqClass)) Q:qqClass=""  D
 ..D Compile^%apiOBJ(qqClass,"-dfk",.error) S:'error error=""
 ..I 'error X "S "_$S($P(qqClass,".",2)="TqARM":"qARM",$P(qqClass,".",2)="qWORD":"qW",1:$P(qqClass,".",2))_"=##class("_qqClass_").%New()" Q
 ..S qq=error,error="Ошибка компиляции класса "_qqClass F qqq=1:1:qq S error=error_$C(13,10)_error(qq)
 ..S er=$S(er="":"",1:er_$C(13,10))_er
 Q:$Q $G(qqcret) Q
 ;
StreemI(Obj,ref,qqc0,level,cqqc) 
 ;cqqc=0 - явное порождение поддерева
 N ORef,qqc,qqw,Lqqc,Lqqw,qObj,qqc1,NoCor,qqwi,cqqc0,LYqqw,flagCxObj
 S qObj=Obj I LineChObj'="" S qObj=$P(LineChObj," ",level) S:qObj="" qObj=Obj ;@Dol 29.10.04 цепочка замен объектов
 S qqc=qqc0,cqqc0=cqqc
 I '$D(Vo(qqnump,qObj,220)) S Vo(qqnump,qObj,220)=$G(^Q(1,"CxObj",qObj,"X5220")) ;@dol 11.11.03 список ключевых потока
 S Lqqc=$G($$$ObjLqqc(qObj)) I Lqqc="" S $$$ObjLqqc(qObj)=$G(^Q(1,"CxObj",qObj,"X50"),255) ;$S($E(qObj)="C":255,1:$L(qqc0)+2)) ;?????
 S ORef="" F  S ORef=$O(@ref@(Obj,ORef)) Q:ORef=""  D
 .S qqc1=$G(^(ORef,"C")) ;,NoCor=$P(qqc1," ",2)
 .I $G(qqcbeg)'="",$E(Obj)'="C",$L(qqc0)<$L(qqcbeg),$E(qqcbeg,1,$L(qqc0))=qqc0 S qqc1=$E(qqcbeg,1,$$$ObjLqqc(qObj)) ;@dol 24.11.03;;10.10.04 $E(Obj)'="C" 
 .I $E(Obj)="X" D  Q  ;логическое дерево - прямая запись (с заменой кода)
 ..I Obj="XClass" N qqc S qqc=ORef,qqc0=$P(qqc," ",1),qqc1=$P(qqc," ",2),qqClass(qqc0)="" K ^oddDEF(qqc0,"method",qqc1) M ^oddDEF(qqc0,"method",qqc1)=@ref@("XClass",qqc) K @ref@("XClass",qqc) D:Rel  Q  ;восстановление методов класса
 ...I '$D(^Q(qqrn,Obj,qqc0))  S ^(qqc0)="" I $I(^Q(qqrn,Obj))
 ...N Obj S Obj="XClassMetod" I '$D(^Q(qqrn,Obj,qqc1)) S ^(qqc1)="" I $I(^Q(qqrn,Obj)) S ^Q(qqrn,"XClass",qqc0,Obj,qqc1)=""
 ..S W("@Zcordtu")=$G(^("@Zcordtu"))
 ..S W("@Zdtudel")=$G(^("@Zdtudel")) ; tdv 20080602 добавлена обработка даты логического удаления (Xd)
 ..K:qqc1'="" @ref@(Obj,ORef,"C") K:W("@Zcordtu")'="" @ref@(Obj,ORef,"@Zcordtu") K:W("@Zdtudel")'="" @ref@(Obj,ORef,"@Zdtudel") S:qqc1="" qqc1=ORef
 ..K ^Q(1,qObj,qqc1) M ^Q(1,qObj,qqc1)=@ref@(Obj,ORef) K @ref@(Obj,ORef) S:level=1 qqcret=qqc1
 .I Vo(qqnump,qObj,220)'="",$S(level'=1:1,1:$G(qqcbeg)="") D  ;@dol 11.11.03 поиск кода по ключевым понятиям;@Dol 28.10.04 $S(level' если задан нач.код, то его и использовать;@Dol 23.04,07 $G(qqcbeg)
 ..F qqwi=1:1:$L(Vo(qqnump,qObj,220)," ") S qqw=$P(Vo(qqnump,qObj,220)," ",qqwi) S:qqw'="" W(qqw)=$G(@ref@(Obj,ORef,qqw)) I qqwi=1,$S(W(qqw)="":1,1:'$D(^Q(1,qqw,$P(W(qqw)," "),Obj))) S qqwi=0 Q  ;@Dol 26.05.07 пустое значение или нет еще ссылок
 ..I qqwi S qqw=..Key(qObj,Vo(qqnump,qObj,220),"") I qqw'="" S qqc1=qqw Q
 ..Q:qqc1=""  S:$D(^Q(1,qObj,qqc1)) qqc1=""
 .I 'cqqc,cqqc0,qqc1'="" S cqqc=1
 .I cqqc,qqc1'="" D  I 1  ;желаемый qqc (Без контроля на длину кода???)
 ..I qqc0'="",level>1 S $E(qqc1,1,$L(qqc0))=qqc0
 ..S qqc=$E(qqc1,1,$$$ObjLqqc(qObj)) I '$D(^Q(1,qObj,qqc)) S:Nobegqqc Vo(qqnump,qObj,36)="",Vo(qqnump,qObj,37)="" S qqc=$P(..rNew(qObj,qqc,0)," ") Q
 ..I $G(@ref@(Obj,ORef,"Xch")) D ..rDel(qObj,qqc,,1) ;@dol 21.08.03 принудительное убиение потомков
 .E  S cqqc=0 S:Nobegqqc=2 Vo(qqnump,qObj,36)="",Vo(qqnump,qObj,37)="" S qqc=$P(..rNew(qObj,$S(qqc1="":qqc,qqc0="":qqc,1:qqc0_$E(qqc1,$L(qqc0)+1,$$$ObjLqqc(qObj))),0)," ")  ;порождение нового экземпляра 0-> qqc'=qqc0;;@dol 24.12.03 для сохранения того же кодаБ что и был (для YT) ; tdv 20081101 учитывается параметр Nobegqqc S:Nobegqqc Vo(qqnump,qObj,36)="",Vo(qqnump,qObj,37)="" ; tdv 20081124 - S:Nobegqqc заменено на S:Nobegqqc=2
 .S (Lqqw,LYqqw,qqw)="" S flagCxObj=''$d(@ref@(Obj,ORef,"CxObj")) F  S qqw=$O(@ref@(Obj,ORef,qqw)) Q:qqw=""  D
 ..I (flagCxObj)&&($D(@ref@(Obj,ORef,qqw))>1) S LYqqw=LYqqw_" "_qqw Q  ; 20100830 maslova+tdv - если flagCxObj=1 - восстанавливаем описание отображения, объекты описания переносим напрямую
 ..I $S(qqw?1.N:1,qqw="XObjStat":0,"YT"[$E(qqw)||($E(qqw,1,2)="HT")&&('$D(^Q(1,"CxObj",qqw))||($G(^Q(1,"CxObj",qqw,"x52"))=6)):0,1:$D(@ref@(Obj,ORef,qqw))>1) D StreemI(qqw,$NA(@ref@(Obj,ORef)),qqc,level+1,cqqc) Q  ;объект нижнего уровня;@Dol 12.05.06 '$D(^Q(1,"CxObj",qqw)) ; tdv 20080908 добавлена проверка на объект-массив ($G(^Q(1,"CxObj",qqw,"x52"))=6)
 ..I qqw'="YT","Y"[$E(qqw) S LYqqw=LYqqw_" "_qqw Q  ; структурированные понятий - переносим напрямую tdv 20100712 ; tdv 20101014 оставлены только понятия на Y - было "YT"[$E(qqw)
 ..S Lqqw=Lqqw_" "_qqw ;список понятий
 .F qqwi=2:1:$L(Lqqw," ") S qqw=$P(Lqqw," ",qqwi) K W(qqw),N(qqw) M W(qqw)=@ref@(Obj,ORef,qqw) I qqw="YT" S W(qqw)=0 K Vt(qqnump,"ZTmpYT") M Vt(qqnump,"ZTmpYT")=W(qqw)  ;@dol 24.12.03 иначе не записывалось в базу
 .S W("CC")=$G(@ref@(Obj,ORef,"CC")),W("@Zcordtu")=$G(^("@Zcordtu")),W("@Zdtudel")=$G(^("@Zdtudel"))  ; tdv 20080602 добавлена обработка даты логического удаления (Xd)
 .S:$G(W("CC"))'="" Lqqw=Lqqw_" CC"
 .D:Xec'="" qARM.Value(Xec,"X") ;@dol 3.12.03 действие перед восстановлением
 .F qqwi=2:1:$L(LYqqw," ") S qqw=$P(LYqqw," ",qqwi) K ^Q(1,qObj,qqc,qqw) M ^Q(1,qObj,qqc,qqw)=@ref@(Obj,ORef,qqw) ; структурированные понятий - переносим напрямую tdv 20100708
 .D:Lqqw'="" ..rCor(qObj,qqc,Lqqw) ;&('NoCor)
 .D:cordtu
 ..I $P(W("@Zcordtu"),";",2)'="" S ^Q(1,qObj,qqc,"Xc")=..zCnv(1,$ZDTH($P($P(W("@Zcordtu"),";",2)," ",1,2),8),$P($P(W("@Zcordtu"),";",2)," ",3)) ;дат. кор всегда @dol 20.06.03 I 'cqqc,$P(W("@
 ..I $P(W("@Zcordtu"),";",1)'="" S ^Q(1,qObj,qqc,"X")=..zCnv(1,$ZDTH($P($P(W("@Zcordtu"),";",1)," ",1,2),8),$P($P(W("@Zcordtu"),";",1)," ",3)) ;@dol 20.06.03 I Lqqw'="",$P(W("@Z
 ..I W("@Zdtudel")'="" S ^Q(1,qObj,qqc,"Xd")=..zCnv(1,$ZDTH($P(W("@Zdtudel")," ",1,2),8),W("@Zdtudel"))  ; tdv 20080602 добавлена обработка даты логического удаления (Xd)
 .I Rel,'$D(^Q(qqrn,Obj,qqc)) S ^(qqc)="" I $I(^Q(qqrn,Obj))
 .K @ref@(Obj,ORef) S:level=1 qqcret=qqc ;???поток очищается
 Q
]]></Implementation>
</Method>

<Method name="TestSort">
<Description>
тестирование на возможность сортировки по понятию вида qqo:qqc в объекте qqosort ( c дозаписью в локальную среду описаний объекта)</Description>
<Internal/>
<FormalSpec>qqw:%String,qqosort:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqo,ObjRef S qqo=$P(qqw,":"),qqw=$P(qqw,":",2) Q:"MXZL@HxR"[$E(qqw) 0
 S ObjRef=$S($D(Vo(qqnump,qqo,5)):$$$ObjRef(qqo),1:$G(^Q(1,"CxObj",qqo,"XORef"))) Q:","_ObjRef_","'[(","_qqosort_",") 0 ;пока только нижележащий
 S:'$D(Vo(qqnump,qqo,5)) Vo(qqnump,qqo,5)=ObjRef Q:$D(Vo(qqnump,qqo,0)) 1
 S Vo(qqnump,qqo,0)=$G(^Q(1,"CxObj",qqo,"X50")),Vo(qqnump,qqo,27)=$G(^Q(1,"CxObj",qqo,"X527")),Vo(qqnump,qqo,28)=$G(^Q(1,"CxObj",qqo,"X528"))
 I Vo(qqnump,qqo,27)'=""||Vo(qqnump,qqo,28) S Vt(qqnump,0)=1 ;флаг наличия условий вывода
 Q 1
]]></Implementation>
</Method>

<Method name="Translit">
<Description>
Транслитерация русских больших и маленьких букв

Arg1 - строка</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S Arg1=$TR(Arg1,"АБВГДЕЁЗИЙКЛМНОПРСТУФХЬЫЪЭЮабвгдеёзийклмнопрстуфхьыъэю","ABVGDEEZIYKLMNOPRSTUFH'Y'EYabvgdeeziyklmnoprstufh'y'ey")
 N b,n F b="Ж","Ц","Ч","Ш","Щ","Я","ж","ц","ч","ш","щ","я" S n=1 F  S n=$F(Arg1,b,n) Q:'n  D
 .S $E(Arg1,n-1)=$S(b="Ж":"ZH",b="Ц":"TS",b="Ч":"CH",b="Ш":"SH",b="Щ":"SCH",b="Я":"YA",b="ж":"zh",b="ц":"ts",b="ч":"ch",b="ш":"sh",b="щ":"sch",b="я":"ya")
 Q Arg1
]]></Implementation>
</Method>

<Method name="UserOrd">
<Description>
Вычисляет следующий (предыдущий) qqc для объекта с проверкой на общее начало
если полученный qqc не подходит, возвращается пусто
Var1-направление(1 или -1),Var2-код объекта,Var3-начальный qqc(если "", то берется Var4_$C(255) при Var1=-1),Var4-общее начало
Avto=1 - автоматическое определение общего кода по предыдущему объекту текущего отображения.
Cond - условие (относительно qqc,qqo) которое должно выполнятся
Cond=1 - учитывать условия вывода текущего объекта. Ecли объекта нет в отображении, условия берутся из описания объекта.

qqwsum - суммировать по заданному коду понятия (относительно обьекта Var2. Но можно использовать синтаксис qqo:qqw для взятия понятия из другого объекта). В этом случае обходятся все подходящие экземпляры и возвращается сумма.
Rel =1 По текущему перечню релевантных, если другое значение - то должно содержать ссылку на перечень релевантных ($$$Relind_qview). Например, в действиях по выходу из отображения перечень релевантных содержится в переменной viewf ;@Dol 30.10.09
raz - если задан и задано qqwsum, то возвращается не сумма, а список значений понятия qqwsum через разделитель raz</Description>
<Internal/>
<FormalSpec>Var1:%Library.String,Var2:%Library.String,Var3:%Library.String,Var4:%Library.String,Avto:%Library.String,Cond:%Library.String,qqwsum:%Library.String,Rel,raz</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 I $G(Avto) S Var4=$$$ObjRef(Var2),Var4=$$$ObjLqqc($P(Var4,",",$L(Var4,",")-1)),Var4=$E($S(Var3="":qqc,1:Var3),1,Var4) ;@dol 17.01.03
 I $G(Cond)=1 S Cond=$S($D(Vo(qqnump,Var2,27)):Vo(qqnump,Var2,27),1:$G(^Q(1,"CxObj",Var2,"X527"))) S:Cond="" Cond=1 ;@Dol 31.10.07
 S Rel=$S($G(Rel)="":1,Rel=1:$$$Relind_qview,1:Rel) ;@Dol 30.10.09
 Q:$G(Cond)="" $$$UserOrdA(Var1,Var2,$G(Var3),$G(Var4),Rel)
 N qqc,qqo S qqo=Var2,qqc=$G(Var3),Var2="" F  S qqc=$$$UserOrdA(Var1,qqo,qqc,$G(Var4),Rel) Q:qqc=""  I @Cond Q:'$D(qqwsum)  S:$G(raz)'="" Var2=$S(Var2="":"",1:Var2_raz)_qW.G(qqwsum) I $G(raz)="",$I(Var2,qW.G(qqwsum)) ;@Dol 7.02.05;29.03.10 raz
 Q $S('$D(qqwsum):qqc,1:Var2)
]]></Implementation>
</Method>

<Method name="X74Xcd">
<Description>
Специальное правило проверки для редактирования @ZXc и @ZXd
qqwcd=Xc или Xd
Создатся W(qqwcd) и изменяется qqwchg
если задан z, то это преобразуемая дата в формате ГГГГММДД. quser и qqwchg НЕ используются
@ank 20101101 Изменён алгоритм запаковки\распаковки дат</Description>
<Internal/>
<FormalSpec>qqwcd:%Library.String,z:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $D(z) N Z,quser,qqwchg,$ET S Z=z,qqwchg="",$ET="S $EC="""",W(qqwcd)="""" Q:$Q ""???"" Q  " ;для закачки
 I Z>99991231 S Z=""
 S W(qqwcd)=$S(Z="":"",1:$S((($ZDH(Z,8)\(256**2)>0)||($ZDH(Z,8)=0)):$C(0,0),1:"")_$RE($E($ZLC($ZDH(Z,8)),1,$S((($ZDH(Z,8)\(256**2)>0)||($ZDH(Z,8)=0)):3,1:2)))_$RE($E($ZLC($S(qqwcd="Xc":0,1:24*3600-1)),1,3))_$G(quser)),qqwchg=qqwchg_" "_qqwcd Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="gForm">
<Description>
qqnmax - максимально допустимое кол-во обрабатываемых экземпляров объекта
qxml=1 - формирование XML (=2 - включит атрибут id=qqc)
form - НЕ ИСПОЛЬЗУЕТСЯ

В варианте не XML создается массив состояния дерева экземпляров Vc (раньше W("C")).
Vc(qqnump) = текущая ORef - локальная объектная ссылка (раньше - W("Zrol",1))
Vc(qqnump,ORef)=OID - qqc
Vc(qqnump,ORef,0)=Obj - код объекта
Vc(qqnump,Oref,1)=0 - неактивный объект
Vc(qqnump,Oref,2)=1 - включен в релевантные
Vc(qqnump,Oref,5)=qqtime (дата, время, пользователь последней коррекции)

ORef - два символа на уровень иерархии (AA-$C(120,120)) с шагом 5 (для вставок).

xmlRef - глобал, в который записывается текст xml (при этом qqdev не учитывается)
picRef  - глобал, в который записываются картинки (при этом qqdev не учитывается)
qcodepage - перекодировать выходные данные в UTF-8 если =1 sas 20081205
innerRef - ссылка на глобал, куда пишутся стили для ОО (ширина столбцов встроеных таблиц, встроеная разметка) @rda 20090525
2010.09.02 rda вставка обработки значений дополнительных понятий при записи в XML при печати в OpenOffice.</Description>
<Internal/>
<FormalSpec>qql:%String=1,qqo:%String="""",qqc:%String="""",qqnmax:%String,add:%String,qxml:%String=0,full:%String=0,rewr:%Library.String,q6:%Library.String,xmlRef:%Library.String,picRef:%Library.String,qcodepage:%Library.String=0,picNameHead:%String,innerRef:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqbeg,qqcbeg,qqnum,qqci,qqso,qqgll,qqref,qqtree,qins,qqfmax,qqReFind,qqo87,qqvir,qqcbeg0,qqobeg0
 new dataLinkParamList,dataLinkResultList
 new dataLinkParamSep set dataLinkParamSep = "~"
 new dataLinkResultSep set dataLinkResultSep = "_$char(1)_"
 new exprCnt,prefixAndExpr,prefix,expr
 S qqReFind=$$$ReFind ;текущий режим (выбор/уточнение)
 S qqtree=+$G($$$Tree) ;признак дерева
 S qqfmax=$G(Vo(qqnump,-1,71),500) ;max при фиксации
 S:'$G(qqnmax) qqnmax=$S($G(Vo(qqnump,-1,60),20)="*":3000,1:$G(Vo(qqnump,-1,60),20))   ;;sasha 20080723
 I $G(Vs(qqnump,7))'="",qqfmax>qqnmax S qqnmax=qqfmax ;@dol 10.01.03 при фиксации
 S add=$G(add) S qins=add'="" ;вставка
 ;qqso - текущая строка объекта
 ;qqgll = признак поддерева главного объекта (выводится целиком)
 S qqgll=""
 S qqnum=0 ;текущее количество записей в дереве
 S qqref="" D:qqtree
 .S qqref=$S($G($$$GloRef)'="":$NA(@$$$GloRef,1),$E(Vo(qqnump),4,7)="sysS":"^QS(1)",1:$NA(^Q(qql))) ; текущая ссылка в дереве
 .I $G($$$GloRef)'="",qqc'="" S:add'="" qqref=$$$GloRef S $$$GloRef=$NA(@$$$GloRef@(qqo,qqc)) ;нужна полная ссылка для анализа
 S qqci="" ;текущий индекс в Vc(qqnump,qqci)
 S qqbeg=1,(qqcbeg0,qqcbeg)=$G(qqc),(qqobeg0,qqobeg)=$G(qqo) S:qqobeg'="" qqobeg=$G($$$ObjRef(qqobeg)) ;начальная объектная ссылка;@Dol 14.02.09 qqcbeg0, qqobeg0
 I qqobeg'="",qqcbeg="",'qqtree,$G(Vo(qqnump,qqo,2))<2 S qqcbeg=..gOrder(1,qqo,qqcbeg) ;?@Dol 6.10.06
 ;
 I add'="" D  G gFormend
 .N qqo1,qqci0,qi I $G(rewr) S qqci=add S Vc(qqnump)="" G gFormrw ;@dol 8.12.03 S Vc(qqnump)=""
 .S Vc(qqnump)=""
 .;наидем предыдущую строку и спозиционируемся на нее (с учетом зачеркнутых)
 .S qqso="",qqci0=add D
 ..F  S qqci0=$O(Vc(qqnump,qqci0),-1) Q:qqci0=""  S qqo1=Vc(qqnump,qqci0,0),qqci=qqci0 Q:'$G(Vs(qqnump,1,qqo1))
 .I qqci0="" S qqo1=-1,qqci=-1
 .I qqo1'=qqo,qqo1'=-1 F qi=$L(add):2:$L(qqci0) S qqci=$E(qqci0,1,qi),qqo1=Vc(qqnump,qqci,0) I '$G(Vs(qqnump,1,qqo1)) S qqso="" Q:$G(Vc(qqnump,qqci,40))=-1  D  Q:qqso'=""
 ..S qqso="" F  S qqso=$O(Vo(qqnump,qqo1,0,qqso),-1) Q:'qqso  Q:$G(Vo(qqnump,qqo1,0,qqso))'=""  Q:$G(Vs(qqnump,1,qqo1,qqso))'=2&&($G(Vs(qqnump,1,qqo1,0))'=-2)
 ..I $G(Vo(qqnump,qqo1,0,qqso))'="" S qqso=""
 .I qqso="" D   ;@dol 18.01.03
 ..I $G(Vs(qqnump,1,qqo1,0))=-2 S qqso=0 Q
 ..I $G(Vc(qqnump,qqci,40))=-1 S qqso=0 Q  ;свернут, не выведен
 ..F  S qqso=$O(Vo(qqnump,qqo1,0,qqso),-1) Q:qqso=""  Q:$G(Vo(qqnump,qqo1,0,qqso))=qqo
 ..F  S qqso=$O(Vo(qqnump,qqo1,0,qqso),-1) Q:qqso=""  I $G(Vo(qqnump,qqo1,0,qqso))="",$G(Vs(qqnump,1,qqo1,qqso))'=2 Q
 .I qqso||(qqci'=-1) D qARM.wM(qwin_".T2","M9",1,0,qqci_" "_qqo1_" "_qqso,"","")
gFormrw .D  ;код экземпляра верхнего объекта
 ..I $G(q6)'="" S qqo1=$P(q6,"~",$L(q6,"~")) Q  ;@dol 28.02.04
 ..S qqo1=$S($L(add)=2:"",1:Vc(qqnump,$E(qqci,1,$L(add)-2)))
 .S qqci=add,qqob=$$$ObjRef(qqo),qqci0=0 F qi=1:1:$L(qqob,",") I '$G(Vs(qqnump,1,$P(qqob,",",qi))) S qqci0=qqci0+1 ;@dol 11.11.02 подсчет незачеркнутых
 .S:$G(Vo(qqnump,qqo,2)) Vs(qqnump,"Virt",qqo)=qqc ;@dol 9.02.03
 .D ggwto(qqo,$L(qqob,","),qqo1,"",qqref,qqci0,1,$G(q6),$P(qqob,",",$L(qqob,",")-1)) ;@Dol 20.09.06 qqopa
 I $G(qqc)'="",$D(Vt(qqnump,111)),$L(qqobeg,",")>1,$D(Vc(qqnump))>1 D
 .S qqvir=0 F qqso=1:1:$L(qqobeg,",") I $G(Vo(qqnump,$P(qqobeg,",",qqso),2)) S qqvir=1 Q  ;есть виртуальные предки???
 .Q:'qqvir
 .I $G(Vs(qqnump,7))'="",Vs(qqnump,7)'=qqo,","_qqobeg[(","_Vs(qqnump,7)_",") S qqcbeg=$P($$$CondFind," ",10) S:$G(Vo(qqnump,qqo,2)) Vs(qqnump,"Virt",qqo)=qqc Q
 K:0 Vc(qqnump) K:'qxml Vc(qqnump)
 K Vt(qqnump,669)
 ;Спецальная обработка вершины
 S qqso=0,qqo=-1,qqlev=0,qqobegg=qqobeg ;в нулевой строке постоянные заголовки и параметры граф (пропускаем для вывода)
 F  S qqso=$O(Vo(qqnump,-1,0,qqso)) Q:qqso=""  S %1=$P($G(Vo(qqnump,-1,0,qqso))," ") D
 .I %1'="" Q:qqnum>qqnmax  Q:$S($G(Vs(qqnump,7))="":0,1:%1'=$P(qqobeg,","))  S:qqobeg="" qqobeg=%1 D ggwto(%1,1,"",$S($G(Vo(qqnump,qqo,3)):-1,1:""),qqref,1) S:$G(Vs(qqnump,7))'="" qqnum=qqnmax+1 S:qqobegg="" qqobeg="" Q  ;чтобы не обрабатывать другие поддеревья
 .;стоки вершины
 .N qqci,qqciobj,qqflev S qqflev=0,qqci=-1,qqciobj=-1 I $G(Vs(qqnump,1,-1,qqso))'=2 S %1=..GetLine(qqc,qqo,qqso,qxml,$G(picRef),$G(picNameHead),$G(innerRef)) D wtwe() Q
gFormend S $$$ReFind=qqReFind
 I qxml Q:$Q qqnum Q
 Q:$Q qqnum Q
ggwto(qqo,qqlev,qqc0,qqgll,qqref,qqflev,one,qqfoc,qqopa) ;
 ;qqflev - физический (реальный) уровень
 ;qqfoc - @dol 12.11.02. список объектов и экземпляров (через ~) зачеркнутых на предыдущем уровне. Перенесется в Vc(qqnump,qqci,6). Необходим для коррекной обработки коррекции несуществующих (qqc c пробелом)
 ;qqc0 - начало кода
 ;qqopa- Объект предыдущего уровня (предок);@Dol 20.09.06
 I $S(add="":1,1:'$G(one)) K W("@Znum",qqo) ;@dol 9.8.03 сброс счетчика (на всякий случай)
 N qqob,qqciobj,qqocol,qqocolm,qqX54,qqX54b,qqNof,qqciold,qqval ;qqolast, ;;qqNof=1 - первый выводимый не первый в базе
 n isOutStr ; tdv 22.11.06 является ли строка выводимой
 Q:$G(Vs(qqnump,1,qqo))=-1  ;@Dol 8.10.04 блокировка
 I qqlev=1,$G(Vs(qqnump,1,qqo)) D  Q:qqob=""  ;@dol 12.11.03 блокировка вывода при зачеркивании всех объектов (?? а если несколько вершин??)
 .S qqob=-1 F  S qqob=$O(Vo(qqnump,qqob)) Q:qqob=""  Q:'$G(Vs(qqnump,1,qqob))
 S qqocolm=$G(Vo(qqnump,qqo,41)) S:qqocolm qqocol=1
 I $G(W("Zosrt"))'="",","_$G($$$ObjRef(W("Zosrt")))[(","_qqo_",") S qqX54b=1 ;@dol 10.1.04 блокировка свертки для объектов выше (не включая!!!)объекта сортировки
 S qqX54=$G(Vo(qqnump,qqo,4)) S:qqX54>2 qqX54=2 ;флаг свертки
 S:$G(Vs(qqnump,1,qqo))&&($G(Vs(qqnump,2,qqo))||$G(Vs(qqnump,2))) qqX54b=1,qqX54=0 ;@dol 29.07.05 блокировка свертки для зачеркнутых
 S one=+$G(one) ;@dol 10.11.02 признак вывода только одного экземпляра
 S qqob=$$$ObjRef(qqo)
 I $G(qqgll)="",'$G(qqX54b) S:$S($G(Vs(qqnump,7))="":1,1:Vs(qqnump,7)=qqo) qqgll=$S($G(Vo(qqnump,qqo,3)):qqo,1:"") I 1 ;S:qqgll'="" qqobeg=$P(qqobeg,",",1,qqlev) I 1 ;если стоим ниже главного, перевыводим все экземпляры если нет фиксации
 E  I $P(qqobeg,",",qqlev)'=qqo N qqbeg S qqbeg=0
 I qqbeg S:qqlev>$L(qqobeg,",") qqbeg=0 I qqbeg,$P(qqobeg,",",qqlev)'=qqo Q
 N qqc,qqso,qqoa,qqot
 S qqot=$G(Vo(qqnump,qqo,2)) K:qqot Vs(qqnump,"VirtOld",qqo) ;тип объекта.
 D  I qqc="" Q:$S($G(Vo(qqnump,qqo,40)):0,1:qqReFind)&0  Q:$G(Vo(qqnump,-1,87))=""&&($G(Vo(qqnump,qqo,87))="")  S qqo87=$G(Vo(qqnump,qqo,87)) S:qqo87'="" @("qqo87="_qqo87) Q:$S(qqo87=3!($G(Vo(qqnump,-1,87))=3):0,$G(Vo(qqnump,qqo,40)):0,1:qqReFind)  S:$S(qqo87="":W("ZBtred")+$S($G(Vo(qqnump,-1,87))=3:1,1:$G(Vo(qqnump,-1,87)))>1,qqo87=0:0,1:W("ZBtred")+$S(qqo87=3:1,1:qqo87)>1) qqc=$S(qqot=2:$G(Vs(qqnump,"Virt0",qqo),qqc0),1:qqc0)_" " Q:qqc=""  ;вывод отсутствующих
 .I qqtree D  Q
 ..S qqc="" I qqbeg,$P(qqobeg,",",qqlev)=qqo,$G($$$GloRef)'="" S qqc=$QS($$$GloRef,qqlev*2+1) I qqc'="" S:'$D(@qqref@(qqo,qqc)) qqc="",qqcbeg=""
 ..I qqc="" S qqc=$O(@qqref@(qqo,qqc),$S($G(Vs(qqnump,99,"Revers")):-1,1:1)) Q
 ..I 'qxml,'one,$S($P($G(Vo(qqnump,-1,669))," ")=qqo:1,1:$D(Vo(qqnump,qqo,11,"@ZXXmove"))),'$G(Vs(qqnump,1,qqo)) S qqNof=1 ;@Dol 21.05.08 'one
 .I qqot D  Q
 ..S qqc="" I qqbeg,$P(qqobeg,",",qqlev)=qqo,qqcbeg'="",qqgll=""||(qqo=qqgll)||$G(Vs(qqnump,99,"Auto")) S qqc=$G(Vs(qqnump,"Virt",qqo)) I qqc'="" S:'..gOrder(0,qqo,qqc,qqc0) qqc="",qqcbeg="" I qqc'="" D:'qxml&&('one)&&$S($P($G(Vo(qqnump,-1,669))," ")=qqo:1,1:$D(Vo(qqnump,qqo,11,"@ZXXmove")))&&('$G(Vs(qqnump,1,qqo)))   Q  ;@Dol 21.05.08 'one
 ...N qVirt S qVirt=$G(Vs(qqnump,"Virt",qqo)) I $G(W("Zosrt"))'=qqo S qqNof=..gOrder(-1,qqo,qqc,qqc0)'="",Vs(qqnump,"Virt",qqo)=qVirt Q
 ...N qqww,qqwz S qqww=$P($$$CondFind," "),qqwz=$G(W(qqww)) S qqNof=..gOrder(-1,qqo,qqc,qqc0)'="",W(qqww)=qqwz,Vs(qqnump,"Virt",qqo)=qVirt 
 ..S Vs(qqnump,"VirtOld",qqo)=$G(Vs(qqnump,"Virt",qqo))
 ..S qqc=..gOrder(1,qqo,qqc,qqc0)
 .S qqc=qqc0 I qqbeg,$P(qqobeg,",",qqlev)=qqo,$L(qqcbeg)'<$L(qqc)||$G(qqvir),qqcbeg'="",qqgll=""||(qqo=qqgll)||$G(Vs(qqnump,99,"Auto")) S qqc=$S('$G(qqvir):$E(qqcbeg,1,$$$ObjLqqc(qqo)),1:$G(Vs(qqnump,"Virt",qqo))) S:'..gOrder(0,qqo,qqc,qqc0) qqc=qqc0,qqcbeg="" ;;????@dol 4.03.02 '$G(Vs(qqnump,99,"Auto")) для перемещений при автовыборе;было $L(qqcbeg)>$L(qqc) ;||$G(Vs(qqnump,99,"Auto"))
 .I qqc=qqc0 S qqc=..gOrder(1,qqo,qqc,qqc0) Q
 .I $G(W("Zosrt"))=qqo,$P($$$CondFind," ")'="" S W($P($$$CondFind," "))=qW.GG(qqo,$P($$$CondFind," "),qqc) ;@Dol 02.03.08 иначе задваивание первой строки
 .I 'qxml,'one,$S($P($G(Vo(qqnump,-1,669))," ")=qqo:$G(Vt(qqnump,"SBM"),1),1:$D(Vo(qqnump,qqo,11,"@ZXXmove"))),'$G(Vs(qqnump,1,qqo)),$S($G(Vs(qqnump,7))'=qqo:1,1:'$G(Vs(qqnump,17))) D  ;@Dol 10.12.04 при сортировке - беда!!! ;@Dol 21.05.08 'one
 ..I $G(W("Zosrt"))'=qqo||($P($$$CondFind," ")="") S qqNof=..gOrder(-1,qqo,qqc)'="" Q  ;,qqc0)'="" Q  ;@Dol 27.08.06;;@Dol 4.12.06 $P($$$CondFind," ")
 ..N qqww,qqwz S qqww=$P($$$CondFind," "),qqwz=$G(W(qqww)) S qqNof=..gOrder(-1,qqo,qqc,qqc0)'="",W(qqww)=qqwz 
 ;F  D  Q:qqot=1!one  Q:$S($G(Vs(qqnump,7))="":0,'$D($$$ObjRef(Vs(qqnump,7))):0,1:qqlev'>$L($$$ObjRef(Vs(qqnump,7)),","))  Q:$S(qxml:qqnum>qqnmax,qqnum>qqfmax:1,qqgll="":qqnum>qqnmax,qqnum>qqnmax:","_$$$ObjRef(qqo)'[(","_qqgll_","),1:0)  S qqc=$S(qqtree:$O(@qqref@(qqo,qqc),$S($G(Vs(qqnump,99,"Revers")):-1,1:1)),'qqbeg:..gOrder(1,qqo,qqc,qqc0),qqot>1&&(qqot<8):..gOrder(1,qqo,qqc,qqc0),$E(qqcbeg,1,$L(qqc0))=qqc0:$E(qqcbeg,1,$L(qqc)),1:"") Q:qqc=""  I qqtree,$G(Vs(qqnump,7))=qqo,$E(qqc,1,$L($P($$$CondFind," ",10)))'=$P($$$CondFind," ",10) Q
 F  D  Q:qqot=1!one  Q:$S($G(Vs(qqnump,7))="":0,'$D($$$ObjRef(Vs(qqnump,7))):0,1:qqlev'>$L($$$ObjRef(Vs(qqnump,7)),","))  Q:$S(qxml:qqnum>qqnmax,qqgll'="":$S(","_$$$ObjRef(qqo)'[(","_qqgll_","):qqnum>qqnmax,qqnum>3000:1,1:0),qqnum>qqfmax:1,1:qqnum>qqnmax)  S qqc=$S(qqtree:$O(@qqref@(qqo,qqc),$S($G(Vs(qqnump,99,"Revers")):-1,1:1)),'qqbeg:..gOrder(1,qqo,qqc,qqc0),qqot>1&&(qqot<8):..gOrder(1,qqo,qqc,qqc0),$E(qqcbeg,1,$L(qqc0))=qqc0:$E(qqcbeg,1,$L(qqc)),1:"") Q:qqc=""  I qqtree,$G(Vs(qqnump,7))=qqo,$E(qqc,1,$L($P($$$CondFind," ",10)))'=$P($$$CondFind," ",10) Q  ;@Dol 03.02.09 обработка главных объектов qqgll'="" ;$S(qxml:qqnum>qqnmax,qqnum>qqfmax:1,qqgll="":qqnum>qqnmax,qqnum>qqnmax:","_$$$ObjRef(qqo)'[(","_qqgll_","),1:0)
 .S:$G(Vo(qqnump,qqo,400))'="" @("qqX54="_Vo(qqnump,qqo,400)) ;выражение для флага свертки
 .I qqocolm,qqocol>1 S Vc(qqnump,qqci)=Vc(qqnump,qqci)_"~"_qqc,qqocol=qqocol+1 Q:qqocol'>qqocolm  D gFormM S qqocol=1 Q
 .I 'qqtree,'qqot,$G(W("Zosrt"))=qqo,$E(qqc,1,$L(qqc0))'=qqc0 S qqcbeg=qqc,qqbeg=1,qqobeg=$$$ObjRef(qqo),qqot=1 Q
 .I qxml,qxml<6 N qxmlnam D
 ..I qxml=5 S qxmlnam=$G(Vo(qqnump,qqo,101)) S:qxmlnam="" qxmlnam=qARM.GetPar("X5101",,qqo) Q:qxmlnam="-"  S:qxmlnam="" qxmlnam="O"_$TR(qqo,"@","o") D write("<"_qxmlnam_">") Q  ;@Dol 27.08.04 XML-имя для внешнего файла ;@Dol 11.01.09 Q:qxmlnam="-"
 ..D write("<O"_$TR(qqo,"@","o")_$S(qxml=1:"",1:" id='"_qqc_"'")_">")
 .D:'$G(Vs(qqnump,1,qqo))  ;не зачеркнутый
 ..S qqnum=qqnum+1
 ..I qxml Q
 ..S qqciold=qqci ;@Dol 10.03.06 для X5246
 ..I $G(add)'="" S add="",qqciobj=qqci I 1
 ..E  S qqlevi=qqflev-1*2,qqcii=$O(Vc(qqnump,$E(qqci,1,qqlevi)_$C(255,255)),-1),(qqciobj,qqci)=$E(qqci,1,qqlevi)_$S($L(qqcii)<(qqlevi+2):"AA",$E(qqcii,1,qqlevi)'=$E(qqci,1,qqlevi):"AA",1:$S($A(qqcii,qqlevi+2)>120:$C($A(qqcii,qqlevi+1)+1,65),1:$E(qqcii,qqlevi+1)_$C($A(qqcii,qqlevi+2)+3))) ;sasha 20080723 
 ..I $G(qqNof) S qqNof=$O(Vc(qqnump,qqciobj),-1) S:qqNof=""||($G(Vc(qqnump,$E(qqNof,1,$L(qqciobj)),0))'=qqo) Vt(qqnump,"ZXXmove",qqo,qqciobj,1)="" K qqNof ; @dol 7.05.04 для указателей возможных перемещений
 ..I qqX54=1 S Vs(qqnump,2,-1,qqo,qqci)="" ;объект свернут
 ..I $G(qqfoc)'="" S Vc(qqnump,qqci,6)=qqfoc ;@Dol 18.11.04 ,qqfoc="" ;@dol 12.11.02 зачеркнутых на предыдущем уровне
 ..S Vc(qqnump,qqci)=qqc,Vc(qqnump,qqci,0)=qqo I $$$RelNum S Vc(qqnump,qqci,2)=$S($$$ReFind:1,$G(Vo(qqnump,qqo,2))<2||($G(qqopa)=""):''$D(^Q($$$Relind_qview,qqo,qqc)),1:''$D(^Q($$$Relind_qview,qqopa,qqc0,qqo,qqc))) ;релевантные в дереве
 ..I W("ZBtred"),'qqtree S Vc(qqnump,qqci,5)=$G(^Q(1,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)),qqc,"X")) ;нужно сохранить qqtime и затем анализировать при коррекции
 .I qqbeg S:qqlev=$L(qqobeg,",") qqbeg=0 I 'qxml,'$G(Vo(qqnump,-1,660)),qqbeg,qqgll="",'$G(Vs(qqnump,1,qqo)) S Vc(qqnump,qqci,1)=0  ;@Dol 23.02.05
 .;I 'qxml,'qqbeg,$G(Vc(qqnump))="",$P(qqobeg,",",qqlev)=qqo,$S(qqtree:1,qqot:$S($G(Vs(qqnump,"VirtOld",qqo))="":1,1:$G(Vs(qqnump,"VirtOld",qqo))=qqc),qqgll="":1,$L(qqcbeg)<$L(qqc):1,1:qqc=$E(qqcbeg,1,$$$ObjLqqc(qqo))) S Vc(qqnump)=qqci S:qqtree $$$GloRef=qqref
 .I 'qxml,'qqbeg,$G(Vc(qqnump))="",qqobeg0=qqo,$S(qqtree:1,qqot:$S($G(Vs(qqnump,"VirtOld",qqo))="":1,1:$G(Vs(qqnump,"VirtOld",qqo))=qqc),qqgll="":1,$L(qqcbeg0)<$L(qqc):1,1:qqc=qqcbeg0,1:qqc=$E(qqcbeg0,1,$$$ObjLqqc(qqo))) S Vc(qqnump)=qqci S:qqtree $$$GloRef=qqref ;@Dol 14.02.09 $P(qqobeg,",",qqlev)=qqo=>qqobeg0=qqo
 .I qqocolm S qqocol=qqocol+1 Q
 .I qqX54,'$G(Vs(qqnump,1,qqo)),$S($G(qqX54b):1,$G(Vs(qqnump,2,qqo,qqc)):1,$G(Vs(qqnump,2,qqo)):1,1:$G(Vs(qqnump,2))=1) N qqX54 S qqX54=0 D:'qxml  ;@dol 17.8.03 $G(Vs(qqnump,2))=1 - все ;;@dol 16.1.4 ???? I $G(Vo(qqnump,qqo,4))
 ..S Vc(qqnump,qqci,40)=1 D
 ..I "12"[+$G(Vo(qqnump,qqo,4)) S Vt(qqnump,"Expand")=qqci_" "_qqo_" 0" ;@dol 29.03.03 отработка перевывода ;,$G(Vt(qqnump,"Expand"))=""
 .I $G(Vo(qqnump,qqo,249))'="" D  ;@Dol 21.10.06 список выводимых строк
 ..I $TR(Vo(qqnump,qqo,249),"-0123456789 ")'="" S @("qqval="_Vo(qqnump,qqo,249)) Q
 ..S qqval=Vo(qqnump,qqo,249)
 .S qqso="" F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""   S %1=$G(Vo(qqnump,qqo,0,qqso)) D  I isOutStr,qqnum>qqnmax,(","_$$$ObjRef(qqo)'[(","_qqgll_",")) Q
 ..s isOutStr=$S($G(qqval)="":1,%1'=""&&(+qqval=-1):1,1:" "_qqval_" "[(" "_qqso_" ")) ; tdv 22.11.06 - является ли строка выводимой
 ..i 'isOutStr d  q  ; если не выводится - пишет тег с номером строки
 ...i %1="",qxml,qxml<6 d write("<NotOutStr num='"_qqso_"'/>")
 ..I %1="" D:'$G(Vs(qqnump,1,qqo))  Q
 ...I 'qxml,'qqso,qqX54>1 S Vc(qqnump,qqci,40)=-1 ;@dol 18.02.03
 ...I qqso,qqX54>1||($G(Vs(qqnump,1,qqo,qqso))=2)||($G(Vs(qqnump,1,qqo,0))=-2) Q  ;@dol 18.01.03 $G(Vs(qqnump,1,qqo,qqso))=2 - зачеркнута строка ,$G(Vs(qqnump,1,qqo,0))=-2 - зачеркнуть все, кроме 0;Vc(qqnump,qqci,40)=-1  ;признак невыведенного свернутого;;||($G(Vo(qqnump,qqo,249))'="")
 ...I qqso,qqtree,'qxml,$G(Vc(qqnump,qqci,1))=0 Q  ;для дерева для неактивных только первая строка
 ...S %1=..GetLine(qqc,qqo,qqso,qxml,$G(picRef),$G(picNameHead),$G(innerRef))
 ...; sasha 20080929
 ...d:qxml=9 ..gFormdbf() 
 ...I %1'="" D wtwe() Q
 ...I W("ZBtred")!($G(Vo(qqnump,-1,65)))!(qqff'=""),$S(qxml:1,1:$G(Vc(qqnump,qqci,1))'=0) D wtwe() Q  ;qqff'=""- есть флаг
 ...Q:qqso
 ...D wtwe() Q
 ..Q:$G(Vs(qqnump,3,qqo))  I qqX54>1 S:qqbeg&&($P(qqobeg,",",qqlev)=qqo) qqbeg=0,qqcbeg=qqc,qqobeg=$P(qqobeg,",",1,qqlev) S:0 Vc(qqnump,qqci,40)=-1 Q  ;признак невыведенного свернутого
 ..I $G(Vs(qqnump,7))'="",$D($$$ObjRef(Vs(qqnump,7))),qqlev<$L($$$ObjRef(Vs(qqnump,7)),","),","_$$$ObjRef(Vs(qqnump,7))_","'[(","_%1_",") Q  ;@dol 19.10.02 более корректная обработка фиксации ;@dol 18.01.03 Q:$G(Vs(qqnump,3,qqo)) вместо Q:qqolast
 ..D ggwto($P(%1," "),qqlev+1,qqc,qqgll,$S('qqtree:"",1:$NA(@qqref@(qqo,qqc))),'$G(Vs(qqnump,1,qqo))+qqflev,,$S($G(Vs(qqnump,1,qqo)):$S($G(qqfoc)="":"",1:qqfoc_"~")_qqo_"~"_qqc,1:""),qqo)
 ..I $G(Vo(qqnump,qqo,246)),$E($O(Vc(qqnump,qqciobj)),1,$L(qqciobj))'=qqciobj,$G(Vt(qqnump,0))'=0 D qARM.wM(qwin_".T2","M9",1,0,qqci_" "_qqo_" 0"),qARM.wM(qwin_".T2","DeleteDependents","") K Vc(qqnump,qqci) S (qqci,qqciobj)=qqciold S qqnum=qqnum-1 ;@Dol 10.03.06 X5246 - не выводить без потомков
 .I qxml,qxml<6 D
 ..D:$G(Vo(qqnump,qqo,7))'=""   ;@Dol 1.10.04 вывод в XML дополнительных понятий (X57)
 ...N qqwi,qqw,qqwz F qqwi=1:1:$L(Vo(qqnump,qqo,7)," ") S qqw=$P(Vo(qqnump,qqo,7)," ",qqwi) i qqw'="" S qqwz=..GG(qqo,qqw,qqc) D write("<"_$S($E(qqw)?1N:"O",1:"")_$TR(qqw,"@:","oo")_">"_$S(($g(x320)=10)||($g(x320)=11):qW.ConvertTag2OO(qqwz,innerRef),qqwz[$C(13,10):..CXMLdoc(qqwz),1:..CXML(qqwz))_"</"_$S($E(qqw)?1N:"O",1:"")_$TR(qqw,"@:","oo")_">") ;@Dol 18.05.06 ..CXMLdoc ;@rda 01.10.2010 ..ConvertTag2OO(...)
 ..I qxml=5 Q:qxmlnam="-"  D write("</"_$P(qxmlnam," ")_">") Q  ;@Dol 27.08.04 XML-имя для внешнего файла;@Dol 11.01.09 Q:qxmlnam="-"
 ..D write("</O"_$TR(qqo,"@","o")_">")
 I $G(W("ZBtred")),'qxml,$D(Vo(qqnump,qqo,11,"@ZXXadd")),'$G(Vs(qqnump,1,qqo)),$L($G(qqciobj))>1,$G(Vc(qqnump,qqciobj))'[" " S Vt(qqnump,"ZXXadd",qqo,qqciobj)=""
 I qqc'="",'one,'qxml,$S($P($G(Vo(qqnump,-1,669))," ")=qqo:$G(Vt(qqnump,"SBM"),1),1:$D(Vo(qqnump,qqo,11,"@ZXXmove"))),'$G(Vs(qqnump,1,qqo)),$L($G(qqciobj))>1,$G(Vc(qqnump,qqciobj))'[" ",$S($G(Vs(qqnump,7))'=qqo:1,1:'$G(Vs(qqnump,17))) S Vt(qqnump,"ZXXmove",qqo,qqciobj,2)=""  ;@dol 7.05.04 для указателей возможных перемещений;@Dol 7.06.07 жесткая фикс Vs(qqnump,17) ;@Dol 29.04.08 Vt(qqnump,"SBM")=0 -блокировка скролбара
 I qqocolm,qqocol>1 D gFormM
 I $G(W("Zosrt"))=qqo,qqc="" S qqnum=99999999999
 Q
gFormM
 S qqso="" F  S qqso=$O(Vo(qqnump,qqo,0,qqso)) Q:qqso=""  S %1=$G(Vo(qqnump,qqo,0,qqso)) D  Q:qqnum>qqnmax&(","_$$$ObjRef(qqo)'[(","_qqgll_","))
 .I %1="" D:'$G(Vs(qqnump,1,qqo))  Q
 ..I qqso,qqtree,'qxml,$G(Vc(qqnump,qqci,1))=0 Q  ;для дерева для неактивных только первая строка 
 ..S %1=..GetLine(qqc,qqo,qqso,qxml,$G(picRef),$G(picNameHead),$G(innerRef))
 ..I %1'="" D wtwe() Q
 ..I W("ZBtred")!($G(Vo(qqnump,-1,65)))!(qqff'=""),$S(qxml:1,1:$G(Vc(qqnump,qqci,1))'=0) D wtwe() Q  ;qqff'=""- есть флаг
 ..Q:qqso  D wtwe() Q
 .Q:$G(Vs(qqnump,3,qqo))  I $G(Vs(qqnump,7))'="",qqlev<$L($$$ObjRef(Vs(qqnump,7)),","),","_$$$ObjRef(Vs(qqnump,7))_","'[(","_%1_",") Q  ;@dol 19.10.02 более корректная обработка фиксации
 .D ggwto($P(%1," "),qqlev+1,qqc,qqgll,$S('qqtree:"",1:$NA(@qqref@(qqo,qqc))),'$G(Vs(qqnump,1,qqo))+qqflev,,$S($G(Vs(qqnump,1,qqo)):$S($G(qqfoc)="":"",1:qqfoc_"~")_qqo_"~"_qqc,1:"")) Q
 Q
write(str) D ..gFormwrite(str) Q   ///sas 20081208
wtwe() ;вывод
 I qxml D:%1'="" write($S(qxml>5&&$G(qqWinDos):$ZCVT(%1,"O","CP866"),1:%1)) Q  ;I qxml D write("<O"_qqo_"s"_qqso_">"_%1_"</O"_qqo_"s"_qqso_">") Q
 S:'$G(Vc(qqnump,qqciobj,1),1) qqso=qqso_" " ;для неактивной строки спец.номер (чтобы не устанавливать цвет) qqso_" "
 I '$D(Vt(qqnump,9,qqo_" "_qqso)) S qqzz=0  D  S:qqzz Vt(qqnump,9)=Vt(qqnump,9)+1 S Vt(qqnump,9,qqo_" "_qqso)=$S(qqzz:Vt(qqnump,9),1:-1) I qqzz,'qqso,$D(WQ(qqnump,"po"_qqo)) D qARM.wP(,"M3","po"_qqo,"")  ;картинка индекса
 .F qiii=0:1:$O(Vo(qqnump,qqo,0,+qqso,""),-1) S qiiii=$S($G(Vs(qqnump,1,qqo,+qqso,qiii)):"",1:$G(Vo(qqnump,qqo,0,+qqso,qiii))) I qiiii'=""  D  ;I $P(qqsty,",",6)'="" D qARM.wP("F"_$P(qqsty,",",5),"Size",8)  ;Vs(qqnump,1,qqo - зачеркнутые;;@Dol 21.07.09 $P(qqsty,",",6)
 ..I "67"[$E(qiiii) S:$E(qiiii)=6 Vt(qqnump,9,"FCBUT",qqo,+qqso,qiii)="FCBUT" S $E(qiiii)=$S($E(qiiii,2,4)="@ZX":2,1:0) ;для кнопки
 ..S qqz=$G(Vo(qqnump,qqo,0,+qqso,qiii,60)) I qqz'="" S Vt(qqnump,9,"FCBUT",qqo,+qqso,qiii)=qqz_" "_qARM.GetPar("X761",,qqo,+qqso,qiii) ;@Dol 19.09.05 стиль вывода (см. qARM.wwwwFCBUT
 ..I qqz="",$G(Vo(qqnump,qqo,0,+qqso,qiii,84))'="" S Vt(qqnump,9,"FCBUT",qqo,+qqso,qiii)="@" ;@Dol 13.07.08 для образцов X784
 ..I $G(Vo(qqnump,qqo,0,+qqso,qiii,20))'="" S Vt(qqnump,9,"PPP",qqo,+qqso,qiii)=$S($G(Vo(qqnump,qqo,0,+qqso,qiii,84))="":Vo(qqnump,qqo,0,+qqso,qiii,20),1:"@qARM.GetPar(""X720"",,qqo,"_(+qqso)_","_qiii_",,"""_qSYS.dblqw(Vo(qqnump,qqo,0,+qqso,qiii,20))_""")") ;@Dol 4.02.06 для образцов (X784) @dol 20.01.03 динамические параметры
 ..I $G(Vo(qqnump,qqo,0,+qqso,qiii,102))'="" S Vt(qqnump,9,"PPt",qqo,+qqso,qiii)=$S($G(Vo(qqnump,qqo,0,+qqso,qiii,84))="":Vo(qqnump,qqo,0,+qqso,qiii,102),1:"@qARM.GetPar(""X7102"",,qqo,"_(+qqso)_","_qiii_")") ;@dol 11.04.06 Всплывающие подсказки
 ..I $G(Vo(qqnump,qqo,0,+qqso,qiii,63))'="" S Vt(qqnump,9,"PPDL",qqo,+qqso,qiii)=$S($G(Vo(qqnump,qqo,0,+qqso,qiii,84))="":Vo(qqnump,qqo,0,+qqso,qiii,63),1:"@qARM.GetPar(""X763"",,qqo,"_(+qqso)_","_qiii_")") ;tdv 18.03.08 Пересчитываемое выражение
 ..I $G(Vo(qqnump,qqo,0,+qqso,qiii,6))'="" D  I 1 ;картинка ячейки
 ...I "@RF"[$E($TR(Vo(qqnump,qqo,0,+qqso,qiii,6),"- ")) S Vt(qqnump,9,"PP",qqo,+qqso,qiii)=$S($G(Vo(qqnump,qqo,0,+qqso,qiii,84))="":Vo(qqnump,qqo,0,+qqso,qiii,6),1:"@qARM.GetPar(""X76"",,qqo,"_(+qqso)_","_qiii_",,"""_qSYS.dblqw(Vo(qqnump,qqo,0,+qqso,qiii,6))_""")") D:$E(Vt(qqnump,9,"PP",qqo,+qqso,qiii))="-"  Q  ;@dol 9.01.03 если указан ресурс, то приравнивается к постоянной картинке;9.12.06 умолчания для образцов
 ....S Vt(qqnump,9,"PPd",qqo,+qqso,qiii)=$E(Vt(qqnump,9,"PP",qqo,+qqso,qiii),2,30000) K Vt(qqnump,9,"PP",qqo,+qqso,qiii) ;@Dol 03.03.08 картинки на выделенной строке - обрабатываются в qARM.wpoe
 ...S Vt(qqnump,9,"P",qqo_" "_(+qqso)_" "_qiii)=""
 ..E  S qqz=$G(Vo(qqnump,qqo,0,+qqso,qiii,30)) D  ;всегда видимые картинки;@dol 6.8.03 на кнопку не ставятся
 ...I qqz=9!($E(qiiii,1,4)="2@ZX"),'$D(Vt(qqnump,9,"FCBUT",qqo,+qqso,qiii)),$S($E(qqRES,4):1,"05"[$E(qiiii):1,1:$E(qiiii,1,4)="2@ZX") S Vt(qqnump,9,"PP",qqo,+qqso,qiii)="bu9" Q  ;указатель для псевдокнопки (развертка-действие для констант, выражений или @ZX*-понятий )@dol 23.10.02
 ...I $S(qqso:0,qiii:0,"15"'[(+$G(Vo(qqnump,-1,61))):0,1:$G(Vo(qqnump,qqo,4))) S Vt(qqnump,9,"PP",qqo,+qqso,qiii)=$S($G(qqXBp)="":"@$S($G(Vc(qqnump,qqci,40))=1:""p1"",1:""p0"")",1:"@$S($G(Vc(qqnump,qqci,40))=1:"""_$P(qqXBp," ",2)_""",1:"""_$P(qqXBp," ",1)_""")") Q  ;"arrow" Q  ;указатель сворачиваемого в бланке объекта
 ...I $G(Vo(qqnump,qqo,0,+qqso,qiii,84))'="",$E(qiiii)'=4 S Vt(qqnump,9,"PP",qqo,+qqso,qiii)="@qARM.GetPar(""X76"",,qqo,"_(+qqso)_","_qiii_")" Q  ;@Dol 4.02.06 для образцов (X784);9.12.06 умолчания
 ..S qqsty=$G(Vo(qqnump,qqo,0,+qqso,qiii,2))
 ..S qqsty0=$G(Vo(qqnump,-1,$S($E(qiiii)=0:50,$G(W("ZBtred"))&&($G(Vo(qqnump,qqo,0,+qqso,qiii,31))<0)&&($G(Vo(qqnump,-1,77))'=""):77,$E(qiiii)=5:51,$E(qiiii,1,4)="2@ZX":51,$G(W("ZBtred"))&&($G(Vo(qqnump,-1,664))'="")&&(qARM.GetPar("X740",,qqo,+qqso,qiii)||(" "_qARM.GetPar("X5223",,qqo)_" "[(" "_$E(qiiii,2,255)_" "))):664,1:52))) ;@Dol 9.11.07 X5223
 ..I $G(Vo(qqnump,-1,55))'="" S:$P(qqsty0,",",4)="" $P(qqsty0,",",4)=$P(Vo(qqnump,-1,55),",",1) S:$P(qqsty0,",",6)="" $P(qqsty0,",",6)=$P(Vo(qqnump,-1,55),",",2) ;параметры по умолчанию (понятия @ZX* приравнены выражениям)
 ..I $TR($P(qqsty0,",",4,9),",")_$P(qqsty0,",",2)_$TR($P(qqsty0,",",13,12),",")'="" F qqz=2,4:1:9,12,13 S:$P(qqsty,",",qqz)="" $P(qqsty,",",qqz)=$P(qqsty0,",",qqz) ;уточнить наследуемые ;@dol 9.03.03 2;;@Dol 27.02.05 12,13 
 ..I qqso'=+qqso S $P(qqsty,",",8,9)="," ;сброс цвета для неактивной строки
 ..I $P(qqsty,",",6)'="" S $P(qqsty,",",5)=+$P(qqsty,",",5) ;D qARM.wP("F"_$P(qqsty,",",5),"Size",$P(qqsty,",",6)) ;@Dol 21.07.09 $P(qqsty,",",6)
 ..I $P(qqsty,",",5)'="",$P(qqsty,",",6)="" S $P(qqsty,",",6)=8
 ..I $P(qqsty,",",2)'=""||($P(qqsty,",",7)'="")||$P($G(Vo(qqnump,-1,9,qiii)),",",2) D:'qqzz qARM.wM(qwin_".T3","AddItem","") D qARM.wP(qwin_".T3","CellTextAlign",$S($P(qqsty,",",2)'="":$P(qqsty,",",2),1:$P($G(Vo(qqnump,-1,9,qiii)),",",2))+(32*$P(qqsty,",",7)),Vt(qqnump,9)+1,qiii) S qqzz=1
 ..;I $E(qiiii)=0 S:$E(qiiii,2)="@" qiiii=0_$S(1!'$G(W("Zadm")):"",$L(qiiii)=2:qqo_" ",1:$E(qiiii,3,2000)_" ")_$TR($S($L(qiiii)=2:qARM.GetName(,qqo),1:qARM.GetName(,qqo,$E(qiiii,3,2000))),"%") D:'qqzz qARM.wM(qwin_".T3","AddItem","") D qARM.wP(qwin_".T3","M1",$TR($E(qiiii,2,32000),"_"," "),Vt(qqnump,9)+1,qiii,$S($P(qqsty,",",5)="":"",$P(qqsty,",",5)=0&($P(qqsty,",",6)=""):"",1:"F"_$P(qqsty,",",5)_" "_$P(qqsty,",",6)),$P(qqsty,",",9),$P(qqsty,",",8),$P(qqsty,",",13),$P(qqsty,",",12)) S qqzz=1 D  Q  ;@Dol 21.07.09 $P(qqsty,",",6)
 ..I $E(qiiii)=0 S:$E(qiiii,2)="@" qiiii=0_$S(1!'$G(W("Zadm")):"",$L(qiiii)=2:qqo_" ",1:$E(qiiii,3,2000)_" ")_$TR($S($L(qiiii)=2:qARM.GetName(,qqo),1:qARM.GetName(,qqo,$E(qiiii,3,2000))),"%") s:$g(XBLocal) qiiii=0_qSYS.getLocal($e(qiiii,2,$l(qiiii)),1) D:'qqzz qARM.wM(qwin_".T3","AddItem","") D qARM.wP(qwin_".T3","M1",$TR($E(qiiii,2,32000),"_"," "),Vt(qqnump,9)+1,qiii,$S($P(qqsty,",",5)="":"",$P(qqsty,",",5)=0&($P(qqsty,",",6)=""):"",1:"F"_$P(qqsty,",",5)_" "_$P(qqsty,",",6)),$P(qqsty,",",9),$P(qqsty,",",8),$P(qqsty,",",13),$P(qqsty,",",12)) S qqzz=1 D  Q  ;@Dol 21.07.09 $P(qqsty,",",6)
 ...S qqz=$G(Vo(qqnump,qqo,0,+qqso,qiii,30)) I qqz'="",qqz'<0,qqz<9||(qqz=21) D qARM.wP(,"M4","Bd",Vt(qqnump,9)+1,qiii,0) ;,wP(,"CellPictureAlign",2,Vt(qqnump,9)+1,qiii) ;указатель развертки;<8
 ..Q:'$E(qiiii)  I $P(qqsty,",",5)'=""||($TR($P(qqsty,",",8,9),",")'="")||($TR($P(qqsty,",",12,13),",")'="")  D:'qqzz qARM.wM(qwin_".T3","AddItem","") D qARM.wP(qwin_".T3","M1","",Vt(qqnump,9)+1,qiii,$S($P(qqsty,",",5)'="":"F"_$P(qqsty,",",5)_" "_$P(qqsty,",",6),1:""),$P(qqsty,",",9),$P(qqsty,",",8),$P(qqsty,",",13),$P(qqsty,",",12)) S qqzz=1  ;@Dol 21.07.09 $P(qqsty,",",6)
 ..S qiiii=$P(qiiii," ")
 ..I $S($E(qiiii,2,255)="":0,$D(W("ZaFind",qqo,$E(qiiii,2,255))):1,$G(W("Zosrt"),"??")=qqo&&$G(W("ZBs"_(qiii+1))):$E(qiiii,2,255)=$P($$$CondFind," ")||($G(W("Zosrt","y"))=(+qqso)&&($G(W("Zosrt","x"))=qiii)),1:0) D:'qqzz qARM.wM(qwin_".T3","AddItem","") D qARM.wP(qwin_".T3","M1","",Vt(qqnump,9)+1,qiii,"",$S($P($G(qqX155),",",8)="":16776960,1:$TR($P(qqX155,",",8),"*")),$TR($P($G(qqX155),",",7),"*"),$S($P($G(qqX155),",",10)="":16776960,1:$TR($P(qqX155,",",10),"*")),$S($P($G(qqX155),",",9)="":255,1:$TR($P(qqX155,",",9),"*"))) S qqzz=1 ;@Dol 21.04.09 ZaFind - автопоиск; цвета выделения из параметров базы
 I $G(Vo(qqnump,-1,61))=2,'W("ZBtred"),%1[$C(13,10) D  S qqso=+qqso D qARM.wM(qwin_".T2","M9",1,0,qqciobj_" "_qqo_" "_(+qqso)) G wtweP ;Q  ;??? а картинки ????спец.вывод многосточных пояснений
 .S qqz=2 F qiiii=1:1 D  Q:qiiii=qqz
 ..S qqsty="" F qiii=1:1:$L(%1,$C(31)) S $P(qqsty,$C(31),qiii)=$P($P(%1,$C(31),qiii),$C(13,10),qiiii) I qiiii=1,$L($P(%1,$C(31),qiii),$C(13,10))>qqz S qqz=$L($P(%1,$C(31),qiii),$C(13,10))
 ..D:$G(rewr) qARM.wP(qwin_".T2","M1",qqsty,"")
 ..D:'$G(rewr) qARM.wM(qwin_".T2","M2",$S(qins:"",1:-1),qqsty,qqflev-('qqso),qqciobj_" "_qqo_" "_(+qqso),0,$G(Vc(qqnump,qqciobj,1)),"") D:'$G(Vc(qqnump,qqciobj,1),1) qARM.wP(,"RowBackColor",8421504,"") I 'qqso,$G(Vs(qqnump,99,"Auto")),$$$MObjRef($$$ObjRef(qqo)) D qARM.wP(,"ItemExpandable",1,"") ;-2147483633,"")
 ..K rewr I Vt(qqnump,9,qqo_" "_qqso)'<0 D qARM.wM(,"M7",qwin_".T3","",Vt(qqnump,9,qqo_" "_qqso),0)
 D:$G(rewr) qARM.wP(qwin_".T2","M1",%1,"")
 D:'$G(rewr) qARM.wM(qwin_".T2","M2",$S(qins:"",1:-1),%1,qqflev-('qqso),qqciobj_" "_qqo_" "_(+qqso),0,$S($G(Vs(qqnump,99,"Auto")):1,1:$G(Vc(qqnump,qqciobj,1))),$S(qqso:"",$G(Vo(qqnump,qqo,244)):"",'$G(Vc(qqnump,qqciobj,1),1):"",$G(Vo(qqnump,-1,194))="":"",$G(Vo(qqnump,-1,821))'="":$P(Vo(qqnump,-1,194)," ",''qW.GG(qqo,Vo(qqnump,-1,821),qqc)+1),1:$P(Vo(qqnump,-1,194)," ",''$G(Vc(qqnump,qqciobj,2))+1))) D:'$G(Vc(qqnump,qqciobj,1),1) qARM.wP(,"RowBackColor",8421504,"") I 'qqso,"15"'[(+$G(Vo(qqnump,-1,61))),$S($G(Vs(qqnump,99,"Auto")):$$$MObjRef($$$ObjRef(qqo)),1:$G(Vo(qqnump,qqo,4))>1) D  ;@Dol 21.08.08 Vo(qqnump,-1,821)
 .I $G(Vo(qqnump,qqo,4))>1,'$$$MObjRef($$$ObjRef(qqo)) Q:$O(Vo(qqnump,qqo,0,0))=""  D qARM.wP(,"ItemExpandable",1,"") Q  ;есть свернутые строки
 .S qqz=$O($$$MObjRef($$$ObjRef(qqo))),qqz=$P(","_qqz,","_qqo_",",2) 
 .I qqz=""||($G(Vo(qqnump,qqz,2))=1) D qARM.wP(,"ItemExpandable",1,"") Q
 .Q:qqc[" "  I '$G(Vo(qqnump,qqz,2)) D  Q
 ..I $$$UserOrd(1,qqz,qqc,qqc)'=""||$G(Vo(qqnump,qqz,87)) D qARM.wP(,"ItemExpandable",1,"")
 .N qVirt S qVirt=$G(Vs(qqnump,"Virt",qqz)) I ..gOrder(1,qqz,"",qqc)'=""||$G(Vo(qqnump,qqz,87)) D qARM.wP(,"ItemExpandable",1,"") ;@Dol 10.10.05 ||($G(Vo(qqnump,qqo,87))'="") вывод отсутствующего ;;;не очень хороший способ определения наличия потомков ;-2147483633,"")
 .S Vs(qqnump,"Virt",qqz)=qVirt
 K rewr I Vt(qqnump,9,qqo_" "_qqso)'<0 D qARM.wM(,"M7",qwin_".T3","",Vt(qqnump,9,qqo_" "_qqso),W("ZBtred"))
wtweP D  ;@Dol 10.07.08 qqci->qqciobj
 .S qiii=$P($G(Vo(qqnump,qqo,0,qqso,0,2)),",",16) I qiii D  D qARM.wP(qwin_".T2","MinItemHeight",+qiii,"") Q
 ..I $G(qqXBwsize),$P($G(qqX155),",",2)>8 S qiii=$P(qARM.wsize("0,"_qiii),",",2) ;25.02.11
 .I "145"[Vo(qqnump,-1,61) D  D qARM.wP(qwin_".T2","MinItemHeight",+qiii,"") ;@Dol 10.02.08 - чтобы для бланка и таблицы (в них нет свертки дерева) строки были повыше (см qARM.Grid) 
 ..S qiii=19 I $G(qqXBwsize),$P($G(qqX155),",",2)>8 S qiii=$P(qARM.wsize("0,"_qiii),",",2) ;@Dol 11.03.11
 I qqff'="" F qiii=2:1:$L(qqff," ") S qiiii=$P(qqff," ",qiii)  D qARM.wP(,"M4","Flg"_(''$E(qiiii)),"",$E(qiiii,2,5),0) ;флаги (нужно переделать на постоянные картинки)
 I 'qxml,'qqso,$G(Vo(qqnump,qqo,242))'="" S qqz=Vo(qqnump,qqo,242) S Vt(qqnump,9,"FR",qqo,qqciobj)=qqz,Vt(qqnump,9,"FCBUT")=""
 I 'qxml,'qqso,$G(Vo(qqnump,qqo,245))'="" S Vt(qqnump,9,"FH",qqo,qqciobj)=Vo(qqnump,qqo,245),Vt(qqnump,9,"FCBUT")=""
 I $D(Vt(qqnump,9,"PP",qqo,+qqso)) S qiii="" F  S qiii=$O(Vt(qqnump,9,"PP",qqo,+qqso,qiii)) Q:qiii=""  D:'$G(Vs(qqnump,1,qqo,+qqso,qiii))  ;D wP(,"M4",Vt(qqnump,9,"PP",qqo,+qqso,qiii),"",qiii,0) ;постоянные картинки
 .I " 2@ZXXadd 2@ZXXmove 2@ZXXPntr "[(" "_$G(Vo(qqnump,qqo,0,+qqso,qiii))_" ") Q  ;@dol 18.05.03 для кнопки ввода - спец обработка
 .D qARM.wcellpic(qqo,+qqso,qiii,qqciobj) Q  ;@dol 1.12.03
 I $D(Vt(qqnump,9,"PPP",qqo,+qqso)) S qiii="" F  S qiii=$O(Vt(qqnump,9,"PPP",qqo,+qqso,qiii)) Q:qiii=""  D:'$G(Vs(qqnump,1,qqo,+qqso,qiii))  ;@dol 20.01.03 Вычисляемые параметры ячейки (пока - только цвет)
 .D qARM.wcelldpar(qqo,+qqso,qiii,qqciobj) Q  ;@dol 10.03.05
 I $D(Vt(qqnump,9,"PPt",qqo,+qqso)) D:'$G(Vt(qqnump,9,"PPt"))  S qiii="" F  S qiii=$O(Vt(qqnump,9,"PPt",qqo,+qqso,qiii)) Q:qiii=""  D:'$G(Vs(qqnump,1,qqo,+qqso,qiii)) qARM.wcellttips(qqo,+qqso,qiii,qqciobj) ;@dol 11.04.06 Всплывающие подсказки
 .D qARM.wP(qwin_".T2","OnToolTipCell_",1) S Vt(qqnump,9,"PPt")=1 Q  ;флаг вывода
 I $G(Vt(qqnump,786)) S qiii="" F  S qiii=$O(Vo(qqnump,qqo,0,+qqso,qiii)) Q:qiii=""  D:$G(Vo(qqnump,qqo,0,+qqso,qiii,86)) qARM.wP(qwin_".T2","CellItemData",$G(Vo(qqnump,qqo,0,+qqso,qiii,86)),"",qiii) ;@Dol 31.08.06 метки табуляции
 I $D(Vt(qqnump,9,"PPDL",qqo,+qqso)) S qiii="" F  S qiii=$O(Vt(qqnump,9,"PPDL",qqo,+qqso,qiii)) Q:qiii=""  D:'$G(Vs(qqnump,1,qqo,+qqso,qiii))  ;tdv 20080520 пересчитываемые выражения
 .set dataLinkParamList=Vt(qqnump,9,"PPDL",qqo,+qqso,qiii)
 .set dataLinkResultList=..getDataLinkResultList(dataLinkParamList)
 .do qARM.wP(qwin_".T2","CellDataLink",dataLinkResultList,"",qiii)
 ;
 S qqso=+qqso I 'qxml,qqo'=-1 S Vc(qqnump,qqciobj,11,qqso)=1 Q  ;@dol 27.03.03 добавлено сохранение выведенных строк
 Q
]]></Implementation>
</Method>

<Method name="gFormdbf">
<Description>
sasha 20080929</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - (1) явное имя ^CacheTemp заменено на макрос $$$tmpGl
                       - (2) добавлена переменная refTmpGl - ссылка на временный массив
    */
 s Fld("N")=$G(Fld("N"))+1
 n refTmpGl s refTmpGl=$s($g(xmlRef)'="":xmlRef,1:$na($$$tmpGl(qqdev,$J))) ; 15.12.2008 Kokarev (1) (2) ; tdv 20081219 xmlRef - учёт печати версии 2
 
 i $G(@refTmpGl@($s($g(xmlRef)'="":1,1:0)))'="" Q  ; 15.12.2008 Kokarev (2) ; tdv 20081219 добавлена обработка для печати версии 2 - заголовок будет в индексе 1
 n S,I
 s @refTmpGl@($I(@refTmpGl))=1 ; 15.12.2008 Kokarev (2)
 i $G(Fld(-1))=-1 d qARM.Message("Отображение не должно содержать строки -1 Объекта !") Q
 for I=1:1:Fld { ; формируем подзаписи полей
     s S=$tr($j("",32)," ",$c(0))
     s $e(S,1,$l(Fld(I,"N")))=Fld(I,"N") ; название поля
     s $e(S,12)=Fld(I,"T") ; тип данных
     s $e(S,17)=$c(Fld(I,"L")) ;de! ; Длина поля (в байтах) ;исправить (не Юникод!)
     s $e(S,18)=$c(Fld(I,"F")) ;отсутствовала длина дробной части
  s @refTmpGl@($I(@refTmpGl))=S ; 15.12.2008 Kokarev (2)
}
 s @refTmpGl@($I(@refTmpGl))=$C(13) ; 15.12.2008 Kokarev (2)
]]></Implementation>
</Method>

<Method name="gFormdbfwrite">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 ///15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
 ///20081219 sas правильная запись пустого значения
 n string,tmp
 i $G(Fld)'="" i $G(Fld(-1))'=-1 s str="&*****"_str n i f i=1:1:(Fld+1) d
 .s tmp=$P(str,"*****",i)
 .s string=$S($G(Fld(i-1,"T"))="L":$S(+tmp=0:"F",1:"T"),1:tmp) //если поле Logical в FoxPro 20101112 sas
 .I $G(xmlRef)'="" S:string'="&" @xmlRef@($I(@xmlRef))=$S(Fld(i-1,"T")="N":$J(string,Fld(i-1,"L"),Fld(i-1,"F")),Fld(i-1,"T")="D":$E($P(string,".",3)_$P(string,".",2)_$P(string,".")_$J("",8),1,8),1:$E(string_$J("",Fld(i-1,"L")),1,Fld(i-1,"L"))) S:string="&" @xmlRef@($I(@xmlRef))=" " Q
 .I qqdev'=0,qqdev?1.N S:string'="&" $$$tmpGl(qqdev,$J,$I($$$tmpGl(qqdev,$J)))=$S(Fld(i-1,"T")="N":$J(string,Fld(i-1,"L"),Fld(i-1,"F")),Fld(i-1,"T")="D":$E($P(string,".",3)_$P(string,".",2)_$P(string,".")_$J("",8),1,8),1:$E(string_$J("",Fld(i-1,"L")),1,Fld(i-1,"L"))) S:string="&" $$$tmpGl(qqdev,$J,$I($$$tmpGl(qqdev,$J)))=" " Q  ; 15.12.2008 Kokarev
 .U:qqdev'=0 qqdev W str,! Q
]]></Implementation>
</Method>

<Method name="gFormwrite">
<Description>
sasha 20081208 вынесение метода write из gForm</Description>
<Internal/>
<FormalSpec>str:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 ;sasha 20080929
 i qxml=9 d ..gFormdbfwrite() Q
 ///перекодировка строки в UTF-8 sas 20081205 для OOW 
 s:qcodepage=1 str=$ZCVT(str,"O","UTF8")
 I $G(xmlRef)'="" S @xmlRef@($I(@xmlRef))=str_$C(13,10) Q
 I qqdev'=0,qqdev?1.N S $$$tmpGl(qqdev,$J,$I($$$tmpGl(qqdev,$J)))=str_$C(13,10) Q  ; 15.12.2008 Kokarev
 U:qqdev'=0 qqdev W str,! Q
]]></Implementation>
</Method>

<Method name="gOrder">
<Description>
ggcc(qorder,qqo,qqcc,qqcc0) ;,qqz,qqz0) 
;qorder=1/-1 следующий/предыдущий код, qorder=0 проверка на существование
;W("Zostr") - объект сортировки
;qqcc - начальный код
;qqcc0 - общая часть кода
;????
;qqz - начальное значение понятия сортировки
;qqz0 - общая часть понятия сортировки
find=1 - вызов из поиска</Description>
<Internal/>
<FormalSpec>qorder:%String,qqo:%String,qqcc:%String,qqcc0:%String,qsor:%Library.String,find:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 S qqcc0=$G(qqcc0) N qqcc1,Cond,Gtmf s Gtmf=$ZV["GT.M"
 S:$G(qqReFind) $$$ReFind=$S($G(Vo(qqnump,qqo,40))#3:0,1:qqReFind) ;сброс уточнения (qqReFind - в методе gForm);@Dol 23.05.06 X540=3 - учет условий в релвантных
 I $G(Vs(qqnump,99,"Revers")),qorder D:'$D(Vo(qqnump,-1,666)) qARM.GetPar("X1666") I $S(Vo(qqnump,-1,666)="":1,1:" "_Vo(qqnump,-1,666)_" "[(" "_qqo_" ")) S qorder=$S(qorder=-1:1,1:-1) ;@Dol 30.07.05 666- объекты реверса
 I $$$ReFind N qql S qql=$S($G(find):'$$$Relind,1:$$$Relind)_qview,Cond=$S($G(Vo(qqnump,qqo,40))'=3:0,1:$G(Vt(qqnump,0))) I 1 ;@Dol 23.05.06 X540=3 - учет условий в релвантных
 E  S Cond=$G(Vt(qqnump,0)) I '$G(find),$G(qqReFind)=1,$G(Vo(qqnump,qqo,40))<2 S Cond=0 ;@Dol 7.08.05 Vo(qqnump,qqo,40)<2  ;qqReFind=$$$ReFind вызов из метода gForm .текущий режим (выбор/уточнение). Не проверять условия в варианте установки флага X540<2 - Сброс уточнения
 I $G(Vo(qqnump,qqo,2)),$S(Vo(qqnump,qqo,2)>3:1,qqo=$G(W("Zosrt")):$G(Vs(qqnump,"SortV"))="",1:1) G:Vo(qqnump,qqo,2)=4 gOrderBeg:$$$ReFind&($L($$$ObjRef(qqo),",")=1),gOrder4:'$$$ReFind&($L($$$ObjRef(qqo),",")=1) G:'$$$ReFind||$S(qqo'=$G(W("Zosrt")):0,1:$G(Vs(qqnump,"SortV"))="") gOrderVi  D  Q qqcc ;@Dol 17.08.06 учет сортировки по построенным индексам Vs(qqnump,"SortV");@Dol 30.08.06 ,$S(Vo(qqnump,qqo,2)>2:1,qqo=$G(W("Zosrt")):$G(Vs(qqnump,"SortV"))="",1:1) ; tdv 20090218 $S(Vo(qqnump,qqo,2)>2 заменено на $S(Vo(qqnump,qqo,2)>3
 .I 'qorder S qorder=''$D(^Q(qql,qqo,qqcc)) D:Vo(qqnump,qqo,2)=3 qUSER.gOrder(0,qqo,qqcc) S qqcc=qorder Q
 .N qqob S qqob=$$$ObjRef(qqo) I $L(qqob,",")=1 S qqcc=$O(^Q(qql,qqo,qqcc),qorder) D:Vo(qqnump,qqo,2)=3 qUSER.gOrder(0,qqo,qqcc) Q
 .S qqob=$P(qqob,",",$L(qqob,",")-1) S:qqcc0="" qqcc0=$O(^Q(qql,qqob,""),qorder)
 .F  S qqcc=$O(^Q(qql,qqob,qqcc0,qqo,qqcc),qorder) Q:qqcc=""  Q:$D(^Q(qql,qqo,qqcc))  K ^Q(qql,qqob,qqcc0,qqo,qqcc)
 .I Vo(qqnump,qqo,2)=3 D qUSER.gOrder(0,qqo,qqcc) ;понятий в W(qqw)
 G:$G($$$Tree) ggcctr
gOrderBeg I qorder=0 Q:qqcc="" 0 S qorder=$D(^Q(qql,qqo,qqcc)) Q:'Cond qorder  D:qorder  Q qorder
 .I $G(Vo(qqnump,qqo,28)),qqcc'=$O(^Q(qql,qqo,qqcc0_"я"),-1) S qorder=0 Q  ;только последний
 .I $G(Vo(qqnump,qqo,27))'="" D  Q:'qorder
 ..N qqc S qqc=qqcc I @Vo(qqnump,qqo,27) Q
 ..S qorder=0
 .D:$G(Vo(qqnump,-1,67))'=""  ;условие вывода для отображения
 ..N qqc S qqc=qqcc I @Vo(qqnump,-1,67) Q
 ..S qorder=0
 I Cond,$G(Vo(qqnump,qqo,28)) Q:$L(qqcc)>$L(qqcc0) "" S:qorder'=-1 qorder=-1
 I $G(Vs(qqnump,7))'="" Q:$G(Vs(qqnump,17))&(Vs(qqnump,7)=qqo) "" I Vs(qqnump,7)'=qqo I $S('$D(Vt(qqnump,111)):1,1:'(..RefVirt(Vs(qqnump,7),qqo))),$L($P($$$CondFind," ",10))>$L(qqcc0) S qqcc0=$E($P($$$CondFind," ",10),1,$$$ObjLqqc(qqo)) Q:$$$ObjLqqc(qqo)'>$L(qqcc0) $S(qqcc=qqcc0:"",1:qqcc0)
 I qqo'=$G(W("Zosrt")) S:$L(qqcc)'>$L(qqcc0) qqcc=qqcc0_$S(qorder=-1:$C(255,255,255,255,255),1:"") D  Q:$G(Vs(qqnump,7))'=qqo qqcc Q:qqcc="" "" S $P($$$CondFind," ",10,11)=qqcc_" "_qqcc Q qqcc
 .N qqc F  S qqcc=$O(^Q(qql,qqo,qqcc),qorder) Q:qqcc=""  S qqcc=$S($E(qqcc,1,$L(qqcc0))=qqcc0:qqcc,1:"") Q:qqcc=""  Q:'Cond  S qqcc1=0 D  Q:qqcc1
 ..I $G(Vo(qqnump,qqo,27))="",$G(Vo(qqnump,-1,67))="",qorder=1,qqcc0'="" S qqcc1=1 Q
 ..D gOrderV(qqo,qqcc) Q:qqcc1  Q:$P(qqcc1," ",2)=qqo  I $G(qqReFind),$G(qqReFind)'=$$$ReFind Q  ;@Dol 07.06.07 Оптимизация перемещения (см. gOrderV)
 ..S qqcc=$O(^Q(qql,$P(qqcc1," ",2),$P(qqcc1," ",3)),qorder) I qqcc="" S qqcc1=1 Q
 ..S:qorder=-1 qqcc=qqcc_$C(255,255,255,255,255)
 N qqwc S qqwc=$P($$$CondFind," "),Z=$S("@Z"'[$E(qqwc):$P($G(W(qqwc))," ",W("Znsort")),1:$G(W(qqwc))),Z0=$P($$$CondFind," ",5)
 I $G(Vs(qqnump,99,"Revers"))=2 S qorder=$S(qorder=1:-1,1:1) ;@Dol 07.05.09
 G:$G(Vs(qqnump,"SortV"))="" gOrderSo ;@Dol 16.06,06 Vs(qqnump,"SortV") - локальный словарь (индекс) ^Qi(qqwc,Vs(qqnump,"SortV"),Z,qqo,qqc) , Vs(qqnump,"SortVn")=1 - без ссылок на экземпляры (ссылки из основного словаря); ..CreSortV - создание словаря
 S:$G(Vo(qqnump,-1,1990)) Z=$ZCVT(Z,"U"),Z0=$ZCVT(Z0,"U") ;@Dol 06.03.09
 S:$G(Vo(qqnump,W("Zosrt"),2))>1 qqcc0="" ;@Dol 16.05.10
 S:qqcc="" Z="" S:Z="" qqcc="" I Z=""||'$D(^Qi(qqwc,Vs(qqnump,"SortV"),Z)) S Z=..qOrd($NA(^Qi(qqwc,Vs(qqnump,"SortV"))),Z,Z0,qorder) I Z="" S W(qqwc)="" Q "" ;@Dol 27.04.09
 S qqcc1=0,qqcc=$G(qqcc) S:$G(Vo(qqnump,W("Zosrt"),2))<2 qqcc0=$S($G(Vs(qqnump,7))="":"",Vs(qqnump,7)=W("Zosrt"):"",1:$P($$$CondFind," ",10)) ;@Dol 08.06.06 оптимизация фиксации;@Dol 16.05.10 <2
 F  S:qqcc=""&&(qqcc0'="") qqcc=qqcc0_$S(qorder'=-1:"",1:$C(255,255,255,255,255,255)) S qqcc=$S('$G(Vs(qqnump,"SortVn")):$O(^Qi(qqwc,Vs(qqnump,"SortV"),Z,W("Zosrt"),qqcc),qorder),qqlang=1:$O(^Q(1,$S($E(qqwc)'="C":qqwc,1:$E(qqwc,2,255)),$S($E(qqwc)'="C":Z,1:$G(^Q(1,qqwc,Z),"???")),W("Zosrt"),qqcc),qorder),1:$O(^Q(1,qqwc,^Q(1,"C"_qqwc,^Q(qqlang,qqwc,Z)),W("Zosrt"),qqcc),qorder)),qqcc=$S($E(qqcc,1,$L(qqcc0))=qqcc0:qqcc,1:"") D:$S(qqcc'="":$G(^(qqcc),99)+1=W("Znsort"),1:0)  Q:qqcc1  I qqcc="" S Z=..qOrd($NA(^Qi(qqwc,Vs(qqnump,"SortV"))),Z,Z0,qorder) Q:Z=""  ;@Dol 27.04.09 ;;$O(^Qi(qqwc,Vs(qqnump,"SortV"),Z),qorder) Q:Z=""  I Z0'="",$S(Z?1.N:"167"[$E(qARM.GetPar(710,"",W("Zosrt"),qqwc)_9)||($L($O(^Qi(qqwc,Vs(qqnump,"SortV"),"")))=$L($O(^Qi(qqwc,Vs(qqnump,"SortV")," "),-1))),1:1),$E(Z,1,$L(Z0))'=Z0 S Z="" Q  ;@Dol 28.03.06 $G(^(qqcc),99)+1=W("Znsort") ;$G( - для R*-понятий
 .I $P($$$CondFind," ",6)'="",$G(W("ZfIlTr"))'="" D  Q:'qqcc1  ;@Dol 4.03.05 фильтр
 ..I $ZCVT(qW.GG(W("Zosrt"),qqwc,qqcc),"U")?@W("ZfIlTr") S qqcc1=1 Q
 ..S qqcc1=0 
 .I 'Cond S qqcc1=1 Q
 .D gOrderV(W("Zosrt"),qqcc)
 I qqcc="" S W(qqwc)="" Q ""
 S W(qqwc)=$S($G(Vo(qqnump,W("Zosrt"),2))>1:Z,1:..GG(W("Zosrt"),qqwc,qqcc)) S:W(qqwc)="" W(qqwc)=" " D:$G(Vo(qqnump,W("Zosrt"),2))>1  S:$G(Vo(qqnump,-1,1990)) W(qqwc)=$ZCVT(W(qqwc),"U") Q qqcc
 .I Vo(qqnump,W("Zosrt"),2)=3 D qUSER.gOrder(0,W("Zosrt"),qqcc)  ; tdv 20090218 для виртуальных объектов
 .N virt S Vs(qqnump,"Virt",W("Zosrt"))=qqcc,virt=$G(^Qi(qqwc,Vs(qqnump,"SortV"),Z,W("Zosrt"),qqcc)) I virt'="" S Vs(qqnump,"Virt",$P(virt," ",1))=$P(virt," ",2) S:$G(qqfoc)'="" $P(qqfoc,"~",$L(qqfoc,"~")-1)=$P(virt," ",1),$P(qqfoc,"~",$L(qqfoc,"~"))=$P(virt," ",2) ;@Dol 13.09.06 см ..CreSortV, qqfoc - см. ..gForm, - информация о зачеркнутых предках
gOrderSo 
 I qqwc="C"||(qqwc="CC") S:qqwc="CC" qqcc=$S(qqcc="":"",1:$G(^Q(1,qqo,qqcc))),qqo=$S($E(qqo)="C":$E(qqo,2,255),1:"C"_qqo) S qqcc0=Z0 D  Q:qqwc="C" qqcc Q:qqcc="" "" S W(qqwc)=qqcc Q ^Q(qql,qqo,qqcc)
 .;S Z0=$TR(Z0,$C(31)),$P($$$CondFind," ",5)=Z0 ;@dol 15.1.04 - для обработки слов, начинающихся с цифры.См. метод qARM.OnKeyPass
 .;I qorder=1,Z0'="",qqcc="",$D(^Q(qql,qqo,Z0)) S qqcc=Z0 Q
 .;I Z0=+Z0 S qqcc=$O(^Q(qql,qqo,$S(qqcc="":qqcc0_$S(qorder=-1:"я",1:""),1:qqcc)),qorder) S:qorder=-1 qqcc=$S(qqcc<Z0:"",1:qqcc) Q
 .;S:$L(qqcc)'>$L(qqcc0) qqcc=qqcc0_$S(qorder=-1:"я",1:"")
 .;F  S qqcc=$O(^Q(qql,qqo,qqcc),qorder),qqcc=$S($E(qqcc,1,$L(qqcc0))=qqcc0:qqcc,1:"") Q:qqcc=""  D  Q:qqcc1
 .F  S qqcc=..qOrd($NA(^Q(qql,qqo)),qqcc,qqcc0,qorder) Q:qqcc=""  D  Q:qqcc1  ;@Dol 18.05.10
 ..I $P($$$CondFind," ",6)'="",$G(W("ZfIlTr"))'="" D  Q:'qqcc1
 ...I $ZCVT(qqcc,"U")?@W("ZfIlTr") S qqcc1=1 Q
 ...S qqcc1=0 
 ..I 'Cond S qqcc1=1 Q
 ..D gOrderV(W("Zosrt"),qqcc)
 I $G(Vo(qqnump,-1,1990)),$L(qql)>2 S Z=$ZCVT(Z,"U"),Z0=$ZCVT(Z0,"U") ;@Dol 06.03.09
 N qqoo S qqoo=W("Zosrt") I qqwc[":" S qqoo=qqwc N qqwc S qqwc=$P($P(qqoo,":",2),"{"),qqoo=$P(qqoo,":",1) ;@Dol 25.09.08
 I qqcc'="" S:$L(qqcc)'>$L(qqcc0) qqcc=qqcc0_$S(qorder=-1:$C(255,255,255),1:"") ;?для зачеркнутых вершин ;?25.05.09
 N qqla,ql S qqla=$S(qql=1:$S("MXZL@Hx"[$E(qqwc)||(qqwc[":")&&$G(Vo(qqnump,-1,199)):$$$Relind_qview,1:qqlang),1:qql) ;@Dol 21.12.04 ;;для релевантных словарь построен
 S:qqcc="" Z="" S:Z="" qqcc="" I Z=""||'$D(^Q(qqla,qqwc,Z)) S Z=..qOrd($NA(^Q(qqla,qqwc)),Z,Z0,qorder) I Z="" S W(qqwc)="" Q "" ;@Dol 27.04.09
 S qqcc1=0,qqcc=$G(qqcc),qqcc0=$S($G(Vs(qqnump,7))="":"",Vs(qqnump,7)=W("Zosrt"):"",1:$P($$$CondFind," ",10)) ;@Dol 08.06.06 оптимизация фиксации
 I W("Zosrt")'=qqoo,qqcc'="",qorder'=-1 S qqcc=qqcc_"я"
 F  S:qqcc=""&&(qqcc0'="") qqcc=qqcc0_$S(qorder'=-1:"",1:$C(255,255,255,255)) S qqcc=$S(qqlang=1||(qql'=1)||($E(qqwc)="C"):$O(^Q(qqla,$S($E(qqwc)'="C":qqwc,1:$E(qqwc,2,255)),$S($E(qqwc)'="C":Z,1:$G(^Q(1,qqwc,Z),"???")),qqoo,qqcc),qorder),1:$O(^Q(1,qqwc,^Q(1,"C"_qqwc,^Q(qqlang,qqwc,Z)),qqoo,qqcc),qorder)),qqcc=$S($E(qqcc,1,$L(qqcc0))=qqcc0:qqcc,1:"") D:$S(qqcc'="":$G(^(qqcc),99)+1=W("Znsort"),1:0)  Q:qqcc1  I qqcc="" S Z=..qOrd($NA(^Q(qqla,qqwc)),Z,Z0,qorder) Q:Z=""  ;@Dol 27.04.09 ;$O(^Q(qqla,qqwc,Z),qorder) Q:Z=""  I Z0'="" S ql=$S(Z?1.N:"167"[$E(qARM.GetPar(710,"",W("Zosrt"),qqwc)_9)||($L($O(^Q(qqla,qqwc,"")))=$L($O(^Q(qqla,qqwc," "),-1))),Z=+Z:0,1:1) S ql=$S(ql:$E(Z,1,$L(Z0))'=Z0,$G(Vs(qqnump,99,"Revers")):Z>Z0,1:Z<Z0) S:ql Z="" Q:ql  ;@Dol 28.03.06 $G(^(qqcc),99)+1=W("Znsort") ;$G( - для R*-понятий
 .I $P($$$CondFind," ",6)'="",$G(W("ZfIlTr"))'="" D  Q:'qqcc1  ;@Dol 4.03.05 фильтр
 ..I $ZCVT(qW.GG(qqoo,qqwc,qqcc),"U")?@W("ZfIlTr") S qqcc1=1 Q
 ..S qqcc1=0 
 .I 'Cond S qqcc1=1 Q
 .D gOrderV(qqoo,qqcc)
 I qqcc="" S W(qqwc)="" Q ""
 S W(qqwc)=..GG(qqoo,qqwc,qqcc) S:W(qqwc)="" W(qqwc)=" "
 I $G(Vo(qqnump,-1,1990)),$L(qql)>2 S W(qqwc)=$ZCVT(W(qqwc),"U") ;@Dol 06.03.09
 I W("Zosrt")'=qqoo S W(qqoo_":"_qqwc)=W(qqwc)
 Q $E(qqcc,1,$$$ObjLqqc(W("Zosrt")))
gOrderV(qqoo,qqcc)
 N qqo,qqob,qqoi,qqc S qqob=$G($$$ObjRef(qqoo),qqoo) F qqoi=$L(qqob,","):-1:1 S qqo=$P(qqob,",",qqoi) I $D(Vo(qqnump,qqo,0)) S qqc=$E(qqcc,1,$$$ObjLqqc(qqo)),qqcc1=0 D  I 'qqcc1 S qqcc1="0 "_qqo_" "_qqc Q
 .I $G(Vo(qqnump,qqo,27))'="" D  Q:'qqcc1
 ..I @Vo(qqnump,qqo,27) S qqcc1=1 Q
 .I $G(Vo(qqnump,-1,67))="" S qqcc1=1 Q
 .I @Vo(qqnump,-1,67) S qqcc1=1 Q
 .S qqcc1=0
 Q
ggcctr  ;режим дерева
 I '$D(qqref) N qqref
 I qorder=0 Q $D(@$$$GloRef@(qqo,qqcc)) 
 N qi,qqob,qqlev,qqc,qi0 S qqob=$$$ObjRef(qqo),qqlev=$L(qqob,",") 
 I qqcc'="" S qqcc=$O(@$$$GloRef@(qqo,qqcc),qorder) S:$G(Vs(qqnump,7))=qqo qqcc=$S($P($$$CondFind," ",10)="":qqcc,$E(qqcc,1,$L($P($$$CondFind," ",10)))=$P($$$CondFind," ",10):qqcc,1:"") Q:qqcc'="" qqcc Q:$G(Vs(qqnump,7))=qqo "" Q:qqlev=1 "" D  S:qqcc'="" $$$GloRef=qqref Q qqcc
 .S qqref=$$$GloRef F  S qqcc=$$ggcctl(qqlev-1) Q:qqcc=""  S qqcc=$O(@qqref@(qqo,""),qorder) I qqcc'="" S $$$GloRef=qqref Q
 I $G(Vs(qqnump,7))'="" S qi0=$L($$$ObjRef(Vs(qqnump,7)),","),qqref=$NA(@$$$GloRef,qi0-1*2+1) I 1
 E   S qqref=$NA(@$$$GloRef,1),qi0=1 
 F qi=qi0:1:qqlev S qqcc=$O(@qqref@($P(qqob,",",qi),""),qorder) D  I qqcc="" Q
 .I qqcc="" Q:qi=qi0  S qqcc=$$ggcctl(qi-1) Q:qqcc=""  S qi=qi-1 Q
 .I qqcc'="" Q:qi=qqlev  S qqref=$NA(@qqref@($P(qqob,",",qi),qqcc)) Q
 S:qqcc'="" $$$GloRef=qqref Q qqcc 
ggcctl(qql) ;получить следующий/предыдущий на заданном уровне
 I $G(Vs(qqnump,7))=$P(qqob,",",qql) Q "" ;фиксация жесткая ??
 N qqc S qqc=$QS(qqref,qql*2+1)
 S qqref=$NA(@($NA(@qqref,qql*2-1))@($P(qqob,",",qql),qqc)),qqc=$O(@qqref,qorder) I qqc'="" S qqref=$NA(@$NA(@qqref,qql*2)@(qqc)) Q qqc
 Q:qql=1 "" F  S qqc=$$ggcctl(qql-1) Q:qqc=""  S qqref=$NA(@$NA(@qqref,qql*2-1)@($P(qqob,",",qql),"")) S qqc=$O(@qqref,qorder) I qqc'="" S qqref=$NA(@$NA(@qqref,qql*2)@(qqc)) Q
 Q qqc
 ;для qWORD4
gOrder4 Q:'qorder ''$D(@("^"_qqo)@(qqcc)) Q:qqo'=$G(W("Zosrt")) $O(@("^"_qqo)@(qqcc),qorder)
 N qqwc S qqwc=$P($$$CondFind," "),Z=$P($G(W(qqwc))," ",W("Znsort")),Z0=$P($$$CondFind," ",5)
 I qqwc="C" S qqcc0=Z0 D  Q qqcc
 .I qorder=1,Z0'="",qqcc="",$D(@("^"_qqo)@(Z0)) S qqcc=Z0 Q
 .I Z0=+Z0 S qqcc=$O(@("^"_qqo)@($S(qqcc="":qqcc0_$S(qorder=-1:"я",1:""),1:qqcc)),qorder) S:qorder=-1 qqcc=$S(qqcc<Z0:"",1:qqcc) Q
 .S:$L(qqcc)'>$L(qqcc0) qqcc=qqcc0_$S(qorder=-1:"я",1:"")
 .F  S qqcc=$O(@("^"_qqo)@(qqcc),qorder),qqcc=$S($E(qqcc,1,$L(qqcc0))=qqcc0:qqcc,1:"") Q:qqcc=""!('Cond)  D gOrderV(W("Zosrt"),qqcc) Q:qqcc1
 S:qqcc="" Z=Z0
 S:Z="" Z=Z0
 I Z="" S qqcc="",Z=$O(^QW(1,qqwc,0,Z),qorder) Q:Z="" "" I 1
 E  I '$D(^QW(1,qqwc,0,Z)) S qqcc="",Z=$O(^QW(1,qqwc,0,$S(Z=+Z:$S(qARM.GetPar(710,"",W("Zosrt"),qqwc)=1:Z_$TR($J("",8-$L(Z))," ",$S(qorder=-1:9,1:0)),qorder=-1:Z_"я",1:Z),qorder=-1:Z_"я",1:Z)),qorder) Q:Z="" "" I Z0'="",$S(Z?1.N:qARM.GetPar(710,"",W("Zosrt"),qqwc)=1,1:1),$E(Z,1,$L(Z0))'=Z0 Q ""
 S qqcc1=0 F  S qqcc=$O(^QW(1,qqwc,0,Z,$E(W("Zosrt"),2,255),qqcc),qorder) D:$S(qqcc'="":^(qqcc)+1=W("Znsort"),1:0)  Q:qqcc1  I qqcc="" S Z=$O(^QW(1,qqwc,0,Z),qorder) Q:Z=""  I Z0'="",$S(Z?1.N:qARM.GetPar(710,"",W("Zosrt"),qqwc)=1,1:1),$E(Z,1,$L(Z0))'=Z0 S Z="" Q
 .I 'Cond S qqcc1=1 Q
 .D gOrderV(W("Zosrt"),qqcc)
 S:qqcc'="" W(qqwc)=$S(qqcc="":"",1:..GG(W("Zosrt"),qqwc,qqcc)) Q qqcc
 ;виртуальные объекты
gOrderVi
 I Vo(qqnump,qqo,2)=8 N qqNS,qqNSN S qqNS=$ZU(5) D:'$D(Vo(qqnump,qqo,29)) qARM.GetPar(529,,qqo) S Vo(qqnump,qqo,2)=0 ZN $S($P(Vo(qqnump,qqo,29)," ")="":qqNameSpace,1:$P(Vo(qqnump,qqo,29)," ")) D  ZN qqNS S Vo(qqnump,qqo,2)=8,Vs(qqnump,"Virt",qqo)=qqcc Q qqcc
 .I $P(Vo(qqnump,qqo,29)," ",2)'="",'$D(Vo(qqnump,$P(Vo(qqnump,qqo,29)," ",2))) M Vo(qqnump,$P(Vo(qqnump,qqo,29)," ",2))=Vo(qqnump,qqo) ;S qqo=$P(Vo(qqnump,qqo,29)," ",2) ;длина кода?
 .S qqcc=..gOrder(qorder,$S($P(Vo(qqnump,qqo,29)," ",2)="":qqo,1:$P(Vo(qqnump,qqo,29)," ",2)),qqcc,qqcc0) Q:qqcc=""
 N qqcond,qqc S qqc=qqcc I Cond S qqcond=$G(Vo(qqnump,qqo,27)) S:$G(Vo(qqnump,-1,67))'="" qqcond=$S(qqcond'="":qqcond_",",1:"")_$G(Vo(qqnump,-1,67)) I $G(Vo(qqnump,qqo,28)),qorder Q:qqcc'="" "" S:qorder'=-1 qorder=-1 ;только последний - единственный
 S qqcc1=$P($$$ObjRef(qqo),",",$L($$$ObjRef(qqo),",")-1) ;предыдущий объект
 I Vo(qqnump,qqo,2)=1 D  Q qqcc  ;встроенный объект
 .I 'qorder D  Q
 ..S qqcc=$D(^Q(qql,$S($E(qqcc1)'="v":qqcc1,1:$E(qqcc1,3,255)),qqcc)) Q:'qqcc  Q:$G(qqcond)=""  I @qqcond Q
 ..S qqcc=0
 .S (qqcc,qqc)=$S(qqc="":qqcc0,1:"") Q:qqc=""  Q:$G(qqcond)=""  I @qqcond Q
 .S qqcc=""
 I Vo(qqnump,qqo,2)=5 Q:'qorder $D(@("^"_$E(qqo,2,255))@(qqcc)) S:qqcc=""&(qorder=1) qqcc=0 S qqcc=$O(@("^"_$E(qqo,2,255))@(qqcc),qorder) S:qqcc=0 qqcc="" Q qqcc
 I Vo(qqnump,qqo,2)=6 D  S:qorder Vs(qqnump,"Virt",qqo)=qqc Q qqc ;массив
 .I qqcc1'="",qqcc0'="" S Vs(qqnump,"Virt",qqcc1)=qqcc0 ;предыдущий объект
 .I '$D(Vo(qqnump,qqo,33)) S Vo(qqnump,qqo,33)=qARM.GetPar("X533",,qqo) S:$E(Vo(qqnump,qqo,33),1,2)="@@" Vo(qqnump,qqo,33)=qARM.Value($E(Vo(qqnump,qqo,33),3,2555)) D:$E(Vo(qqnump,qqo,33))="@"  ;добыча имени для массива 
 ..I Vo(qqnump,qqo,33)="@" S Vo(qqnump,qqo,33)=Vo(qqnump,qqcc1,33),Vo(qqnump,qqo,33,1)="" Q  ;@Dol 21.03.05
 ..I $E(Vo(qqnump,qqo,33),1,3)="@*@" S Vo(qqnump,qqo,33)=$S(Vo(qqnump,qqcc1,33)[")":$E(Vo(qqnump,qqcc1,33),1,$L(Vo(qqnump,qqcc1,33))-1)_",",1:Vo(qqnump,qqcc1,33)_"(")_"Vs(qqnump,""Virt"","""_qqcc1_""")"_$S($TR($E(Vo(qqnump,qqo,33),4,255)," ")="":"",1:","_$E(Vo(qqnump,qqo,33),4,255))_")" Q  ;@Dol 29.03.05 , @tdv 19.09.2006 - исправлено, если ссылка - имя глобала 
 ..S Vo(qqnump,qqo,33)=$E(Vo(qqnump,qqo,33),2,2555),Vo(qqnump,qqo,33,1)=""  Q  ;прямая ссылка 
 .I 'qorder D  S Vs(qqnump,"Virt",qqo)=$S(qqcc:qqc,1:""),qqc=qqcc Q  ;проверка наличия
 ..S qqcc=$S((Vo(qqnump,qqo,33)'="^$Global")||('Gtmf):$D(@Vo(qqnump,qqo,33)@(qqc)),1:$D(@qqc)) Q:$G(qqcond)=""  Q:'qqcc  D  Q   ;dima 08.09.04
 ...I @qqcond Q
 ...S qqcc=0 Q
 .I $D(Vo(qqnump,qqo,33,1)) S qqc=$S(qqc="":$S($D(@Vo(qqnump,qqo,33)@(qqcc0)):qqcc0,1:""),1:"") Q:$G(qqcond)=""  D:qqc'=""  Q  ;прямая ссылка 
 ..I @qqcond Q
 ..S qqc=""
 .N qqco S qqco="" I qqo'=$G(W("Zosrt")) D gOrderVib6 Q
 .N qqwc S qqwc=$P($$$CondFind," ") S Z=$P($G(W(qqwc))," ",W("Znsort")),Z0=$P($$$CondFind," ",5)
 .I $G(Vs(qqnump,"SortV"))'="" S qqc=$$gOrderVib6s() Q
 .S qqco=Z0 D gOrderVib6 Q  ;@Dol 18.05.10
 .;I qqwc'="C"!(Z0="") D gOrderVib6 Q
 .;S qqco=Z0 I qorder=1,Z0'="",qqc="",$D(@Vo(qqnump,qqo,33)@(qqco)) S qqc=qqco Q
 .;S qqc=$S(Z0=+Z0:$S(qqc="":qqco_$S(qorder=-1:"я",1:""),1:qqc),$L(qqc)'>$L(qqco):qqco_$S(qorder=-1:"я",1:""),1:qqc)
 .;D gOrderVib6 Q
 I Vo(qqnump,qqo,2)=7 D  S:qorder Vs(qqnump,"Virt",qqo)=qqc Q qqc ;SQL определяем вершину это F5
 .N qq,qqq,error,add,qqwi,qqw  I qqc="" D  I $G(error)'=""  D qARM.Message("SQLCODE="_$G(SQLCODE)_" ERROR "_error_" CONNECT:"_$g(Vt(qqnump,"sql",qqo,"con"))) K SQLCODE D:0 gOrderVib7 S qqc="" Q  ;инициализация соединения K SQLCODE
 ..I '$D(Vt(qqnump,"sql")) S error=qSYS.SQLini() I $G(error)'="" Q
 ..I '$D(Vt(qqnump,"sql",qqo)) Q
 ..I ((qqcc1'="")&(qqcc0'="")) D
 ...I $E($G(Vo(qqnump,qqo,29)))="@" S add=" where "_qARM.Value($P($E(Vo(qqnump,qqo,29),2,30000),";;")) Q
 ...S qq=$G(Vt(qqnump,529,qqo,qqcc1)) I qq'="" S qqq=$P(qq,";",2),qq=$P(qq,";",1),add=" where" F qqwi=$L(qq," "):-1:1 S qqw=$E($P(qq," ",qqwi),2,255),add=add_$S(qqwi=$L(qq," "):" ",1:" and ")_qqw_"="_..GG(qqcc1,$S($P(qqq," ",qqwi)="":$P(qq," ",qqwi),1:$P(qqq," ",qqwi)),qqcc0) ;Vs(qqnump,"Virt",qqcc1,qqw)
 ..S qq=$s($g(Vt(qqnump,"sql",qqo,"con"))'="???":"use "_$g(Vt(qqnump,"sql",qqo,"con")),1:"")_" select "_Vt(qqnump,"sql",qqo,"qqwR")_" from "_$S($G(^Q(1,"XView",Vo(qqnump),"XShema1"))'="":^Q(1,"XView",Vo(qqnump),"XShema1")_".",1:"")_Vt(qqnump,"sql",qqo,"tab")_$G(add)
 ..S:'$D(Vo(qqnump,qqo,45)) Vo(qqnump,qqo,45)=qARM.GetPar("X545",,qqo)
 ..i $L(Vo(qqnump,qqo,45)) s @("Vt(qqnump,""sql"",qqo)=..SQLExec(sqlcon(qqnump),"_Vo(qqnump,qqo,45)_")") s qq="@"_Vo(qqnump,qqo,45) i 1  ; added by Vol 28.09.2004  
 ..e  s qq=qq_$S($G(qsor)'="":" ORDER BY "_qsor,1:""),Vt(qqnump,"sql",qqo)=..SQLExec(sqlcon(qqnump),qq) 
 ..i %SQLCODE<0 s error="Ошибка Exec "_qq Q 
 ..K error
 .I '$D(Vt(qqnump,"sql",qqo)) i '$G(Vt(qqnump,"sql",qqo)) s qqc="" Q  
 .K Vs(qqnump,"Virt",qqo) d:$G(Vt(qqnump,"sql",qqo))'="" ..SQLNextBQ(Vt(qqnump,"sql",qqo),$G(qnextb,1)) s:$G(Vt(qqnump,"sql",qqo))="" %SQLCODE=-100   i %SQLCODE=-100 S Vt(qqnump,"sql",qqo)="",qqc="" K error Q
 .K error 
 .S qqc=1 ;первичный ключ
 I $E(qview,1,3)="XXX" Q:$E(qqo)="v" ..gOrderVsys($E(qqo,3,30)) ;системных виртуальных
 I Vo(qqnump,qqo,2)=2,$G(Vo(qqnump,qqo,29))="*" S:$E(qqo)="v" qqo=$E(qqo,3,255) G gOrderBeg ;объект-аналог (все,как для подлинника) 
 I 'qorder D  Q:'qqcc1 0 Q:$G(qqcond)="" 1 I @qqcond Q 1
 .I Vo(qqnump,qqo,2)=4 S qqc=$D(@("^"_qqo)@(qqcc)) Q
 .I $S(Vo(qqnump,qqo,2)=3:1,1:$G(Vo(qqnump,qqo,29))="") S qqcc1=qUSER.gOrder(qorder,qqo,qqc,qqcc0) Q
 .I $G(qqcc1)'="",$G(Vt(qqnump,529,qqo,qqcc1))'="" S qqcc1=$D(^Q(qql,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)),qqc)) Q
 .I $P(Vo(qqnump,qqo,29)," ")["(" S qqcc1=qARM.Value(Vo(qqnump,qqo,29)) Q
 .I $P(Vo(qqnump,qqo,29)," ",2)'="" S @("qqcc1="_$P(Vo(qqnump,qqo,29)," ",2,255)) I qqcc1[" " S qqcc1=qqcc1[qqc  Q
 .S qqcc1=$D(^Q(qql,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)),qqc))
 Q:'qorder 0
 I $S(Vo(qqnump,qqo,2)=3:1,1:$G(Vo(qqnump,qqo,29))="") D  S:qorder Vs(qqnump,"Virt",qqo)=qqc Q qqc
 .F  S qqc=qUSER.gOrder(qorder,qqo,qqc,qqcc0) Q:qqc=""  Q:$G(qqcond)=""  I @qqcond Q
 N qqov S qqov=$S($E(qqo)'="v":qqo,1:$E(qqo,3,255))
 I qqcc1'="",$G(Vt(qqnump,529,qqo,qqcc1))'="" D   S:qorder Vs(qqnump,"Virt",qqo)=qqc Q qqc
 .I $E($P(Vt(qqnump,529,qqo,qqcc1),";",1))="O" S qqcc1=$S($E(qqcc1)'="v":qqcc1,1:$E(qqcc1,3,255)) S qqc=$O(^Q(1,qqcc1,qqcc0,qqov,qqcc),qorder) Q
 .N qqct S qqct=$P(Vt(qqnump,529,qqo,qqcc1),";",3) I qqct'="" D:'$D($$$ObjLqqc(qqct)) qARM.GetPar("X50",,qqct) S qqct=$E(qqcc0,1,$$$ObjLqqc(qqct)) ;@dol 14.08.04 общая часть кода
 .S qqc=$S(Vo(qqnump,qqo,2)'=4:qW.Key(qqov,$P(Vt(qqnump,529,qqo,qqcc1),";",1),qqcc,$G(qqcond),qorder,1,qqcc1,qqcc0,$P(Vt(qqnump,529,qqo,qqcc1),";",2),,qqct),1:qW.Key4(qqov,$P(Vt(qqnump,529,qqo,qqcc1),";",1),qqcc,$G(qqcond),qorder,1,qqcc1,qqcc0,$P(Vt(qqnump,529,qqo,qqcc1),";",2)))
 S:'$D(Vo(qqnump,qqo,280)) Vo(qqnump,qqo,280)=qARM.GetPar("X5280",,qqo)
 S qqcc1=$S($E(qqcc1)'="v":qqcc1,1:$E(qqcc1,3,255))
 I Vo(qqnump,qqo,280)="@",$S($S($E(qqcc1)'="v":qqcc1,1:$E(qqcc1,3,255))=$G(Vt(qqnump,"ZTmpqqo")):$G(Vt(qqnump,"ZTmpqqc"))'=qqcc0,1:1) D  ;инициализация темпоральности (Vt(qqnump,"ZTmp1") - для совместимости со старым вариантом через zTmp)
 .I $G(Vt(qqnump,"ZTmpqqc"))'="",$G(W("ZBtred")),$G(Vt(qqnump,"ZTmpYT"))'=1,Vt(qqnump,"ZTmpqqc")'[" ",$L(Vt(qqnump,"ZTmpqqc"))=$S($G($$$ObjLqqc(Vt(qqnump,"ZTmpqqo")))'="":$$$ObjLqqc(Vt(qqnump,"ZTmpqqo")),1:$$$ObjLget(Vt(qqnump,"ZTmpqqo"))) D ..rCor(Vt(qqnump,"ZTmpqqo"),Vt(qqnump,"ZTmpqqc"),"YT",,0) ;@Dol 26.01.06 проверка на длину кода) ;;;;автокоррекция предыдущего??? без изменения даты ;$P($G(Vt(qqnump,"ZTmpYT"))," ",2)-что-то изменено
 .I $G(Vt(qqnump,"ZTmpqqo"))'=qqcc1 S Vt(qqnump,"ZTmpObjList")=$S(" "_$TR(qqXBTempor,":"," ")_" "[(" "_qqcc1_" "):qqXBTempor,1:qqcc1) ;список объектов-документов с общими темпоральными объектами 
 .S Vt(qqnump,"ZTmpqqc")=qqcc0,Vt(qqnump,"ZTmpqqo")=qqcc1
 .K Vt(qqnump,"ZTmpYT") M Vt(qqnump,"ZTmpYT")=^Q(1,qqcc1,qqcc0,"YT")
 .S Vt(qqnump,"ZTmpYT")=''$D(Vt(qqnump,"ZTmpYT")) ;будет признаком, что состояние есть
 I $P(Vo(qqnump,qqo,29)," ")'["(" D  S:qorder Vs(qqnump,"Virt",qqo)=qqc Q qqc
 .I $P(Vo(qqnump,qqo,29)," ",2)'="" S @("qqcc0="_$P(Vo(qqnump,qqo,29)," ",2,255)) I qqcc0[" " D   Q:qqc=""  S:'$D(^Q(1,qqov,qqc)) qqc=qqc_" " Q  ;Обработка списка желаемых кодов
 ..N endd F  S qqc=$P($E(qqcc0,$F(" "_qqcc0,$TR(qqc," ")_" ")-1,30000)," ") Q:qqc=""  Q:$G(qqcond)=""   I @qqcond Q
 .I $P(Vo(qqnump,qqo,29)," ",2)="" S qqcc1=$P(Vo(qqnump,qqo,29)," ") S:'($D($$$ObjLqqc(qqcc1))#2) $$$ObjLqqc(qqcc1)=$G(^Q(1,"CxObj",qqcc1,"X50"),255) S qqcc0=$E(qqcc0,1,$$$ObjLqqc(qqcc1)) ;длина кода
 .S Vs(qqnump,"Virt0",qqo)=qqcc0 ;общая часть кода 
 .I Vo(qqnump,qqo,280)="@",$G(Vt(qqnump,0)) S:qqcond="" qqcond="$$gOTmp()" I $D(Vt(qqnump,"ZTmpYT",qqov)) S qqc=$S(qqc'="":"",$G(Vt(qqnump,"ZTmpYT",qqov))'="":qqcc0_Vt(qqnump,"ZTmpYT",qqov),1:"") Q:qqc=""  Q:$D(^Q(1,qqov,qqc))  S qqc="" K Vt(qqnump,"ZTmpYT",qqov) S $P(Vt(qqnump,"ZTmpYT")," ",2)=1 ;темпоральный с явным связанным кодом\ автомодификация несуществующего;???qqc=""
 .I qqo=qqcc1 S qqc=$S(qqc="":qqcc0,1:"") Q:$G(qqcond)=""  Q:qqc=""  D  Q  ;если виртуальный относительно себя, то единственный экземпляр
 ..I @qqcond Q
 ..S qqc=""
 .I $L(qqcc0)=$G($$$ObjLqqc(qqo)) S qqc=$S(qqc="":$S($D(^Q(1,qqov,qqcc0)):qqcc0,1:""),1:"") Q:$G(qqcond)=""  Q:qqc=""  D  Q  ;@dol если задан "желаемый" код, проверим его наличие;@dol 19.07.04 $G($$$
 ..I @qqcond Q
 ..S qqc=""
 .S qqcc="" F  S qqc=$$$UserOrd(qorder,qqov,qqc,qqcc0) S:qqcc="" qqcc=qqc Q:qqc=""  Q:$G(qqcond)=""  I @qqcond Q
 .I Vo(qqnump,qqo,280)'="" S:qqc'="" Vt(qqnump,"ZTmpYT",qqov)=$P(qqc,qqcc0,2,255),$P(Vt(qqnump,"ZTmpYT")," ",2)=1 ; запись явного кода для темпоральных
 F  S @("qqc="_Vo(qqnump,qqo,29)) Q:qqc=""  Q:$G(qqcond)=""  I @qqcond Q
 S:qorder Vs(qqnump,"Virt",qqo)=qqc Q qqc
 ;
gOTmp() ;Условие вывода на автоматическое (когда нет привязки) определение темпоральности текущего объекта по датам создания
 N qqw,qqT,qqTD,qqTDD,test,qqcc,qqoo S test=0 D  Q test
 .S qqT=$$gOTmpXc(qqo,qqc) ;берем дату создания (или коррекции) с точность до дня
 .I qqT="" S test=1 Q  ;нет никаких дат (берем последний)
 .S qqTD=$$gOTmpXc(Vt(qqnump,"ZTmpqqo"),Vt(qqnump,"ZTmpqqc")) ;берем дату создания (или коррекции) текущего документа
 .I qqTD="" S test=1 Q  ;нет никаких дат у документа
 .S test=qqT'>qqTD Q:test  ;общие сведения созданы не позже документа
 .S test=1 F iobj=1:1:$L(Vt(qqnump,"ZTmpObjList")," ") S qqoo=$P($P(Vt(qqnump,"ZTmpObjList")," ",iobj),":") D  Q:'test
 ..S qqcc="" F  S qqcc=$$$UserOrd(-1,qqoo,qqcc,qqcc0) Q:qqcc=""    I $S(qqoo=$G(Vt(qqnump,"ZTmpqqo")):qqcc'=$G(Vt(qqnump,"ZTmpqqc")),1:1) S qqTDD=$$gOTmpXc(qqoo,qqcc) I qqTDD>qqTD,qqT'<qqTDD S test=0 Q  ;есть более поздний документ с подходящими общими сведениями
 Q ""
gOTmpXc(qqop,qqcp)  N qqw,qq F qqw="Xc","X" S qq=$G(^Q(1,qqop,qqcp,qqw)) I qq'="" S qq=$ZD($P(..zCnv(0,qq)," "),8) Q
 Q qq
gOrderVib7 ;
 Q
gOrderVib6 I $G(Vo(qqnump,qqo,29))="" D  Q
 .I (Vo(qqnump,qqo,33)'="^$Global")||('Gtmf) D  Q  ;@Dol 18.05.10
 ..F  S qqc=..qOrd($NA(@Vo(qqnump,qqo,33)),qqc,qqco,qorder) Q:$G(qqcond)=""  Q:qqc=""  I @qqcond Q
 .F  S qqc=$S(qqc'="":$O(@qqc,qorder),1:$O(^%,qorder)) S:qqco'="" qqc=$S(qqco=+qqco:$S(qorder=-1&&(qqc<qqco):"",1:qqc),$E(qqc,1,$L(qqco))=qqco:qqc,1:"") Q:$G(qqcond)=""  Q:qqc=""  I @qqcond Q
 .;F  S qqc=$S((Vo(qqnump,qqo,33)'="^$Global")||('Gtmf):$O(@Vo(qqnump,qqo,33)@(qqc),qorder),1:$S(qqc'="":$O(@qqc,qorder),1:$O(^%,qorder))) S:qqco'="" qqc=$S(qqco=+qqco:$S(qorder=-1&&(qqc<qqco):"",1:qqc),$E(qqc,1,$L(qqco))=qqco:qqc,1:"") Q:$G(qqcond)=""  Q:qqc=""  I @qqcond Q
 I qqcc1'="",$G(Vt(qqnump,529,qqo,qqcc1))'="" D  Q
 .I $L($G(Vs(qqnump,"Virt",qqcc1,$P(Vt(qqnump,529,qqo,qqcc1)," ",1)))),$L($G(Vs(qqnump,"Virt",qqcc1,$P(Vt(qqnump,529,qqo,qqcc1)," ",2)))) D  Q
 ..F  S qqc=$O(^DBF("Index",qqo,$TR(Vt(qqnump,529,qqo,qqcc1)," ",","),Vs(qqnump,"Virt",qqcc1,$P(Vt(qqnump,529,qqo,qqcc1)," ",1)),Vs(qqnump,"Virt",qqcc1,$P(Vt(qqnump,529,qqo,qqcc1)," ",2)),qqc),qorder) S:qqco'="" qqc=$S(qqco=+qqco:$S(qorder=-1&&(qqc<qqco):"",1:qqc),$E(qqc,1,$L(qqco))=qqco:qqc,1:"") Q:$G(qqcond)=""  Q:qqc=""  I @qqcond Q
 .I $L($P(Vt(qqnump,529,qqo,qqcc1),";",1),",")=2 D  Q  ;@Dol 24.03.03 тодько для двойных индексов
 ..N qin1,qin2 S qin1=$P(Vt(qqnump,529,qqo,qqcc1),";",1),qin2=$P(Vt(qqnump,529,qqo,qqcc1),";",2) S:qin2="" qin2=qin1 S qin1=$E($P(qin1,",",1),2,255)_","_$E($P(qin1,",",2),2,255)
 ...F  S qqc=$O(^DBF("Index",qqo,qin1,..GG(qqcc1,$P(qin2,",",1),Vs(qqnump,"Virt",qqcc1)),..GG(qqcc1,$P(qin2,",",2),Vs(qqnump,"Virt",qqcc1)),qqc),qorder) S:qqco'="" qqc=$S(qqco=+qqco:$S(qorder=-1&&(qqc<qqco):"",1:qqc),$E(qqc,1,$L(qqco))=qqco:qqc,1:"") Q:$G(qqcond)=""  Q:qqc=""  I @qqcond Q
 .F  S qqc=$O(^DBF("Index",qqo,$E($P(Vt(qqnump,529,qqo,qqcc1),";",1),2,255),..GG(qqcc1,$S($P(Vt(qqnump,529,qqo,qqcc1),";",2)="":$P(Vt(qqnump,529,qqo,qqcc1),";",1),1:$P(Vt(qqnump,529,qqo,qqcc1),";",2)),Vs(qqnump,"Virt",qqcc1)),qqc),qorder) S:qqco'="" qqc=$S(qqco=+qqco:$S(qorder=-1&&(qqc<qqco):"",1:qqc),$E(qqc,1,$L(qqco))=qqco:qqc,1:"") Q:$G(qqcond)=""  Q:qqc=""  I @qqcond Q
 F  S @("qqc="_Vo(qqnump,qqo,29)) S:qqco'="" qqc=$S(qqco=+qqco:$S(qorder=-1&&(qqc<qqco):"",1:qqc),$E(qqc,1,$L(qqco))=qqco:qqc,1:"") Q:$G(qqcond)=""  Q:qqc=""  I @qqcond Q
 Q
gOrderVib6s()   ;сортировка массива по построенным индексам ;@Dol 26.03.10 - фактически повтор как для обычных :Старый фрагмент ниже в комментариях 
 ;@Dol 16.08,06 Vs(qqnump,"SortV") - локальный словарь (индекс) ^Qi(qqwc,Vs(qqnump,"SortV"),Z,qqo,qqc) , Vs(qqnump,"SortVn")=1 - без ссылок на экземпляры (ссылки из основного словаря); ..CreSortV - создание словаря
 S:$G(Vo(qqnump,-1,1990)) Z=$ZCVT(Z,"U"),Z0=$ZCVT(Z0,"U")
 ;@Dol 18.05.10 I qqcc'="" S:$L(qqcc)'>$L(qqcc0) qqcc=qqcc0_$S(qorder=-1:$C(255,255,255),1:"") ;?для зачеркнутых вершин;?25.05.09
 S:qqcc="" Z="" S:Z="" qqcc="" I Z=""||'$D(^Qi(qqwc,Vs(qqnump,"SortV"),Z)) S Z=..qOrd($NA(^Qi(qqwc,Vs(qqnump,"SortV"))),Z,Z0,qorder) I Z="" S W(qqwc)="" Q "" ;@Dol 27.04.09
 S qqcc1=0,qqcc=$G(qqcc) ;@Dol 18.05.10 ,qqcc0=$S($G(Vs(qqnump,7))="":"",Vs(qqnump,7)=W("Zosrt"):"",1:$P($$$CondFind," ",10)) ;@Dol 08.06.06 оптимизация фиксации
 F  S:qqcc=""&&(qqcc0'="") qqcc=qqcc0_$S(qorder'=-1:"",1:$C(255,255,255,255,255,255)) S qqcc=$S('$G(Vs(qqnump,"SortVn")):$O(^Qi(qqwc,Vs(qqnump,"SortV"),Z,W("Zosrt"),qqcc),qorder),qqlang=1:$O(^Q(1,$S($E(qqwc)'="C":qqwc,1:$E(qqwc,2,255)),$S($E(qqwc)'="C":Z,1:$G(^Q(1,qqwc,Z),"???")),W("Zosrt"),qqcc),qorder),1:$O(^Q(1,qqwc,^Q(1,"C"_qqwc,^Q(qqlang,qqwc,Z)),W("Zosrt"),qqcc),qorder)),qqcc=$S($E(qqcc,1,$L(qqcc0))=qqcc0:qqcc,1:"") D:$S(qqcc'="":$G(^(qqcc),99)+1=W("Znsort"),1:0)  Q:qqcc1  I qqcc="" S Z=..qOrd($NA(^Qi(qqwc,Vs(qqnump,"SortV"))),Z,Z0,qorder) Q:Z=""  ;@Dol 27.04.09 ;;$O(^Qi(qqwc,Vs(qqnump,"SortV"),Z),qorder) Q:Z=""  I Z0'="",$S(Z?1.N:"167"[$E(qARM.GetPar(710,"",W("Zosrt"),qqwc)_9)||($L($O(^Qi(qqwc,Vs(qqnump,"SortV"),"")))=$L($O(^Qi(qqwc,Vs(qqnump,"SortV")," "),-1))),1:1),$E(Z,1,$L(Z0))'=Z0 S Z="" Q  ;@Dol 28.03.06 $G(^(qqcc),99)+1=W("Znsort") ;$G( - для R*-понятий
 .I $P($$$CondFind," ",6)'="",$G(W("ZfIlTr"))'="" D  Q:'qqcc1
 ..I $ZCVT(qW.GG(W("Zosrt"),qqwc,qqcc),"U")?@W("ZfIlTr") S qqcc1=1 Q
 ..S qqcc1=0 
 .I 'Cond S qqcc1=1 Q
 .D gOrderVm(W("Zosrt"),qqcc)
 I qqcc="" S W(qqwc)="" Q ""
 S W(qqwc)=Z S:W(qqwc)="" W(qqwc)=" " S:$G(Vo(qqnump,-1,1990)) W(qqwc)=$ZCVT(W(qqwc),"U") D  Q qqcc
 .N virt S Vs(qqnump,"Virt",W("Zosrt"))=qqcc,virt=$G(^Qi(qqwc,Vs(qqnump,"SortV"),Z,W("Zosrt"),qqcc)) I virt'="" S Vs(qqnump,"Virt",$P(virt," ",1))=$P(virt," ",2) S:$G(qqfoc)'="" $P(qqfoc,"~",$L(qqfoc,"~")-1)=$P(virt," ",1),$P(qqfoc,"~",$L(qqfoc,"~"))=$P(virt," ",2) ;@Dol 13.09.06 см ..CreSortV, qqfoc - см. ..gForm, - информация о зачеркнутых предках
 Q
gOrderVm(qqo,qqc)   ;условия вывода
 S qqcc1=0 D  
 .I $G(Vo(qqnump,qqo,27))'="" D  Q:'qqcc1
 ..I @Vo(qqnump,qqo,27) S qqcc1=1 Q
 .I $G(Vo(qqnump,-1,67))="" S qqcc1=1 Q
 .I @Vo(qqnump,-1,67) S qqcc1=1 Q
 .S qqcc1=0
 Q
]]></Implementation>
</Method>

<Method name="gOrderSort">
<Description><![CDATA[
S:$G(Vo(qqnump,-1,1990)) Z=$ZCVT(Z,"U"),Z0=$ZCVT(Z0,"U") ;@Dol 06.03.09
S:qqcc="" Z=Z0 S:Z="" Z=Z0 S Z0=$TR(Z0,$C(31)),$P($$$CondFind," ",5)=Z0 ;@dol 26.11.02 - для обработки слов, начинающихся с цифры.См. метод qARM.OnKeyPass
I Z="" S qqcc="",Z=$O(^Qi(qqwc,Vs(qqnump,"SortV"),Z),qorder) S:Z="" W(qqwc)=""  Q:Z="" "" I 1
E  I '$D(^Qi(qqwc,Vs(qqnump,"SortV"),Z)) D  I Z="" S W(qqwc)="" Q ""
.S qqcc="" I Z'?1.N S Z=$O(^Qi(qqwc,Vs(qqnump,"SortV"),$S(qorder=-1:Z_$C(255,255,255),1:Z)),qorder) Q:Z=""  S:Z0'=""&&($E(Z,1,$L(Z0))'=Z0) Z="" Q
.N ql S (LL,ql)=$S(qARM.GetPar(710,"",W("Zosrt"),qqwc)=1:8,qARM.GetPar(710,"",W("Zosrt"),qqwc)=6:6,$L($O(^Qi(qqwc,Vs(qqnump,"SortV"),"")))=$L($O(^Qi(qqwc,Vs(qqnump,"SortV")," "),-1)):$L($O(^Qi(qqwc,Vs(qqnump,"SortV")," "),-1)),1:0)
.I 'ql S Z=$O(^Qi(qqwc,Vs(qqnump,"SortV"),$S(qorder=-1:Z_$C(255,255,255),1:Z)),qorder) Q
.S Z=Z_$TR($J("",ql-$L(Z))," ",$S(qorder=-1:9,1:0)) I Z0=Z S Z="" Q
.Q:$D(^Qi(qqwc,Vs(qqnump,"SortV"),Z))  S Z=$O(^Q(qqwc,Vs(qqnump,"SortV"),Z),qorder) Q:Z=""  S:Z0'=""&&($E(Z,1,$L(Z0))'=Z0) Z="" Q  ;спец обработка нормализованной даты и чисел одинакового размера
S qqcc1=0,qqcc=$G(qqcc),qqcc0=$S($G(Vs(qqnump,7))="":"",Vs(qqnump,7)=W("Zosrt"):"",1:$P($$$CondFind," ",10)) ;@Dol 08.06.06 оптимизация фиксации
F  S:qqcc=""&&(qqcc0'="") qqcc=qqcc0_$S(qorder'=-1:"",1:$C(255,255,255,255)) S qqcc=$S('$G(Vs(qqnump,"SortVn")):$O(^Qi(qqwc,Vs(qqnump,"SortV"),Z,W("Zosrt"),qqcc),qorder),qqlang=1:$O(^Q(1,$S($E(qqwc)'="C":qqwc,1:$E(qqwc,2,255)),$S($E(qqwc)'="C":Z,1:$G(^Q(1,qqwc,Z),"???")),W("Zosrt"),qqcc),qorder),1:$O(^Q(1,qqwc,^Q(1,"C"_qqwc,^Q(qqlang,qqwc,Z)),W("Zosrt"),qqcc),qorder)),qqcc=$S($E(qqcc,1,$L(qqcc0))=qqcc0:qqcc,1:"") D:$S(qqcc'="":$G(^(qqcc),99)+1=W("Znsort"),1:0)  Q:qqcc1  I qqcc="" S Z=$O(^Qi(qqwc,Vs(qqnump,"SortV"),Z),qorder) Q:Z=""  I Z0'="",$S(Z?1.N:qARM.GetPar(710,"",W("Zosrt"),qqwc)=1||($L($O(^Qi(qqwc,Vs(qqnump,"SortV"),"")))=$L($O(^Qi(qqwc,Vs(qqnump,"SortV")," "),-1))),1:1),$E(Z,1,$L(Z0))'=Z0 S Z="" Q  ;@Dol 28.03.06 $G(^(qqcc),99)+1=W("Znsort") ;$G( - для R*-понятий
.I $P($$$CondFind," ",6)'="",$G(W("ZfIlTr"))'="" D  Q:'qqcc1  ;@Dol 4.03.05 фильтр
..I $ZCVT(qW.GG(W("Zosrt"),qqwc,qqcc),"U")?@W("ZfIlTr") S qqcc1=1 Q
..S qqcc1=0 
.I 'Cond S qqcc1=1 Q
.D gOrderVm(W("Zosrt"),qqcc)
I qqcc="" S W(qqwc)="" Q ""
S W(qqwc)=..GG(W("Zosrt"),qqwc,qqcc) S:W(qqwc)="" W(qqwc)=" " S:$G(Vo(qqnump,-1,1990)) W(qqwc)=$ZCVT(W(qqwc),"U") S Vs(qqnump,"Virt",W("Zosrt"))=qqcc Q qqcc
Для использовании в X529 ссылочных объектов.
Выполняет сортировку экземпляров по значению понятия qqwsort. Если Arg1=1, то qqwsort вычисляется как выражение.
Кол-во экземпляров должно быть небольшим.
revers=1 - обратная сортировка]]></Description>
<Internal/>
<FormalSpec>qqwsort:%Library.String,Arg1:%Library.String,revers:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I 'qorder Q 1
 I $G(revers) S revers=qorder N qorder S qorder=$S(revers=-1:1,1:-1)
 I qqc=""||('$D(Vs(qqnump,"Vsort",qqo))) D
 .K Vs(qqnump,"Vsort",qqo) N qqz,qqc S qqc="" F  S qqc=$$$UserOrd(1,qqo,qqc,qqcc0) Q:qqc=""  S:'$G(Arg1) qqz=qW.G(qqwsort) S:$G(Arg1) @("qqz="_qqwsort) S:qqz="" qqz="???" S Vs(qqnump,"Vsort",qqo,qqz,qqc)=""
 .S Vs(qqnump,"Vsort",qqo)=$O(Vs(qqnump,"Vsort",qqo,""),qorder) ;первое значение
 I $G(Vs(qqnump,"Vsort",qqo))'="" S qqc=$O(Vs(qqnump,"Vsort",qqo,Vs(qqnump,"Vsort",qqo),qqc),qorder) Q:qqc'="" qqc
 S Vs(qqnump,"Vsort",qqo)=$O(Vs(qqnump,"Vsort",qqo,Vs(qqnump,"Vsort",qqo)),qorder) Q:Vs(qqnump,"Vsort",qqo)="" ""
 S qqc=$O(Vs(qqnump,"Vsort",qqo,Vs(qqnump,"Vsort",qqo),""),qorder) Q qqc
]]></Implementation>
</Method>

<Method name="gOrderVsys">
<Internal/>
<FormalSpec>par:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 G @("gOrderV"_par)
 ;виртуальные объекты системных отображений
gOrderVCxObj
 I $E(qqo,2)=0 Q:'qorder 1 S qqcc=$S(qqcc="":-1,1:"") S:qqcc=-1 W("ZCxObj")=qqcc,W("ZXy")=0,W("ZXx")="" Q qqcc ;объект -1 (вершина); заодно забрали код отображения. Предыдущий объект обязан быть отображением
 I 'qorder Q ''$D(Vo(W("Zqqnump"),qqcc)) ;???относительно предыдущего надо бы
 N y,x,z S y="",x=0 F  S y=$O(Vo(W("Zqqnump"),qqcc0,0,y)) Q:y=""  S z=$G(Vo(W("Zqqnump"),qqcc0,0,y)) I z'="" Q:qqcc=""  S:z=qqcc qqcc=""
 S W("ZXy")=0,W("ZXx")="" S:y'="" W("ZCxObj")=z S:$S(z="":0,1:$G(Vs(W("Zqqnump"),1,z))) Vs(qqnump,1,qqo,z)=1 Q $S(y="":"",1:z)
gOrderVXy I 'qorder Q ''$D(Vo(W("Zqqnump"),W("ZCxObj"),0,qqcc))
 F  S qqcc=$O(Vo(W("Zqqnump"),W("ZCxObj"),0,qqcc),qorder) Q:qqcc=""  Q:$G(Vo(W("Zqqnump"),W("ZCxObj"),0,qqcc))=""
 S:qqcc'="" W("ZXy")=qqcc S W("ZXx")="" Q qqcc
gOrderVXx  G:W("ZXy")="" gOrderVXx1 F  S qqcc=$O(Vo(W("Zqqnump"),W("ZCxObj"),0,W("ZXy"),qqcc),qorder) Q:qqcc=""  S z=$G(Vo(W("Zqqnump"),W("ZCxObj"),0,W("ZXy"),qqcc)) I z'="","2345"[$E(z)||(qARM.GetPar("X731",,W("ZCxObj"),W("ZXy"),qqcc,W("Zqqnump"))'="") Q
 I qqcc'="" S W("ZCxWoc")=$E(z,2,255),W("ZXx")=qqcc Q W("ZXx")
gOrderVXx1 F  S W("ZXy")=$O(Vo(W("Zqqnump"),W("ZCxObj"),0,W("ZXy")),qorder) Q:W("ZXy")=""  Q:$G(Vo(W("Zqqnump"),W("ZCxObj"),0,W("ZXy")))=""
 I W("ZXy")'="" S qqcc="" G gOrderVXx
 Q ""
gOrderVXView I "01"[$E(qqo,2) S %1=$G(WS(W("Zqqnump"),"Zsform")) I %1=1!(%1>9) Q ""
 I "0"[$E(qqo,2) Q:'$D(qwin("Q"_W("Zqqnump"),"o",1)) "" Q $S(qqcc="":1,1:"") ;вызовы
 I "i"[$E(qqo,2) D  Q %1
 .N i F i=1:1 S %1=$G(qwin("Q"_W("Zqqnump"),"o",1,i)) Q:%1=""  Q:qqcc=""  S:%1=qqcc qqcc=""
 I "1"[$E(qqo,2) Q:'$D(qwin("Q"_W("Zqqnump"),"o",2)) "" Q $S(qqcc="":1,1:"") ;печать
 N i F i=1:1 S %1=$G(qwin("Q"_W("Zqqnump"),"o",2,i)) Q:%1=""  Q:qqcc=""  S:%1=qqcc qqcc=""
 Q %1
gOrderVXQuery
 I "7"[$E(qqo,2) Q:'$D(qwin("Q"_W("Zqqnump"),"o",7)) "" Q $S(qqcc="":1,1:"") ;запросы
 N i F i=2:1 S %1=$G(qwin("Q"_W("Zqqnump"),"o",7,i)) Q:%1=""  Q:qqcc=""  S:%1=qqcc qqcc=""
 Q %1
gOrderVXQuest
 I "7"[$E(qqo,2) Q:'$D(^Q(1,"XView",Vo(W("Zqqnump")),"XQuest")) "" Q $S(qqcc="":1,1:"") ;действия
 S qqcc=$O(^Q(1,"XView",Vo(W("Zqqnump")),"XQuest",qqcc),qorder)
 Q qqcc
]]></Implementation>
</Method>

<Method name="gRel">
<Description><![CDATA[
Работа с текущим ($$$Relind) перечнем релевантных.
Arg1= 0 -очистить
+ - занести
-  - удалить
qObj - код объекта
qqc - код экземпляра
Возвращает . через пробел
- кол_во экземпляров объекта
-0/1 - перечень пуст/нет 
Oref - используется только для отображений виртуалных объектов
Arg2=1 действовать как будто виртуальных нет (для обработки X1191)

Arg1="" возвращает $D от перечня релевантных с заданной детализацией (qObj="" - наличие перечня, qqc="" - (!!!)кол-во экземпляров объекта, qqc'="" - экземпляра)
!!! @Dol 11.12.09 исправлена работа со счетчиками $D - избежать ошибок счетчиков; было r<1]]></Description>
<Internal/>
<FormalSpec>Arg1:%String,qObj:%String,qqc:%String,Oref:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 S:$G(qObj)="" qObj=$$$CurObj
 I Arg1=0 K:qview'="" ^Q($$$Relind_qview) Q "0 0"
 N i,qqr,qqob,qqob1,qqco S qqr=0,qqob=$G($$$ObjRef(qObj)) ;,qlist=""
 G:$D(Vt(qqnump,111))&&('$G(Arg2)) gRelend:Arg1="",gRelV
 I Arg1="+" D  Q qqr_" 1"
 .F i=1:1:$L(qqob,",") S qObj=$P(qqob,",",i) I qObj'="",'$D(^Q($$$Relind_qview,qObj,$E(qqc,1,$$$ObjLget(qObj)))) S @$ZR="",$$$RelNum=$I(^Q($$$Relind_qview,qObj)) D gRelZTMPN(qObj,$E(qqc,1,$$$ObjLget(qObj))) ;@Dol 25.05.06 qObj'="" ;$G($$$ObjLqqc(qObj),255)
 .Q:'$G(Vs(qqnump,99,"Find"))  ;отметка поддерева
 .K qqMdel S (qqob,qqob1)=qqob_"," F  S qqob=$O($$$MObjRef(qqob)) Q:$E(qqob,1,$L(qqob1))'=qqob1  D
 ..S qObj=$P(qqob,",",$L(qqob,",")) D:'$D(qqMdel(qObj))
 ...;S qqMdel(qObj)=1,qqco=qqc F  S qqco=..gOrder(1,qObj,qqco,qqc) Q:$E(qqco,1,$L(qqc))'=qqc  D
 ...S qqMdel(qObj)=1,qqco="" F  S qqco=..gOrder(1,qObj,qqco,qqc) Q:qqco=""  D
 ....I '$D(^Q($$$Relind_qview,qObj,qqco)) S ^(qqco)="" I $I(^Q($$$Relind_qview,qObj)),$$gRelZTMPN(qObj,qqco)
 .K qqMdel
 I Arg1="-" D  Q qqr_" "_($D(^Q($$$Relind_qview))>1)
 .Q:'$D(^Q($$$Relind_qview,qObj,qqc))
 .K @$ZR S qqr=$I(^Q($$$Relind_qview,qObj),-1) I $D(^Q($$$Relind_qview,qObj))<10 K ^(qObj) D gRelZTMPN(qObj,,1) ;@Dol 11.12.09 $D - избежать ошибок счетчиков; было r<1
 .;нужно удалить и все поддерево
 .K qqMdel S (qqob,qqob1)=qqob_"," F  S qqob=$O($$$MObjRef(qqob)) Q:qqob=""  Q:$E(qqob,1,$L(qqob1))'=qqob1  D
 ..F i=$L(qqob1,","):1:$L(qqob,",") S qObj=$P(qqob,",",i) D:'$D(qqMdel(qObj))
 ...S qqMdel(qObj)="",qqco=qqc F  S qqco=$O(^Q($$$Relind_qview,qObj,qqco)) Q:qqco=""  Q:$E(qqco,1,$L(qqc))'=qqc  D
 ....K ^(qqco) I $I(^Q($$$Relind_qview,qObj),-1)!1,$D(^Q($$$Relind_qview,qObj))<10 K ^(qObj) D gRelZTMPN(qObj,,1) ;@Dol 11.12.09 $D - избежать ошибок счетчиков; было r<1
 .K qqMdel
gRelend Q $S($G(qObj)="":$D(^Q($$$Relind_qview)),$G(qqc)="":$G(^Q($$$Relind_qview,qObj)),1:$D(^Q($$$Relind_qview,qObj,qqc))) ;@dol 6.07.04
gRelV ;для отображений с виртуальными объектами. Только для вызова из RecRel
 N qqci S:$G(Oref)="" Oref=$G(qOref,$G(Vc(qqnump))) ;@Dol 05.04.06;qOref - в действии по релевантным (X182)
 I Arg1="+" D  Q qqr_" 1"
 .N qqc0,qqc1,qqo0,qqo1,qq6,qq6i
 .F i=2:2:$L(Oref) D
 ..S qq6=$G(Vc(qqnump,$E(Oref,1,i),6)) I qq6'="" F qq6i=1:2:$L(qq6,"~") S qqo0=$P(qq6,"~",qq6i),qqc0=$P(qq6,"~",qq6i+1) D gRelVo
 ..S qqo0=Vc(qqnump,$E(Oref,1,i),0),qqc0=Vc(qqnump,$E(Oref,1,i)) D gRelVo
 .Q:'$G(Vs(qqnump,99,"Find"))  ;отметка поддерева
 .D gRelVP(qqob,qqc,qObj)
 I Arg1="-" D  Q qqr_" "_(''$D(^Q($$$Relind_qview)))
 .Q:'$D(^Q($$$Relind_qview,qObj,qqc))  N qqc0,qqo0,ReF,Vt0 S Vt0=$G(Vt(qqnump,0)),ReF=$$$ReFind S Vt(qqnump,0)=0,$$$ReFind=1
 .D  ;@Dol 8.04.06 найдем qqc верхнего объекта
 ..I $G(Vc(qqnump,Oref,6))'="" S qqc0=Vc(qqnump,Oref,6),qqo0=$P(qqc0,"~",$L(qqc0,"~")-1),qqc0=$P(qqc0,"~",$L(qqc0,"~")) Q  ;есть зачеркнутые
 ..I $L(Oref)=2 S qqc0="",qqo0="" Q
 ..S qqc0=Vc(qqnump,$E(Oref,1,$L(Oref)-2)),qqo0=Vc(qqnump,$E(Oref,1,$L(Oref)-2),0) Q
 .D gRelVM(qqob,qqc,qObj,qqc0,qqo0) S $$$ReFind=ReF,Vt(qqnump,0)=Vt0
 .K ^Q($$$Relind_qview,qObj,qqc) S qqr=$I(^Q($$$Relind_qview,qObj),-1) I $D(^Q($$$Relind_qview,qObj))<10 K ^(qObj) D gRelZTMPN(qObj,,1) ;@Dol 11.12.09 $D - избежать ошибок счетчиков; было r<1
 Q ""
gRelVo I '$D(^Q($$$Relind_qview,qqo0,qqc0)) S @$ZR="",$$$RelNum=$I(^Q($$$Relind_qview,qqo0)) D gRelZTMPN(qqo0,qqc0)
 I $G(qqo1)'="",$D(Vt(qqnump,111,1,qqo0)) S ^Q($$$Relind_qview,qqo1,qqc1,qqo0,qqc0)=""
 S qqo1=qqo0,qqc1=qqc0 Q
gRelVP(qqob,qqc,qqo)
 N qObj,qqco S (qqob,qqob1)=qqob_"," F  S qqob=$O($$$MObjRef(qqob)) Q:$E(qqob,1,$L(qqob1))'=qqob1  D  S qqob=qqob_"я"
 .S qObj=$P(qqob,",",$L(qqob,",")) S Vs(qqnump,"Virt",qqo)=qqc ;@Dol 16.12.09 добавлен Virt. Может использоватся в описании массива или X529
 .S qqco="" F  S qqco=..gOrder(1,qObj,qqco,qqc) Q:qqco=""  D
 ..I '$D(^Q($$$Relind_qview,qObj,qqco)) S ^(qqco)="" I $I(^Q($$$Relind_qview,qObj)) D gRelZTMPN(qObj,qqco)
 ..I $D(Vt(qqnump,111,1,qObj)) S ^Q($$$Relind_qview,qqo,qqc,qObj,qqco)=""
 ..D gRelVP(qqob,qqco,qObj)
 Q
gRelVM(qqob,qqc,qqo,qqc0,qqo0)
 ; D qARM.Message(qqc_" "_qqo_" "_qqc0_" "_qqo0)
 N qqco,qqob1,qObj I qqo0'="" K ^Q($$$Relind_qview,qqo0,qqc0,qqo,qqc) ;@Dol 8.04.06 удаение ссылки из верхнего объекта (см. перечень релевантных для ссылочных)
 S (qqob,qqob1)=qqob_"," F  S qqob=$O($$$MObjRef(qqob),1) Q:$E(qqob,1,$L(qqob1))'=qqob1  D  S qqob=qqob_"я"
 .S qObj=$P(qqob,",",$L(qqob,",")) S Vs(qqnump,"Virt",qqo)=qqc ;@Dol 16.12.09 добавлен Virt. Может использоватся в описании массива или X529
 .S qqco="" F  S qqco=..gOrder(1,qObj,qqco,qqc) Q:qqco=""  D
 ..D gRelVM(qqob,qqco,qObj,qqc,qqo)
 ..K ^Q($$$Relind_qview,qObj,qqco) I $I(^Q($$$Relind_qview,qObj),-1)!1,$D(^Q($$$Relind_qview,qObj))<10 K ^(qObj) D gRelZTMPN(qObj,,1)
 Q
gRelZTMPN(qqqo,qqqc,del)    ;@dol 3.3.03 номер отметки
 I '$D(Vo(qqnump,qqqo,11,"ZTMPN"))," "_$G(Vo(qqnump,qqqo,7))_" "'[" ZTMPN " Q:$Q 0 Q
 I $G(del) K ^Q($$$Relind_qview,"ZTMPNcount",qqqo) Q:$Q 1 Q
 S:'$D(^Q($$$Relind_qview,qqqo,qqqc,"ZTMPN")) ^Q($$$Relind_qview,qqqo,qqqc,"ZTMPN")=$I(^Q($$$Relind_qview,"ZTMPNcount",qqqo)) Q:$Q 1 Q
]]></Implementation>
</Method>

<Method name="gTempor">
<Internal/>
<FormalSpec>qqo:%Library.String,qqoT:%Library.String,qqoP:%Library.String,qqcP:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqnump S qqnump="T" K Vt(qqnump,"ZTmpqqc") ;K Vo(qqnump),Vs(qqnump),Vt(qqnump)
 S Vt(qqnump,0)=1,$$$Tree=0,$$$ReFind=0,Vo(qqnump,qqo,2)=2,Vo(qqnump,qqo,29)=qqoT,Vo(qqnump,qqo,280)="@",Vo(qqnump,qqo,28)=1,Vo(qqnump,qqo,5)=qqoP_","_qqo,Vo(qqnump,qqoP,2)=0
 Q ..gOrder(1,qqo,"",qqcP)
]]></Implementation>
</Method>

<Method name="getDataLinkResultList">
<Internal/>
<FormalSpec>dataLinkParamList:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; tdv 20080520 - пересчитываемые выражения 
 new dataLinkParam,dataLinkParamCnt,dataLinkResult,dataLinkResultList
 new dataLinkParamSep set dataLinkParamSep = "~"
 new dataLinkResultSep set dataLinkResultSep = "_$c(1)_"
 new exprCnt,prefixAndExpr,prefix,expr
    
 ; выражение, возвращающее выражение для списка
 if ($extract(dataLinkParamList,1,2) = "@@") set @("dataLinkParamList="_$extract(dataLinkParamList,3,$length(dataLinkParamList)))
 set dataLinkResultList=""
 for dataLinkParamCnt=1:1:$length(dataLinkParamList,dataLinkParamSep) do
 .set dataLinkParam = $piece(dataLinkParamList,dataLinkParamSep,dataLinkParamCnt)
 .; выражение, возвращающее выражение для элемента
 .if ($extract(dataLinkParam,1) = "@") set @("dataLinkParam="_$extract(dataLinkParam,2,$length(dataLinkParam)))
 .; обработка выражений в {}
 .set dataLinkResult = ""
 .for exprCnt = 1: 1: qSYS.PSYN(dataLinkParam, "}") do
 ..set prefixAndExpr = qSYS.PSYN(dataLinkParam, "}", exprCnt)
 ..set prefix = qSYS.PSYN(prefixAndExpr, "{", 1)
 ..if (prefix '= "") set dataLinkResult = dataLinkResult _ prefix
 ..set expr = qSYS.PSYN(prefixAndExpr, "{", 2)
 ..if (expr '= "") set @("expr = "_ expr) set dataLinkResult = dataLinkResult _ """" _ expr _ """"
 .if (dataLinkResult = "") set dataLinkResult = dataLinkParam
 .if (dataLinkResultList'="") set dataLinkResultList=dataLinkResultList_dataLinkResultSep
 .set dataLinkResultList=dataLinkResultList_$select(dataLinkResult="":"""""",1:"("_dataLinkResult_")")  
 
 quit dataLinkResultList
]]></Implementation>
</Method>

<Method name="getPicSize">
<Description>
Получение размера картиники</Description>
<Internal/>
<FormalSpec>ref:%String,type:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 new node set node = $order(@ref@(""))
 if (node = "") quit ""
 
 new head
 new size set size = ""
 new width
 new height
 
 if (type = "png") {
     set head = $E($P($G(@ref@(node)),"IHDR",2),1,13)
     set width=(256*256*256*$A($E(head)))+(256*256*$A($E(head,2)))+(256*$A($E(head,3)))+$A($E(head,4))
     set height=(256*256*256*$A($E(head,5)))+(256*256*$A($E(head,6)))+(256*$A($E(head,7)))+$A($E(head,8))
     set size = height _ " " _ width
 }
 
 quit size
]]></Implementation>
</Method>

<Method name="oZ1310">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[ Q $C(13,10)
]]></Implementation>
</Method>

<Method name="oZLA">
<Description>
Обобщения для подсчета взвешенных значений агрегатов (в % к общему)
Используется код понятия вида @ZLA.код_понятия (передается из метода qW.G в переменной qqZN).</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 K W(qqw) N iii,qqq,qqz,qqzz ;,$ET S $ET="S $EC="""" Q $ZE_$G(qqz)_""-""_$G(qqzz)"
 S qqz=..G("LA"_$P(qqZN,".",2)) Q:qqz="-" "" Q:qqz="" "" S qqzz=..GG(-1,"LA"_$P(qqZN,".",2),"") Q:qqzz="" "" F iii=1:1:$LL(qqz) S:$LG(qqz,iii)'="" $LI(qqq,iii)=$S('$LI(qqzz,iii):"",qqo'=-1:$J($LI(qqz,iii)*100/$LI(qqzz,iii),0,1)_"%",1:"100%")
 S W(qqw)="0яяя00",W(qqw,$P(qqZN,".",2))=..GtoExt(,qqq,"LA") Q "" ;"0яяя00" - чтобы не совпадал с qqc (см. метод qW.G, вызов обобщений "с точкой")
]]></Implementation>
</Method>

<Method name="oZLAY">
<Description>
Обобщения-коллекция для значений агрегатов
Используется код понятия вида @ZLA.код_понятия (передается из метода qW.G в переменной qqZN).</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 K W(qqw) N iii,qqq,qqz,qqzz ;,$ET S $ET="S $EC="""" Q $ZE_$G(qqz)_""-""_$G(qqzz)"
 S qqz=..G("LA"_$P(qqZN,".",2)) Q:qqz="-" "" Q:qqz="" "" 
 S W(qqw)="0яяя00",W(qqw,$P(qqZN,".",2),$P(qqZN,".",3))=$LG(qqz,$P(qqZN,".",3)-$S($P(qqZN,".",3)>4:4,1:0)) Q "" ;"0яяя00" - чтобы не совпадал с qqc (см. метод qW.G, вызов обобщений "с точкой")
]]></Implementation>
</Method>

<Method name="oZListOfView">
<Description>
Возвращает через пробел список отображений, в которых встречается понятие или объект.</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 N qList,qviewt,qListObj S qList=""
 I $$$CurObj="CxWoc" N xWoc,qqot D
 .S qviewt="" F  S qviewt=$O(^Q(1,"XView",qviewt)) Q:qviewt=""  S qListObj="" D  S:qListObj'="" qList=qList_" "_qviewt_qListObj_","
 ..S qqot="" F  S qqot=$O(^Q(1,"XView",qviewt,"CxObj",qqot)) Q:qqot=""  D  
 ...I (" "_$G(^Q(1,"XView",qviewt,"CxObj",qqot,"X57"))_" ")[(" "_qqc_" ") S qListObj=qListObj_","_qqot Q
 ...S xWoc=$G(^Q(1,"XView",qviewt,"CxObj",qqot,"xWoc")) 
 ...I xWoc'="","@Z"'[$E(qqc) S:(" "_xWoc_" ")[(" "_qqc_" ") qListObj=qListObj_","_qqot Q
 ...N x,y S y="" F  S y=$O(^Q(1,"XView",qviewt,"CxObj",qqot,"Xy",y)) Q:y=""  S x="" F  S x=$O(^Q(1,"XView",qviewt,"CxObj",qqot,"Xy",y,"Xx",x)) Q:x=""  I $G(^(x,"X71"))=qqc,$G(^("x70"))?1(1"2",1"3",1"4") S qListObj=qListObj_","_qqot
 I $$$CurObj="CxObj" D
 .S qviewt="" F  S qviewt=$O(^Q(1,"XView",qviewt)) Q:qviewt=""  I $D(^Q(1,"XView",qviewt,"CxObj",qqc))>1 D
 ..S qList=qList_" "_qviewt
 ..;S qList=qList_$C(13,10)_qviewt_" "_$G(^Q(1,"XView",qviewt,"CxObj",qqc,"X51")) ;с именами в отображении
 Q $E(qList,2,$L(qList))
]]></Implementation>
</Method>

<Method name="oZTMP">
<Description>
Обобщение срабатывает при изменении отметки релевантных.
Выводит значение по умолчанию для понятия (X75) 
ZTMP - новая отметка (+ или -)</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[ N zzzz S zzzz=qARM.GetPar("X75",,qqo,"@ZTMP") S:$E(zzzz)="@" @("zzzz="_$E(zzzz,2,30000)) Q zzzz
]]></Implementation>
</Method>

<Method name="oZVs8">
<Description>
Расшифровка поискового образа для вывода в заголовок отчета (если режим Уточнения).
qqnump8 - номер окна с поисковым образом (не задано - текущее)
NoReFind=1 - вне зависимости от режима уточнения
Возвращает (через ВК ПС ) имена понятий с наложенными на них условиями.
Нормализованная дата в простых условиях преобразуется к стандартному виду</Description>
<Internal/>
<FormalSpec>qqnump8:%Library.String,NoReFind:%Library.String,qxml0:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqo8,qqw8,qqz,qqzz,ret,qqwt S ret="" S:$G(qxml0)="" qxml0=$G(qxml)&&($G(qxml)<5) S:$G(qqnump8)="" qqnump8=qqnump I '$G(Vs(qqnump8,"ReFind")),'$G(NoReFind) Q "" ;не режим Уточнение
 S qqo8="" F  S qqo8=$O(Vs(qqnump8,8,qqo8)) Q:qqo8=""  S qqw8=""  F  S qqw8=$O(Vs(qqnump8,8,qqo8,qqw8)) Q:qqw8=""  S qqz=$G(Vs(qqnump8,8,qqo8,qqw8)) D:qqz'=""
 .S ret=ret_$S('$G(qxml0):$C(13,10),1:"<p>")_qARM.GetName(,qqo8,qqw8,qqnump8)_": "
 .S qqzz=$P(qqz," ") D  S ret=ret_$S('$G(qxml0):qqzz_" "_$P(qqz," ",2,255),1:..CXML(qqzz_" "_$P(qqz," ",2,255)))_$S('$G(qxml0):"",1:"</p>")
 ..I qqz[";;",$L($P(qqz,";;"))>30 S qqz=" "_$P(qqz,";;",2,255),qqzz="..." Q 
 ..I $E(qqzz,1,3)="..." Q
 ..S qqwt=qARM.GetPar("x710",,qqo8,qqw8,,qqnump8) ;тип понятия
 ..I qqzz[">>"  D:qqwt'=""  S qqzz=$S($P(qqzz,">>",1)'="":"от "_$P(qqzz,">>",1)_" ",1:"")_$S($P(qqzz,">>",2)'="":"до "_$P(qqzz,">>",2),1:"") Q
 ...I "16"[$E(qqwt) S:$L($P(qqzz,">>",1))=8 $P(qqzz,">>",1)=qW.GtoExt(qqwt,$P(qqzz,">>",1)) S:$L($P(qqzz,">>",2))=8 $P(qqzz,">>",2)=qW.GtoExt(qqwt,$P(qqzz,">>",2)) Q  ;если полная дата - преобразуем
 ...I "78"[$E(qqwt) S:$L($P(qqzz,">>",1))>7 $P(qqzz,">>",1)=qW.GtoExt($S($L($P(qqzz,">>",1))=8:10,1:70),$P(qqzz,">>",1)) S:$L($P(qqzz,">>",2))>7 $P(qqzz,">>",2)=qW.GtoExt($S($L($P(qqzz,">>",1))=8:10,1:70),$P(qqzz,">>",2)) Q  ;интервал или датавремя
 ..I qqzz'["*",qqwt'="" D
 ...I "16"[$E(qqwt),$L(qqzz)=8 S qqzz=qW.GtoExt(qqwt,qqzz) Q  ;чистая дата
 ...I "78"[$E(qqwt),$L(qqzz)>7 S qqzz=qW.GtoExt($S($L(qqzz)=8:10,1:70),qqzz) Q
 ..I qqzz="*" S qqzz="""ЕСТЬ значение""" Q
 ..I qqzz="=""""" S qqzz="""НЕТ значения""" Q
 Q:$G(qxml0) ret Q $E(ret,3,30000)
]]></Implementation>
</Method>

<Method name="oZZdate">
<Description>
W("@ZZdateWeek")=кол-во отображаемых недель</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(Arg2)=1 S $E(W("ZZdate"),5,6)=$E($P(Z," ")+100,2,3) D qW.oZZdate(),qARM.wwww("* ZZdate",1) X:$G(W("ZZxcute"))'="" W("ZZxcute") Q "" ;правило проверки для выбора месяца
 I $G(Arg2)=2 S $E(W("ZZdate"),1,4)=Z D qW.oZZdate(),qARM.wwww("* ZZdate",1) X:$G(W("ZZxcute"))'="" W("ZZxcute") Q "" ;правило проверки для выбора года
 I $G(Arg2)=3 S W("ZZdate")=$ZD($H,8) D qW.oZZdate() K qqwold D qARM.OpenTimer(100,"D qARM.wwww(""* ZZdate"",1) X:$G(W(""ZZxcute""))'="""" W(""ZZxcute"")") Q "" ; действие Сегодня
 I $G(Arg2)=4 N qd S qd=$E(W("ZZdate"),5,6)-1 S:qd<1 qd=12,$E(W("ZZdate"),1,4)=$E(W("ZZdate"),1,4)-1 S $E(W("ZZdate"),5,6)=$E(qd+100,2,3) D qW.oZZdate() K qqwold D qARM.OpenTimer(100,"D qARM.wwww(""* ZZdate"",1) X:$G(W(""ZZxcute""))'="""" W(""ZZxcute"")") Q:$Q "" Q  ;действие Предыдущий месяц
 I $G(Arg2)=5 N qd S qd=$E(W("ZZdate"),5,6)+1 S:qd>12 qd=1,$E(W("ZZdate"),1,4)=$E(W("ZZdate"),1,4)+1 S $E(W("ZZdate"),5,6)=$E(qd+100,2,3) D qW.oZZdate() K qqwold D qARM.OpenTimer(100,"D qARM.wwww(""* ZZdate"",1) X:$G(W(""ZZxcute""))'="""" W(""ZZxcute"")") Q:$Q "" Q  ;действие Следующий месяц
 I $G(Arg2)=6||($G(Arg2)=7) S W("ZZdate")=$ZD($ZDH(W("ZZdate"),8)+$S($G(Arg2)=7:7,1:-7),8)  D qW.oZZdate() K qqwold D qARM.OpenTimer(100,"D qARM.wwww(""* ZZdate"",1) X:$G(W(""ZZxcute""))'="""" W(""ZZxcute"")") Q:$Q "" Q  ;действие Предыдущая|Следующая  неделя
 I $G(Arg2)=8||($G(Arg2)=9) S W("ZZdate")=$ZD($ZDH(W("ZZdate"),8)+$S($G(Arg2)=9:1,1:-1),8)  D qW.oZZdate() K qqwold D qARM.OpenTimer(100,"D qARM.wwww(""* ZZdate"",1) X:$G(W(""ZZxcute""))'="""" W(""ZZxcute"")") Q:$Q "" Q  ;действие Предыдущий|Следующий  день
 I $G(Arg2)=10 D qW.oZZdate() D qARM.OpenTimer(100,"D qARM.wwww(""* ZZdate"",1,,-1,"""") X:$G(W(""ZZxcute""))'="""" W(""ZZxcute"")") Q:$Q "" Q  ;перевывод
 I $G(Arg1)=0 D  Q:$Q "" Q  ;Действие выбор дня
 .N qd,qd0 S qd0=$S($G(Arg3)'="":$S(Arg3=-1:1,1:Arg3),1:$P(qqw,".",2)) I '$G(W("@ZZdateWeek")),$G(W("@ZZdate",qd0+42))="~" Q
 .I $G(W("@ZZdate",0)) Q:qd0=W("@ZZdate",0)  S qd=W("@ZZdate",0) K W("@ZZdate",0) D:$G(Arg3)'=-1 qARM.wwww("@ZZdate."_qd,,,-1,"") D:$P($G(W("@ZZdateWeek"))," ",2) qARM.wP(qwin_".T2","ColumnWidth",+Vo(qqnump,-1,0,0,$P(Vo(qqnump,-1,11,"@ZZdate.2")," ",2),2),$P(Vo(qqnump,-1,11,"@ZZdate."_qd)," ",2))
 .S qd=qd0,W("@ZZdate",0)=qd D:$G(Arg3)'=-1  D:$P($G(W("@ZZdateWeek"))," ",2) qARM.wP(qwin_".T2","ColumnWidth",+Vo(qqnump,-1,0,0,$P(Vo(qqnump,-1,11,"@ZZdate.1")," ",2),2),$P(Vo(qqnump,-1,11,"@ZZdate."_qd)," ",2))
 ..I '$G(W("@ZZdateWeek")) D qARM.wwww("@ZZdate."_qd,,,-1,"") Q
 ..S qd0=W("@ZZdate",qd),W("@ZZdate",qd)=qW.GtoExt(1,W("@ZZdate",qd+42)_$E(W("@ZZdate",qd)+100,2,3)) D qARM.wwww("@ZZdate."_qd,,,-1,"") S W("@ZZdate",qd)=qd0
 .D
 ..I '$G(W("@ZZdateWeek")) S $E(W("ZZdate"),7,8)=$E(W("@ZZdate",qd)+100,2,3) Q
 ..S:$G(Arg3)'=-1 W("ZZdate")=W("@ZZdate",qd+42)_$E(W("@ZZdate",qd)+100,2,3)
 .D:$G(Arg3)'=-1 qARM.wwww("ZZdate",1,,-1,"")
 .I $G(Arg3)="",$G(W("ZZxcute"))'="" X W("ZZxcute")
 I $G(Arg1)>0 S Arg2=$S('$P($G(W("@ZZdateWeek"))," ",2):"07"[(Arg1#7),1:"Сб Вс"[W("@ZZdate",Arg1+126)) Q $S(W("@ZZdate",Arg1+42)["~":12632256,W("@ZZdate",Arg1+42)["*":16711680,Arg2:255,1:8388608)_","_$S($G(W("@ZZdate",0))=Arg1:16776960,1:16777215)
 N hd1,d1,hi
 I $G(W("@ZZdate",0)),$G(W("@ZZdate",0))'=1,$P($G(W("@ZZdateWeek"))," ",2) D ..oZZdate(0,,-1)
 K W("@ZZdate") S W("@ZZdate")="",hd1=$ZDH($S($G(W("@ZZdateWeek")):W("ZZdate"),1:$E(W("ZZdate"),1,6)_"01"),8),hd1=$S($P($G(W("@ZZdateWeek"))," ",2):hd1-1,1:hd1-..zDW(hd1)) ;(hd1+3#7)-1) ;$H и день недели первого числа;Arg1+3#7+1
 F hi=1:1:$S($G(W("@ZZdateWeek")):$G(W("@ZZdateWeek"))*7,1:42) S W("@ZZdate",hi)=+$E($ZD(hd1+hi,8),7,8),W("@ZZdate",hi+42)=$S($G(W("@ZZdateWeek")):$E($ZD(hd1+hi,8),1,6),hd1+hi=+$H:"*",$E($ZD(hd1+hi,8),5,6)=$E(W("ZZdate"),5,6):"",1:"~") I W("@ZZdate",hi)=+$E(W("ZZdate"),7,8),$S($G(W("@ZZdateWeek")):$E($ZD(hd1+hi,8),5,6)=$E(W("ZZdate"),5,6),1:$G(W("@ZZdate",hi+42))'="~") S W("@ZZdate",0)=hi
 I '$G(W("@ZZdate",0)) D  S $E(W("ZZdate"),7,8)=$E(100+W("@ZZdate",hi),2,3),W("@ZZdate",0)=hi ;если заданный день вне месяца
 .I '(+$E(W("ZZdate"),7,8)) F hi=1:1 Q:$G(W("@ZZdate",hi+42))'="~"
 .I (+$E(W("ZZdate"),7,8)) F hi=$S($G(W("@ZZdateWeek")):$G(W("@ZZdateWeek"))*7,1:42):-1 Q:$G(W("@ZZdate",hi+42))'="~"
 I $G(W("@ZZdateWeek")) S hd1=..zDW($ZDH(W("ZZdate"),8))-2 F hi=1:1:W("@ZZdateWeek")*7 S W("@ZZdate",hi+84)=$S($G(W("@ZZdate",hi+42))=$G(W("@ZZdate",hi+41)):"~",1:qW.GetWoc("CxMonth",+$E(W("@ZZdate",hi+42),5,6))) S:W("@ZZdate",hi+84)'="~" W("@ZZdate",hi+84)=$ZCVT($E(W("@ZZdate",hi+84)),"U")_$E(W("@ZZdate",hi+84),2,255) S W("@ZZdate",hi+126)=$P("Пн Вт Ср Чт Пт Сб Вс"," ",hi+hd1#7+1) ;Название месяца и дня недели
 ;I $G(W("ZZxcute"))'="" X W("ZZxcute")
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="oZZrasp">
<Description>
Создание массива расписания на заданный день (Arg1 в формате ГГГГММДД).
tlist - строка описания. Если не задана, ищется в W(qqwr)
Описание расписания хранится в текстовом понятии W(qqwr) в виде строк. (qqwr="Traspisan" по умолчанию)
Формат строк описания - список (через пробел) вида:
(1) - тип дня.
Пусто - любой;
ч - четный день, н - нечетный, п - праздничный, г - нерабочий (праздники и выходные),
число (1-7) - день недели;
*ГГГГММДД - конкретное число;
*ГГГГММДД-ГГГГММДД - число в интервале; *ГГГГММДД- - начиная с конкретного числа
к варианту * можно добавлять: 
#число - периодичность (#1 - каждый день (по умолчанию), #2 - через день и т.п.)
Nчисло - кол-во раз
Тип дня может быть составным. Например 123, гч
(2) - информация о приеме на заднный день
(3 и далее) - время и (через ~ ) информация о приеме на заданное время.

Примечание: поиск подходящей строки ведется ведется начиная с последней

tlistDef - строка описания по умолчанию (если для Arg1 не найдена строка в W(qqwr)  ). Если не задана - выходные и праздничные дни - НЕТ_ПРИЕМА, остальные - ПРИЕМ с 9 до 15 с интервалом 30 минут.
listnd - список через пробел нерабочих дней в в формате ММДД (по умолчанию - текущие праздники)

Add=1 - добавление текущей информации в массив расписания (иначе массив удаляется)

Массив расписания имеет вид:
W("@ZZrasp",Arg1)=~~информация о приеме на заднный день
W("@ZZrasp",Arg1,время)=~~информация о приеме на заднное время

Два первых поля (разделитель "~" ) зарезервированы для счетчика и кода экземпляра в отображении работы с графиком
W("@ZZrasp",Arg1)  при вызове уничтожается.

При вызове в виде функции возвращается строка описания расписания для Arg1.

Пример описания расписания:
W(qqwr,0)= ОБЩЕЕ 9:00 9:30 10:00~ПРОВЕТРИВАНИЕ 10:30
W(qqwr,1)=5 МЕТОДИЧЕСКИЙ_ДЕНЬ 9:00-15:00
W(qqwr,0)=г НЕТ_ПРИЕМА</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,tlist:%Library.String,qqwr:%Library.String,tlistDef:%Library.String,listnd:%Library.String,Add:%Library.String,qqoadd:%Library.String,qqwadd:%Library.String,qqc0add:%Library.String,qqwladd:%Library.String,qqwdat:%Library.String,Noqqc:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N tlisti,dw,qw,dp,zz,zzz,qN S:$G(Arg1)="" Arg1=$ZD($H,8) S:$G(qqwr)="" qqwr="Traspisan" S dw=$ZD($ZDH(Arg1,8),10) S:'dw dw=7 ;$ZDH(Arg1,8)+3#7+1
 S:'$D(listnd) listnd="0101 0102 0107 0308 0501 0509 1206 0711 1212" S dp=" "_listnd_" "[(" "_$E(Arg1,5,8)_" ")
 D:$G(tlist)=""
 .S tlisti="" F  S tlisti=$O(W(qqwr,tlisti),-1) Q:tlisti=""  S tlist=W(qqwr,tlisti),qw=$P(tlist," ") D  Q:qw=""
 ..Q:qw=""  I $E(qw)="*" S zzz=$P(qw,"*",3),qw=$P(qw,"*",2) D  Q
 ...S zz=$S(zzz["#":$P($TR($P(zzz,"#",2),"N"," ")," "),1:""),zzz=$S(zzz["N":$P($TR($P(zzz,"N",2),"#"," ")," "),1:"")
 ...Q:Arg1<qw  I qw=Arg1 S qw="" Q
 ...Q:qw'["-"  I $P(qw,"-",2)'="",Arg1>$P(qw,"-",2) Q
 ...S qw=$ZDH(Arg1,8)-$ZDH($P(qw,"-"),8)+1
 ...I zz="",zzz="" S qN=qw,qw="" Q
 ...I zz'="",zz'=1 Q:qw-1#zz  S qw=qw\zz+1
 ...I zzz=""||(qw'>zzz) S qN=qw,qw="" Q
 ..I (qw[dw)||$S(qw["н":$ZDH(Arg1,8)#2,qw["ч":'($ZDH(Arg1,8)#2),qw["г":dw>5||dp,qw["п":dp,qw["р":'dp&&(dw<6),1:0) S qw=""
 .I tlisti="" S tlist="" I $D(W(qqwr))<10 S tlist=$G(tlistDef,$S(dw>5||dp:" НЕТ_ПРИЕМА",1:" ПРИЕМ 9:00 9:30 10:00 10:30 11:00 11:30 12:00 12:30 13:00 13:30 14:00 14:30 15:00"))
 K:'$G(Add) W("@ZZrasp",Arg1) I $TR(tlist," ")'="" S W("@ZZrasp",Arg1)="~~"_$P(tlist," ",2) F tlisti=3:1:$L(tlist," ") S qw=$P(tlist," ",tlisti) I qw'="" S:qw[":" qw=$E(100+qw,2,3)_":"_$P(qw,":",2,255) D
 .I $D(W("@ZZrasp",Arg1,$P(qw,"~"))),$P(W("@ZZrasp",Arg1,$P(qw,"~")),"~",3)'="" Q:$P(W("@ZZrasp",Arg1,$P(qw,"~")),"~",3)=$P(qw,"~",2)  Q:$P(qw,"~",2)=""  S W("@ZZrasp",Arg1,$P(qw,"~")_"*")="~~"_$P(qw,"~",2,255) S:$D(W("@ZZrasp",0)) W("@ZZrasp",0,$P(qw,"~")_"*")="" Q  ;дублирование времени ???
 .S W("@ZZrasp",Arg1,$P(qw,"~"))="~~"_$P(qw,"~",2,255) S:$D(W("@ZZrasp",0)) W("@ZZrasp",0,$P(qw,"~"))=""
 I $G(qqoadd)'="" D  ;дополнение информацией из объекта
 .S:'$D(qqc0add) qqc0add=$G(qqc) S:'$D(qqwadd) qqwadd="pPN" N qqc,zzzi S qqc="" F  s qqc=$$$UserOrd(1,qqoadd,qqc,qqc0add) Q:qqc=""  I $S($G(qqwdat)="":1,qqwadd'="Traspisan":qW.GG(qqoadd,qqwdat,qqc)=Arg1,1:qW.GG(qqoadd,qqwdat,qqc)'>Arg1) D
 ..S zz=$TR(qW.GG(qqoadd,qqwadd,qqc),"*")
 ..I qqwadd="Traspisan" D ..oZZrasp(Arg1,,,"",,1) Q
 ..S:zz="" zz="б/в" D
 ...S zzz="" Q:'$D(qqwladd)  F zzzi=1:1:$L(qqwladd," ") S zzz=zzz_"~"_$S($P(qqwladd," ",zzzi)="":"",$P(qqwladd," ",zzzi)'[":":qW.GG(qqoadd,$P(qqwladd," ",zzzi),qqc),1:qW.GG($P($P(qqwladd," ",zzzi),":",1),$P($P(qqwladd," ",zzzi),":",2)))
 ...S zzz=$E(zzz,2,30000)
 ..I $D(W("@ZZrasp",Arg1,zz)),$P(W("@ZZrasp",Arg1,zz),"~",3)'="" D  Q
 ...I $P(W("@ZZrasp",Arg1,zz),"~",3)=$P(zzz,"~") Q:$G(Noqqc)  S $P(W("@ZZrasp",Arg1,zz),"~",2)=qqc Q
 ...Q:zzz=""  S W("@ZZrasp",Arg1,zz_"*")="~"_$S($G(Noqqc):"",1:qqc)_"~"_zzz
 ..S W("@ZZrasp",Arg1,zz)="~"_$S($G(Noqqc):"",1:qqc)_"~"_zzz
 Q:$Q $S(tlist="":"",1:" "_$P(tlist," ",2,32000)) Q
]]></Implementation>
</Method>

<Method name="oZZraspday">
<Description>
Возврат подходящей для заданного дня (Arg1) строки расписания.
Параметры см. qW.oZZrasp</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,qqwr:%Library.String,tlistDef:%Library.String,listnd:%Library.String,time:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N tlisti,dw,qw,dp,zz,zzz,qN S:$G(Arg1)="" Arg1=$ZD($H,8) S:$G(qqwr)="" qqwr="Traspisan" S dw=$ZD($ZDH(Arg1,8),10) S:'dw dw=7 ;$ZDH(Arg1,8)+3#7+1
 S:'$D(listnd) listnd="0101 0102 0107 0308 0501 0509 1206 0711 1212" S dp=" "_listnd_" "[(" "_$E(Arg1,5,8)_" ")
 S tlisti="" F  S tlisti=$O(W(qqwr,tlisti),-1) Q:tlisti=""  S tlist=W(qqwr,tlisti),qw=$P(tlist," ") D  Q:qw=""
 .Q:qw=""  I $E(qw)="*" S zzz=$P(qw,"*",3),qw=$P(qw,"*",2) D  Q
 ..S zz=$S(zzz["#":$P($TR($P(zzz,"#",2),"N"," ")," "),1:""),zzz=$S(zzz["N":$P($TR($P(zzz,"N",2),"#"," ")," "),1:"")
 ..Q:Arg1<qw  I qw=Arg1 S qw="" Q
 ..Q:qw'["-"  I $P(qw,"-",2)'="",Arg1>$P(qw,"-",2) Q
 ..S qw=$ZDH(Arg1,8)-$ZDH($P(qw,"-"),8)+1
 ..I zz="",zzz="" S qN=qw,qw="" Q
 ..I zz'="",zz'=1 Q:qw-1#zz  S qw=qw\zz+1
 ..I zzz=""||(qw'>zzz) S qN=qw,qw="" Q
 .I (qw[dw)||$S(qw["н":$ZDH(Arg1,8)#2,qw["ч":'($ZDH(Arg1,8)#2),qw["г":dw>5||dp,qw["п":dp,qw["р":'dp&&(dw<6),1:0) S qw=""
 I tlisti="" S tlist="" I $D(W(qqwr))<10 S tlist=$G(tlistDef,$S(dw>5||dp:" НЕТ_ПРИЕМА",1:" ПРИЕМ 9:00 9:30 10:00 10:30 11:00 11:30 12:00 12:30 13:00 13:30 14:00 14:30 15:00"))
 I $G(time)'="" S tlist=$P(tlist," ",1,2)_" "_time_$P($P(tlist," "_time,2)," ") ;для конкретного времени ??? а если одинаковое
 Q:$Q tlist Q
]]></Implementation>
</Method>

<Method name="oZZraspw">
<Description>
Расшифровка (визуализация) расписания
qqwr - код понятия расписания
Arg2=1 - выводить только время</Description>
<Internal/>
<FormalSpec>qqwr:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qq,qqq,qqz,qqzz,qqzzz,qqzi,qqzii S:$G(qqwr)="" qqwr="Traspisan" S qqz=""
 S (qq,qqzi)="" F  S qqzi=$O(W(qqwr,qqzi)) Q:qqzi=""  S qqz=W(qqwr,qqzi) I $TR(qqz," ")'="" S:qq'="" qq=qq_$C(13,10) D
 .S qqzz=$P(qqz," ") I qqzz'="" F qqzii=1:1:$L(qqzz) D
 ..I $E(qqzz,qqzii)="N" S qqzii=qqzii+2 S:$E(qqzz,qqzii)?1n qqzii=qqzii+1 Q  ;кол-во пропустим
 ..I $E(qqzz,qqzii)="#" S qq=qq_"через "_$E(qqzz,qqzii+1)_" дн,",qqzii=qqzii+1 Q
 ..I $E(qqzz,qqzii)?1N S qq=qq_$P("Пн Вт Ср Чт Пт Сб Вс"," ",$E(qqzz,qqzii))_"," Q
 ..I $E(qqzz,qqzii)="ч" S qq=qq_"чет," Q
 ..I $E(qqzz,qqzii)="н" S qq=qq_"нечет," Q
 ..I $E(qqzz,qqzii)="п" S qq=qq_"празд," Q
 ..I $E(qqzz,qqzii)="г" S qq=qq_"нераб," Q
 ..I $E(qqzz,qqzii)="г" S qq=qq_"раб," Q
 .S:$E(qq,$L(qq))="," $E(qq,$L(qq))=""
 .S qqzz=$P(qqz," ",3,255) I qqzz'="" F qqzii=1:1:$L(qqzz," ") S qqzzz=$P(qqzz," ",qqzii) D:qqzzz'=""
 ..S qqq=$P(qqzzz,"~",2) S:qqq="" qqq=$P($P(qqz," ",2),"~")
 ..S qq=qq_" "_$P(qqzzz,"~") I '$G(Arg2) S qqq=$P(qqzzz,"~",2) S:qqq="" qqq=$P($P(qqz," ",2),"~") S:qqq'="" qq=qq_":"_qqq
 Q qq
]]></Implementation>
</Method>

<Method name="oZcordtu">
<Description>
Дата, время,пользователь коррекции и создания  текущего экземпляра объекта. ;@Dol 21.07.09 для виртуальных
Arg1=1 - только коррекция
2 - только создание
3 - обе  через ; (вариант по умолчанию) 

Arg2 - код объекта (по умолчанию qqo)
Arg3 - код экземпляра (по умолчанию qqc)
@ank 20101101 Изменён алгоритм запаковки\распаковки дат</Description>
<Internal/>
<FormalSpec>Arg1:%String=3,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qqtm,qqtm1
 I $G(Arg2)'="" N qqo S qqo=Arg2
 I $G(Arg3)'="" N qqc S qqc=Arg3
 I Arg1#2 S qqtm=$G(^Q(1,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)),qqc,"X")) S:$L(qqtm)&($L(qqtm)<$S($E(qqtm,1,2)=$C(0,0):8,1:5)) qqtm=$E(qqtm_$C(0,0,0,0),1,$S($E(qqtm,1,2)=$C(0,0):8,1:5)) S:qqtm'="" qqtm=$ZDT($ZLA($RE($S($E(qqtm,1,2)=$C(0,0):$E(qqtm,3,5),1:$E(qqtm,1,2)))_$S($E(qqtm,1,2)=$C(0,0):$C(0),1:$C(0,0)))_","_$ZLA($RE($S($E(qqtm,1,2)=$C(0,0):$E(qqtm,6,8),1:$E(qqtm,3,5)))_$C(0)),8)_" "_$E(qqtm,$S($E(qqtm,1,2)=$C(0,0):9,1:6),255) Q:Arg1=1 qqtm
 I Arg1>1 S qqtm1=$G(^Q(1,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)),qqc,"Xc")) S:$L(qqtm1)&($L(qqtm1)<$S($E(qqtm1,1,2)=$C(0,0):8,1:5)) qqtm1=$E(qqtm1_$C(0,0,0,0),1,$S($E(qqtm1,1,2)=$C(0,0):8,1:5)) S:qqtm1'="" qqtm1=$ZDT($ZLA($RE($S($E(qqtm1,1,2)=$C(0,0):$E(qqtm1,3,5),1:$E(qqtm1,1,2)))_$S($E(qqtm1,1,2)=$C(0,0):$C(0),1:$C(0,0)))_","_$ZLA($RE($S($E(qqtm1,1,2)=$C(0,0):$E(qqtm1,6,8),1:$E(qqtm1,3,5)))_$C(0)),8)_" "_$E(qqtm1,$S($E(qqtm1,1,2)=$C(0,0):9,1:6),255) Q:Arg1=2 qqtm1
 Q $G(qqtm)_$S($G(qqtm1)="":"",1:";"_qqtm1) ;_" qqc="_$TR(qqc," ","_") ;временно qqc
]]></Implementation>
</Method>

<Method name="oZdtuco">
<Internal/>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[ Q ..oZcordtu(1)
]]></Implementation>
</Method>

<Method name="oZdtucor">
<Description>
Дата, время, имя пользователя коррекции</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[ N dtu,usr S dtu=..oZcordtu(1) Q:dtu="" "" S usr=qW.GG("XUser","XUn",$P(dtu," ",3)) S:usr=""&&($P(dtu," ",3)'="") usr=$G(^Q(1,"XUser",$P(dtu," ",3),"Thlp",0)) Q $E(dtu,7,8)_"."_$E(dtu,5,6)_"."_$E(dtu,3,4)_" "_$P($P(dtu," ",2),":",1,2)_" "_usr
]]></Implementation>
</Method>

<Method name="oZdtucr">
<Description>
           Распаковка информации о создании</Description>
<Internal/>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[ Q ..oZcordtu(2)
]]></Implementation>
</Method>

<Method name="oZdtudel">
<Description>
@ank 20101101 Изменён алгоритм запаковки\распаковки дат</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[ N qqtm S qqtm=$G(^Q(1,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)),qqc,"Xd")) S:$L(qqtm)&($L(qqtm)<$S($E(qqtm,1,2)=$C(0,0):8,1:5)) qqtm=$E(qqtm_$C(0,0,0,0),1,$S($E(qqtm,1,2)=$C(0,0):8,1:5)) S:qqtm'="" qqtm=$ZDT($ZLA($RE($S($E(qqtm,1,2)=$C(0,0):$E(qqtm,3,5),1:$E(qqtm,1,2)))_$S($E(qqtm,1,2)=$C(0,0):$C(0),1:$C(0,0)))_","_$ZLA($RE($S($E(qqtm,1,2)=$C(0,0):$E(qqtm,6,8),1:$E(qqtm,3,5)))_$C(0)),8)_" "_$E(qqtm,$S($E(qqtm,1,2)=$C(0,0):9,1:6),255) Q qqtm ;@Dol 21.07.09 для виртуальных
]]></Implementation>
</Method>

<Method name="oZnum">
<Description>
Специальное обобщение для счетчиков (иерархических) кол-ва экземпляров для печатных форм.
Можно использовать как метод с Arg1 (любое, не совпадающее с кодами объектов) для сквозной нумерации (без учета уровней иерархии)</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $G(Arg1)'="" N qqo,qqw S qqo=Arg1,qqw="@Znum"
 Q:$G(qqc)[" " 1 Q:$G(qqnump,"P")="P" $I(W(qqw,qqo)) Q:$D(W(qqw,qqo,qqc)) W(qqw,qqo,qqc) S W(qqw,qqo,qqc)=$I(W(qqw,qqo)) Q W(qqw,qqo) ;@Dol 25.03.09 блокировка увеличения счетчика при повторном перевыводе (особенно через qARM.wqqotree после коррекции)
]]></Implementation>
</Method>

<Method name="oZnumBase">
<Description>
Кол-во экземпляров в базе</Description>
<Internal/>
<FormalSpec>qqoo:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ S:$G(qqoo)="" qqoo=qqo Q:$G(qqoo)=""||(qqoo=-1) "" Q $S($G(Vo(qqnump,qqoo))<3:+$G(^Q(1,$S($E(qqoo)'="v":qqoo,1:$E(qqoo,3,255)))),Vo(qqnump,qqoo,2)=4:+$P($G(@("^"_qqoo))," ",2),1:"")
]]></Implementation>
</Method>

<Method name="oZnumRel">
<Description>
Счетчик релевантных</Description>
<Internal/>
<FormalSpec>qqoo:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ S:$G(qqoo)="" qqoo=qqo Q:$G(qqoo)=""||(qqoo=-1) "" Q +$G(^Q($$$Relind_qview,qqoo))
]]></Implementation>
</Method>

<Method name="oZrXc">
<Description>
Дата создания
@ank 20101101 Изменён алгоритм запаковки\распаковки дат</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[ N qqtm1 S qqtm1=$G(^Q(1,qqo,qqc,"Xc")) Q:qqtm1="" "" S:$L(qqtm1)&($L(qqtm1)<$S($E(qqtm1,1,2)=$C(0,0):8,1:5)) qqtm1=$E(qqtm1_$C(0,0,0,0),1,$S($E(qqtm1,1,2)=$C(0,0):8,1:5)) S qqtm1=$ZD($ZLA($RE($S($E(qqtm1,1,2)=$C(0,0):$E(qqtm1,3,5),1:$E(qqtm1,1,2)))_$S($E(qqtm1,1,2)=$C(0,0):$C(0),1:$C(0,0))),8) Q qqtm1
]]></Implementation>
</Method>

<Method name="oZrXd">
<Description>
Дата логического удаления
@ank 20101101 Изменён алгоритм запаковки\распаковки дат</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[ N qqtm1 S qqtm1=$G(^Q(1,qqo,qqc,"Xd")) Q:qqtm1="" "" S:$L(qqtm1)&($L(qqtm1)<$S($E(qqtm1,1,2)=$C(0,0):8,1:5)) qqtm1=$E(qqtm1_$C(0,0,0,0),1,$S($E(qqtm1,1,2)=$C(0,0):8,1:5)) S qqtm1=$ZD($ZLA($RE($S($E(qqtm1,1,2)=$C(0,0):$E(qqtm1,3,5),1:$E(qqtm1,1,2)))_$S($E(qqtm1,1,2)=$C(0,0):$C(0),1:$C(0,0))),8) Q qqtm1
]]></Implementation>
</Method>

<Method name="parent">
<Description>
qqnump, qqo, qqw и qqc (через пробел) предыдущего экрана ( "родителя" текущей экранной формы)</Description>
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[ N parent S parent=$G(Vt(qqnump,"ZparentW")) Q:parent="" "" Q $P(parent," ",2)_" "_$G(Vs($P(parent," ",2),"CurObj"))_" "_$P(parent," ",3)_" "_$G(Vs($P(parent," ",2),"ID"))
]]></Implementation>
</Method>

<Method name="qAnal">
<Description>
построение аналитического среза по Vs(qqnump,12)
qqpar1 - (0) =1 - учет пустых значений
qqpar2 - (0) =1 - аналитика по словам значений
qqpar3 - =1 - построение иерархии ссылок на экземпляры объектов. Если пуст, то автоматическое
определение наличия ссылок для объектов Vs(qqnump,12,qqo)=1.
por - (0) - порог экземпляров
qanam - имя архива
all - (0) =1 - полное дерево
@Dol 22.04.09 Cond||($G(Vo(qqnump,qqao0,40))=3) - учтен вариант учета условий в релевантных ;22.11.10 R*</Description>
<Internal/>
<FormalSpec>qqpar1:%String=0,qqpar2:%String=0,qqpar3:%String,por:%String=0,qanam:%Library.String,all:%Library.String=0</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 ;N $ET S $ET="D qARM.Error() S $EC="""" ZQ 1 Q:$Q """" Q  "
 S qqpar3=$G(qqpar3) S:qqpar3 qqpar3="" ;1 - построение иерархии ссылок на экземпляры объектов
 N qqao,qqao0,qqao1,qqao2,qqao3,qqc,qqw,qobn,qobnA,qqwA,qqpar3o,Cond,qqob,qqob0,qQo,qAn,qqwLA,qqref,Virt,qAnalDO ;@dol 21.01.03 qqref
 S qAnalDO=1 ;идет аналитика
 ;S:qW.GG("XBase","XFNewAn",0) qAn=1 ;новый вариант аналитики
 I $$$ReFind S Cond=0 I 1
 E  S Cond=$G(Vt(qqnump,0)) ;если уточнение, пстоянные условия проверять не надо (???)
 I $G(qanam)="" S qqrela=$S($G(W("Zar"))="":"A"_qview,1:W("Zar")),qanam=$NA(^Qa(qqrela)) ;,"A",1))
 K @qanam,$$$tmpGl($J,"A") ;слой аналитики ; 15.12.2008 Kokarev
 ;очистка отображения и выражения постобработки (в Vs(qqnump,"12p") ;@Dol 07.06.09
 K Vs(qqnump,"12p") S qqao="" F  S qqao=$O(Vs(qqnump,12,qqao)) Q:qqao=""  S qqao0="" F  S qqao0=$O(Vs(qqnump,12,qqao,qqao0)) Q:qqao0=""  D
 .F qqao1=5:1:11 K Vs(qqnump,12,qqao,qqao0,qqao1)
 .I $G(Vs(qqnump,12,qqao,qqao0,4))="D",$G(Vs(qqnump,12,qqao,qqao0,2))["@@@" S Vs(qqnump,"12p",qqao,qqao0,2)=$P(Vs(qqnump,12,qqao,qqao0,2),"@@@",2,255) ;выражения постобработки
 ;составление массива объектных ссылок поиска qfn. Исключаются объекты вне зоны фиксации
 K qfn,qfn0,qfn1,Vt(qqnump,111,12),Vt(qqnump,111,13)
 S qqo="" F  S qqo=$O(Vs(qqnump,12,qqo)) Q:qqo=""  I $S($G(Vs(qqnump,7))="":1,1:'$G(Vs(qqnump,7,qqo))) D
 .;I '$D(Vo(qqnump,qqo)) S Vo(qqnump,qqo,5)=$G(^Q(1,"CxObj","XORef")),Vo(qqnump,qqo,0)=$G(^("X50"),255)
 .S qfn($$$ObjRef(qqo)_",")=""  I qqpar3="",$G(Vs(qqnump,12,qqo)) S qqpar3=1 ;автомат.опр.наличия ссылок на экземпляры
 ;нормализация (выделение вершин). массив qfn0
 S qqob0=""  F  S qqob0=$O(qfn(qqob0)) Q:qqob0=""  D  S qqob0=qqob0_"я"
 .S qqob=$O(qfn($P(qqob0,",")_","_"я"),-1) I qqob'=qqob0 D  S qqob0=$P(qqob0,",",1,qqfi-1)_","
 ..F qqfi=1:1 Q:$P(qqob,",",qqfi)'=$P(qqob0,",",qqfi)
 .S qqob=qqob0,qqfi=$L(qqob0,",") D  F  S qqob=$O(qfn(qqob)) Q:$P(qqob,",",1,qqfi-1)_","'=qqob0  D
 ..S qqo=$P(qqob,",",$L(qqob,",")-1),qfn0($P(qqob,",",qqfi-1,255))=""
 ..Q:'$D(Vt(qqnump,111))   ;Vt(qqnump,111,12,qqo)=ссылка - массив принадлежности к поддереву виртуальных
 ..S Vt(qqnump,111,13,qqo)=$L(qqob,",")-qqfi+1 ;длины ссылок
 ..F qqao0=qqfi-1:1:$L(qqob,",")-1 I '$D(Vt(qqnump,111,0,$P(qqob,",",qqao0))) S Vt(qqnump,111,12,qqo)=$P(qqob,",",qqfi-1,$L(qqob,",")-1) Q
 S qqao0=$P($O(qfn0("")),",") ;объект вершины аналитического среза
 S qqao1=$$$ObjLqqc(qqao0) ;мин. размер кода  объекта
 K Vs(qqnump,14),Vs(qqnump,15) I qqpar3 D  ;построение дерева объектов аналитики
 .S:qW.GG("XBase","XFNewAn",0) qAn=1 ;новый вариант аналитики
 .S qqob="" N qqan1 S qqan1=$P($G(Vs(qqnump,12))," ",1) ;A1
 .F  S qqob=$O(qfn0(qqob)) Q:qqob=""  S qqao=$NA(Vs(qqnump,14)),qqao2="" F qqfi=1:1:$L(qqob,",")-1 S qqo=$P(qqob,",",qqfi) D:$G(Vs(qqnump,12,qqo))
 ..S %1=0 F %2=1:1:$O(Vs(qqnump,13,3,""),-1) S %1=qqo=$P(Vs(qqnump,13,3,%2)," ") Q:%1   ;объект аналитики
 ..I 1!'$D(Vt(qqnump,111)) S qqao=$NA(@qqao@(qqo)),@qqao="",qqao2=$S(qqao2="":"",1:qqao2_",")_""""_qqo_""""_$S('%1:",$E(qqc,1,"_$$$ObjLqqc(qqo)_")",1:",ZC("_%2_")") I 1
 ..E  S qqao=$NA(@qqao@(qqo)),@qqao="",qqao2=$S(qqao2="":"",1:qqao2_",")_""""_qqo_""""_$S('%1:",qQo("""_qqo_""")",1:",ZC("_%2_")") ;qQo(qqcn)
 ..I '$G(qAn) S Vs(qqnump,15,qqo)="@qqref@("_qqao2_")" Q
 ..;I '$D(Vs(qqnump,15)) S Vs(qqnump,15,qqo)="@qqref@("_qqao2_")"
 ..I ","_$$$ObjRef(qqo)_","'[(","_qqan1_",")!('$D(Vs(qqnump,15))) S Vs(qqnump,15,qqo)="@qqref@("_qqao2_")" ;для нового варианта, только объекты выше первой аналитики (пока)
 ;???S qobnA=$P($G(Vs(qqnump,12))," ",2),qqao2=$$$MObjRef(qqao0),qqwA=$P(Vs(qqnump,0,qqao2,-1,qobnA)," ")
 S qqao0=$P($G(Vs(qqnump,12))," ",1),qqwA=$P($G(Vs(qqnump,12))," ",2) ;объект и понятие первой аналитики
 N qqcfix S qqcfix=$P($$$CondFind," ",10) ;есть фиксация
 K ZP,ZA,ZAA,ZC ;массивы понятий аналитик и значений
 S qqrel=qql I $$$ReFind S qqrel=$$$Relind_qview
 I qqao0="" D  Q "" ;только подсчет общих агрегатов. Для виртуальных не совсем корректно. Нужен обход поддерева виртуальных ?
 .S qqo="" F  S qqo=$O(Vs(qqnump,12,qqo)) Q:qqo=""  D
 ..S qqc=$S(qqcfix="":"",qqo'=Vs(qqnump,7):qqcfix,1:$E(qqcfix,1,$L(qqcfix)-1)_$C($A(qqcfix,$L(qqcfix))-1)) F  S qqc=$O(^Q(qqrel,qqo,qqc)) S:qqcfix'="" qqc=$S($E(qqc,1,$L(qqcfix))=qqcfix:qqc,1:"") Q:qqc=""  D
 ...I Cond||($G(Vo(qqnump,qqao0,40))=3),'$$ggVer(qqo,qqc) Q
 ...S qqw="" F  S qqw=$O(Vs(qqnump,12,qqo,qqw)) Q:qqw=""  I $D(Vs(qqnump,12,qqo,qqw,4)),'$G(Vs(qqnump,12,qqo,qqw,4,1)) D
 ....S Z=$S($G(Vo(qqnump,qqo,2))>1:..G(qqw),qqw="C":qqc,"MDC"[$E(qqw):$G(^Q(1,qqo,qqc,qqw)),"@HLZ"'[$E(qqwA)&&(qqwA'[":"):$$gganal(qqo,qqw,qqc),1:..G(qqw)) S:$D(Vs(qqnump,12,qqo,qqw,2)) @("Z="_Vs(qqnump,12,qqo,qqw,2)) ;I $D(Vs(qqnump,12,qqo,qqw,2)) S ZZZ=Vs(qqnump,12,qqo,qqw,2) X ZZZ
 ....I Z="" Q:'qqpar1  S Z="???" ;пустые значения не обрабатываются
 ....D:'qqpar2  Q:'qqpar2  S Z1=Z F qqlev=1:1:$L(Z1," ") S Z=$P(Z1," ",qqlev) D:Z'=""!qqpar1
 .....S %1=$I(Vs(qqnump,12,qqo,qqw,5)) Q:$G(Vs(qqnump,12,qqo,qqw))  ;num
 .....I Z!(Z=0) D
 ......I '$D(Vs(qqnump,12,qqo,qqw,7)) S (Vs(qqnump,12,qqo,qqw,6),Vs(qqnump,12,qqo,qqw,7),Vs(qqnump,12,qqo,qqw,8),Vs(qqnump,12,qqo,qqw,9))=+Z Q
 ......S %2=$I(Vs(qqnump,12,qqo,qqw,6),Z) ;sum
 ......S:Z<Vs(qqnump,12,qqo,qqw,7) Vs(qqnump,12,qqo,qqw,7)=+Z ;min
 ......S:Z>Vs(qqnump,12,qqo,qqw,8) Vs(qqnump,12,qqo,qqw,8)=+Z ;max
 ......S Vs(qqnump,12,qqo,qqw,9)=%2/%1 ;mid
 ;ZP - массив глобальных ссылок на физическое дерево подсчитанной аналитики
 ;qlistA - список спиков для уровней аналитик. Для каждого уровня $LB(объект,понятие,тип,размер кода относительно предыдущего уровня,выражение аналитики,признак виртуального объекта-верхний невиртуальный)
 S qqref=qanam,qlistA="" F ZP=1:1:$O(Vs(qqnump,13,3,""),-1) D  S %2=%1
 .S ZP(ZP)="A"_$P(Vs(qqnump,13,3,ZP)," ",2),qqref=$E(qqref,1,$L(qqref)-1)_",ZP("_ZP_"),ZA("_ZP_"))" ;массив глобальных ссылок для аналитик
 .S %1=Vs(qqnump,13,3,ZP),%6=$P($G(Vs(qqnump,12,$P(%1," ",1),$P(%1," ",2),2)),"@@@"),%7=0 I $D(Vt(qqnump,111)),$D(Vt(qqnump,111,12,$P(%1," "))) S %7=1 ;объект аналитики виртуален ;@Dol 07.06.09 @@@ - постобработка
 .;определение типа
 .I ZP=1 S $LI(qlistA,ZP)=$LB($P(%1," ",1),$P(%1," ",2),0,$$$ObjLqqc($P(%1," ",1)),%6,%7) Q
 .S %3=$$$ObjRef($P(%1," ",1)),%4=$$$ObjRef($P(%2," ",1)) I %3=%4 S $LI(qlistA,ZP)=$LB($P(%1," ",1),$P(%1," ",2),0,$$$ObjLqqc($P(%1," ",1)),%6,%7) Q  ;тот же объект
 .I %4=$E(%3,1,$L(%4)) S $LI(qlistA,ZP)=$LB($P(%1," ",1),$P(%1," ",2),2,$$$ObjLqqc($P(%2," ",1)),%6,$S('%7:%7,1:$P(%2," ",1))) Q  ;ниже
 .I %3=$E(%4,1,$L(%3)) S $LI(qlistA,ZP)=$LB($P(%1," ",1),$P(%1," ",2),1,$$$ObjLqqc($P(%1," ",1)),%6,$S('%7:%7,1:$P(%1," ",1))) Q  ;выше
 .N i F i=1:1 Q:$P(%3,",",i)'=$P(%4,",",i)
 .S $LI(qlistA,ZP)=$LB($P(%1," ",1),$P(%1," ",2),3,$$$ObjLqqc($P(%3,",",i-1)),%6,$S('%7:%7,1:$P(%3,",",i-1))) Q  ;сбоку
 S qsort=0 ;только сортировка
 ;qlistD - список спиков для агрегатов. Для каждого уровня $LB(объект,$LB(понятие,совпадение с аналитикой,выражение,расчет только Num),тип,размер кода относительно предыдущего уровня,признак виртуального объекта-верхний невиртуальный)
 S qlistD="",%12=0
 S qqo=$P(Vs(qqnump,13,3,ZP)," ") ;последний объект аналитического среза
 S %6=1,%3=$$$ObjRef(qqo)
qAnalD S %1="" F  S %1=$O(Vs(qqnump,12,%1)) Q:%1=""  D
 .S %11=0 I $D(Vt(qqnump,111)),$D(Vt(qqnump,111,12,%1)) S %11=1 ;признак виртуальности
 .S %2="",%7="",%8=1,%10="" F  S %2=$O(Vs(qqnump,12,%1,%2)) Q:%2=""  I $G(Vs(qqnump,12,%1,%2,4))'="" S:%10="" %10=$G(Vs(qqnump,12,%1,%2,3)) S qsort=1,$LI(%7,%8)=$LB(%2,+$E($G(Vs(qqnump,12,%1,%2,3)),2,3),$P($G(Vs(qqnump,12,%1,%2,2)),"@@@"),$G(Vs(qqnump,12,%1,%2)),$G(Vs(qqnump,12,%1,%2,4,1))),%8=%8+1 ;@Dol 23.03.08 пятый элемент - %2,4,1) ;@Dol 29.06.09 $G(Vs(qqnump,12,%1,%2,3))'="" >> +$E($G(Vs(qqnump,12,%1,%2,3)),2,3) ;номер уровня
 .I %12,%7'="" Q
 .I %7="" Q:'qqpar3  Q:'$G(Vs(qqnump,12,%1))  Q:'%12
 .S %4=$$$ObjRef(%1) D
 ..I qqo=%1 S %5=0,%9=$$$ObjLqqc(%1) Q  ;совпадает
 ..I %10'="" S %5=-$E(%10,2,3),%9=0 Q  ;совпадает с аналитикой верхних уровней
 ..I %4=$E(%3,1,$L(%4)) S %5=1,%9=$$$ObjLqqc(%1) S:%11 %11=%1 Q  ;выше
 ..I %3=$E(%4,1,$L(%3)) S %5=2,%9=$$$ObjLqqc(qqo) S:%11 %11=qqo Q  ;ниже
 ..N i F i=1:1 Q:$P(%3,",",i)'=$P(%4,",",i)
 ..S %5=3,%9=$$$ObjLqqc($P(%3,",",i-1)) S:%11 %11=$P(%3,",",i-1) Q  ;сбоку
 .S $LI(qlistD,%6)=$LB(%1,%7,%5,%9,%11),%6=%6+1
 I qqpar3,'%12 S %12=1 G qAnalD ;второй проход, чтобы объекты без понятий (чистые ссылки) оказались в конце
 K ^LLL S ^LLL("A")=qlistA,^LLL("D")=qlistD
 I $D(Vt(qqnump,111)),'$D(Vt(qqnump,111,0,qqao0)) D  G qAnalEnd  ;@dol 16.05.04
 .S Virt=1 D ggaoCVV($$$ObjRef(qqao0),"") ;??? оптимизация нужна бы
 ;<oleg> 16.09.2005
 ;добавлено условие на организацию словаря понятия qqwA по объекту qqao0 ('....rWocx711(qqwA,qqao0))
 ;если словарь без ссылок (rWocx711 возвращает 1), то проход не по словарю, а по экземплярам
 ;</oleg>
 I 'qqpar1,'$$$ReFind,qqwA'="C",$S($G(Vo(qqnump,qqao0,2))'=4:"HRYMLXTx@Z"'[$E(qqwA,1)&&('..rWocx711(qqwA,qqao0))&&(qqwA'[":"),1:$E(qqwA,1)'="@"),qqcfix="" G ggaoW ;@dol 27.01.02 Н было забыто
 S qqc=$S(qqcfix="":"",1:qqcfix) D:qqao0=$G(Vs(qqnump,7))  G:qqao0=$G(Vs(qqnump,7)) qAnalEnd F  S qqc=$O(^Q(qqrel,qqao0,qqc)) S:qqcfix'="" qqc=$S($E(qqc,1,$L(qqcfix))=qqcfix:qqc,1:"") Q:qqc=""  D
 .I Cond||($G(Vo(qqnump,qqao0,40))=3),'$$ggVer(qqao0,qqc) Q
 .S:$D(Vt(qqnump,111)) Vs(qqnump,"Virt",qqao0)=qqc ;@Dol 12.05.08
 .S Z=$S(qqwA="C":qqc,$G(Vo(qqnump,qqao0,2))>1:..GG(qqao0,qqwA,qqc),"MDC"[$E(qqwA):$G(^Q(1,qqao0,qqc,qqwA)),"@HLZ"'[$E(qqwA)&&(qqwA'[":"):$$gganal(qqao0,qqwA,qqc),1:..GG(qqao0,qqwA,qqc)) D ggaoC(qqc,Z,2)
qAnalEnd I $G(all) S:ZP=1 all=0
 N qqp4,qqo,qqw S %5=0,(qqref,qqp4)=$NA(@qanam@("A"_qqwA)) F  S qqp4=$Q(@qqp4) Q:$E(qqp4,1,$L(qqref)-1)'=$E(qqref,1,$L(qqref)-1)  I $QL(qqp4)=(2*ZP+2),$E($QS(qqp4,$QL(qqp4)),1,2)="LA" S qqp4=$NA(@qqp4,$QL(qqp4)-1) D  S qqp4=$NA(@qqp4@("яяя"))
 .S qqo="" F  S qqo=$O(Vs(qqnump,12,qqo)) Q:qqo=""  S qqw="" F  S qqw=$O(Vs(qqnump,12,qqo,qqw)) Q:qqw=""  I $D(Vs(qqnump,12,qqo,qqw,4)) D  Q:%1=""
 ..S %1=$G(@qqp4@("LA"_qqw)) S:$G(Vs(qqnump,12,qqo,qqw))=1 (^("LA"_qqw),%1)=$LB(+%1)  ;только Num
 ..S:%1="" %1=$LB(+%1) I por,$S(por=1:$LG(%1,1)'=1,1:$LG(%1,1)<por) S %1="" Q
 ..S por(qqo,qqw)=%1
 .I %1="" K:por @qqp4 Q  ; иначе подсчет итоговых агрегатов
 .S %5=%5+1,qqo="" F  S qqo=$O(Vs(qqnump,12,qqo)) Q:qqo=""  S qqw="" F  S qqw=$O(Vs(qqnump,12,qqo,qqw)) Q:qqw=""  I $D(Vs(qqnump,12,qqo,qqw,4)),'$G(Vs(qqnump,12,qqo,qqw,4,1)) D  D:all qAnalET
 ..S %1=$G(por(qqo,qqw)) Q:%1=""  S (%3,Vs(qqnump,12,qqo,qqw,5))=$G(Vs(qqnump,12,qqo,qqw,5))+$LG(%1,1)_"/"_%5
 ..Q:'$LD(%1,2)  ;$LG(%1,2)=""
 ..S $LI(%1,5)=$LI(%1,2)/$LI(%1,1) ;mid
 ..D:$G(Vs(qqnump,12,qqo,qqw))=2  ;подсчет дисперсий. %11- среднее, %12-значение, %15 - кол-во, %13 - отклонения ;;;???%13 -мин. среднее, %14-мах среднее
 ...S %11=$LI(%1,5),(%13,%14,%15)="",%12=$O(@($na($$$tmpGl)_"($J,""A"","_$P(qqp4,",",2,255))@(qqw,"")) F  Q:%12=""  S %15=%15+^(%12),%13=%13+$ZABS(%11-%12),%12=$O(^(%12)) ; 15.12.2008 Kokarev
 ...S $LI(%1,6)=%13/%15,Vs(qqnump,12,qqo,qqw,10)=$G(Vs(qqnump,12,qqo,qqw,10))+$LI(%1,6)
 ..S @qqp4@("LA"_qqw)=%1
 ..I '$D(Vs(qqnump,12,qqo,qqw,6)) S Vs(qqnump,12,qqo,qqw,6)=$LG(%1,2),Vs(qqnump,12,qqo,qqw,7)=$LG(%1,3),Vs(qqnump,12,qqo,qqw,8)=$LG(%1,4),Vs(qqnump,12,qqo,qqw,9)=$LG(%1,5) Q
 ..S %2=$I(Vs(qqnump,12,qqo,qqw,6),$LG(%1,2)) ;sum
 ..S:$LG(%1,3)<Vs(qqnump,12,qqo,qqw,7) Vs(qqnump,12,qqo,qqw,7)=$LG(%1,3) ;min
 ..S:$LG(%1,4)>Vs(qqnump,12,qqo,qqw,8) Vs(qqnump,12,qqo,qqw,8)=$LG(%1,4) ;max
 ..S Vs(qqnump,12,qqo,qqw,9)=%2/%3 ;mid
 I '$D(@qanam) Q:$Q 1 Q
 S @qanam@("Xc")=..zCnv(1,$H,quser) ;дата время пользователь
 ;формирование и запись понятии итоговых агрегатов
 S qqo="" F  S qqo=$O(Vs(qqnump,12,qqo)) Q:qqo=""  S qqw="" F  S qqw=$O(Vs(qqnump,12,qqo,qqw)) Q:qqw=""  D:$D(Vs(qqnump,12,qqo,qqw,4))
 .S %1="" F qqao1=5:1:11 Q:'$D(Vs(qqnump,12,qqo,qqw,qqao1))  S:qqao1=10 Vs(qqnump,12,qqo,qqw,qqao1)=Vs(qqnump,12,qqo,qqw,qqao1)/$P(Vs(qqnump,12,qqo,qqw,5),"/",2) S $LI(%1,qqao1-4)=Vs(qqnump,12,qqo,qqw,qqao1)
 .S @qanam@("LA"_qqw)=%1
 ;@Dol 07.06.09 Постобработка
 I $D(Vs(qqnump,"12p"))>1 S %5=0,(qqref,qqp4)=$NA(@qanam@("A"_qqwA)) F  S qqp4=$Q(@qqp4) Q:$E(qqp4,1,$L(qqref)-1)'=$E(qqref,1,$L(qqref)-1)  I $QL(qqp4)=(2*ZP+2),$E($QS(qqp4,$QL(qqp4)),1,2)="LA" S qqp4=$NA(@qqp4,$QL(qqp4)-1) D  S qqp4=$NA(@qqp4@("яяя"))
 .S qqo="" F  S qqo=$O(Vs(qqnump,"12p",qqo)) Q:qqo=""  S qqw="" F  S qqw=$O(Vs(qqnump,"12p",qqo,qqw)) Q:qqw=""  I $D(Vs(qqnump,12,qqo,qqw,4)) D  Q:%1=""
 ..;N $ET S $ET="S $LI(%1,1)=$ZE,$LI(%1,2)=$ZE,$EC="""" Q:$Q %1 Q  "
 ..S %1=$G(@qqp4@("LA"_qqw)) X Vs(qqnump,"12p",qqo,qqw,2) S:$D(@qqp4@("LA"_qqw)) @qqp4@("LA"_qqw)=%1 ;@Dol 25.01.10 $D(@qqp4 -чтобы можно было удалять ненужные узлы
 Q:$Q "" Q
GetA(qqw,lev) Q $S($G(lev)=0:@qanam@("LA"_qqw),'$G(lev):$G(@qqp4@("LA"_qqw)),1:$G(@$NA(@qqp4,lev*2+1)@("LA"_qqw))) ;@Dol 07.06.09 взять аналитики текщего уровня (lev="" или отсутствует), итоговое значение (level=0) или заданного уровня - если полное дерево
SetA(qqw,lev,val,nn) S lev=$S($G(lev)=0:qanam,'$G(lev):qqp4,1:$NA(@qqp4,lev*2+1)),$Li(@lev@("LA"_qqw),nn)=val ;@Dol 07.07.10 присвоить val агрегату nn аналитики текщего уровня (lev="" или отсутствует), итоговое значение (level=0) или заданного уровня - если полное дерево ;
GetAind(lev) Q $S('$G(lev):$QS($NA(@qqp4),$QL($NA(@qqp4))),1:$QS($NA(@qqp4),lev*2+1)) ;@Dol 11.06.09 текущие индексы аналитик
 ;заполнение полного дерева
qAnalET F %3=1:1:ZP-1 S %2=$G(@$NA(@qqp4,%3*2+1)@("LA"_qqw)) D
 .I $LG(%1,2)="" S $LI(^("LA"_qqw),1)=$LG(%2)+$LG(%1) Q  ;только Num
 .I $LG(%2,2)="" S $LI(%2)=$LG(%1),$LI(%2,2)=$LI(%1,2),$LI(%2,3)=$LI(%1,3),$LI(%2,4)=$LI(%1,4),$LI(%2,5)=$LI(%1,5),^("LA"_qqw)=%2 Q
 .S $LI(%2)=$LG(%2)+$LG(%1),$LI(%2,2)=$LG(%2,2)+$LG(%1,2) S:$LI(%1,3)<$LI(%2,3) $LI(%2,3)=$LI(%1,3) S:$LI(%1,4)>$LI(%2,4) $LI(%2,4)=$LI(%1,4),$LI(%2,5)=$LI(%2,2)/$LI(%2,1) S ^("LA"_qqw)=%2 Q
 Q
 ;добыча значения
gganal(aqqo,aqqw,aqqc)
 Q:aqqw="CC" $G(^Q(1,aqqo,aqqc))
 S aqqo=$G(^Q(1,aqqo,aqqc,aqqw)) Q:aqqo="" "" I qqlang'=1,'$D(^Q(qqlang,"C"_aqqw)) N qqlang S qqlang=1
 S:$E(aqqw)="R" aqqw=$E(aqqw,3,255) ;@Dol 22.11.10 R*
 S aqqc=$G(^Q(qqlang,"C"_aqqw,$P(aqqo," "))) F aqqw=2:1:$L(aqqo," ") S:$P(aqqo," ",aqqw)'="" aqqc=aqqc_" "_$G(^($P(aqqo," ",aqqw)))
 Q aqqc
 ;проверка на постоянные условия
ggVer(qqoo,qqcc,qqol)   N qqo,qqob,qqoi,qqc,qqcc1 S qqcc1=1,qqob=$$$ObjRef(qqoo) F qqoi=$L(qqob,","):-1:1 S qqo=$P(qqob,",",qqoi) Q:qqo=$G(qqol)  S qqcc1=0,qqc=$E(qqcc,1,$$$ObjLqqc(qqo)) D  Q:'qqcc1
 .I $G(Vo(qqnump,qqo,28)) N qqcc0 D  I $O(^Q(qqrel,qqo,qqcc0_"я"),-1)'=qqc Q  ;не последний экземпляр
 ..S qqcc0=$$$ObjRef(qqo),qqcc0=$P(qqcc0,",",$L(qqcc0,",")-1)
 ..I qqcc0'="" S qqcc0=$E(qqc,1,$$$ObjLqqc(qqcc0))
 .I $G(Vo(qqnump,qqo,27))'="" D  Q:'qqcc1
 ..I @Vo(qqnump,qqo,27) S qqcc1=1 Q
 .I $G(Vo(qqnump,-1,67))="" S qqcc1=1 Q
 .I @Vo(qqnump,-1,67) S qqcc1=1 Q
 Q qqcc1
 ;проход по словарю (без учета пустых значений и перечня релевантных)
ggaoW I $D(Vt(qqnump,111)),$G(Vo(qqnump,qqao0,2))=4 D  G qAnalEnd ;для первого объекта qW4
 .N qqwA1 S qqwA1=$S($E(qqwA,1,2)="q4":$E(qqwA,3,1000),1:qqwA)
 .S Zz="" F  S Zz=$O(^QW(1,qqwA1,0,Zz)) Q:Zz=""  S Zzl=Zz,qqc="" F  S qqc=$O(^QW(1,qqwA1,0,Zzl,$E(qqao0,2,255),qqc)) Q:qqc=""  I '^(qqc),$D(@("^"_qqao0)@(qqc,qqwA1)) D  ;???Проход по первым словам значений (если ссылка не висячая)
 ..I Cond||($G(Vo(qqnump,qqao0,40))=3),'$$ggVer(qqao0,qqc) Q
 ..S Z=$S($L(@("^"_qqao0)@(qqc,qqwA1)," ")=1:Zz,1:..GG(qqao0,qqwA,qqc)) D ggaoC(qqc,Z,2)
 N qqla S qqla=1 I qqlang'=1,$D(^Q(qqlang,qqwA)) S qqla=qqlang
 S Zz="" F  S Zz=$O(^Q(qqla,qqwA,Zz)) Q:Zz=""  S Zzl=$S(qqla=1:Zz,1:$G(^Q(1,"C"_qqwA,^(Zz)),"???")),qqc="" F  S qqc=$O(^Q(qql,qqwA,Zzl,qqao0,qqc)) Q:qqc=""  I '^(qqc),$D(^Q(qql,qqao0,qqc,qqwA)) D  ;???Проход по первым словам значений (если ссылка не висячая);?qqc=$O(^Q(1,qqwA,Zzl,qqao0,qq
 .I Cond||($G(Vo(qqnump,qqao0,40))=3),'$$ggVer(qqao0,qqc) Q
 .S qQo(qqao0)=qqc,Z=$S($L(^Q(qql,qqao0,qqc,qqwA)," ")=1:Zz,"MDC"[$E(qqwA):$G(^Q(1,qqao0,qqc,qqwA)),"@HLZ"'[$E(qqwA)&&(qqwA'[":"):$$gganal(qqao0,qqwA,qqc),1:..GG(qqao0,qqwA,qqc)) D ggaoC(qqc,Z,2)  ;можно оптимизировать добычу значения
 G qAnalEnd
 ;проход по коду аналитики заданного уровня
ggaoC(qqc,Z,qqlev)  N qqcA,qqo,qqw,qqoold
 S %1=$LI(qlistA,qqlev-1),qqoold=$LI(%1,1) I 'qqpar2,$LI(%1,5)'="" S qqw=$LI(%1,2),qqo=$LI(%1,1),@("Z="_$LI(%1,5)) ;@dol 30.1.04
 I Z="" Q:'qqpar1  S Z="???"  ;пропуск пустых 
 S ZA(qqlev-1)=Z,ZC(qqlev-1)=qqc
 I qqlev'>ZP D  Q
 .S %1=$LI(qlistA,qqlev),qqw=$LI(%1,2),qqo=$LI(%1,1),%5=$LI(%1,3)
 .I $LI(%1,6)'=0 D  Q  ;@dol 16.05.04 для виртуальных
 ..I %5<2 S:%5 qqc=Vs(qqnump,"Virt",qqo) S qqz=..G(qqw) Q:qqz=""&('qqpar1)  D ggaoC(qqc,qqz,qqlev+1) Q  ;тот же объект или выше
 ..D ggaoCV($LI(%1,5),$E(qqc,1,$LI(%1,4)),2,qqoold_","_$P(","_Vt(qqnump,111,12,qqo),","_qqoold_",",2),1) Q  ;если ниже
 .I %5<2 S:%5 qqc=$E(qqc,1,$LI(%1,4)) S qqz=..G(qqw) Q:qqz=""&('qqpar1)  D ggaoC(qqc,qqz,qqlev+1) Q  ;тот же объект или выше
 .S (qqcA,qqc)=$E(qqc,1,$LI(%1,4)) F  S qqc=$O(^Q(qqrel,qqo,qqc)) Q:qqcA'=$E(qqc,1,$L(qqcA))  D
 ..I Cond||($G(Vo(qqnump,qqo,40))=3),'$$ggVer(qqo,qqc,qqao0) Q
 ..S qQo(qqo)=qqc,qqz=$S($G(Vo(qqnump,qqo,2))>1:..G(qqw),qqw="C":qqc,"MDC"[$E(qqw):$G(^Q(1,qqo,qqc,qqw)),"@HLZ"'[$E(qqw)&&(qqw'[":"):$$gganal(qqo,qqw,qqc),1:..G(qqw)) I qqz'=""!qqpar1 D ggaoC(qqc,qqz,qqlev+1)
 I qqpar2 K ZAA M ZAA=ZA
 S qqc0=qqc F qi=1:1:$LL(qlistD) S qlist=$LI(qlistD,qi),qqo=$LI(qlist,1),%5=$LI(qlist,3),qwlist=$LI(qlist,2) D
 .I %5,$LI(qlist,5)'=0 D ggaoCV($LI(qlist,5),$E(qqc,1,$LI(qlist,4)),2,qqoold_","_$P(","_Vt(qqnump,111,12,qqo),","_qqoold_",",2),0) Q  ;если виртуальный ;Vt(qqnump,111,13,qqo)+1,Vt(qqnump,111,12,qqao4),0) Q
 .I %5<2 D ggaoL(qqo,$S('%5:qqc0,%5=1:$E(qqc0,1,$LI(qlist,4)),1:ZC(-%5))) Q
 .S (qqcA,qqc)=$E(qqc0,1,$LI(qlist,4))
 .F  S qqc=$O(^Q(qqrel,qqo,qqc)) Q:qqcA'=$E(qqc,1,$L(qqcA))  S qQo(qqo)=qqc D:$S('Cond&&($G(Vo(qqnump,qqo,40))'=3):1,1:$$ggVer(qqo,qqc,qqao0)) ggaoL(qqo,qqc)
 Q
ggaoCVV(qqobb,qqc)
 N qqcn,qqcc S qqcn=$P(qqobb,",") S qqcc="" F  S qqcc=..gOrder(1,qqcn,qqcc,qqc) Q:qqcc=""  D
 .I qqobb=qqcn S Z=$S(qqwA="C":qqcc,1:..GG(qqcn,qqwA,qqcc)) D:Z'=""||qqpar1 ggaoC(qqcc,Z,2) Q
 .D ggaoCVV($P(qqobb,",",2,255),qqcc)
 Q
ggaoCV(qqo,qqc,qqoi,qqoe,an)    N qqcc,qqcn S qqcn=$P(qqoe,",",qqoi) S:qqo'="" qQo(qqo)=qqc I qqcn="" D  Q
 .I 'an D ggaoL(qqo,qqc) Q
 .S qqz=..G(qqw) I qqz'=""!qqpar1 D ggaoC(qqc,qqz,qqlev+1) Q
 S qqcc="" F  S qqcc=..gOrder(1,qqcn,qqcc,qqc) Q:qqcc=""  S qQo(qqcn)=qqcc D ggaoCV(qqcn,qqcc,qqoi+1,qqoe,an) ;@dol 16.05.04 D:$S('Cond:1,1:$$ggVer(qqcn,qqcc,qqo))
 Q
 ;нигде не используется
ggaoR(qqo,qqc)  Q:'$D(ZA)  S @(Vs(qqnump,15,qqo)_"=""""") Q  ;запись ссылок на экземпляры объектов
 N qqrob,qqi,qqio,qqrefo S qqrefo=qqref,qqrob=$$$ObjRef(qqo) F qqi=1:1:$L(qqrob,",") S qqio=$P(qqrob,",",qqi) I $D(Vs(qqnump,12,qqio)) S qqrefo=$NA(@qqrefo@(qqio,$E(qqc,1,$$$ObjLqqc(qqio)))),@qqrefo=""
 Q
 ;запись аналитик во временный массив
 ;qqpar3o - признак обработанных ссылок на экземпляры (qqwLA - понятие записываемого агрегата. Может динамически переопределятся в выражении)
ggaoL(qqo,qqc)  N qqwLA S qqpar3o=0 S qQo(qqo)=qqc S:'%5 %5=-ZP F qqwi=1:1:$LL(qwlist) S %2=$LI(qwlist,qqwi),(qqwLA,qqw)=$LI(%2,1) D
 .D  I Z="" Q:'qqpar1  S Z="???" ;пустые значения не обрабатываются
 ..I $LI(%2,2),$LI(%2,3)="" S Z=$S('qqpar2:ZA($LI(%2,2)),1:ZAA($LI(%2,2))) Q  ;@Dol 29.06.09 с учетом уровня; $LI(%2,3)="" нет выражения ;; $S('qqpar2:ZA(-%5),1:ZAA(-%5)) Q
 ..S Z=$S($G(Vo(qqnump,qqo,2))>1:..G(qqw),qqw="C":qqc,"MDCX"[$E(qqw):$G(^Q(1,qqo,qqc,qqw)),"@HLZ"'[$E(qqw)&&(qqw'[":"):$$gganal(qqo,qqw,qqc),1:..G(qqw)) I 'qqpar2,$LI(%2,3)'="" S @("Z="_$LI(%2,3)) ;S:$LI(%2,3)'="" @("Z="_$LI(%2,3))
 .I 'qqpar2 D ggaoAG Q  ;по значениям
 .S Z1=Z D ggaoL1(1) ;по словам значений
 I qqpar3,'qqpar3o,$D(Vs(qqnump,15,qqo)),qwlist="" D  ;ссылки не построены, нужно их построить???
 .S qqw="" I 'qqpar2 D ggaoAG Q  ;по значениям
 .S Z1=Z D ggaoL1(1) ;по словам значений
 Q
 ;раскладка по словам значений (ВЫРАЖЕНИЕ ДЛЯ КАЖДОГО СЛОВА!!!)
ggaoL1(qqlev)   N ql,qqo1,qqw1 S qqo1=Vs(qqnump,13,3,qqlev),qqw1=$P(qqo1," ",2),qqo1=$P(qqo1," ") F ql=1:1:$L(ZAA(qqlev)," ") S (Z,ZA)=$P(ZAA(qqlev)," ",ql) S:$P($G(Vs(qqnump,12,qqo1,qqw1,2)),"@@@")'="" @("Z="_$P(Vs(qqnump,12,qqo1,qqw1,2),"@@@")) I Z'="" S ZA(qqlev)=Z D  ;@dol 07.06.09 @@@
 .I qqlev'=ZP D ggaoL1(qqlev+1) Q
 .S Z=Z1 S:$LI(%2,3)'="" @("Z="_$LI(%2,3)) D ggaoAG ; @dol 30.1.04 @("Z="_$LI(%2,3))
 Q
 ;подсчет общих агрегатов
ggaoAG I qqpar3,'qqpar3o,$D(Vs(qqnump,15,qqo)) S:$S(qqw'="":1,'qsort:1,1:$D(@qqref)) @(Vs(qqnump,15,qqo)_"="""""),qqpar3o=1 Q:qqw=""  ;записана ссылка на экземпляр
 I $LI(%2,4)=1,$I(@qqref@("LA"_qqwLA)) Q  ;только Num
 S %1=$G(@qqref@("LA"_qqwLA)),$LI(%1,1)=$LG(%1,1)+1
 I $LI(%2,5) D  S @qqref@("LA"_qqwLA)=%1 Q  ;@Dol 23.03.08 первое значение или список значений ( Vs(qqnump,12,qqo,qqw,4,1) )
 .I $LI(%2,5)=5 S:Z'=""&&($I(@qqref@("LA"_qqwLA,Z))=1) $LI(%1,2)=$LG(%1,2)+1 Q  ;@Dol 21.12.10 кол-во уникальных
 .I '$LD(%1,2)||($LI(%2,5)=4) S $LI(%1,2)=Z Q  ;@Dol 20.01.10 =4 - последнее
 .I $LI(%2,5)=3 S $LI(%1,2)=$LI(%1,2)_" "_Z Q  ;@Dol 1.10.08 полный список
 .I $LI(%2,5)=2," "_$LI(%1,2)_" "'[(" "_Z_" ") S $LI(%1,2)=$LI(%1,2)_" "_Z
 I 'Z,Z'=0 S ^("LA"_qqwLA)=%1 Q
 I $LI(%2,4)=2,$I(@($na($$$tmpGl)_"($J,""A"","_$P(qqref,",",2,255))@(qqwLA,Z)),$D(@qqref@("LA"_qqwLA)) ;сохранение значений для подсчета дисперсий ; 15.12.2008 Kokarev
 I '$LD(%1,2) S $LI(%1,2)=+Z,$LI(%1,3)=+Z,$LI(%1,4)=+Z,^("LA"_qqwLA)=%1 Q  ;,$LI(%1,5)=+Z Q  ;было '$LD(%1,3)
 S $LI(%1,2)=$LG(%1,2)+Z S:Z<$LI(%1,3) $LI(%1,3)=+Z S:Z>$LI(%1,4) $LI(%1,4)=+Z S ^("LA"_qqwLA)=%1 Q
]]></Implementation>
</Method>

<Method name="qConv">
<Description>
Преобразование строки qqpar1.
Убираются лишние пробелы. 
qqpar2 - другие разделители,qqpar3 - символы, после которых нужен пробел (или
другой разделитель.
qqpar4'=1 заковыченное соединяется подчерком
qqpar5=1 - преобразовать в большие буквы, =2 - в маленькие.</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String,qqpar3:%String,qqpar4:%String,qqpar5:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 Q:$G(qqpar1)="" "" N qqcs0,qqcs1,qqcs2,qqcs3
 I $G(qqpar5)=1 S qqpar1=$ZCVT(qqpar1,"U") ;$TR(qqpar1,"qwertyuiopasdfghjklzxcvbnmйцукенгшщзхъфывапролджэячсмитьбю","QWERTYUIOPASDFGHJKLZXCVBNMЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ")
 I $G(qqpar5)=2 S qqpar1=$ZCVT(qqpar1,"L") ;S qqpar1=$TR(qqpar1,"QWERTYUIOPASDFGHJKLZXCVBNMЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ","qwertyuiopasdfghjklzxcvbnmйцукенгшщзхъфывапролджэячсмитьбю")
 S qqpar2=$G(qqpar2)
 D:$G(qqpar3)'=""
 .F qqcs1=1:1:$L(qqpar3) S qqcs2=$E(qqpar3,qqcs1) D
 ..S qqcs3=1 F  S qqcs3=$F(qqpar1,qqcs2,qqcs3) Q:'qqcs3  I $E(qqpar1,qqcs3)'=" ",$E(qqpar1,qqcs3)'="" S $E(qqpar1,qqcs3-1)=qqcs2_" ",qqcs3=qqcs3+1
 S qqcs0="",qqcs1=1 F qqcs2=1:1:$L(qqpar1," ") S qqcs3=$P(qqpar1," ",qqcs2) S:qqcs1 qqcs1=qqcs3'="" I qqcs3'="" S qqcs0=qqcs0_$S(qqpar2="":" ",qqcs0="":" ",qqpar2[$E(qqcs0,$L(qqcs0)):"",1:" ")_qqcs3
 S qqcs0=$E(qqcs0,2,4000)
 I '$G(qqpar4),qqcs0["""" D
 .F qqcs1=1:1:$L(qqcs0,"""") I '(qqcs1#2) S $P(qqcs0,"""",qqcs1)=$TR($P(qqcs0,"""",qqcs1)," ","_")
 Q qqcs0
]]></Implementation>
</Method>

<Method name="qConvT">
<Description>
Раскладка текста на факты. Создаются подчиненные текущему экземпляры объекта с фактами.
qqo - код объекта текста
qqw - код экземпляра (пока обслуживаются только TB* и T* -понятия)
qqc - код экземпляра объекта qqo. Если пуст - обход всех экземпляров.
sen=0 - факт - строка;=1 - предложение (до точки с учетом инициалов, чисел)
in - список (через пробел) понятий для имен собственных, названий и номеров строк исходного текста, из которого получен факт.
Если in="", то используются стандартные коды понятий "Wi Wn Mn".
Имена собственные (все, что начинается с большой буквы и не первое слово) и названия (все что в кавычках) добавляются к объекту qqo.
Номера строк - к qqof.
qqof - код объекта для фактов (подчиненный qqo). Объект должен быть описан (!!!). Длина кода больше длины кода экземпляра qqo (на 1 символ - 52 факта, на 2 - 52**2 и т.п.)
qqwf - код понятия фактов (если не задано - берется код "W")
teg - если задан, то предполагается, что текст - html. Тогда teg это имя обрамляющего текст тега (например, PRE). Тег задается только именем (без скобок). Лишние теги внутри текста пропускаются.</Description>
<Internal/>
<FormalSpec>qqo:%String,qqw:%String,qqc:%String,sen:%String=0,in:%Library.String,qqof:%String,qqwf:%Library.String,teg:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N str,sn,n,nmax,p,ss,pp,ii,strn,tegp,nn,qqcL,qqcc
 S:$E(qqw,1,2)="TB" qqw=$E(qqw,2,20) ;код TB* понятия
 S:$G(qqwf)="" qqwf="W" ;понятие факта
 I $D(in),in="" S in="Wi Wn Mn" ;понятия для имен собственных, названий и номеров строк текста
 S qqcL=$S($D($$$ObjLqqc(qqof))#2:$$$ObjLqqc(qqof),1:$G(^Q(1,"CxObj",qqof,"X50"),255)) ;длина кода экземпляра факта
 I $G(qqc)'="" D ConvT0 Q ""
 S qqc=""
 I $E(qqw)="B" F I=1:1 S qqc=$O(^QT(qqw,1,qqo,qqc)) Q:qqc=""  D ConvT0 ;TB*
 I $E(qqw)'="B" F I=1:1 S qqc=$O(^Q(1,qqo,qqc)) Q:qqc=""  D:$D(^(qqc,qqw)) ConvT0 ;T*
 Q ""
ConvT0 S (IM,NM)="",qqcc=qqc S n="",sn="" F  S str=$$ConvTN() D:$TR(str," ")'=""  Q:n=""
 .;I n=nmax,$E(str,$L(str))=")" S str=$P(str,"(",1,$L(str,"(")-1) ;в скобках в последней строке часто агенство 
 .S nn=n ;номера строк исходного текста для факта
 .S p=1 F  S p=$F(str,"  ",p) Q:'p  S $E(str,p-1)="",p=p-2 ;уберем задвоенные пробелы
 .S p=1 F  S p=$F(str,".",p) D  Q:'p  Q:$TR(str," ")=""
 ..I 'p Q:'sen  D:n'=""  Q
 ...S strn=$$ConvTN() Q:strn=""  S nn=nn_" "_n,p=$L(str)+1,str=str_$S($ZSTRIP(str,"*UWPCN")=""=($ZSTRIP(strn,"*UWPCN")=""):" ",1:". ")_strn,pp=p F  S pp=$F(str,"  ",pp) Q:'pp  S $E(str,pp-1)="",pp=pp-2 ;уберем задвоенные пробелы; $ZSTRIP(str,"*UWPCN")=""=($ZSTRIP(strn,"*UWPCN")="") - пробелом соединяются только однотипные (относительно маленьких букв) - иначе разные предложения
 ..I p>3,$E(str,p)'?1N,$E(str,1,p-1)?.np,$E(str,1,p-1)'?.p S:$E(str,p)'=" " $E(str,p-1)=". " Q  ;скорее всего пункт/подпункт
 ..I p>3,$E(str,p-3,p-2)'?1p1u,$E(str,p+1)=""||($E(str,p+1)?1U&&($E(str,p-2,p-1)'?1n1"."))||($E(str,p+1)="""") D  Q  ;не большая буква с точкой
 ...I sen D ConvT1($E(str,1,p-2)) S str=$E(str,p,32000),p=1 Q
 ...I $E(str,p)'="",$E(str,p)'=" " S $E(str,p-1)=" . ",p=p+2 Q
 ...S $E(str,p-1)=" .",p=p+1 Q
 ..I $E(str,p)'="",$E(str,p)'?1N,$E(str,p)'=" " S $E(str,p-1)=". "
 .I str'="" D ConvT1(str)
 I $D(in) S W($P(in," ",1))=IM,W($P(in," ",2))=NM D ..rCor(qqo,qqc,$P(in," ",1,2),0,0)
 ;I $D(SN) S qqcc=qqc F ii=1:1:SN S qqcc=$P(..rNew(qqof,qqcc)," "),W(qqwf)=SN(ii) S:$D(in) W($P(in," ",3))=SN(ii,1) D qW.rCor(qqof,qqcc,qqwf_$S($D(in):" "_$P(in," ",3),1:""),0,0)
 F  S pp=$O(^Q(1,qqof,qqcc)) Q:$E(pp,1,$L(qqc))'=qqc  S qqcc=pp D ..rCor(qqof,qqcc,"",0,0) ;удаление остатков, если не первый проход
 Q
ConvT1(s)   S ss=$ZSTRIP(s,"*AWN",".%") I ss'="" S pp=1 F ii=1:1:$L(ss) S pp=$F(s,$E(ss,ii),pp) D
 .I $E(ss,ii)="-",$E(s,pp-2,pp)?1A1"-"1A Q
 .I $E(ss,ii)=",",$E(s,pp-2,pp)?1N1","1N S $E(s,pp-1)="." Q  ;нормализация чисел
 .S $E(s,pp-1)=" "_$E(ss,ii)_" ",pp=pp+1
 S s=$ZSTRIP(s,"<>W") D:$D(in)  ;выделение названий и имен собственных
 .I $L(NM)<32000,s["""",$L(s,"""")>2 F ii=2:2:$L(s,"""") S ss=$ZSTRIP($P(s,"""",ii),"<>W") I $E(ss)?1U,$L(ss)<100,$L(ss," ")<4 S ss=$ZCVT($TR(ss," ","_"),"U") S:" "_NM_" "'[(" "_ss_" ") NM=NM_" "_ss  ;скорее всего - название
 .I $L(IM)<32000,$ZSTRIP(s,"*UWPCN")'="" F ii=2:1:$L(s," ") S ss=$P(s," ",ii) I $L(ss)>2,$E(ss)?1U,ii>2||($P(s," ",1)'?.np),ss'["." S ss=$E(ss)_$ZCVT($E(ss,2,1000),"L") S:" "_IM_" "'[(" "_ss_" ") IM=IM_" "_ss ;есть маленькие буквы, поиск имен
 S s=$ZCVT($ZSTRIP(s,"*C"),"U") I s="" S nn=n Q
 S pp=$O(^Q(1,qqof,qqcc)) I $E(pp,1,$L(qqc))=qqc S qqcc=pp I 1  ;если экземпляры имеются
 E  S qqcc=$P(..rNew(qqof,qqc)," ")
 S W(qqwf)=s S:$P($G(in)," ",3)'="" W($P(in," ",3))=nn D qW.rCor(qqof,qqcc,qqwf_$S($P($G(in)," ",3)'="":" "_$P(in," ",3),1:""),0,0) ;SN($I(SN))=s,SN(SN,1)=nn
 S nn=n Q
 ;взять следующую строку
ConvTN()
ConvTN0 S n=$S($E(qqw)="B":$O(^QT(qqw,1,qqo,qqc,n)),1:$O(^Q(1,qqo,qqc,qqw,n))) Q:n="" "" S strn=$ZSTRIP($G(^(n)),"<>W") G:strn="" ConvTN0
 Q:'$D(teg) strn
 I '$D(tegp) G:strn'[("<"_teg) ConvTN0 S tegp=1,strn=$P($P(strn,"<"_teg,2,255),">",2,3000) G:strn="" ConvTN0
 I strn[("</"_teg) K tegp S strn=$P(strn,"</"_teg)
 I strn["<A " S strn=$P(strn,"<A ")_" "_$P(strn,"</A>",2,1000)
 F  Q:strn'["<"   S strn=$P(strn,"<")_" "_$P(strn,">",2,1000)
 G:$TR(strn," ")="" ConvTN0 Q strn
]]></Implementation>
</Method>

<Method name="qFind">
<Description>
поиск по Vs(qqnump,8,qqo,qqw)=условие
qqmod - варант поиска
0 - в перечне релевантных только найденные
1 - полное поддерево  объекта вершины поиска
qqcnt - мах.количество найденных

query - кол-во наборов. Можно не задавать. Оставлено для совместимости. Кол-во наборов возьмется из Vs(qqnump,808)

В Vs(qqnump,808) могут находится наборы поисковых образов. Результаты всех наборов объединяются по ИЛИ
Vs(qqnump,808)- кол-во наборов
Vs(qqnump,808,номер_набора,qqo,qqw)=условие
!!!!!Если заданы наборы, то текущий поисковый образ Vs(qqnump,8) должен также находится в одном из наборов

NoKill=1 - не удалять перечень релевантных в режиме уточнения. Позволяет добавлять в результирующий перечень релевантных результаты нескольких способов в режиме Уточнения
X540=1 - обрабатывать флаг сброса уточнения (пока только для ссылочных/виртуальных объектов)

Управляющие переменные: 
Vs(qqnump, 99, "Find"=0/1 - поиск(отметка) экземпляров/поддерева (для вызова через qARM.Find)
Vs(qqnump, 99, "Find", 1) =1 - учитывать одинаковые понятия в разных объектах (для вызова через qARM.Find)
Vs(qqnump, 99, "Find", 2) - максимальное количество экземпляров (если не задано - ищутся все) (для вызова через qARM.Find)
Vs(qqnump, 99, "Find",5) =1 поиск без учета регистра (Поисковый образ должен быть большими буквами !!!)</Description>
<Internal/>
<FormalSpec>qqmod:%Library.String=0,qqcnt:%Library.String,qqolst:%Library.String,qA:%Library.String=0,NoKill:%Library.String,X540:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 N qviewf,qqr,Cond,qFindDO,qqReFind ;ii,qqww,qqww1,iii ;,qqow ;,$ET
 S:$G(X540) qqReFind=$$$ReFind ;@Dol 2.12.04 обрабатывать сброс уточнения в gOrder (т.е. сработает только для виртуальных)
 S qFindDO=1 ;используется как флаг (для вычисления значений ZTMP*-понятий в методе ..G)
 S qqcnt=+$G(qqcnt)
 Q:qview="" 1/0 ;на всякий случай, иначе катастрофа
 I $$$ReFind N qql S qql=$$$Relind_qview,$$$Relind='$$$Relind,Cond=0 K:'$G(NoKill) ^Q($$$Relind_qview) I 1
 E  S Cond=$G(Vt(qqnump,0)) ;если уточнение, постоянные условия проверять не надо (???)
 S qviewf=$$$Relind_qview ;ссылка на перечень релевантных
 D ..qFindList0()
 I qqr'="" S:$$$ReFind $$$Relind='$$$Relind Q:$Q qqr Q
 i $g(OlegFind) S qqr=..qFindNTest(qqcnt,qql,qqlang,qviewf,qlistF,qlistFR,,$G(Vs(qqnump,99,"Find",5))) S:'qqr&&($$$ReFind) $$$Relind='$$$Relind Q:$Q qqr Q  ;@Oleg Тестирование нового варианта поиска
 S qqr=..qFindN(qqcnt,qql,qqlang,qviewf,qlistF,qlistFR,,$G(Vs(qqnump,99,"Find",5))) I 'qqr,$$$ReFind S $$$Relind='$$$Relind
 Q:$Q qqr Q
]]></Implementation>
</Method>

<Method name="qFindA">
<Description><![CDATA[
Добавление к условию cond выражения addcond через логическую операцию log (&& по умолчанию)]]></Description>
<Internal/>
<FormalSpec>cond:%Library.String,addcond:%Library.String,log:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;;;;;;I $ZV["GT.M" S:cond'="" cond=$$Zso^VCPU(cond) S addcond=$$Zso^VCPU(addcond) S:$G(log)="" log="&" S log=$S(log="&&":"&",log="||":"!",1:log)
 Q $S(cond="":"",1:cond_$G(log,"&&")_"(")_addcond_$S(cond="":"",1:")")
]]></Implementation>
</Method>

<Method name="qFindC">
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $D(Arg3) N qNor S qNor=1 Q $$qFindC2(Arg3) ;@Dol 4.03.05 - фильтр для сортировки
 ;ZZ - значение, ZC - коды значения, Z - слово значения
 ;возвращает признак_условие, qerr - сообщение об ошибке
 ;признак =0 - значение не нужно, =1 - только коды (ZC), 2 - полное значение (ZZ)
 ;возможен комментарий (через ;;)
 Q:Arg1?." " ""
 N ii,Z,qqcond,qqcond1,qqcond2,qqzb,qqze,qq1,qq2,qq3,qq4,qqpar3,qqwt,qqwts,qqwdt,qqwZN,qqnc,qqminus,qxp,qqdat,qNor
 S qNor=$G(Vs(qqnump,99,"Find",5)) ;=1 - БЕЗ учета регистра
 ;qqwZN - признак наличия условия на позицию слова в соответствии с порядковым номером условия ( ZN(N_усл)
 ;qqnc - номер условия в выражении
 ;qqdat - используется как признак при анализе выполнимости условия (существования слова в словаре в условии с !!)
 I qqw["*" S qqwt=qqw N qqw S qqw=$P(qqwt,"*") ;@dol 30.03.03 !!!! появляются объединяемые по И условия
 ;
 I $L(Arg1,$C(13,10)) D  ;обработка обязательности выполнения всех условий для одного или разных (!!!) экземпляров
 .N Arg F ii=1:1:$L(Arg1,$C(13,10)) S qqpar3=$P(Arg1,$C(13,10),ii) I qqpar3'="",qqpar3'?1." " S Arg=$S('$D(Arg):"",1:Arg_"!!&")_qqpar3
 .S Arg1=Arg
 I Arg1["!!&" S Arg1="&"_Arg1 ;I $G(Arg2) S Arg1=$P(Arg1,"!!&")
 S qqcond="",qqcond2=""
 ;S:$G(Arg1)="" qqpar2=Vs(qqnump,8,qqo,qqw)
 ;$G(Vo(qqnump,qqo,2))>1 для виртуальных временно тип 0
 S qqwt=$S($G(Vo(qqnump,qqo,2))>2:0,$E(qqw)="T":3,"HL@Z"[$E(qqw)||(qqw="C")||(qqw="CC")||(qqw[":"):0,"CDMX"[$E(qqw):1,1:2) ;тип понятия  ;24.03.10 - "CC" ;? C и CC - Перебором ?
 S qqwdt=qARM.GetPar(710,"",qqo,qqw) ;тип данных. Интересен 1,6 - нормализованная дата
 S qqwts=0 ; S:qqwt qqcond="$$qFZ1("""_qqw_""")"
 ;F ii=1:1:$L(Arg1,"!!") S qqpar3=$P(Arg1,"!!",ii),qqcond1="" S:qqpar3[" ;;" qqpar3=$P(qqpar3," ;;") I qqpar3'="" S qxp=$E(qqpar3)="&" S:qxp qqpar3=$E(qqpar3,2,30000),qfn3(qqo,qqw)=$G(qfn3(qqo,qqw))+1 D  S:$D(qfn3(qqo,qqw)) qqcond1=..qFindA(qqcond1,"$I(qfnCP(qqo,"""_qqw_""","_qfn3(qqo,qqw)_"))","&&") S qqcond=..qFindA(qqcond,qqcond1,$S($D(qfn3(qqo,qqw)):"!",1:"||")) ;выделение альтернатив (условий по ИЛИ). Для множественных условий проверяются все альтернативы
 F ii=1:1:qSYS.PSYN(Arg1,"!!") S qqpar3=qSYS.PSYN(Arg1,"!!",ii),qqcond1="" S:qqpar3[" ;;" qqpar3=qSYS.PSYN(qqpar3," ;;",1) I qqpar3'="" S qxp=$E(qqpar3)="&" S:qxp qqpar3=$E(qqpar3,2,30000),qfn3(qqo,qqw)=$G(qfn3(qqo,qqw))+1 S:qxp&&($E(qqpar3,1,2)="- ") qqpar3=$E(qqpar3,3,30000),qfn4(qqo,qqw,qfn3(qqo,qqw))=1 D  S:$D(qfn3(qqo,qqw)) qqcond1=..qFindA(qqcond1,"$I(qfnCP(qqo,"""_qqw_""","_qfn3(qqo,qqw)_"))","&&") S:qqcond1'="" qqcond=..qFindA(qqcond,qqcond1,$S($D(qfn3(qqo,qqw)):"!",1:"||")) ;выделение альтернатив (условий по ИЛИ). Для множественных условий проверяются все альтернативы ;@dol 15.12.02 S:exp&&($E(qqpar3,1,2)="- ") - множественное отрицание
 .;????S qcond(ii)=qqpar3["Zpw" ;признак наличия условия на позицию
 .S qqwZN=qqpar3["ZN(",qqnc=0
 .S qq1="",qqminus="" F  S qq1=qq1_$P(qqpar3," "),qqpar3=$P(qqpar3," ",2,10000) Q:qq1=""&(qqpar3="")  I qq1'="" S qq2=$L($TR(qq1,$TR(qq1,""""))) S:qq2#2&&(qqpar3'="") qq1=qq1_" " I '(qq2#2)||(qqpar3="") D  S:qq1'="-" qqminus="" S qq1="" S:$G(Arg2) Arg2=2 ;выделение синтаксически чистого пробела (qq2 - кол-во кавычек), Arg2=1 - первое условие
 ..I qq1="-" S qqminus="'" Q  ;отрицание для следующего условия
 ..I $I(qqnc),$E(qq1,1,2)'=">>","><='["[$E(qq1) D  ;приведение к каноническому виду сокращенного условия
 ...S qqzb=$F(qq1,$E($TR(qq1,"><='[")))-1,qq1="...Z"_$E(qq1,1,qqzb-1)_$S($E(qq1,qqzb)="""":$E(qq1,qqzb,4000),1:""""_$$qFindCdb($E(qq1,qqzb,4000))_"""")
 ..S qq2=$P(qq1,"..."),qq3=$P(qq1,"...",2) ;;;???S:qNor qq2=$ZCVT(qq2,"U")
 ..I qq3'="" D
 ...I "><='["[$E(qq3) S qqzb=$F(qq3,$E($TR(qq3,"><='[")))-1,qq3="Z"_$E(qq3,1,qqzb-1)_$S($E(qq3,qqzb)="""":$S(qNor:$ZCVT($E(qq3,qqzb,4000),"U"),1:$E(qq3,qqzb,4000)),1:""""_$$qFindCdb($S(qNor:$ZCVT($E(qq3,qqzb,4000),"U"),1:$E(qq3,qqzb,4000)))_"""") Q  ;приведение к каноническому виду сокращенного условия
 ...Q:'qNor   ;приведение к большим буквам констант
 ...N qqpp,qqppi S qqpp=1 F  S qqpp=$F($TR(qq3,"[]=",$C(31,31,31)),$C(31)_"""",qqpp) Q:'qqpp  F qqppi=qqpp:1 Q:$E(qq3,qqppi)=""  D  Q:'qqppi
 ....I $E(qq3,qqppi)="""",$E(qq3,qqppi+1)="""" S qqppi=qqppi+2 Q
 ....I $E(qq3,qqppi)="""" S qqppi=0 Q
 ....S $E(qq3,qqppi)=$ZCVT($E(qq3,qqppi),"U")
 ..I qq2=">>" S qq2="*" ;@dol 13.10.03
 ..I qq2[">>",qq2["*"||(qq2["?") S qerr=$G(qerr)_" Синтаксис:"_qq2 Q
 ..I qqwdt,qq2'="*" D   ;нормализованная дата
 ...N qwdt0 I $E(qqwdt)=8 D  Q  ;@Dol 27.10.07 интервал. 80-прямой, 81 - обратный
 ....S qNor=0,qwdt0=qq2["<<" S:qq2["*" qq2=$P(qq2,"*")_">>"_$P(qq2,"*")
 ....S qq2=..GtoExt("I",$TR(qq2,"<")) S:qwdt0 qq3=$S(qqwdt=80:"$E(Z,7,12)']]"""_$E(qq2,7,12)_"""",1:""""_$E(qq2,1,6)_"""']]$E(Z,7,12)")  ; >><< - строгое вхождение
 ....I qqwdt=80 S qq2=$E(qq2,1,6)_">>"_$E(qq2,7,12) Q  ;@Dol 17.10.08
 ....S qq3=..qFindA(qq3,"$E(Z,7,12)']]"""_$E(qq2,7,12)_"""") S qq2=$E(qq2,1,6)_">>" ;@Dol 17.10.08 НЕХОРОШО. Надо оптимизировать в qFindN (Да еще регистр ???)
 ...D:qq2["."  ;@Dol 27.10.07 в условии ненормализованная дата
 ....I qq2[">>" S qq2=$S($P(qq2,">>",1)="":"",1:..GtoExt("D",$P(qq2,">>",1)))_">>"_$S($P(qq2,">>",2)="":"",1:..GtoExt("D",$P(qq2,">>",2))) Q
 ....I qq2["*",qq2'["?" S qq2=$S($P(qq2,"*",1)="":"",1:..GtoExt("D",$P(qq2,"*",1)))_"*" Q
 ....I qq2'["*",qq2'["?" S qq2=..GtoExt("D",qq2) Q
 ...S qwdt0=$S(qqwdt=6:6,$E(qqwdt)=7:14,1:8) I qq2[">>" S qq2=$S($P(qq2,">>",1)="":"",1:$P(qq2,">>",1)_$TR($J("",qwdt0-$L($P(qq2,">>",1)))," ",0))_">>"_$S($P(qq2,">>",2)="":"",1:$P(qq2,">>",2)_$TR($J("",qwdt0-$L($P(qq2,">>",2)))," ",9)) Q
 ...I qq2["*",qq2'["?",$P(qq2,"*",1)'="" S qq2=$P(qq2,"*",1)_$TR($J("",qwdt0-$L($P(qq2,"*",1)))," ",0)_">>"_$P(qq2,"*",1)_$TR($J("",qwdt0-$L($P(qq2,"*",1)))," ",9) Q
 ..I $G(Arg2)=1 D  Q  ;условие в виде конец-начало условие для первого условия
 ...I qq3["ZN(" S qerr=$G(qerr)_" Синтаксис:"_qq2_"..."_qq3 Q
 ...I qq2="*",qq3'="" S qq2=""
 ...I qq2="*" S qqcond2=$LB(1) Q 
 ...D
 ....I qq2="" S qqcond2=$LB(1,"","") Q
 ....I qq2[">>" S qqcond2=$LB(1,$P(qq2,">>"),$P(qq2,">>",2)) Q
 ....I qq2'["*",qq2'["?" S qqcond2=$LB(0,qq2) Q
 ....I $P(qq2,"*",2)="",qq2'["?" D  Q  ;@Dol 3.02.07 анализ на условие типа 123* (число*)
 .....I $P(qq2,"*")'?1.N S qqcond2=$LB(1,$P(qq2,"*"),$P(qq2,"*")) Q  ;не число
 .....N qqn S qqn=$O(^Q(1,$S($E(qqw)="R":$E(qqw,3,255),1:qqw),$P(qq2,"*"))) I qqn'="",qqn'=+qqn S qqcond2=$LB(1,$P(qq2,"*")_$C(31),$P(qq2,"*")_"я") Q  ;символьное значение, начиающееся с цифр ;@Dol 13.04.11 R
 .....S qqcond2=$LB(1,$P(qq2,"*"),"","$E(Z,1,"_$L($P(qq2,"*"))_")="_$P(qq2,"*")) ;все, начинающиеся на заданные цифры
 ....S qq1=$$qFindC2(qq2),qqcond2=$LB(1,$P($P(qq2,"*"),"?"),$P($P(qq2,"*"),"?"),$S(qq1=".e":1,1:"Z?"_qq1)) Q:$P($P(qq2,"*"),"?")'=""||qq1=".e"||('$D(^Qi(qqw)))  S $LI(qqcond2,1)=2,$LI(qqcond2,3)=$E($P(qq1,"""",2)) ;поиск по вторичному индексу  (ZN???) ;@dol 21.01.02 $P($P(qq2,"*"),"?") вместо $P(qq2,"*") для отработки ?
 ...I qq3="",qqwZN D qFindS(1) S qqcond1=..qFindA(qqcond1,qqminus_"$$qFN(ZC,"" ""_^Q(qqla,"""_qqw_""",qqzb)_"" "","_qqnc_")") Q
 ...I qq3'="" D  ;??????S qq1=$$qFindC2(qq3) D
 ....I $$qFindCZ(qq3),$$qFindCZ(qq3)'=3,qq3'["qW.",qq3'["qUSER." D:qq2=""  S $LI(qqcond2,4)=..qFindA($LG(qqcond2,4),qq3) Q:'qqwZN  D qFindS(1) S qqcond1=..qFindA(qqcond1,"$$qFZ1("""_qqw_""")&&"_qqminus_"$$qFN(ZC,"" ""_^Q(qqla,"""_qqw_""",qqzb)_"" "","_qqnc_")") Q  ;@dol 26.05.02 qq3'["qW.",qq3'["qUSER." - нужны условия на экземпляр
 .....I $E(qq3,1,2)="Z?"||$E(qq3,1,2)="Z[",$D(^Qi(qqw)) S $LI(qqcond2,1)=2,$LI(qqcond2,3)=$E($P(qq3,"""",2)) ;поиск по вторичному индексу
 ....S:$$qFindSYN(qq3) qerr=$G(qerr)_" Синтаксис:"_qq3 S qqcond1="$$qFZ"_qqwt_"("""_qqw_""")&&("_qq3_")" ;_$S(qqwZN:"&&$$qFN(ZZ,Z,"_qqnc_")",1:"")
 ..;
 ..I qq2="*",qq3'="" S qq2=""
 ..I qq2="*" D qFindS(1) S qqcond1=..qFindA(qqcond1,$S(qqwt=3:qqminus_"$$qFT"_$S($E(qqw,2)="B":"B",1:"")_"("""_qqw_""",""Z'="""""""""")",'qqwt:"ZZ'=""""",1:"ZC'=""""")) Q  ;наличие любого значения
 ..I qq2'="",qq3["ZN(" S qerr=$G(qerr)_" Синтаксис:"_qq2_"..."_qq3 Q
 ..I qq3="",qq2[">>",qqwt=2,$E(qqwdt)'=8 D  Q:qq2=""
 ...I qqlang'=1,'$D(^Q(qqlang,"C"_$S($E(qqw)="R":$E(qqw,3,255),1:qqw))) N qqlang S qqlang=1 ;@Dol 13.04.11 R
 ...N qqz,qqi,qq S (qqz,qqzb)=$P(qq2,">>"),qqze=$P(qq2,">>",2) S:qqze'="" qqze=$S(qqwdt:qqze,qqze=+qqze:qqze+1E-16,1:qqze_$C(255,255,255,255))
 ...I qNor,qqzb'=$ZCVT(qqzb,"U")||(qqze'=$ZCVT(qqze,"U")) N qNor S qNor=0 ;диапазон не большими буквами. Значит строгий поиск
 ...S qq="",qqi=0 I qqzb=$ZCVT(qqzb,"L")||(qqzb="") S qqze=$ZCVT(qqze,"L")
 ...D qFindCc0 I qNor,qqi<101,qqze'="",qqzb'=$ZCVT(qqzb,"L") S (qqz,qqzb)=$ZCVT(qqzb,"L") D qFindCc0 I qqi<101,$L(qqzb)'=1 S (qqz,qqzb)=$ZCVT($E(qqzb),"U")_$E(qqzb,2,30000) D qFindCc0 I qqi<101,qqz'=..zL($ZCVT(qqz,"U")) S (qqz,qqzb)=..zL($ZCVT(qqz,"U")) D qFindCc0
 ...I qqi<101 D  Q
 ....I qq="" S qqdat=$G(qqdat)_" Не существует:"_qq2,qq="~~~~" ;Q  ;S qerr=$G(qerr)_" Не существует:"_qq2 Q
 ....D qFindS(1) S qqcond1=..qFindA(qqcond1,qqminus_"$$qFC("""_qq_""""_$S(qqwZN:","_qqnc,1:"")_")"),qq2="" Q
 ..I qq3="",qq2'[">>" D  Q
 ...I qq2'["*",qq2'["?" D  Q
 ....I qNor,qq2'=$ZCVT(qq2,"U") N qNor S qNor=0 ;слово не большими буквами. Значит строгий поиск
 ....I 'qNor D:qqwt=2||(qqwt=1&("CD"[$E(qqw)))  D qFindS(1) S qqcond1=..qFindA(qqcond1,$S(qqwt=3:qqminus_"$$qFT"_$S($E(qqw,2)="B":"B",1:"")_"("""_qqw_""","""""" """"_Z_"""" """"["""" "_$$qFindCdb(qq2)_" """""")",'qqwZN:""" ""_"_$S('qqwt:"ZZ",1:"ZC")_"_"" """_qqminus_"["" "_$$qFindCdb(qq2)_" """,1:qqminus_"$$qFN("_$S('qqwt:"ZZ",1:"ZC")_","" "_$$qFindCdb(qq2)_" "","_qqnc_")")) Q
 .....I qqlang'=1,'$D(^Q(qqlang,"C"_$S($E(qqw)="R":$E(qqw,3,255),1:qqw))) N qqlang S qqlang=1
 .....I '$D(^Q(qqlang,$S($E(qqw)="R":$E(qqw,3,255),1:qqw),qq2)) S qqdat=$G(qqdat)_" Не существует:"_qq2 Q  ;S qerr=$G(qerr)_" Не существует:"_qq2 Q  ;ошибка. искомого слова нет в словаре
 .....Q:qqwt'=2  I $G(^(qq2))="" S qerr=$G(qerr)_" Ошибка в словаре "_qqw_". Нет кода для "_qq2 Q  ;ошибка. кода искомого слова нет в словаре
 .....S qq2=^(qq2)
 ....I qqwt'=2 D qFindS(2) S qqcond1=..qFindA(qqcond1,$S(qqwt=3:qqminus_"$$qFT"_$S($E(qqw,2)="B":"B",1:"")_"("""_qqw_""","""""" """"_Z["""" "_qq2_" """""")",'qqwZN:""" ""_ZZ"_qqminus_"["" "_qq2_" """,1:qqminus_"$$qFN(ZZ,"" "_qq2_" "","_qqnc_")")) Q
 ....I qqlang'=1,'$D(^Q(qqlang,"C"_$S($E(qqw)="R":$E(qqw,3,255),1:qqw))) N qqlang S qqlang=1
 ....N qqz,qq S qq="" S qqz=$G(^Q(qqlang,$S($E(qqw)="R":$E(qqw,3,255),1:qqw),qq2)) S:qqz'="" qq=qq_" "_qqz I qq2'=$ZCVT(qq2,"L") S qqz=$G(^Q(qqlang,qqw,$ZCVT(qq2,"L"))) S:qqz'="" qq=qq_" "_qqz I $L(qq2)'=1 S qqz=$G(^Q(qqlang,qqw,$E(qq2)_$ZCVT($E(qq2,2,3000),"L"))) S:qqz'="" qq=qq_" "_qqz I $E(qq2)_$ZCVT($E(qq2,2,3000),"L")'=..zL(qq2) S qqz=$G(^Q(qqlang,qqw,..zL(qq2))) S:qqz'="" qq=qq_" "_qqz ;@Dol 19/06/06 ..zL
 ....I qq="" S qqdat=$G(qqdat)_" Не существует: "_qq2,qq="~~~~"
 ....D qFindS(1) S qqcond1=..qFindA(qqcond1,qqminus_"$$qFC("""_$$qFindCdb($E(qq,2,30000))_""""_$S(qqwZN:","_qqnc,1:"")_")") Q
 ...I $P(qq2,"*",2)="",$P(qq2,"*",1)'?1.n,qq2'["?" D  Q  ;@Dol 4.2.07 $P(qq2,"*",1)'?1.n
 ....I qqwt'=2 D qFindS(2) S qqcond1=..qFindA(qqcond1,$S(qqwt=3:qqminus_"$$qFT"_$S($E(qqw,2)="B":"B",1:"")_"("""_qqw_""","""""" """"_Z["""" "_$$qFindCdb($P(qq2,"*"))_""""""")",'qqwZN:""" ""_ZZ"_qqminus_"["" "_$$qFindCdb($P(qq2,"*"))_"""",1:qqminus_"$$qFN(ZZ,"" "_$$qFindCdb($P(qq2,"*"))_" "","_qqnc_")")) Q
 ....I qqlang'=1,'$D(^Q(qqlang,"C"_$S($E(qqw)="R":$E(qqw,3,255),1:qqw))) N qqlang S qqlang=1
 ....N qqz,qqi,qq S (qqz,qqzb)=$P(qq2,"*"),qq="",qqi=0
 ....I qNor,qqzb'=$ZCVT(qqzb,"U") N qNor S qNor=0 ;общая часть слова не большими буквами. Значит строгий поиск
 ....D qFindCc I qNor,qqi<101,qqzb'=$ZCVT(qqzb,"L") S (qqz,qqzb)=$ZCVT(qqzb,"L") D qFindCc I qqi<101,$L(qqzb)'=1 S (qqz,qqzb)=$ZCVT($E(qqzb),"U")_$E(qqzb,2,30000) D qFindCc I qqi<101,qqzb'=..zL($ZCVT(qqzb,"U")) S (qqz,qqzb)=$ZCVT(qqzb,"U") D qFindCc ;@Dol 19/06/06 zL
 ....I qqi<101 D  Q
 .....I qq="" S qqdat=$G(qqdat)_" Не существует: "_qq2,qq="~~~~" ;Q  ;S qerr=$G(qerr)_" Не существует:"_qq2 Q
 .....D qFindS(1) S qqcond1=..qFindA(qqcond1,qqminus_"$$qFC("""_qq_""""_$S(qqwZN:","_qqnc,1:"")_")") Q
 ....D qFindS(2) S qqcond1=..qFindA(qqcond1,$S('qqwZN:""" ""_ZZ"_qqminus_"["" "_$$qFindCdb($P(qq2,"*"))_"""",1:qqminus_"$$qFN(ZZ,"" "_$P(qq2,"*")_" "","_qqnc_")")) Q  ;""" ""_ZZ["" "_$P(qq2,"*")_"""") Q
 ...D qFindS(2) S qq1=$$qFindC2(qq2),qq1=$S(qq1=".e":"ZZ'=""""",1:$S($E(qqw)'="T":""" ""_ZZ_"" """_qqminus_"?.e1"" """_qq1_"1"" "".e",1:"Z?.e"_qq1_".e")),qqcond1=..qFindA(qqcond1,$S(qqwt'=3:qq1,1:qqminus_"$$qFT"_$S($E(qqw,2)="B":"B",1:"")_"("""_qqw_""","""_$$qFindCdb(qq1)_""")")) Q  ;qqnc
 ..I qq2'="" D  S:$$qFindSYN(qq2) qerr=$G(qerr)_" Синтаксис:"_qq2
 ...;I qq2[">>" S qq2=$S($P(qq2,">>")="":"",1:""""_$P(qq2,">>")_"""']]Z")_$S($P(qq2,">>",2)="":"",1:$S($P(qq2,">>",1)="":"",1:"&&")_"(Z']]"""_$S(qqwdt=1:$P(qq2,">>",2),$P(qq2,">>",2)=+$P(qq2,">>",2):$P(qq2,">>",2)+1E-16,1:$P(qq2,">>",2)_$C(255,255,255,255))_""")") Q  ;для чисел тоже нужно что-то добавить
 ...I qq2[">>" S qq2=$S($P(qq2,">>")="":"Z'=""""",1:""""_$$qFindCdb($P(qq2,">>"))_"""']]Z")_$S($P(qq2,">>",2)="":"",1:"&&(Z']]"""_$S(qqwdt:$$qFindCdb($P(qq2,">>",2)),$P(qq2,">>",2)=+$P(qq2,">>",2):$P(qq2,">>",2)+1E-16,1:$P(qq2,">>",2)_$C(255,255,255,255))_""")") Q  ;@dol 15.10.03 Z'=""
 ...I qq2'["*",qq2'["?" S qq2="Z="""_$$qFindCdb(qq2)_"""" Q
 ...I $P(qq2,"*",2)="",qq2'["?" S qq2=""" ""_Z"_qqminus_"["" "_$$qFindCdb($P(qq2,"*"))_"""" Q
 ...S qq1=$$qFindC2(qq2),qq2=$S(qq1=".e":"",1:$S($E(qqw)'="T":"Z"_qqminus_"?"_qq1,1:"Z?.e"_qq1_".e")) Q
 ..I qq3'="" S:$$qFindSYN(qq3) qerr=$G(qerr)_" Синтаксис:"_qq3
 ..I qqwZN,qq3["ZN("  S qqcond1=..qFindA(qqcond1,qq3) Q
 ..S qq1=$$qFindCZ(qq3) I qq2'=""||("12"[qq1) D qFindS(2) S qqcond1=..qFindA(qqcond1,qqminus_$S(qqwt'=3:"$$qF(",1:"$$qFT"_$S($E(qqw,2)="B":"B",1:"")_"("""_qqw_""",")_""""_$$qFindCdb($S(qq2="":"",1:qq2_$S(qq3'="":",",1:""))_qq3)_""""_$S(qqwZN:","_qqnc,1:"")_")") Q
 ..D:qq1=3 qFindS(2) S qqcond1=..qFindA(qqcond1,$S(qqminus="":qq3,1:"'("_qq3_")"))
 I $D(qqdat) D
 .I $D(Vs(qqnump,808))>1 Q  ;@dol 2.07.04 условия по ИЛИ
 .I $E(Arg1)="&" S qerr=$G(qerr)_qqdat Q  ;@dol множественное условие
 .I $L(Arg1,"!!")=($L(qqdat," Не существует:")-1) S qerr=$G(qerr)_qqdat ;если все альтернативы не существуют, тогда ошибка
 I '$G(Arg2) Q qqcond ;$S($ZV'["GT.M":qqcond,1:$$Zso^VCPU(qqcond))
 Q $LB($LG(qqcond2,1),$LG(qqcond2,2),$LG(qqcond2,3),$S($LG(qqcond2,4)="":1,1:$LG(qqcond2,4)),qqcond)
 ;Q $LB($$Zso^VCPU($LG(qqcond2,1)),$$Zso^VCPU($LG(qqcond2,2)),$$Zso^VCPU($LG(qqcond2,3)),$S($LG(qqcond2,4)="":1,1:$$Zso^VCPU($LG(qqcond2,4))),$$Zso^VCPU(qqcond))
qFindS(qqqq)    Q:qqwt=3  Q:qqwts'<qqqq
 I 'qqwt S qqwts=2,qqcond1=..qFindA(qqcond1,"$$qFZ"_qqwt_"("""_$$qFindCdb(qqw)_""")") Q
 I qqqq=1!(qqwt=1),qqwts=0 S qqwts=$S(qqwt=1:2,1:1),qqcond1=..qFindA(qqcond1,"$$qFZ1("""_qqw_""")") Q
 I qqwts=0 S qqwts=2,qqcond1=..qFindA(qqcond1,"$$qFZ2("""_qqw_""")") Q
 S qqwts=2,qqcond1=..qFindA(qqcond1,"$$qFZ2("""_qqw_""",1)") Q
 ;
 ;проверка наличия в условии ZZ (возврат 3) Z (возврат 2) ZC (1) иначе 0 
qFindCZ(qqqq)   S qqqq=$TR(qqqq_")","_'=<>[]!&)|?,",$C(1,1,1,1,1,1,1,1,1,1,1,1,1,1))_$C(1) Q $S(qqqq[("ZZ"_$C(1)):3,qqqq[("Z"_$C(1)):2,qqqq[("ZC"_$C(1)):1,1:0) ;"????@dol 26.01.02 qqqq["qW.":3,qqqq["qUSER.":3 - условие содержит метод
 ;
 ;проверка на синтаксис
qFindSYN(cond)
 N $ET,qqc,qqo,qqw S (qqc,qqo,qqw)=1,(ZZ,ZC,Z)=0,$ET="S:$ZE[""SYN"" Z=1 S $EC="""" Q:Z 1"
 I $G(cond)'="",qARM.Value(cond)
 Q Z
 ;cdrs2
qFindC2(Z)  N qq1,qq2,qq3,i
 S qq1=$P($TR(Z,"*?",$C(31,31)),$C(31))
 S qq2=$S(qq1="":Z,1:$P(Z,qq1,2,255)),Z=qq1
 S qq1=$S(Z="":"",1:"1"""_$$qFindCdb($S(qNor:$ZCVT(Z,"U"),1:Z))_""""),qq3=0 F i=1:1:$L(qq2) D
 .I $E(qq2,i)="*" S qq1=qq1_".e" Q
 .I $E(qq2,i)="?" S qq1=qq1_"1e" Q
 .S qq3=$E(qq2,i,511),qq3=$P($TR(qq3,"*?",$C(31,31)),$C(31))
 .S qq1=qq1_"1"""_$$qFindCdb($S(qNor:$ZCVT(qq3,"U"),1:qq3))_"""",i=i+$L(qq3)-1
 Q qq1
qFindCdb(qqpar1) ;удваивание кавычек
 ;S:$ZV["GT.M" qqpar1=$$Zso^VCPU(qqpar1)
 N qqpos S qqpos=1 F  S qqpos=$F(qqpar1,"""",qqpos) Q:'qqpos  S $E(qqpar1,qqpos-1)="""""",qqpos=qqpos+1
 Q qqpar1
qFindCc ;;список кодов qq, если слов меньше 100 ;13.04.11 R
 F  D  Q:qqi=101  S qqz=$O(^Q(qqlang,$S($E(qqw)="R":$E(qqw,3,255),1:qqw),qqz)) Q:$E(qqz,1,$L(qqzb))'=qqzb
 .I $D(^Q(qqlang,$S($E(qqw)="R":$E(qqw,3,255),1:qqw),qqz,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)))) Q:$I(qqi)=101  S $P(qq," ",qqi)=^Q(qqlang,$S($E(qqw)="R":$E(qqw,3,255),1:qqw),qqz)
 Q
qFindCc0 ;список кодов для диапазона ;13.04.11 R
 F  D:qqz'=""  Q:qqi=101  S qqz=$O(^Q(qqlang,$S($E(qqw)="R":$E(qqw,3,255),1:qqw),qqz)) Q:qqz=""  I qqze'="",qqz]]qqze Q
 .I $D(^Q(qqlang,$S($E(qqw)="R":$E(qqw,3,255),1:qqw),qqz,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)))) Q:$I(qqi)=101  S $P(qq," ",qqi)=^Q(qqlang,$S($E(qqw)="R":$E(qqw,3,255),1:qqw),qqz)
 Q
]]></Implementation>
</Method>

<Method name="qFindList">
<Description>
Формирование списка управления поиском</Description>
<Internal/>
<FormalSpec>Cond:%Library.String,qqmod:%Library.String,query:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 N i,qqr,qqo,qqw,qqfi,qqob,qqob0,qqob00,qqww,qqwc,qqwi,qqow,qqobs,qerr
 S qlistF="",qlistFR="" ; - список управления поиском
 ;qlistF=$LB(список_поддерева_поиска,...) - поддеревьев может быть несколько, если условия наложены на разные поддеревья (и они есть в отображении)
 ;  список_поддерева_поиска=$LB(вариант, объект, постоянные_условия?, код_понятия, $LB(список_понятия_обхода,...), $LB(вложенные_списки_объектов,...),объект фиксации, код_фиксации)
 ;    вариант - 0 - обход по релевантным
 ;              1 - обход по словарю понятия объекта вершины поискового образа
 ;              2 - обход по словарю понятия объекта ниже вершины поискового образа
 ;    список_понятий_обхода = $LB(тип_обхода_значения,начало, конец, условие_на_текущее_слово, условие на значение) - списков может быть несколько, если в условии на данное понятие есть альтернативы (!!)
 ;      тип_обхода значения - 0 - конкретное слово, 1 - диапазон, 2 - вторичный индекс (конец - код вторичного индекса) 
 ;      вложенные_списки_объектов = $LB([1]код_объекта, [2]тип_обхода,[3] условия,[4]свободен, [5]$LB(вложенные_списки_объектов,...),[6]длина_кода,[7] множеств.усл. на экземпляры,[8]постоянные_условия,[9]???ссылка на аналитику)[10]тип объекта
 ;      ****    вложенность списков соответствует порядку обхода поддерева поискового образа
 ;        ;тип_обхода - +1 или -1 для $Order по экземплярам. Чтобы учесть постоянное условие типа "Последний экземпляр" 
 ;        условие - состоит из  условий на понятие ;постоянных условий и - изято
 ;        свободен - признак свободного от условий, но включаемого в перечень релевантных объекта (все потомки должны быть свободны тоже)
 ;
 ;qlistFR - список  вставляемых в перечень объектов, дополняющих дерево поиска до полного (от текущего - вверх)
 ;         первый в списке - вершина поискового образа) 
 ;qlistFR=$LB(объект дерева поиска, $LB(вычисляемый объект,длина_кода, вычисляемый объект,длина_кода, ...), ...)
 ;
 ;составление массива объектных ссылок поиска qfn для объектов, входящих в поисковый образ
 ;qfn(qqo1_",")=""
 ;............
 ;qfn(qqo1_","_....qqoN_",")=""
 ;
 S query=$G(Vs(qqnump,808)) ;@dol 19.06.04 Наборы условий по ИЛИ (их кол-во). Параметр query не очень нужен, но пусть пока остается
 ;;I $G(query)'="" S ^QL("Q")=query K Vs8 M Vs8=Vs(qqnump,8) K Vs(qqnump,8,$P($P(query," ",2),","),$P(query," ",1)) ;запрос в виде списка пока для одного понятия (qqw qqo1,qqo2... условие)
 K:$G(W("Zadm")) ^QL("Q") I $G(query)'="" M:$G(W("Zadm")) ^QL("Q")=Vs(qqnump,808) K Vs8 M Vs8=Vs(qqnump,8) ;@dol 19.06.04
 ;последний экземпляр Надо включить предыдущий????
qFindL0 K qfn,qfn3,qfn4 S qqr=0,qerr="" ;;I $G(query)'="" S Vs(qqnump,8,$P($P(query," ",2),","),$P(query," ",1))=$P(query," ",3,255)
 I $G(query)'="" K Vs(qqnump,8) M Vs(qqnump,8)=Vs(qqnump,808,query) ;@dol 19.06.04
 ;@dol 1.09.04 очистка пустых условий
 S qqo="" F  S qqo=$O(Vs(qqnump,8,qqo)) Q:qqo=""  S qqw="" F  S qqw=$O(Vs(qqnump,8,qqo,qqw)) Q:qqw=""  K:$TR($G(Vs(qqnump,8,qqo,qqw))," ")="" Vs(qqnump,8,qqo,qqw)
 ;исключаются объекты вне зоны фиксации
 ;S qqo="" F  S qqo=$O(Vs(qqnump,8,qqo)) Q:qqo=""  I $S($G(Vs(qqnump,7))="":1,1:'$G(Vs(qqnump,7,qqo))) S qqob=$G($$$ObjRef(qqo)) I qqob'="" S qfn(qqob_",")="" D:Cond!$D(Vt(qqnump,111))  ;I qqob'="" - чтобы не включать в поисковый образ объекты, отсутствующие в отображении
 S qqo="" F  S qqo=$O(Vs(qqnump,8,qqo)) Q:qqo=""  I $S($G(Vs(qqnump,7))="":1,1:'$G(Vs(qqnump,7,qqo))) S qqob=$G($$$ObjRef(qqo)) I qqob'="" S qfn(qqob_",")="" D  ;I qqob'="" - чтобы не включать в поисковый образ объекты, отсутствующие в отображении
 .;@dol 30.03.03 обработка условий вида &{}
 .S qqw="" F  S qqw=$O(Vs(qqnump,8,qqo,qqw)) Q:qqw=""  I qqw["*",qqw?1.e1"*"1.N K Vs(qqnump,8,qqo,qqw) ;очистка старых
 .S qqw="" F  S qqw=$O(Vs(qqnump,8,qqo,qqw)) Q:qqw=""  I Vs(qqnump,8,qqo,qqw)["{" D
 ..S Z=Vs(qqnump,8,qqo,qqw),Vs(qqnump,8,qqo,qqw)=qSYS.PSYN(Z,"{",1),i=2
 ..I $E(Vs(qqnump,8,qqo,qqw),$L(Vs(qqnump,8,qqo,qqw)))="&" S Vs(qqnump,8,qqo,qqw)=$E(Vs(qqnump,8,qqo,qqw),1,$L(Vs(qqnump,8,qqo,qqw))-1)
 ..I $TR(Vs(qqnump,8,qqo,qqw)," ")="" S Vs(qqnump,8,qqo,qqw)=qSYS.PSYN(qSYS.PSYN(Z,"{",2),"}",1),i=3 I 1
 ..F i=i:1:qSYS.PSYN(Z,"{") S Vs(qqnump,8,qqo,qqw_"*"_(i-1))=qSYS.PSYN(qSYS.PSYN(Z,"{",i),"}",1) S:$G(Vs(qqnump,8,qqo,qqw,1)) Vs(qqnump,8,qqo,qqw_"*"_(i-1),1)=Vs(qqnump,8,qqo,qqw,1)
 .;
 .I 'Cond,'$D(Vt(qqnump,111)) Q
 .F qqfi=1:1:$L(qqob,",") S qqob0=$P(qqob,",",qqfi) D
 ..I Cond,$G(Vo(qqnump,qqob0,27))'="" S qfn($$$ObjRef(qqob0)_",")=""  ;вверх по ссылке ??!($G(Vo(qqnump,-1,67))'="")-нельзя
 ..I Cond,$G(Vo(qqnump,qqob0,28)),$L(qqob,",")>1 S qfn($$$ObjRef($P(qqob,",",qqfi-1))_",")="" ;обязательно включим объект перед только последним ; @Dol 4.02.04 $L(qqob,",")>1
 ..I $D(Vt(qqnump,111)),$D(Vt(qqnump,111,1,qqob0)) D
 ...I qqfi=1 S qfn($$$ObjRef(qqob0)_",")="" Q  ;самый первый - виртуальный
 ...S qfn($$$ObjRef($P(qqob,",",qqfi-1))_",")="" ;обязательно включим объект перед виртуальным
 I $S($D(Vt(qqnump,111)):1,Cond:$G(Vo(qqnump,-1,67))'="",1:0) D  ;при постоянном условии отображения или наличии вирт.объектов нужно заполнить дырки
 .S (qqobs,qqob)=$O(qfn("")) F  S qqob=$O(qfn(qqob)) Q:$P(qqob,",",1,$L(qqobs,",")-1)_","'=qqobs  D
 ..F qqfi=$L(qqobs,","):1:$L(qqob,",")-1 S qqob0=$P(qqob,",",qqfi) S qfn($$$ObjRef(qqob0)_",")=""
 S qfn=0
qFindLBeg ;поиск отдельных деревьев и составление массива плана обхода qfn0. qqoT - объект вершины поиска
 ;qfn0(qqoT_",",1-4)=условие
 ;..................
 ;qfn0(qqoT_","....qqoN_",",1-4)=условие
 F ilist=1:2 S qfn=$O(Vo(qqnump,-1,0,qfn)) Q:qfn=""  I $D(Vo(qqnump,-1,0,qfn))=1,$G(Vo(qqnump,-1,0,qfn))'="" Q  ;ссылка на дерево
 I qfn="" S:$G(W("Zadm")) ^QL("F")=qlistF,^QL("FR")=qlistFR Q:$G(query)="" $G(qerr) D  G:$G(qerr)=1 qFindL0 Q $G(qerr)
 .;I $G(qerr)="",$L($P(query," ",2),",")'=1 K Vs(qqnump,8,$P($P(query," ",2),","),$P(query," ",1)) S $P(query," ",2)=$P($P(query," ",2),",",2,255),qerr=1 Q  ;K  ,$P(query," ",1))
 .I $G(qerr)="",query,$I(query,-1) S qerr=1 Q  ;@dol 19.06.04
 .K Vs(qqnump,8) M Vs(qqnump,8)=Vs8 K Vs8 Q
 S qqob00=Vo(qqnump,-1,0,qfn),qqob0=qqob00_" ",qqr=0 K qfn0,qqow
 ;проверка множественных условий для предполагаемой вершины поискового образа
 S qqob=$O(qfn(qqob0)) I $P(qqob,",")=qqob00 D
 .S qqo=$P(qqob,",",$L(qqob,",")-1) S qqw="" F  S qqw=$O(Vs(qqnump,8,qqo,qqw)) Q:qqw=""  Q:$G(Vs(qqnump,8,qqo,qqw))[$C(13,10)
 .Q:qqw=""   ;есть, нужно навести порядок (добавить объект верхнего уровня)
 .I $L(qqob,",")>2 S qfn($P(qqob,",",1,$L(qqob,",")-2)_",")="" Q  ;очень грубо. может получится чистый перебор
 .S Vs(qqnump,8,qqo,qqw)=$TR(Vs(qqnump,8,qqo,qqw),$C(13,10),"!!")
 ;нормализация (выделение вершин). массив qfn0
 F  S qqob0=$O(qfn(qqob0)) Q:$P(qqob0,",")'=qqob00  D  Q:qqr  S qqob0=qqob0_"я"  ;I $S($O(qfn($P(qqob0,",")_","_$C(255)),-1)=qqob0:1,1:$D(Vs(qqnump,8,$P(qqob0,",",$L(qqob0,",")-1)))>1)- неправильно!!!;I $S(... пропуск включенных в поисковый образ объектов вершины, которые и так туда попадут
 .S qqob=$O(qfn($P(qqob0,",")_","_"я"),-1) I qqob'=qqob0 D  S qqob0=$P(qqob0,",",1,qqfi-1)_","
 ..F qqfi=1:1 Q:$P(qqob,",",qqfi)'=$P(qqob0,",",qqfi)
 .S qqob=qqob0,qqfi=$L(qqob0,",") D  Q:qqr  F  S qqob=$O(qfn(qqob)) Q:$P(qqob,",",1,qqfi-1)_","'=qqob0  D  Q:qqr
 ..;поиск кандидата для обхода по словарю (виртуальные и ниже не включаются. за исключением первого q4)
 ..S qqo=$P(qqob,",",$L(qqob,",")-1),qfn0($P(qqob,",",qqfi-1,255))=""
 ..;<oleg> 16.09.2005
 ..; добавлена проверка на организацию словаря понятия по конкретному значению: I "@ZTLHMXx"'[$E(qqw),qqw'="C",qqw'="CC",'..rWocx711(qqw,qqo),...
 ..; если словарь - без ссылок, то поиск идет по экземплярам, а не по словарю
 ..;</oleg>
 ..;<oleg> 01.08.2008
 ..; если условие было определено через дополнительное понятие (qqw_*), то возникала ошибка при определении организации словаря для понятия
 ..; исправлено: '..rWocx711(qqw,qqo) --> '..rWocx711($p(qqw,"*"),qqo)
 ..;</oleg>
 ..S qqw="" F  S qqw=$O(Vs(qqnump,8,qqo,qqw)) Q:qqw=""  S:0 qqr=..qFindC(qqo,qqw) M qfn0($P(qqob,",",qqfi-1,255),qqw)=qcond Q:qqr  I "@ZTLHMXxR"'[$E(qqw),qqw'[":",qqw'="C",qqw'="CC",'..rWocx711($P(qqw,"*"),qqo),$S('$D(Vt(qqnump,111)):1,$G(Vo(qqnump,qqo,2))=4:$L($$$ObjRef(qqo),",")=1,1:$D(Vt(qqnump,111,0,qqo))),$S($G(qqow)<1:1,1:$G(Vs(qqnump,8,qqo,qqw,1))<$P($G(qqow,"0 0 0 99")," ",4)) S Z=Vs(qqnump,8,qqo,qqw) I $E(Z,1,3)'="=""""",Z'["Z=""""",Z'["!!=""""" S Z=$P($P(Z,"!!")," ") D:Z'=""  ;отсев условия на отсутствие экземпляра;@Dol 22.11.10 R*
 ...I $P(Z," ")="-" Q
 ...I $S($E(Z,1,2)=">>":1,"><'=[?"[$E(Z):0,1:1),Z'["*",Z'["?",Z'["..." S qqow=2_" "_$P(qqob,",",qqfi-1,255)_" "_qqw_" "_$G(Vs(qqnump,8,qqo,qqw,1)) Q  ;конкретное слово
 ...I $E(Z,1,3)="..." Q:Z="...Z="""""  S ZZ=$P($P(Z," "),"...",2) Q:ZZ["qW."!(ZZ["qUSER.")  ;Q:ZZ["qW.zNum"  Q:ZZ["qW.zSum"
 ...I Z["..." S Z=$P(Z,"...") I Z'="",Z'["*",Z'["?" S qqow=1_" "_$P(qqob,",",qqfi-1,255)_" "_qqw_" "_$G(Vs(qqnump,8,qqo,qqw,1)) Q  ;задано начало слова
 ...I Z["*",$P(Z,"*")'="" S qqow=1_" "_$P(qqob,",",qqfi-1,255)_" "_qqw_" "_$G(Vs(qqnump,8,qqo,qqw,1)) Q  ;задано начало слова
 ...I Z'="=""""" S qqow=0_" "_$P(qqob,",",qqfi-1,255)_" "_qqw_" "_$G(Vs(qqnump,8,qqo,qqw,1)) ;задано условие на слово
 I $D(qfn0)<10 G qFindLBeg
 ;I qqr Q "SYNTAX "_Vs(qqnump,8,qqo,qqw)
 ;поиск
 S qqos0=$O(qfn0("")),qqo0=$P(qqos0,",") ;главный объект обхода и его ссылка (вершина дерева поиска)
 I $G(qqmod) K qfn1 D  ;дозапись поисковых образов полного поддерева
 .S (qqobs,qqob)=$$$ObjRef(qqo0) F  S qqob=$O($$$MObjRef(qqob)) Q:$P(qqob,",",1,$L(qqobs,","))'=qqobs  D:'$D(qfn0($P(qqob,",",$L(qqobs,","),255)_","))
 ..S qfn(qqob_",")="",qfn0($P(qqob,",",$L(qqobs,","),255)_",")="" Q  ;вниз по ссылке 
 ;
 S qqfi='($G(qqow)=""!$$$ReFind!($P($$$CondFind," ",10)'=""&&(qqo0=$G(Vs(qqnump,7))))!($P($G(qqow)," ",3)="C")) I qqfi S qqo=$P(qqow," ",2),qqo=$P(qqo,",",$L(qqo,",")-1),qqw=$P(qqow," ",3) S:qqo0'=qqo qqfi=2,qqo00=qqo D  ;вариант поиска
 .;постоянные условия?
 .S qqww="",qqwc=Vs(qqnump,8,qqo,qqw)  ;есть множественные условия для экземпляров - [$C(13,10)
 .F qqwi=1:1:$S(qqwc[$C(13,10):1,1:qSYS.PSYN(qqwc,"!!")) S qqobs=..qFindC($S(qqwc[$C(10,13):qqwc,1:qSYS.PSYN(qqwc,"!!",qqwi)),1) D  S $LI(qqww,qqwi)=qqobs
 ..I $G(qerr)'="",qerr'["Синтаксис:",qqwc["!!" K qerr ;Не существует альтернатива (не очень хорошо, нужно смотреть все альтернативы)
 ..Q:'qqfi
 ..N qqwc S qqwc=qqw N qqw S qqw="" F  S qqw=$O(Vs(qqnump,8,qqo,qqw)) Q:qqw=""  I $G(Vs(qqnump,8,qqo,qqw))'="",qqw'=qqwc S $LI(qqobs,5)=..qFindA($LI(qqobs,5),..qFindC(Vs(qqnump,8,qqo,qqw)))
 ..S:Cond $LI(qqobs,5)=$$qFindLC($LI(qqobs,5),qqo) S:$LI(qqobs,5)="" $LI(qqobs,5)=1
 ;
 K qfn1,qfn3,qfn4
 S qqob=$$$ObjRef(qqo0),qlist="" I $L(qqob,",")>1 D  S qlistFR=qlistFR_$LB(qqo0,qlist)
 .F i=$L(qqob,",")-1:-1:1 S qlist=qlist_$LB($P(qqob,",",i),$$$ObjLqqc($P(qqob,",",i)))
 S qlistF=qlistF_$LB($LB(qqfi,$S(qqfi:qqo,1:""),"",$S(qqfi:$P(qqw,"*"),1:""),$S(qqfi:qqww,1:""),$$qFindLt(qqo0_$S(qqfi=1:",",1:"")),$G(Vs(qqnump,7)),$P($$$CondFind," ",10)))
 I $D(qfn3) D  ;формирование условия на главный объект, если есть множественные условия для экземпляров ????qqw*
 .N qco,qqo,qqw,i S qco="",qqo="" F  S qqo=$O(qfn3(qqo)) Q:qqo=""  S qqw="" F  S qqw=$O(qfn3(qqo,qqw)) Q:qqw=""  D
 ..F i=1:1:qfn3(qqo,qqw) S qco=$S(qco="":"",1:qco_"&&")_$S($G(qfn4(qqo,qqw,i)):"'",1:"")_"$D(qfnCP("""_qqo_""","""_qqw_""","_i_"))" ;@dol 17.12.02 $S($G(qfn4(qqo,qqw,i)):"'",1:"") - множественное отрицание
 .S qqo=$LI(qlistF,$LL(qlistF)),qqw=$LI(qqo,6),i=$LI(qqw,1),$LI(i,7)=qco
 .S $LI(qqw,1)=i,$LI(qqo,6)=qqw,$LI(qlistF,$LL(qlistF))=qqo
 K qfn1,qfn3,qfn4 G qFindLBeg
qFindLt(qqobtr) N qqob,list,qqo,qqofr,qqopcond S list="",qqob=qqobtr S:$E(qqobtr,$L(qqobtr))'="," qqobtr=qqobtr_"," F  S qqob=$O(qfn0(qqob)) Q:$E(qqob,1,$L(qqobtr))'=qqobtr  S qqo=$P(qqob,",",$L(qqob,",")-1) D  S list=list_$LB($LB(qqo,$S(Cond&$G(Vo(qqnump,qqo,28)):-1,1:1),$S(qqww="":1,1:qqww),qqofr,$$qFindLt(qqob),$$$ObjLqqc(qqo),,qqopcond,,+$G(Vo(qqnump,qqo,2)))) S qqob=qqob_"я"
 .S qqw="",qqww=$S(qqfi=2&&(qqo=qqo00):"qfnCC=qqc",1:""),qqopcond=$$qFindLC("",qqo),qqopcond=$S('Cond:1,qqopcond="":1,qqww="":qqopcond,1:..qFindA(qqww,qqopcond,"||")) F  S qqw=$O(Vs(qqnump,8,qqo,qqw)) Q:qqw=""  S qqwc=$G(Vs(qqnump,8,qqo,qqw)) I qqwc'="" S qqww=..qFindA(qqww,..qFindC(qqwc),$S(qqfi'=2:"&&",qqo'=qqo00:"&&",qqww'="qfnCC=qqc":"&&",1:"||")) ;||игнорирование условия для уже найденного по словарю кода экземпляра
 .I qqo=qqo0 S qqofr=0 S:'qqfi&Cond qqww=$$qFindLC(qqww,qqo) Q  ;вершина поискового образа не свободна по определению (постоянные условия нужно навесить??если обход дерева)
 .S qqobs=qqo0_","_$P(","_$$$ObjRef(qqo)_",",","_qqo0_",",2,255) I $L(qqobs,",")>3 S qqofr="" D  I qqofr'="" S qlistFR=qlistFR_$LB(qqo,qqofr) ;дополняемые объекты
 ..F i=$L(qqobs,",")-2:-1:2 Q:$D(qfn0($P(qqobs,",",1,i)_","))  Q:$D(qfn1($P(qqobs,",",i)))  S qqofr=qqofr_$LB($P(qqobs,",",i),$$$ObjLqqc($P(qqobs,",",i))),qfn1($P(qqobs,",",i))="" ;qfn1 - чтобы не было повторов
 .S qqofr=$D(Vs(qqnump,8,qqo))<10 D:qqofr  ;свободен
 ..N qqob S (qqob,qqobs)=qqobtr_qqo_"," F  S qqob=$O(qfn0(qqob)) Q:$E(qqob,1,$L(qqobs))'=qqobs  S qqofr=$D(Vs(qqnump,8,$P(qqob,",",$L(qqob,",")-1)))<10 Q:'qqofr
 Q list
 ;Добавление постоянных условий
qFindLC(cond,qqo)
 I 'Cond Q cond
 S:$G(Vo(qqnump,qqo,27))'="" cond=..qFindA(cond,Vo(qqnump,qqo,27)) S:$G(Vo(qqnump,-1,67))'="" cond=..qFindA(cond,Vo(qqnump,-1,67)) Q cond
]]></Implementation>
</Method>

<Method name="qFindList0">
<Internal/>
<Language>cache</Language>
<Implementation><![CDATA[
 N VVs M VVs(8)=Vs(qqnump,8),VVs(7)=Vs(qqnump,7),VVs("CondFind")=Vs(qqnump,"CondFind")
 I $G(Vs(qqnump,7))="" D
 .N qqo0 S qqr="" F  S qqr=$O(Vs(qqnump,8,qqr)) Q:qqr=""  S:'$D(qqo0) qqo0=$P($G($$$ObjRef(qqr)),",") Q:qqo0'=$P($G($$$ObjRef(qqr)),",")  ;проверка на единственность вершины поиска
 .Q:qqr'=""
 .S qqr="" F  S qqr=$O(Vs(qqnump,8,qqr)) Q:qqr=""  I $D(Vs(qqnump,8,qqr,"C")) Q:'$D(Vt(qqnump,111))  Q:$D(Vt(qqnump,111,0,qqr))  ;есть условие на экземляр
 .I qqr'="",$G(Vs(qqnump,8,qqr,"C"))'="",$E(Vs(qqnump,8,qqr,"C"))'?1NP,Vs(qqnump,8,qqr,"C")'[">>",Vs(qqnump,8,qqr,"C")'["!!",Vs(qqnump,8,qqr,"C")'[$C(13,10),$L(Vs(qqnump,8,qqr,"C")," ")=1 D
 ..N qqq S qqq=$P(Vs(qqnump,8,qqr,"C"),"...") D
 ...I qqq["*",$E(qqq,$L(qqq))'="*" Q
 ...S Vs(qqnump,8,qqr,"C")=$P(Vs(qqnump,8,qqr,"C"),"...",2,255) K:Vs(qqnump,8,qqr,"C")="" Vs(qqnump,8,qqr,"C")
 ..S Vs(qqnump,7)=qqr,Vs(qqnump,8,qqr)="",$P($$$CondFind," ",10)=$P(qqq,"*") ;псевдофиксация
 S qqr=..qFindList(Cond,+$G(qqmod),$G(qqolst))
 K Vs(qqnump,8),Vs(qqnump,7),Vs(qqnump,"CondFind") M Vs(qqnump)=VVs
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="qFindN">
<Internal/>
<FormalSpec>qqcnt:%Library.String=0,qql:%Library.String,qqlang:%Library.String,qviewf:%Library.String,qlistF:%Library.String,qlistFR:%Library.String,qqr0:%Library.String=0,qNor:%Library.String=0</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ; qfnC -временный массив релевантных для текущего поддерева
 N qicond,qcond,qlist,qlistw,qqo,qqw,qqend,qqr,time,qlist1,qlist7,qlistw ;ii,qqww,qqww1,iii ;,qqow ;,$ET
 K Zpw,qfnC
 S time=$H
 F qicond=1:1:$LL(qlistF) S qqo=$LI($LI(qlistF,qicond),2),qqo0=$S($LI($LI(qlistF,qicond),1)=1:qqo,1:$LI($LI($LI($LI(qlistF,qicond),6),1),1)),qqr=qqr0 S:0 qqob0=$$$ObjRef(qqo0) K qfnC,qfnCT D @("qFind"_$LI($LI(qlistF,qicond),1))
 S:$G(^Q(qviewf))="" ^Q(qviewf)=time_" "_($P($H,",",2)-$P(time,",",2)) ;дата и (через пробел) время выполнения запроса
 K qfnCT Q $D(^Q(qviewf))>1
 ;пословное сканирование значения ZZ ???
qF(cccc,ccccZN) F cccci=1:1:$L(ZZ," ") S Z=$P(ZZ," ",cccci) I @cccc S:$D(ccccZN) ZN(ccccZN)=cccci S cccci=0 Q
 Q 'cccci
 ;пословное сканирование значения ZC ???
qFC(cccc,ccccZN)    I '$D(ccccZN),$L(ZC," ")>$L(cccc," ") D  Q 'cccci
 .F cccci=1:1:$L(cccc," ") I " "_ZC_" "[(" "_$P(cccc," ",cccci)_" ") S cccci=0 Q
 F cccci=1:1:$L(ZC," ") I " "_cccc_" "[(" "_$P(ZC," ",cccci)_" ") S:$D(ccccZN) ZN(ccccZN)=cccci S cccci=0 Q
 Q 'cccci
 ;добыча значения общая
qFZ0(qqwww) S ZZ=..G(qqwww) S:qNor ZZ=$ZCVT(ZZ,"U") Q 1 ;S:qqwww[":" ^II($I(^II))=ZZ Q 1
 ;добыча кодов значений (значений для M* F* D*) 
qFZ1(qqwww) S (ZZ,ZC)=$G(^Q(1,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)),qqc,qqwww)) S:qNor ZZ=$ZCVT(ZZ,"U") Q 1 ;Q:$G(qqwwwt)="" 1 Q " "_ZC_" "[(" "_qqwwwt_" ")
 ;добыча кодов значений 
qFZ2(qqwww,qqwwwt)  S:'$G(qqwwwt) ZC=$G(^Q(1,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)),qqc,qqwww)) I ZC="" S ZZ="" Q 1
 S:$E(qqwww)="R" qqwww=$E(qqwww,3,255) I qqlang'=1,'$D(^Q(qqlang,"C"_qqwww)) N qqlang S qqlang=1  ;@Dol 13.04.11 R*
 S ZZ=$G(^Q(qqlang,"C"_qqwww,$P(ZC," "))) F qqwww=2:1:$L(ZC," ") S:$P(ZC," ",qqwww)'="" ZZ=ZZ_" "_$G(^($P(ZC," ",qqwww)))
 S:qNor ZZ=$ZCVT(ZZ,"U")
 Q 1
 ;проверка на вхождение с заполнением позиции 
qFN(cccc1,cccc2,ccccZN) S cccc1=" "_cccc1_"  ",cccci=$F(cccc1,cccc2) Q:'cccci 0 S ZN(ccccZN)=$L($E(cccc1,1,cccci-1)," ")-($E(cccc2,$L(cccc2))=" ")-1 Q 1
 ;текстовые понятия T ;(qqlang???)
qFT(qqwww,cccc)
 N it,itcond S it="",itcond=0 F  S it=$O(^Q(1,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)),qqc,qqwww,it)) Q:it=""  S Z=$S('qNor:^(it),1:$ZCVT(^(it),"U")) I Z'="",@cccc S itcond=1 Q
 Q itcond
 ;большие текстовые понятия TB ; qqwww=$E(qqw,2,255) ;(qqlang???)
qFTB(qqwww,cccc)
 N it,itcond S it="",itcond=0 F  S it=$O(^QT(qqlang,qqwww,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)),qqc,it)) Q:it=""  S Z=$S('qNor:^(it),1:$ZCVT(^(it),"U")) I Z'="",@cccc S itcond=1 Q
 Q itcond
 ;
 ;проход по дереву зкземпляров
qFind0 N qqcfix,qqtype S qqo=qqo0,qqtype=$LI($LI($LI($LI(qlistF,qicond),6),1),10),cond0=$LI($LI($LI($LI(qlistF,qicond),6),1),3),qlist1=$LI($LI($LI($LI(qlistF,qicond),6),1),5),qlist7=$LG($LI($LI($LI(qlistF,qicond),6),1),7) S:qlist7="" qlist7=1
 S qqcfix=$LI($LI(qlistF,qicond),8) ;$P($$$CondFind," ",10) ;есть фиксация
 I qqtype,qqtype<3 S:$E(qqo)="v" qqo=$E(qqo,3,255),qqtype=0 ;@dol 3.07.04 для встроенных и ссылочных
 S qqc=qqcfix I qqcfix'="",qqo=$LI($LI(qlistF,qicond),7),$LI($LI($LI($LI(qlistF,qicond),6),1),6)=$L(qqcfix) D  Q  ;вершина фиксирована
 .I @cond0 K qfnCC,qfnCP I qlist1=""||'$$qFindTr(qlist1,qqc,qqo),@qlist7 S qfnC(qqo,qqc)="" M:qlist1'="" qfnC=qfnCC D qFindEnd
 I 'qqtype F  S qqc=$O(^Q(qql,qqo,qqc)) Q:qqc=""||(qqcfix'=""&&($E(qqc,1,$L(qqcfix))'=qqcfix))   I @cond0 K qfnCC,qfnCP I qlist1=""||'$$qFindTr(qlist1,qqc,qqo),@qlist7 S qfnC(qqo,qqc)="" M:qlist1'="" qfnC=qfnCC D:$I(qqr)>500 qFindEnd I qqcnt,qqr'<qqcnt S qqend=1 Q  ;а виртуальные (ссылки в перечне релевантных)
 I qqtype F  S qqc=..gOrder(1,qqo,qqc,,,1) Q:qqc=""||(qqcfix'=""&&($E(qqc,1,$L(qqcfix))'=qqcfix))   I @cond0 K qfnCC,qfnCP I qlist1=""||'$$qFindTr(qlist1,qqc,qqo),@qlist7 S qfnC(qqo,qqc)="" M:qlist1'="" qfnC=qfnCC D:$I(qqr)>500 qFindEnd I qqcnt,qqr'<qqcnt S qqend=1 Q
 D qFindEnd Q
 ;проход по словарю  (вершина прохода совпадает с вершиной поискового образа)
qFind1 N qqla,qqzb,qqcfix,qqzb0 S qqcfix=$LI($LI(qlistF,qicond),8),qqw=$LI($LI(qlistF,qicond),4),qlistw=$LI($LI(qlistF,qicond),5),qlist1=$LI($LI(qlistF,qicond),6),qqla=1,qlist7=$S(qlist1="":"",1:$LG($LI(qlist1,1),7)) S:qlist7="" qlist7=1 I qqlang'=1,$D(^Q(qqlang,qqw)) S qqla=qqlang ;есть иностранный словарь
 S qqend=0 F qqwii=1:1:$LL(qlistw) S qqzb=$LI($LI(qlistw,qqwii),2),condC=$LI($LI(qlistw,qqwii),5) D  Q:qqend
 .I '$LI($LI(qlistw,qqwii)) D qFind1c Q:'qNor||(qqzb'=$ZCVT(qqzb,"U"))  Q:qqzb=$ZCVT(qqzb,"L")  S qqzb=$ZCVT(qqzb,"L") D qFind1c Q:qqend||($L(qqzb)=1)  S qqzb=$ZCVT($E(qqzb),"U")_$E(qqzb,2,3000) D qFind1c Q:qqend||(qqzb=..zL($ZCVT(qqzb,"U")))  S qqzb=..zL($ZCVT(qqzb,"U")) D qFind1c Q  ;проход по конкретному слову
 .S qqze=$LI($LI(qlistw,qqwii),3),condZ=$LI($LI(qlistw,qqwii),4)
 .I $LI($LI(qlistw,qqwii))=2 D  Q  ;проход по вторичному индексу
 ..S qqzb="" F  S qqzb=$O(^Qi(qqw,qqze,qqzb)) Q:qqzb=""  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFind1c Q:qqend
 .I qqze'="" S qqze=$S(qqze=+qqze:qqze+1E-16,1:qqze_$C(255,255,255,255)) I qNor,qqzb=$ZCVT(qqzb,"U"),qqzb=""||(qqzb=$ZCVT(qqzb,"L")) S qqze=$ZCVT(Z,"L") ;не дальше яяяя
 .S qqzb0=qqzb I qqzb'="" D qFind1c Q:qqend  I 'qNor,qqzb=$ZCVT(qqzb,"U"),qqzb'=$ZCVT(qqzb,"L")  S qqzb=$ZCVT(qqzb,"L") D qFind1c Q:qqend  I $L(qqzb)'=1 S qqzb=$ZCVT($E(qqzb),"U")_$E(qqzb,2,3000) D qFind1c Q:qqend  I qqzb'=..zL(qqzb0) S qqzb=..zL(qqzb0) D qFind1c Q:qqend
 .S qqzb=qqzb0 F  S qqzb=$O(^Q(qqla,qqw,qqzb)) Q:qqzb=""||(qqze'=""&&(qqzb]]qqze))  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFind1c Q:qqend
 .Q:'qNor||qqend||(qqze="")||(qqzb0="")||(qqzb0'=$ZCVT(qqzb0,"U"))||(qqzb0=$ZCVT(qqzb0,"L"))
 .S qqzb=$ZCVT(qqzb0,"L"),qqze=$ZCVT(qqze,"L")
 .F  S qqzb=$O(^Q(qqla,qqw,qqzb)) Q:qqzb=""||(qqze'=""&&(qqzb]]qqze))  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFind1c Q:qqend
 .Q:qqend||($L(qqzb)=1)  S qqzb=$ZCVT($E(qqzb0),"U")_$ZCVT($E(qqzb0,2,3000),"L"),qqze=$ZCVT($E(qqze),"U")_$E(qqze,2,3000)
 .F  S qqzb=$O(^Q(qqla,qqw,qqzb)) Q:qqzb=""||(qqze'=""&&(qqzb]]qqze))  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFind1c Q:qqend
 .Q:qqend||(qqzb=..zL(qqzb0))  S qqzb=..zL(qqzb0),qqze=..zL($ZCVT(qqze,"U"))
 .F  S qqzb=$O(^Q(qqla,qqw,qqzb)) Q:qqzb=""||(qqze'=""&&(qqzb]]qqze))  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFind1c Q:qqend
 D qFindEnd Q
qFind1c S qqc=qqcfix,qqz=$S($E(qqw)="C":$G(^Q(1,qqw,qqzb),"???"),qqla=1:qqzb,1:$G(^Q(1,"C"_qqw,$G(^Q(qqla,qqw,qqzb),"???")),"???")) I $E(qqw)="C" S qqend=qqw N qqw S qqw=$E(qqend,2,255) 
 F  S qqc=$O(^Q(1,qqw,qqz,qqo,qqc)) Q:qqc=""||(qqcfix'=""&&($E(qqc,1,$L(qqcfix))'=qqcfix))   I @condC K qfnCC,qfnCP I qlist1=""||'$$qFindTr(qlist1,qqc,qqo),@qlist7 S qfnC(qqo,qqc)="" M:qlist1'="" qfnC=qfnCC D:$I(qqr)>500 qFindEnd I qqcnt,qqr'<qqcnt S qqend=1 Q  ;а виртуальные (ссылки в перечне релевантных)
 Q
 ;проход по словарю
qFind2 N qqla,qqzb,qqze,qqcfix,cond00,qqof,qqopcond,qqzb0,qqopcnd0 S qqcfix=$LI($LI(qlistF,qicond),8),cond0=$LI($LI($LI($LI(qlistF,qicond),6),1),3),qqopcnd0=$LI($LI($LI($LI(qlistF,qicond),6),1),8),qlist1=$LI($LI($LI($LI(qlistF,qicond),6),1),5),qqcL=$LI($LI($LI($LI(qlistF,qicond),6),1),6),qqw=$LI($LI(qlistF,qicond),4),qlistw=$LI($LI(qlistF,qicond),5),qqla=1,qlist7=$LG($LI($LI($LI(qlistF,qicond),6),1),7) S:qlist7="" qlist7=1
 I qqlang'=1,$D(^Q(qqlang,qqw)) S qqla=qqlang ;есть иностранный словарь
 S qqend=0 F qqwii=1:1:$LL(qlistw) S qqzb=$LI($LI(qlistw,qqwii),2),condC=$LI($LI(qlistw,qqwii),5) D  Q:qqend
 .I '$LI($LI(qlistw,qqwii)) D qFind2c Q:'qNor||(qqzb'=$ZCVT(qqzb,"U"))  Q:qqzb=$ZCVT(qqzb,"L")  S qqzb=$ZCVT(qqzb,"L") D qFind2c Q:qqend||($L(qqzb)=1)  S qqzb=$ZCVT($E(qqzb),"U")_$E(qqzb,2,3000) D qFind2c Q:qqend||(qqzb=..zL($ZCVT(qqzb,"U")))  S qqzb=..zL($ZCVT(qqzb,"U")) D qFind2c Q  ;проход по конкретному слову
 .S qqze=$LI($LI(qlistw,qqwii),3),condZ=$LI($LI(qlistw,qqwii),4)
 .I $LI($LI(qlistw,qqwii))=2 D  Q  ;проход по вторичному индексу
 ..S qqzb="" F  S qqzb=$O(^Qi(qqw,qqze,qqzb)) Q:qqzb=""  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFind2c Q:qqend
 .I qqze'="" S qqze=$S(qqze=+qqze:qqze+1E-16,1:qqze_$C(255,255,255,255))  I qNor,qqzb=$ZCVT(qqzb,"U"),qqzb=""||(qqzb=$ZCVT(qqzb,"L")) S qqze=$ZCVT(Z,"L") ;не дальше яяяя
 .S qqzb0=qqzb I qqzb'="" D qFind2c Q:qqend  I 'qNor,qqzb=$ZCVT(qqzb,"U"),qqzb'=$ZCVT(qqzb,"L")  S qqzb=$ZCVT(qqzb,"L") D qFind2c Q:qqend  I $L(qqzb)'=1 S qqzb=$ZCVT($E(qqzb),"U")_$E(qqzb,2,3000) D qFind2c Q:qqend  I qqzb'=..zL($ZCVT(qqzb,"U")) S qqzb=..zL($ZCVT(qqzb,"U")) D qFind2c Q:qqend
 .S qqzb=qqzb0 F  S qqzb=$O(^Q(qqla,qqw,qqzb)) Q:qqzb=""||(qqze'=""&&(qqzb]]qqze))  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFind2c Q:qqend
 .Q:'qNor||qqend||(qqze="")||(qqzb0="")||(qqzb0'=$ZCVT(qqzb0,"U"))||(qqzb0=$ZCVT(qqzb0,"L"))
 .S qqzb=$ZCVT(qqzb0,"L"),qqze=$ZCVT(qqze,"L")
 .F  S qqzb=$O(^Q(qqla,qqw,qqzb)) Q:qqzb=""||(qqze'=""&&(qqzb]]qqze))  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFind2c Q:qqend
 .Q:qqend||($L(qqzb)=1)  S qqzb=$ZCVT($E(qqzb0),"U")_$ZCVT($E(qqzb0,2,3000),"L"),qqze=$ZCVT($E(qqze),"U")_$E(qqze,2,3000)
 .F  S qqzb=$O(^Q(qqla,qqw,qqzb)) Q:qqzb=""||(qqze'=""&&(qqzb]]qqze))  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFind2c Q:qqend
 .Q:qqend||(qqzb=..zL($ZCVT(qqzb0,"U")))  S qqzb=..zL($ZCVT(qqzb0,"U")),qqze=..zL($ZCVT(qqze,"U")) ;@Dol 19/06/06 ..zL
 .F  S qqzb=$O(^Q(qqla,qqw,qqzb)) Q:qqzb=""||(qqze'=""&&(qqzb]]qqze))  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFind2c Q:qqend
 D qFindEnd Q
qFind2c S qqof=qqo,qqc=qqcfix,qqz=$S($E(qqw)="C":$G(^Q(1,qqw,qqzb),"???"),qqla=1:qqzb,1:$G(^Q(1,"C"_qqw,$G(^Q(qqla,qqw,qqzb),"???")),"???")) I $E(qqw)="C" S qqend=qqw N qqw S qqw=$E(qqend,2,255)
 F  S qqc=$O(^Q(1,qqw,qqz,qqo,qqc)) Q:qqc=""||(qqcfix'=""&&($E(qqc,1,$L(qqcfix))'=qqcfix))   K qfnCP I $E(qqw)'="W"||('$D(qfnC(qqo,qqc))&&'$D(^Q(qviewf,qqo,qqc))),@condC D  I qqcnt,qqr'<qqcnt S qqend=1 Q  ;перечень релевантных надо проверить??? если понятие W
 .K qfnCC S qfnCC=qqc N qqc,qqo S qqc=$E(qfnCC,1,qqcL),qqo=qqo0 I @cond0,@qqopcnd0 D  ;@dol 29.07.04 qqopcnd0
 ..S cond00=1 I $LL(qlist1)=1,$LI($LI(qlist1),2)'=-1,qlist7=1 S qqZN=qlist1,qfnCC(qqo,qqc)="" N qlist1 S qlist1=qqZN F  S qlist1=$LI(qlist1),qqo=$LI(qlist1),qqc=$E(qfnCC,1,$LI(qlist1,6)),cond00=$LI(qlist1,3),qqopcond=$LI(qlist1,8),qlist1=$LI(qlist1,5) Q:qqo=qqof  D:'$D(qfnC(qqo,qqc))  Q:'cond00||(qlist1="")||($LL(qlist1)>1)  S qfnCC(qqo,qqc)=""  ;чтобы безтолку не перебирать объекты верхних уровней
 ...I @qqopcond,@cond00 S cond00=1 Q
 ...S cond00=0
 ..I qqo'=qqof,'cond00 Q
 ..I qlist1=""||'$$qFindTr(qlist1,qqc,qqo),@qlist7 S qfnC(qqo,qqc)="" M qfnC=qfnCC D:$I(qqr)>500 qFindEnd  ;а виртуальные (ссылки в перечне релевантных)
 Q
 ;проверка поддерева (хотя бы одна ветьвь должна быть)
 ;qqltr - вложенные_списки_объектов = $LB(код_объекта, тип_обхода, условия,$LB(вложенные_списки_объектов,...))
 ;@Dol 30.11.04 qqc0 заменено на qqcc0 т.к. оно может встретится в условиях вывода
qFindTr(qqltr,qqcc0,qqom)   N qqend0,qqltr1,qqend,qqco,qqci,qqend,qqo,qqc,qqli,qqci,qqofr,qorder,qqopcond,qqAn,qqtype,qqc0  ;S qqend=0,qqoo=$P(qqobtr,",",$L(qqobtr,",")-1),qqco=qqc0
 S qqend=0 F qqli=1:1:$LL(qqltr) S:$G(qA) qqAn=$LI($LI(qqltr,qqli),9) S qqtype=$LI($LI(qqltr,qqli),10),qqo=$LI($LI(qqltr,qqli),1),qorder=$LI($LI(qqltr,qqli),2),qqopcond=$LI($LI(qqltr,qqli),8),qqco=$LI($LI(qqltr,qqli),3),qqltr1=$LI($LI(qqltr,qqli),5),qqofr=$LI($LI(qqltr,qqli),4) D  Q:qqend
 .S qqend0=1 I 'qqtype S qqc=$S(qorder'=-1:qqcc0,1:qqcc0_"я") F qqci=0:1 S qqc=$O(^Q(qql,qqo,qqc),qorder) Q:$E(qqc,1,$L(qqcc0))'=qqcc0  I @qqopcond D  I qorder=-1,$G(Vo(qqnump,qqo,28)) Q  ;@Dol 19.08.08 28-только последний  ;Q:qorder=-1 - последний экземляр означает и единственный
 ..I @qqco,qqltr1=""||'$$qFindTr(qqltr1,qqc,qqo) S qfnCC(qqo,qqc)="",qqend0=0
 .I qqtype S qqc="" F qqci=0:1 S qqc=..gOrder(qorder,qqo,qqc,qqcc0,,1) Q:qqc=""   D  I qorder=-1,$G(Vo(qqnump,qqo,28)) Q  ;I @qqopcond D  Q:qorder=-1  ;@Dol 30.11.04 @qqopcond - проверка постоянных условий не нужна - есть в gOrder
 ..I @qqco,qqltr1=""||'$$qFindTr(qqltr1,qqc,qqo) S qfnCC(qqo,qqc)="",qfnCC(qqom,qqcc0,qqo,qqc)="",qqend0=0 ;,qfnCC(qqom,qqc0)="" ;@dol 21.02.03 qfnCC(qqom,qqc0)=""
 .I qqend0 Q:qqofr  S qqend=1 Q  ;только последний узел А постоянные условия???;@dol 25.10.03
 Q qqend
 ;.I '$D(qfnCC(qqo)) Q:qqofr  S qqend=1 Q  ;только последний узел А постоянные условия???
 ;
qFindEnd S qqoo="" F  S qqoo=$O(qfnC(qqoo)) Q:qqoo=""  S qfnC=$D(^Q(qviewf,qqoo))>1,qqcco="",qqooi=0,qqoor=$LF(qlistFR,qqoo) S qqoor=$S('qqoor:"",1:$LI(qlistFR,qqoor+1)) D  I $I(^Q(qviewf,qqoo),qqooi)
 .F  S qqcco=$O(qfnC(qqoo,qqcco)) Q:qqcco=""  D:$D(qfnC(qqoo,qqcco))>1  I $S(qfnC:$G(^Q(qviewf,qqoo,qqcco),"?")="?",1:1),$I(^Q(qviewf,qqoo,qqcco)),$I(qqooi),qqoor'="" F qqoi=1:2:$LL(qqoor) S qqooo=$LI(qqoor,qqoi),qqcoo=$E(qqcco,1,$LI(qqoor,qqoi+1)) I $L(qqcoo)>3||'$D(qfnCT(qqooo,qqcoo)),'$D(^Q(qviewf,qqooo,qqcoo)),$I(^(qqcoo)),$I(^Q(qviewf,qqooo)) I $L(qqcoo)<4 K:$S<10000 qfnCT(qqooo) S qfnCT(qqooo,qqcoo)=""
 ..S:'$D(^Q(qviewf,qqoo,qqcco)) qfnC(qqoo,qqcco)="?" M ^Q(qviewf,qqoo,qqcco)=qfnC(qqoo,qqcco) ;@dol 21.02.03 для правильного подсчета виртуальных
 K qfnC S qqr=0 Q
 Q
]]></Implementation>
</Method>

<Method name="qFindNTest">
<Internal/>
<FormalSpec>qqcnt:%Library.String=0,qql:%Library.String,qqlang:%Library.String,qviewf:%Library.String,qlistF:%Library.String,qlistFR:%Library.String,qqr0:%Library.String=0,qNor:%Library.String=0</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ; qfnC -временный массив релевантных для текущего поддерева
 N qicond,qcond,qlist,qlistw,qqo,qqw,qqend,qqr,time,qlist1,qlist7,qlistw,qlst0,qt ;ii,qqww,qqww1,iii ;,qqow ;,$ET
 n ref s ref=$na(^mtempRel($j)) k @ref,Zpw
 S time=$H
 F qicond=1:1:$LL(qlistF) S qlst0=$LI(qlistF,qicond),qqo=$LI(qlst0,2),qqo0=$S($LI(qlst0,1)=1:qqo,1:$LI($LI($LI(qlst0,6),1),1)),qqr=qqr0 K qfnCT D @("qFindTest"_$LI(qlst0,1))
 S:$G(^Q(qviewf))="" ^Q(qviewf)=time_" "_($P($H,",",2)-$P(time,",",2)) ;дата и (через пробел) время выполнения запроса
 K qfnCT Q $D(^Q(qviewf))>1
 ;проход по дереву зкземпляров
qFindTest0 N qqcfix,qqtype S qqo=qqo0,qqtype=$LI($LI($LI(qlst0,6),1),10),cond0=$LI($LI($LI(qlst0,6),1),3),qlist1=$LI($LI($LI(qlst0,6),1),5),qlist7=$LG($LI($LI(qlst0,6),1),7) S:qlist7="" qlist7=1
 S qqcfix=$LI(qlst0,8) ;$P($$$CondFind," ",10) ;есть фиксация
 I qqtype,qqtype<3 S:$E(qqo)="v" qqo=$E(qqo,3,255),qqtype=0 ;@dol 3.07.04 для встроенных и ссылочных
 S qqc=qqcfix I qqcfix'="",qqo=$LI(qlst0,7),$LI($LI($LI(qlst0,6),1),6)=$L(qqcfix) D  Q  ;вершина фиксирована
 .I @cond0 K:0 qfnCC,qfnCP I qlist1=""||'$$qFindTestTr(qlist1,qqc,qqo),@qlist7 S @ref@(qqo,qqc)="" D qFindTestEnd ;M:qlist1'="" @refC=qfnCC D qFindTestEnd
 I 'qqtype F  S qqc=$O(^Q(qql,qqo,qqc)) Q:qqc=""||(qqcfix'=""&&($E(qqc,1,$L(qqcfix))'=qqcfix))  I @cond0 K:0 qfnCC,qfnCP I qlist1=""||'$$qFindTestTr(qlist1,qqc,qqo),@qlist7 S @ref@(qqo,qqc)="" I qqcnt,qqr'<qqcnt S qqend=1 Q  ;а виртуальные (ссылки в перечне релевантных)
 I qqtype F  S qqc=..gOrder(1,qqo,qqc,,,1) Q:qqc=""||(qqcfix'=""&&($E(qqc,1,$L(qqcfix))'=qqcfix))   I @cond0 K:0 qfnCC,qfnCP I qlist1=""||'$$qFindTestTr(qlist1,qqc,qqo),@qlist7 S @ref@(qqo,qqc)="" I qqcnt,qqr'<qqcnt S qqend=1 Q
 D qFindTestEnd Q
 ;проход по словарю  (вершина прохода совпадает с вершиной поискового образа)
qFindTest1 N qqla,qqzb,qqcfix,qqzb0 S qqcfix=$LI(qlst0,8),qqw=$LI(qlst0,4),qlistw=$LI(qlst0,5),qlist1=$LI(qlst0,6),qqla=1,qlist7=$S(qlist1="":"",1:$LG($LI(qlist1,1),7)) S:qlist7="" qlist7=1 I qqlang'=1,$D(^Q(qqlang,qqw)) S qqla=qqlang ;есть иностранный словарь
 S qqend=0 F qqwii=1:1:$LL(qlistw) S qqzb=$LI($LI(qlistw,qqwii),2),condC=$LI($LI(qlistw,qqwii),5) D  Q:qqend
 .I '$LI($LI(qlistw,qqwii)) D qFindTest1c Q:'qNor||(qqzb'=$ZCVT(qqzb,"U"))  Q:qqzb=$ZCVT(qqzb,"L")  S qqzb=$ZCVT(qqzb,"L") D qFindTest1c Q:qqend||($L(qqzb)=1)  S qqzb=$ZCVT($E(qqzb),"U")_$E(qqzb,2,3000) D qFindTest1c Q  ;проход по конкретному слову
 .S qqze=$LI($LI(qlistw,qqwii),3),condZ=$LI($LI(qlistw,qqwii),4)
 .I $LI($LI(qlistw,qqwii))=2 D  Q  ;проход по вторичному индексу
 ..S qqzb="" F  S qqzb=$O(^Qi(qqw,qqze,qqzb)) Q:qqzb=""  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFindTest1c Q:qqend
 .I qqze'="" S qqze=$S(qqze=+qqze:qqze+1E-16,1:qqze_$C(255,255,255,255)) I qNor,qqzb=$ZCVT(qqzb,"U"),qqzb=""||(qqzb=$ZCVT(qqzb,"L")) S qqze=$ZCVT(Z,"L") ;не дальше яяяя
 .S qqzb0=qqzb I qqzb'="" D qFindTest1c Q:qqend  I 'qNor,qqzb=$ZCVT(qqzb,"U"),qqzb'=$ZCVT(qqzb,"L")  S qqzb=$ZCVT(qqzb,"L") D qFindTest1c Q:qqend  I $L(qqzb)'=1 S qqzb=$ZCVT($E(qqzb),"U")_$E(qqzb,2,3000) D qFindTest1c Q:qqend
 .S qqzb=qqzb0 F  S qqzb=$O(^Q(qqla,qqw,qqzb)) Q:qqzb=""||(qqze'=""&&(qqzb]]qqze))  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFindTest1c Q:qqend
 .Q:'qNor||qqend||(qqze="")||(qqzb0="")||(qqzb0'=$ZCVT(qqzb0,"U"))||(qqzb0=$ZCVT(qqzb0,"L"))
 .S qqzb=$ZCVT(qqzb0,"L"),qqze=$ZCVT(qqze,"L")
 .F  S qqzb=$O(^Q(qqla,qqw,qqzb)) Q:qqzb=""||(qqze'=""&&(qqzb]]qqze))  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFindTest1c Q:qqend
 .Q:qqend||($L(qqzb)=1)  S qqzb=$ZCVT($E(qqzb0),"U")_$ZCVT($E(qqzb0,2,3000),"L"),qqze=$ZCVT($E(qqze),"U")_$E(qqze,2,3000)
 .F  S qqzb=$O(^Q(qqla,qqw,qqzb)) Q:qqzb=""||(qqze'=""&&(qqzb]]qqze))  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFindTest1c Q:qqend
 D qFindTestEnd Q
qFindTest1c S qqc=qqcfix,qqz=$S($E(qqw)="C":$G(^Q(1,qqw,qqzb),"???"),qqla=1:qqzb,1:$G(^Q(1,"C"_qqw,$G(^Q(qqla,qqw,qqzb),"???")),"???")) I $E(qqw)="C" S qqend=qqw N qqw S qqw=$E(qqend,2,255) 
 F  S qqc=$O(^Q(1,qqw,qqz,qqo,qqc)) Q:qqc=""||(qqcfix'=""&&($E(qqc,1,$L(qqcfix))'=qqcfix))   I @condC K:0 qfnCC,qfnCP I qlist1=""||'$$qFindTestTr(qlist1,qqc,qqo),@qlist7 S @ref@(qqo,qqc)="" I qqcnt,qqr'<qqcnt S qqend=1 Q  ;а виртуальные (ссылки в перечне релевантных)
 Q
 ;проход по словарю
qFindTest2 N qqla,qqzb,qqze,qqcfix,cond00,qqof,qqopcond,qqzb0,qqopcnd0 S qqcfix=$LI($LI(qlistF,qicond),8),cond0=$LI($LI($LI($LI(qlistF,qicond),6),1),3),qqopcnd0=$LI($LI($LI($LI(qlistF,qicond),6),1),8),qlist1=$LI($LI($LI($LI(qlistF,qicond),6),1),5),qqcL=$LI($LI($LI($LI(qlistF,qicond),6),1),6),qqw=$LI($LI(qlistF,qicond),4),qlistw=$LI($LI(qlistF,qicond),5),qqla=1,qlist7=$LG($LI($LI($LI(qlistF,qicond),6),1),7) S:qlist7="" qlist7=1
 I qqlang'=1,$D(^Q(qqlang,qqw)) S qqla=qqlang ;есть иностранный словарь
 S qqend=0 F qqwii=1:1:$LL(qlistw) S qqzb=$LI($LI(qlistw,qqwii),2),condC=$LI($LI(qlistw,qqwii),5) D  Q:qqend
 .I '$LI($LI(qlistw,qqwii)) D qFindTest2c Q:'qNor||(qqzb'=$ZCVT(qqzb,"U"))  Q:qqzb=$ZCVT(qqzb,"L")  S qqzb=$ZCVT(qqzb,"L") D qFindTest2c Q:qqend||($L(qqzb)=1)  S qqzb=$ZCVT($E(qqzb),"U")_$E(qqzb,2,3000) D qFindTest2c Q  ;проход по конкретному слову
 .S qqze=$LI($LI(qlistw,qqwii),3),condZ=$LI($LI(qlistw,qqwii),4)
 .I $LI($LI(qlistw,qqwii))=2 D  Q  ;проход по вторичному индексу
 ..S qqzb="" F  S qqzb=$O(^Qi(qqw,qqze,qqzb)) Q:qqzb=""  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFindTest2c Q:qqend
 .I qqze'="" S qqze=$S(qqze=+qqze:qqze+1E-16,1:qqze_$C(255,255,255,255))  I qNor,qqzb=$ZCVT(qqzb,"U"),qqzb=""||(qqzb=$ZCVT(qqzb,"L")) S qqze=$ZCVT(Z,"L") ;не дальше яяяя
 .S qqzb0=qqzb I qqzb'="" D qFindTest2c Q:qqend  I 'qNor,qqzb=$ZCVT(qqzb,"U"),qqzb'=$ZCVT(qqzb,"L")  S qqzb=$ZCVT(qqzb,"L") D qFindTest2c Q:qqend  I $L(qqzb)'=1 S qqzb=$ZCVT($E(qqzb),"U")_$E(qqzb,2,3000) D qFindTest2c Q:qqend
 .S qqzb=qqzb0 F  S qqzb=$O(^Q(qqla,qqw,qqzb)) Q:qqzb=""||(qqze'=""&&(qqzb]]qqze))  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFindTest2c Q:qqend
 .Q:'qNor||qqend||(qqze="")||(qqzb0="")||(qqzb0'=$ZCVT(qqzb0,"U"))||(qqzb0=$ZCVT(qqzb0,"L"))
 .S qqzb=$ZCVT(qqzb0,"L"),qqze=$ZCVT(qqze,"L")
 .F  S qqzb=$O(^Q(qqla,qqw,qqzb)) Q:qqzb=""||(qqze'=""&&(qqzb]]qqze))  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFindTest2c Q:qqend
 .Q:qqend||($L(qqzb)=1)  S qqzb=$ZCVT($E(qqzb0),"U")_$ZCVT($E(qqzb0,2,3000),"L"),qqze=$ZCVT($E(qqze),"U")_$E(qqze,2,3000)
 .F  S qqzb=$O(^Q(qqla,qqw,qqzb)) Q:qqzb=""||(qqze'=""&&(qqzb]]qqze))  S Z=qqzb S:qNor Z=$ZCVT(Z,"U") I @condZ D qFindTest2c Q:qqend
 D qFindTestEnd Q
qFindTest2c S qqof=qqo,qqc=qqcfix,qqz=$S($E(qqw)="C":$G(^Q(1,qqw,qqzb),"???"),qqla=1:qqzb,1:$G(^Q(1,"C"_qqw,$G(^Q(qqla,qqw,qqzb),"???")),"???")) I $E(qqw)="C" S qqend=qqw N qqw S qqw=$E(qqend,2,255)
 F  S qqc=$O(^Q(1,qqw,qqz,qqo,qqc)) Q:qqc=""||(qqcfix'=""&&($E(qqc,1,$L(qqcfix))'=qqcfix))   K:0 qfnCP I $E(qqw)'="W"||('$D(@ref@(qqo,qqc))),@condC D  I qqcnt,qqr'<qqcnt S qqend=1 Q  ;перечень релевантных надо проверить??? если понятие W
 .K:0 qfnCC S qfnCC=qqc N qqc,qqo S qqc=$E(qfnCC,1,qqcL),qqo=qqo0 I @cond0,@qqopcnd0 D  ;@dol 29.07.04 qqopcnd0
 ..S cond00=1 I $LL(qlist1)=1,$LI($LI(qlist1),2)'=-1,qlist7=1 S qqZN=qlist1,@ref@(qqo,qqc)="" N qlist1 S qlist1=qqZN F  S qlist1=$LI(qlist1),qqo=$LI(qlist1),qqc=$E(qfnCC,1,$LI(qlist1,6)),cond00=$LI(qlist1,3),qqopcond=$LI(qlist1,8),qlist1=$LI(qlist1,5) Q:qqo=qqof  D:'$D(@ref@(qqo,qqc))  Q:'cond00||(qlist1="")||($LL(qlist1)>1)  S @ref@(qqo,qqc)=""  ;чтобы безтолку не перебирать объекты верхних уровней
 ...I @qqopcond,@cond00 S cond00=1 Q
 ...S cond00=0
 ..I qqo'=qqof,'cond00 Q
 ..I qlist1=""||'$$qFindTestTr(qlist1,qqc,qqo),@qlist7 S @ref@(qqo,qqc)="" ;а виртуальные (ссылки в перечне релевантных)
 Q
 ;проверка поддерева (хотя бы одна ветьвь должна быть)
 ;qqltr - вложенные_списки_объектов = $LB(код_объекта, тип_обхода, условия,$LB(вложенные_списки_объектов,...))
 ;@Dol 30.11.04 qqc0 заменено на qqcc0 т.к. оно может встретится в условиях вывод
qFindTestTr(qqltr,qqcc0,qqom)   N qqend0,qqltr1,qqend,qqco,qqci,qqend,qqo,qqc,qqli,qqci,qqofr,qorder,qqopcond,qqAn,qqtype,qqc0  ;S qqend=0,qqoo=$P(qqobtr,",",$L(qqobtr,",")-1),qqco=qqc0
 S qqend=0 F qqli=1:1:$LL(qqltr) S:$G(qA) qqAn=$LI($LI(qqltr,qqli),9) S qqtype=$LI($LI(qqltr,qqli),10),qqo=$LI($LI(qqltr,qqli),1),qorder=$LI($LI(qqltr,qqli),2),qqopcond=$LI($LI(qqltr,qqli),8),qqco=$LI($LI(qqltr,qqli),3),qqltr1=$LI($LI(qqltr,qqli),5),qqofr=$LI($LI(qqltr,qqli),4) D  Q:qqend
 .S qqend0=1 I 'qqtype S qqc=$S(qorder'=-1:qqcc0,1:qqcc0_"я") F qqci=0:1 S qqc=$O(^Q(qql,qqo,qqc),qorder) Q:$E(qqc,1,$L(qqcc0))'=qqcc0  I @qqopcond D  Q:qorder=-1  ;Q:qorder=-1 - последний экземляр означает и единственный
 ..I @qqco,qqltr1=""||'$$qFindTestTr(qqltr1,qqc,qqo) S @ref@(qqo,qqc)="",qqend0=0
 .I qqtype S qqc="" F qqci=0:1 S qqc=..gOrder(qorder,qqo,qqc,qqcc0,,1) Q:qqc=""   D  Q:qorder=-1  ;I @qqopcond D  Q:qorder=-1  ;@Dol 30.11.04 @qqopcond - проверка постоянных условий не нужна - есть в gOrder
 ..I @qqco,qqltr1=""||'$$qFindTestTr(qqltr1,qqc,qqo) S @ref@(qqo,qqc)="",@ref@(qqom,qqcc0,qqo,qqc)="",qqend0=0 ;,qfnCC(qqom,qqc0)="" ;@dol 21.02.03 qfnCC(qqom,qqc0)=""
 .I qqend0 Q:qqofr  S qqend=1 Q  ;только последний узел А постоянные условия???;@dol 25.10.03
 Q qqend
 ;.I '$D(qfnCC(qqo)) Q:qqofr  S qqend=1 Q  ;только последний узел А постоянные условия???
 ;
qFindTestEnd S qqoo="" F  S qqoo=$O(@ref@(qqoo)) Q:qqoo=""  S qqcco="",qqooi=0,qqoor=$LF(qlistFR,qqoo) S qqoor=$S('qqoor:"",1:$LI(qlistFR,qqoor+1)) D  i $i(@ref@(qqoo),qqooi)
 .F  S qqcco=$O(@ref@(qqoo,qqcco)) Q:qqcco=""  i $i(qqooi),qqoor'="" f qqoi=1:2:$LL(qqoor) S qqooo=$LI(qqoor,qqoi),qqcoo=$E(qqcco,1,$LI(qqoor,qqoi+1)) I $L(qqcoo)>3||'$D(qfnCT(qqooo,qqcoo)),'$D(@ref@(qqooo,qqcoo)),$I(^(qqcoo)),$I(@ref@(qqooo)) I $L(qqcoo)<4 K:$S<10000 qfnCT(qqooo) S qfnCT(qqooo,qqcoo)=""
 S qqr=0 Q
 Q
]]></Implementation>
</Method>

<Method name="qFindNew">
<Internal/>
<FormalSpec>qqmod:%Library.String=0,qqcnt:%Library.String,qqolst:%Library.String,qA:%Library.String=0</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 N qviewf,qqr,Cond,qFindDO ;ii,qqww,qqww1,iii ;,qqow ;,$ET
 S qFindDO=1 ;используется как флаг (для вычисления значений ZTMP*-понятий в методе ..G)
 S qqcnt=+$G(qqcnt)
 Q:qview="" 1/0 ;на всякий случай, иначе катастрофа
 I $$$ReFind N qql S qql=$$$Relind_qview,$$$Relind='$$$Relind,Cond=0 K ^Q($$$Relind_qview) I 1
 E  S Cond=$G(Vt(qqnump,0)) ;если уточнение, пстоянные условия проверять не надо (???)
 S qviewf=$$$Relind_qview ;ссылка на перечень релевантных
 N VVs M VVs=Vs(qqnump,8)
 S qqr=..qFindList(Cond,+$G(qqmod),$G(qqolst))
 K Vs(qqnump,8) M Vs(qqnump,8)=VVs
 I qqr'="" S:$$$ReFind $$$Relind='$$$Relind Q qqr
 S qqr=..qFindN(qqcnt,qql,qqlang,qviewf,qlistF,qlistFR) I 'qqr,$$$ReFind S $$$Relind='$$$Relind
 Q qqr
]]></Implementation>
</Method>

<Method name="qFonFindErr">
<Internal/>
<ClassMethod>1</ClassMethod>
<Language>cache</Language>
<Implementation><![CDATA[
 s xxxmax=$st(-1) I $G(qERR) Q:$st>1&$Q "" Q:$st>1  S $EC="" K qERR Q:$Q "" Q
 S xxxstr="" f xxxi=1:1:xxxmax-1 S xxxstr=xxxstr_$C(13,10)_$P($st(xxxi,"place"),"ooLibrary.")_$P($st(xxxi,"place"),"ooLibrary.",2)_" "_$P($st(xxxi,"mcode")," ",2,30000) ;S:$st(xxxi,"ecode")'="" xxxstr=xxxstr_"***> "_$st(xxxi,"ecode")
 S ^Q(qviewf)=$E($P($ZE,">"),2,255)_" GloRef="_xxxZR_$C(13,10)_"qqo="_$G(qqo)_" qqc="_$G(qqc)_" qqw="_$G(qqw)_" qqz="_$G(qqz)_$C(13,10)_xxxstr S qERR=xxxmax
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="qGrabCol">
<Description>
Выполняет сборку мусора в прямых словарях понятий.
Список понятий определяется параметрами qqwlst и qqw (см. описание параметров).
НО вне зависимости от списка понятий, сборка мусора НЕ ВЫПОЛНЯЕТСЯ для следующих типов:
- системные понятия;
- понятия, у которых значение реквизита "%Сборка мусора" равно "запрещена".
Если код понятия начинается на R или C (ссылочные понятия), то системность понятия и "%Сборка мусора" определяется по основному понятию (см. метод).

Параметры:
qqwlist - список понятий (через пробел), для которых нужно выполнить сборку мусора;
wwww - не используется; оставлен для совместимости со старыми версиями;
qqw     - код понятия, от которого начать сборку мусора для всех нижележащих понятий (обход идет по ^Q(1,CxWoc)); для понятия qqw сборка мусора НЕ ВЫПОЛНЯЕТСЯ;
svref   - ссылка на массив, в который будут записываться удаленные значения для каждого понятия; если равен "", то запись не ведется

Если определен параметр qqw (не равен ""), то значение параметра qqwlist игнорируется.
Если qqwlst и qqw равны "", то сборка мусора выполняется для всех понятий.

Если сборка мусора выполнялась по qqwlst, то результат работы метода возвращается в виде строки:
qqw1: num1/del1 ... qqwN: numN/delN, где qqw1,...,qqwN - код понятия из списка qqwlst; num - число обработанных значений понятия; del - число удаленных значений понятия

Если определен svref, то перед записью значений выполняется команда "k @svref".
Для каждого понятия, для которого идет сборка мусора, формируются следующие узлы:
- @svref@(код_понятия, "num") - число обработанных значений
- @svref@(код_понятия, "del") - число удаленных значений
- @svref@(код_понятия, "ex",код_значения)=значение
- @svref@(код_понятия, "qqwlst")=список ссылочных понятий (на R*) (включая само понятие) - заполняется только в том случае, если x711 ("%Организация словаря") для понятия равна 1.</Description>
<Internal/>
<FormalSpec>qqwlst:%String,wwww:%String,qqw:%String,svref:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 n ref,$ET,qqwn,qqwd,val,code,qqo,qqc,flag,i,iL,iW,reflst,qt,valex s $ET="S $EC="""" Q:$Q $ZE Q"
 s qqw=$g(qqw),ref=$na(^mtempqSYS("tmp",$j,$o(^mtempqSYS("tmp",$j,""),-1)+1)) k @ref s @ref=""
 s svref=$g(svref) k:svref'="" @svref
 i qqw'=""||($g(qqwlst)="") d  k @ref $$$oQuit(1,"")
 .f  s qqw=$o(^Q(1,"CxWoc",qqw)) q:qqw=""  i "@TMLXRCx"'[$e(qqw),qqw'[":",'$g(^(qqw,"Xsys")),$g(^("xGrCol"))'=2 s reflst="" d GrabColD
 n res s res="" f i=1:1:$l(qqwlst," ") s qqw=$p(qqwlst," ",i) i qqw'="","@MXLTx"'[$e(qqw),qqw'[":" s qqw=$s($e(qqw)="C":$e(qqw,2,20),$e(qqw)="R":$e(qqw,3,20),1:qqw) i "MXLTx"'[$e(qqw),'$g(^Q(1,"CxWoc",qqw,"Xsys")),$g(^("xGrCol"))'=2,'$d(@ref@(qqw)) s reflst="" d GrabColD s res=res_" "_qqw_": "_qqwn_"/"_qqwd
 k @ref $$$oQuit(1,res)
GrabColD s val="",qqwd=0 f qqwn=0:1 s val=$o(^Q(1,qqw,val)) q:val=""  s flag=0 d  i flag,$i(qqwd) s:svref'="" @svref@(qqw,"ex",code)=val
 .s code=^(val) d GrabColC q:flag
 .s qqo="" f  s qqo=$o(^Q(1,qqw,val,qqo)) q:qqo=""  d:..rWocx711(qqw,qqo)
 ..d:'$g(@ref@(qqw,0,qqo))  q:$g(@ref@(qqw,1,code,qqo))  k ^Q(1,qqw,val,qqo)
 ...s:$g(reflst)="" reflst=..rWocRefLst(qqw)
 ...s @ref@(qqw,0,qqo)=1 s qqc="" f  s qqc=$o(^Q(1,qqo,qqc)) q:qqc=""  f iW=1:1:$l(reflst," ") s valex=$g(^(qqc,$p(reflst," ",iW))) d:valex'=""
 ....f qt=1:1:$l(valex," ")  s:$p(valex," ",qt)'="" @ref@(qqw,1,$p(valex," ",qt),qqo)=1
 .d GrabColC
 s:svref'="" @svref@(qqw,"qqwlst")=reflst,@svref@(qqw,"num")=qqwn,@svref@(qqw,"del")=qqwd
 i $e(qqw)'="D" s ^Q(1,"C"_qqw)=qqwn-qqwd s:$d(^Q(1,qqw))=1 ^Q(1,qqw)="" q
 s ^Q(1,qqw)=$s((qqwn-qqwd):qqwn-qqwd,1:"")
 q
GrabColC i $d(^Q(1,qqw,val))=1,$i(flag) k ^(val) i $e(qqw)'="D"  k ^Q(1,"C"_qqw,code) d:$g(qqllang)'=""
 .f iL=1:1:$l(qqllang," ") i $p(qqllang," ",iL)'="",$d(^Q($p(qqllang," ",iL),"C"_qqw,code)) k:^(code)'="" ^Q($p(qqllang," ",iL),qqw,^(code)) k ^Q($p(qqllang," ",iL),"C"_qqw,code)
 q
]]></Implementation>
</Method>

<Method name="qObjConv">
<Description>
Преобразование экземпляров объекта qqo.
Вызывается из меню Администратор-Преобразование для текущего объекта.
Прееобразуются значения понятий по выражениям аналитик.
затем rCor.
В методе qqc - текущий код, qqo - текущий объект. Измененные значения понятий должны
содержаться в W(код_понятия). qqc не должно изменяться в методе.
Arg1=1 - преобразование всех объектов отображения
Arg1=2 - последовательный проход по всем экземплярам каждого объекта

Arg2=1 - не выводить сообщение

Arg3=1 - если Arg1=1 - преобразовывать и понятия хранимых объектов</Description>
<Internal/>
<FormalSpec>qqo:%String,qqonew:%Library.String,Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N $ET,ErrOr S $ET="D qObjConve Q:$Q """" Q  "
 N qqftime S qqftime=$P($H,",",2) I $G(Arg1),$D(Vt(qqnump,111)) G qObjConvAll:Arg1=1,qObjConvAllp
 I $$$Tree D:'$G(Arg2) qARM.Message("Только для логического дерева") Q ""
 I $G(qqo)="",'$G(Arg1) S qqo=$$$CurObj
 ;;;D qARM.wP("-qARM","Cursor",-11)
 N qqnum,qqnumc,qqc,qqd,qqwchg,qqwchgall,qqw S qqnumc=0 I $$$ReFind N qql S qql=$$$Relind_qview
 I $G(qqo)'="" G:$G(Vo(qqnump,qqo,2))>1 qObjConvVir D qObjConvO S qqftime=$P($H,",",2)-qqftime D:'$G(Arg2) qARM.Message("За "_(qqftime\60)_":"_$E(qqftime#60+100,2,3)_" Обработано/преобразовано: "_$G(qqnum)_"/"_$G(qqnumc)_$S($G(qqwchgall)="":"",1:" собран мусор:"_..qGrabCol(qqwchgall))) Q ""
 S qqo="" F  S qqo=$O(Vs(qqnump,12,qqo)) Q:qqo=""  D qObjConvO
 G qObjConvVirEnd
 ;
qObjConvO S qqc="" F qqnum=0:1 S qqc=$O(^Q(qql,$S($E(qqo)'="v":qqo,1:$E(qqo,3,255)),qqc)) Q:qqc=""  D  Q:$D(ErrOr)
 .S qqwchg="" D  I qqwchg'="",$I(qqnumc) S qqwchgall=qqwchg D ..rCor(qqo,qqc,qqwchg)
 ..S qqw="" F  S qqw=$O(Vs(qqnump,12,qqo,qqw)) Q:qqw=""  S Z1=$G(Vs(qqnump,12,qqo,qqw,2)),Z2=$G(Vs(qqnump,12,qqo,qqw,1)) I Z1'=""||(Z2'=""),$S(Z2'="":1,1:Z1'="-"),$E(qqw)'="@",qqw'[":" S (W(qqw),Z)=..G(qqw) S:Z1'=""&(Z1'="-") @("Z="_Z1) X:Z2'="" Z2 I Z1'="-",Z'=W(qqw) S W(qqw)=Z,qqwchg=qqwchg_" "_qqw ;@dol 30.12.03 qARM.Value(Z1)
 Q
qObjConve D qARM.Message("Ошибка "_$ZE) S ErrOr=1,$EC="" Q
 ;преопразование виртуальных в хранимые
qObjConvVir
 N qqob,qqcv,qqo0,qqc0 S qqob=$$$ObjRef(qqo) S:$G(qqonew)="" qqonew=qqo
 I qqob=qqo D  G qObjConvVirEnd
 .S qqc="",qqcv="" F  S qqc=..gOrder(1,qqo,qqc,"") Q:qqc=""  D qObjConvVirDo
 S qqo0=$P(qqob,",",$L(qqob,",")-1) I $G(Vo(qqnump,qqo0,2)) D qARM.Message("Не потомок хранимого объекта") Q ""
 S qqc0="" F  S qqc0=$O(^Q(qql,qqo0,qqc0)) Q:qqc0=""  S qqc="",qqcv=qqc0 F  S qqc=..gOrder(1,qqo,qqc,qqc0) Q:qqc=""  D qObjConvVirDo
qObjConvVirEnd S qqftime=$P($H,",",2)-qqftime D:'$G(Arg2) qARM.Message("За "_(qqftime\60)_":"_$E(qqftime#60+100,2,3)_" Преобразовано: "_$G(qqnumc)) d:($g(%qGWcon)=1)&&('$G(Arg2)) qW.SQLClose(sqlcon(qqnump)) Q:$Q "" Q
qObjConvVirDo I qqo=qqonew,$E(qqo)="v" N qqonew S qqonew=$E(qqo,3,2555) ;@dol 23.08.03
 S qqwchg="" D  I $S($G(Vo(qqnump,qqonew,2))>2:$I(qqnumc),qqwchg'="":$I(qqnumc),1:1) S qqcv=$S($G(Vo(qqnump,qqonew,2))<3:qqc,$G(Vo(qqnump,qqonew,0))'=255:$P(..rNew(qqonew,qqcv,,,1)," "),1:qqcv0_..G(Vo(qqnump,qqo,22))) I qqwchg'="" D ..rCor(qqonew,qqcv,qqwchg,,,,1) ;@dol 23.07.03 rNew, rCor добавлен NoVir=1;;@Dol 22.03.06 $G(Vo(qqnump,qqonew,2))
 .I $G(Vo(qqnump,qqo,2))=8 S qqcv=qqc,W("X")=..G("X"),W("Xc")=..G("Xc"),qqwchg=qqwchg_" X Xc"
 .S qqw="" F  S qqw=$O(Vo(qqnump,qqo,11,qqw)) Q:qqw=""  S Z1=$G(Vs(qqnump,12,qqo,qqw,2)) I Z1'="-",$E(qqw)'="@",qqw'="C",qqw'[":" S (W(qqw),Z)=..G(qqw) S:Z1'=""&(Z1'="-") @("Z="_Z1) X:$G(Vs(qqnump,12,qqo,qqw,1))'="" Vs(qqnump,12,qqo,qqw,1) I Z'=""||("YT"[$E(qqw)) S W(qqw)=Z,qqwchg=qqwchg_" "_qqw ;@dol 30.12.03 Value(
 Q
qObjConvAll ;обход всего отображения (только для виртуальныx)
 N qqcv,qqw,qqwchg,qqnumc
 I 'qW.GG("XBase","XFSQLcon",0)     D qObjConvA(-1,"","") G qObjConvVirEnd
 F qqConList=1:1:$L(qW.GG("XBase","XSQLcon",0)," ") K Vt(qqnump,"sql") D qObjConvA(-1,"","")
 G qObjConvVirEnd
qObjConvA(qqolist,qqc0,qqcv0)
 S:'$D(Vo(qqnump,qqolist,"xObj")) Vo(qqnump,qqolist,"xObj")=$G(^Q(1,"XView",Vo(qqnump),"CxObj",qqolist,"xObj")) S qqolist=Vo(qqnump,qqolist,"xObj") Q:qqolist=""
 N qqc,qqo,qqonew,qqoi,qqcv F qqoi=1:1:$L(qqolist," ") S (qqonew,qqo)=$P(qqolist," ",qqoi),qqc="",qqcv=qqcv0 F  S qqc=..gOrder(1,qqo,qqc,qqc0) Q:qqc=""  D  D qObjConvA(qqo,qqc,qqcv)
 .I $G(Vo(qqnump,qqo,2))>1||$G(Arg3) D qObjConvVirDo Q
 .S qqcv=qqc
 Q
qObjConvAllp ;последовательный обход всего отображения(только для виртуальных)
 N qqcv,qqw,qqwchg,qqnumc K ^Qerr
 I 'qW.GG("XBase","XFSQLcon",0)     D qObjConvAp(-1,"","") G qObjConvVirEnd
 F qqConList=1:1:$L(qW.GG("XBase","XSQLcon",0)," ") K Vt(qqnump,"sql") D qObjConvAp(-1,"","")
 G qObjConvVirEnd
qObjConvAp(qqoo,qqc0,qqcv0)
 N qqolist,qsor,qnextb
 S:'$D(Vo(qqnump,qqoo,"xObj")) Vo(qqnump,qqoo,"xObj")=$G(^Q(1,"XView",Vo(qqnump),"CxObj",qqoo,"xObj")) S qqolist=Vo(qqnump,qqoo,"xObj") Q:qqolist=""
 N qqc,qqo,qqonew,qqoi,qqcv,qqoox,v0,v1,v2,v3 S qqoox=$S($E(qqoo)'="v":qqoo,1:$E(qqoo,3,255)) F qqoi=1:1:$L(qqolist," ") D
 .S (qqonew,qqo)=$P(qqolist," ",qqoi),qqc="",qqcv="" Q:qqo=""
 .I $G(Vo(qqnump,qqo,2))>1 S v0=$G(Vt(qqnump,529,qqo,qqoo))'="" S:v0 v1=$P($P(Vt(qqnump,529,qqo,qqoo),";",2),","),v2=$P($P(Vt(qqnump,529,qqo,qqoo),";",1),","),v1=$S(v1="":v2,1:v1) S:'v0 v1=$P($G(Vo(qqnump,qqo,29)),";;",2,255) S qsor=qARM.GetPar("X538",,qqo),qnextb=0 F  S qqc=..gOrder(1,qqo,qqc,"",qsor) Q:qqc=""  D  ; S qsor=$G(Vo(qqnump,$$$CurObj,38)) ;@dol 19.08.04 v1<->v2
 ..I qqoo'=-1 D  I qqcv="" S ^Qerr($I(^Qerr))="Не найдена вершина для qqo="_qqo M ^Qerr(^Qerr)=Vs(qqnump,"Virt",qqo) Q
 ...I v0 S qqcv=..FastKey(qqoox,v1,"",1,v2,,qqo,qqc) Q  ;S qqcv=qW.Key(qqoox,v1,"","",1,1,qqo,qqc,v2) Q
 ...X:v1'="" v1
 ..D qObjConvVirDo
 .D qObjConvAp(qqo,qqc,qqcv)
 Q
 ;;;;старый текст
 N qqolist
 S:'$D(Vo(qqnump,qqoo,"xObj")) Vo(qqnump,qqoo,"xObj")=$G(^Q(1,"XView",Vo(qqnump),"CxObj",qqoo,"xObj")) S qqolist=Vo(qqnump,qqoo,"xObj") Q:qqolist=""
 N qqc,qqo,qqonew,qqoi,qqcv F qqoi=1:1:$L(qqolist," ") D
 .S (qqonew,qqo)=$P(qqolist," ",qqoi),qqc="",qqcv="" Q:qqo=""
 .I $G(Vo(qqnump,qqo,2))>1 F  S qqc=..gOrder(1,qqo,qqc,"") Q:qqc=""  D
 ..I qqoo'=-1,$G(Vt(qqnump,529,qqo,qqoo))'="" S qqcv=qW.Key($S($E(qqoo)'="v":qqoo,1:$E(qqoo,3,255)),$P(Vt(qqnump,529,qqo,qqoo),";",1),"","",1,1,qqo,qqc,$P(Vt(qqnump,529,qqo,qqoo),";",2)) I qqcv="" S ^Qerr($I(^Qerr))="Не найдена вершина для qqo="_qqo M ^Qerr(^Qerr)=Vs(qqnump,"Virt",qqo) Q
 ..I qqoo'=-1,$G(Vt(qqnump,529,qqo,qqoo))="" S qqcv=$P($G(Vo(qqnump,qqo,29)),";;",2,255) I qqcv'="" X qqcv  I qqcv="" S ^Qerr($I(^Qerr))="Не найдена вершина для qqo="_qqo M ^Qerr(^Qerr)=Vs(qqnump,"Virt",qqo) Q
 ..D qObjConvVirDo
 .D qObjConvAp(qqo,qqc,qqcv)
 Q
]]></Implementation>
</Method>

<Method name="qObjNum">
<Description>
Подсчет экземпляров объектов в базе или в перечне релевантных. Если qqo="", то всех.</Description>
<Internal/>
<FormalSpec>qqo:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qqnum,qqc S qqnum=0,qqo=$G(qqo) I $$$ReFind N qql S qql=$$$Relind_qview
 D:qqo'=""  Q:qqo'="" qqnum F  S qqo=$O(^Q(qql,qqo)) Q:qqo=""  D:"CXD"[$E(qqo)||(qqo?1.N)||$D(^Q(1,"CxObj",qqo))  ;@Dol 17.01.05 $D(
 .I qql=1 S:'$D(Vo(qqnump,qqo,247)) Vo(qqnump,qqo,247)=$G(^Q(1,"CxObj",qqo,"X5247")) D:Vo(qqnump,qqo,247)'="" ..rX5247(qqo,0) ;обнуление ;@Dol 20/03/06 счетчик поддеревьев
 .S qqc="" F qqnum=0:1 S qqc=$O(^Q(qql,qqo,qqc)) Q:qqc=""  I qql=1,Vo(qqnump,qqo,247)'="" D ..rX5247(qqo,+1,qqc)
 .S:qqnum ^Q(qql,qqo)=qqnum
 Q:$Q qqnum Q
]]></Implementation>
</Method>

<Method name="qOrd">
<Description>
$Order на общее начало с учетом чисел на общее начало. Т.е. для чисел при заданном общем начале имитируется символьная кодировка.
Для отрицательных содержащих точку может и неверно 
!!! ind может быть пусто, или значение на общее начало (!!!). Нельзя qW.qOrd($NA(^Q(1,"pB"),"bb","a")</Description>
<Internal/>
<FormalSpec>refer:%String,ind:%String,ind0:%String,direct:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:'$G(direct) direct=1 I $G(ind0)="" Q $O(@refer@(ind),direct)
 ;D qARM.Message(qqcc_">"_$G(direct)_">"_ind0_">"_ind)
 I $S(ind0=+ind0:0,$TR(ind0,"-.0123456789")'="":1,$E(ind0)=0:1,$E(ind0,1,2)="-0":1,1:".-0"'[$E(ind0,$L(ind0))) Q:ind=""&&(direct=1)&&$D(@refer@(ind0)) ind0 S:ind="" ind=ind0_$S(direct=1:"",1:$C(255,255,255,255,255,255,255)) S ind=$O(@refer@(ind),direct) Q:$E(ind,1,$L(ind0))=ind0 ind Q "" ///нечисловая общая часть;15.06.10 $E(ind0)=0:1,
 N itest,indi,ind00 S indi=ind I direct=1 Q:ind=""&&(ind0=+ind0)&&$D(@refer@(ind0)) ind0 S:ind="" indi=$S($E(ind0)="-":$S(ind0'[".":"",1:ind0_99999999999),ind0=+ind0:ind0,1:ind0+.00000000000000001) S indi=$O(@refer@(indi),direct) Q:indi="" "" Q:$E(indi,1,$L(ind0))=ind0 indi D  Q indi
 .I $E(ind0)="-",ind=+ind,$E(indi)'="-" S indi="" Q
 .I ind0[".",indi'=+indi,ind'=ind S indi="" Q
 .I indi=+indi  D  Q:indi=""  Q:$E(indi,1,$L(ind0))=ind0
 ..F itest=1:1:20 D  D:0 qARM.Message(ind_"*"_indi_"*"_ind00) S indi=ind00 Q:$D(@refer@(ind00))  S indi=$O(@refer@(ind00),direct) Q:$E(indi,1,$L(ind0))=ind0  Q:indi'=+indi
 ...I $E(ind0)'="-" S ind00=ind0_$TR($J("",$L($P(indi,"."))-$L(ind0))," ","0") S:indi>ind00 ind00=ind00_0 Q
 ...I $E(indi)'="-" S ind00=$C(0) Q
 ...S ind00=ind0_$TR($J("",$L($P(indi,"."))-$L(ind0))," ","9") S:indi>ind00 ind00=$E(ind00,1,$L(ind00)-1)
 .S:ind=+ind||(ind="") ind=ind0 S indi=$O(@refer@(ind_$C(0)),direct) S:$E(indi,1,$L(ind0))'=ind0 indi="" Q  ;@Dol 24.08.09 :ind=+ind||(ind="")
 S indi=ind S:ind="" indi=ind0_$C(255,255,255,255,255,255,255) S indi=$O(@refer@(indi),direct) Q:indi="" "" Q:$E(indi,1,$L(ind0))=ind0 indi I ind=+ind,$E(ind0)'="-",indi<ind0 Q ""
 I indi'=+indi||($E(ind0)="-"&&($E(indi)'="-")) S indi=$O(@refer@($S($E(ind0)'="-":$C(0),1:ind0-.00000000000000001)),direct)  Q:indi="" "" Q:$E(indi,1,$L(ind0))=ind0 indi I $E(ind0)'="-",indi<ind0 Q ""
 I ind0["." Q:ind'="" "" S indi=$S(ind0=+ind0:ind0,1:ind0+.00000000000000001) S indi=$O(@refer@(indi),direct) Q:$E(indi,1,$L(ind0))=ind0 indi Q ""
 F itest=1:1:20 D  S indi=ind00 Q:$D(@refer@(ind00))  S indi=$O(@refer@(ind00),direct) D:0 qARM.Message(ind_"*"_ind00_"*"_indi) Q:indi=""  Q:$E(indi,1,$L(ind0))=ind0  I $E(ind0)'="-",indi<ind0 Q  ;@Dol 07.05.09 D  Q:ind0=ind00&&($E(ind0)'="-")
 .I $E(ind0)'="-" S ind00=ind0_$TR($J("",$L($P(indi,"."))-$L(ind0))," ",9) Q:ind0=ind00  S:ind00>indi ind00=$E(ind00,1,$L(ind00)-1) Q
 .S ind00=ind0_$TR($J("",$L($P(indi,"."))-$L(ind0))," ",0)  S:ind00>indi ind00=ind00_0 ;$E(ind00,1,$L(ind00)-1)
 Q:$E(indi,1,$L(ind0))=ind0 indi Q ""
]]></Implementation>
</Method>

<Method name="qRef">
<Description>
Восстановить ссылку W("Zref") по  qqci (соответствует W("Zrol",1)).</Description>
<Internal/>
<FormalSpec>qqci:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qi S $$$GloRef=$S($G($$$GloRef)'="":$NA(@$$$GloRef,1),1:$NA(^Q(qql))) F qi=2:2:$L(qqci)-2 S $$$GloRef=$NA(@$$$GloRef@(Vc(qqnump,$E(qqci,1,qi),0),Vc(qqnump,$E(qqci,1,qi))))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="qWoc">
<Description>
gorw()  ;
;qqpar5=1 - заполнять W(qqw),W("C"_qqw)
;qqpar6'="" - заполнять массив @qqpar6
;qqpar6="Zldrl" - заполнять W("Zldrl"). Вместо пробела - ~</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String,qqpar3:%String,qqpar4:%String,qqpar5:%String,qqpar6:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    /*
    15.12.2008 Kokarev - явное имя ^CacheTemp заменено на макрос $$$tmpGl
    */
 ;много лишнего. Нужно разобраться
 N j,qq6Z,ID,$ET S $ET="S Z=$E($P($ZE,"">""),2,20),$EC="""" Q:$Q Z Q",qqZN=$G(qqw) N qqw S qqw=qqZN S qorder=qqpar1,qqpar3=$G(qqpar3,1),qqpar6=$G(qqpar6) I qqpar6'="" D
 .I qqpar6="Zldrl" K W("Zldrl") S W("Zldrl")="" Q
 .K @qqpar6 S:$P(qqpar2," ",1)="VGindex" qq6Z=$G(W(qqw))
 S qqqq1=$P(qqpar2," ",2),Z=$S(qqqq1="*":$G(W(qqw)),1:qqqq1)
 S qqqq1=$P(qqpar2," ",1),qqw=$S(qqqq1="*"!(qqqq1=""):$G(qqw),1:qqqq1),qqpar5=$S('$G(qqpar5):"",$E(qqw)="C":$E(qqw,2,25)_" "_qqw,1:qqw_" C"_qqw)
 I Z'="" D  
 .I Z=+Z S Z=Z-1 Q
 .S Z=$E(Z,1,$L(Z)-1)_$C($A(Z,$L(Z))-1)_"я" ;чтобы развертка начиналась с текущего слова
 ;????S qqqq1=$P(qqpar2," ",2),Z=$S(qqqq1="*":$G(W(qqw)),1:qqqq1)
 F j=1:1:qqpar3 S Z=$S(j'=1:$$gwor0(),1:$$gwor(qorder,Z,$P(qqpar2," ",3),$P(qqpar2," ",4),$P(qqpar2," ",6),$P(qqpar2," ",5))) Q:Z=""  D
 .I qqpar6="Zldrl" S W("Zldrl")=$S(j=1:"",qqpar1>0:W("Zldrl")_"~",1:"")_Z_$S(qqpar5="":"",1:" "_$G(^Q(qqlang,qqw,Z)))_$S(j=1:"",qqpar1<0:"~"_W("Zldrl"),1:"") Q
 .I qqpar6="XML" S ID=$G(^Q(qqlang,qqw,Z)) D qWocwrt("<"_qqw_" ID="""_ID_""">"_$S(qqpar5="":"",1:ID_" ")_Z_"</"_qqw_">") Q
 Q:$Q $S(qqpar4=-1:Z,Z="":j-1,1:j) Q
 ;
qWocwrt(str) ;копия qWEB.write(str)
 I qqdev'=0,qqdev?1.N S $$$tmpGl(qqdev,$J,$I($$$tmpGl(qqdev,$J)))=str_$C(13,10) Q  ; 15.12.2008 Kokarev
 U:qqdev'=0 qqdev W str,! Q
 ;
gwor0() G gwor11 
gwor(qqpar1,qqpar2,qqpar3,qqpar4,qqpar5,qqpar6)  ;
 N:0 qorder,Z,qqzb,qqze,qqconZ,qqzo S qorder=qqpar1,Z=$G(qqpar2)
 S:$D(qqpar3) qqzb=qqpar3 S:$D(qqpar4) qqze=qqpar4 S qqconZ=$G(qqpar5),qqzo=$G(qqpar6)
 S:'$D(qqzb) qqzb=""  S:'$D(qqze) qqze=qqzb S:qqze="" qqze="я" I qqzb=qqze,+qqzb'=qqzb S qqze=qqze_$C(0)
 I $G(qqzo)'="" S:qqzo]]qqzb qqzb=qqzo I qqze]]qqzo,+qqze'=qqze S qqze=qqzo_"я"
 ;I Z'="" S Z=$E(Z,1,$L(Z)-1)_$C($A(Z,$L(Z))-1)_$C(255) ;чтобы развертка начиналась с текущего слова
 I Z'="" S:qqzb]]Z Z="" I Z'="",Z]]qqze Q ""
 I Z="" D
 .I qorder>0 D:qqzb'=""  Q
 ..I qqzb'=+qqzb S Z=$RE(qqzb),$E(Z,1)=$C($A(Z)-1),Z=$RE(Z)_"я" Q
 ..S Z=qqzb-(qqzb*1E-14)
 .S Z=$S(qqze=+qqze:qqze+(qqze*1E-14),1:qqze_"я")
gwor11  I qqlang'=1,'$D(^Q(qqlang,qqw)) N qqlang S qqlang=1
gwor1 ;S Z=$S($E(qqw)="V":$$order^%qfv(qqw,$G(Z),qorder),1:$O(^Q(qqlang,$S("TCMDRY"'[$E(qqw):qqw,$E(qqw)="C":qqw,$E(qqw)="R":$E(qqw,3,10),1:qqw),$G(Z)),qorder)) Q:Z="" ""  I qorder>0,$G(qqze)'="",Z]]qqze Q ""
 S Z=$S($D(qqnump)&&($G(Vo(qqnump,$$$CurObj,2))'=4):$O(^Q(qqlang,$S("TCMDRYXL"'[$E(qqw):qqw,$E(qqw)="C":qqw,$E(qqw)="R":$E(qqw,3,10),1:qqw),$G(Z)),qorder),1:$O(^QW(1,qqw,0,$G(Z)),qorder)) Q:Z="" ""  I qorder>0,$G(qqze)'="",Z]]qqze Q ""
 I qorder<0,$G(qqzb)'="",qqzb]]Z Q ""
 Q:$G(qqconZ)="" Z I @qqconZ Q Z
 G gwor1
]]></Implementation>
</Method>

<Method name="qWocCnv">
<Description>
Выполняет преобразование словаря понятия в зависимости от свойства x711 ("%Организация словаря").

Параметры:
qqwt - код понятия, словарь которого нужно преобразовать;
qqot  - код объекта, для которого нужно преобразовать словарь понятия;
mess - признак вывода сообщений (через qARM.Message()): 0 (по умолчанию) - не выводить, 1 - выводить

Если qqot равен "", то преобразование словаря понятия выполняется по всем объектам, которые есть в словаре этого понятия.

При преобразовании НЕ выполняется сборка мусора и проверка правильности словаря.</Description>
<Internal/>
<FormalSpec>qqwt:%Library.String,qqot:%Library.String,mess:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 i $g(qqwt)="" d:$g(mess) qARM.Message("Не определен код понятия.") $$$oQuit(1,0)
 n val,qc,qw,code,ref,qwreflst,iW,iC s val="",ref=$na(^mtempqSYS("tmp",$j,$o(^mtempqSYS("tmp",$j,""),-1)+1)) k @ref s @ref=""
 i $g(qqot)'="" d  k @ref $$$oQuit(1,1)
 .f  s val=$o(^Q(1,qqwt,val)) q:val=""  d:$d(^(val,qqot)) qWocCnv1
 .i $g(mess) d qARM.Message($s($g(@ref@(qqot)):"Выполнено преобразование словаря понятия "_qqwt_ " по объекту "_qqot_".",1:"Организация словаря понятия "_qqwt_" по объекту "_qqot_" не изменилась."))
 f  s val=$o(^Q(1,qqwt,val)) q:val=""  s qqot="" f  s qqot=$o(^Q(1,qqwt,val,qqot)) q:qqot=""  d qWocCnv1
 i $g(mess) d  d qARM.Message(mess)
 .i $d(@ref)=1 s mess="Организация словаря понятия "_qqwt_" по всем объектам не изменилась." q
 .s mess="Выполнено преобразование словаря понятия по объектам:"_$c(13,10),qqot="" f  s qqot=$o(@ref@(qqot)) q:qqot=""  s mess=mess_qqot_" "
 k @ref $$$oQuit(1,1)
qWocCnv1 i ..rWocx711(qqwt,qqot) q:$d(^Q(1,qqwt,val,qqot))=1  k ^(qqot) s ^(qqot)="",@ref@(qqot)=1 q
 q:$d(^Q(1,qqwt,val,qqot))>1  k ^(qqot) s:$g(qwreflst)="" qwreflst=..rWocRefLst(qqwt)
 i '$g(@ref@(qqot)) s ^(qqot)=1,qc="" f  s qc=$o(^Q(1,qqot,qc)) q:qc=""  d
 .f iW=1:1:$l(qwreflst," ") s qw=$p(qwreflst," ",iW),code=$g(^Q(1,qqot,qc,qw)) i code'="" f iC=1:1:$l(code," ") i $p(code," ",iC)'="" s @ref@(qqot,$p(code," ",iC),qw,qc)=$s(iC>1:iC-1,1:"")
 s code=$s($e(qqwt)'="D":$g(^Q(1,qqwt,val)),1:val) q:code=""  i '$d(@ref@(qqot,code)) k ^Q(1,qqwt,val,qqot) q
 s qw="" f  s qw=$o(@ref@(qqot,code,qw)) q:qw=""  s qc="" f  s qc=$o(@ref@(qqot,code,qw,qc)) q:qc=""  d
 .i qw=qqwt||($e(qw)="C") s ^Q(1,qqwt,val,qqot,qc)=@ref@(qqot,code,qw,qc) q
 .i $e(qw)="R" s ^Q(1,qqwt,val,qqot,qc,$e(qw,2))=@ref@(qqot,code,qw,qc)
 q
]]></Implementation>
</Method>

<Method name="rCodeWoc">
<Internal/>
<FormalSpec>Arg1:%Library.String,par1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 Q:$g(Arg1)="" qARM.Message("Не задан список понятий!")
 Q:$g(par1)="" qARM.Message("Не задан споcоб кодирования!")
 s res=""
 k ^Qtt,^Qtmp2,^Qtt1,^QtmpN,^Qtmp1,^Qtmp3

 // без учета частоты использования
 f q=1:1:$L(Arg1," ") d:par1=0
 .s qqc=$p(Arg1," ",q)
 .i qW.GG("CxWoc","X712",qqc)=1 q:qARM.Message("Перекодировать понятие "_qqc_" невозможно. Коды значимы.")  q
 .i $E(qqc,1)="D" q:qARM.Message("Перекодировать понятие "_qqc_" невозможно. Некодируемое понятие.")  q
 .i $E(qqc,1)="@" q:qARM.Message("Перекодировать понятие "_qqc_" невозможно. Обобщение.")  q
 .i $E(qqc,1)="X"||($E(qqc,1)="x") q:qARM.Message("Перекодировать понятие "_qqc_" невозможно. Системное.")  q
 .s res=res_qqc_" "
 .n qqcN,code,codeOLD,new
 .m ^Qtmp1(1,qqc)=^Q(1,qqc)
 .m ^Qtmp1(1,"C"_qqc)=^Q(1,"C"_qqc)
 .s code=""
 .s codeOLD=""
 .f  s codeOLD=$O(^Qtmp1(1,"C"_qqc,codeOLD)) q:codeOLD=""  d
 ..s code=$$rCodeWoc1(code)
 ..m ^QtmpN(1,"C"_qqc,code)=^Qtmp1(1,"C"_qqc,codeOLD)
 ..s new=^QtmpN(1,"C"_qqc,code)
 ..s ^QtmpN(1,qqc,new)=code
 ..s qN=""
 ..f  s qN=$O(^Qtmp1(1,qqc,new,qN)) q:qN=""  d
 ...s qqN=""
 ...f  s qqN=$O(^Qtmp1(1,qqc,new,qN,qqN)) q:qqN=""  d
 ....s ^QtmpN(1,qN,qqN,qqc)=$s($D(^QtmpN(1,qN,qqN,qqc))[0:" "_$g(^Q(1,qN,qqN,qqc))_" ",1:^QtmpN(1,qN,qqN,qqc))
 ....f qq=1:1:$L(^QtmpN(1,qN,qqN,qqc)," ") d
 .....s q2=$p(^QtmpN(1,qN,qqN,qqc)," ",qq)
 .....i q2=codeOLD d
 ......s line1=$F(^QtmpN(1,qN,qqN,qqc)," "_q2_" ")-$L(" "_q2_" ")
 ......s line2=line1+$L(codeOLD)
 ......s ^QtmpN(1,qN,qqN,qqc)=$E(^QtmpN(1,qN,qqN,qqc),1,line1)_code_"@"_$E(^QtmpN(1,qN,qqN,qqc),line2+1,$L(^QtmpN(1,qN,qqN,qqc)))
 ......s ^Qtt(1,qN,qqN,qqc)=^QtmpN(1,qN,qqN,qqc)
 ..k ^Q(1,"C"_qqc,codeOLD)
 .s ^QtmpN(1,qqc)=code



 // вычисление частоты использования + проверка на значимость кодов
 f q4=1:1:$L(Arg1," ") d:par1=1
 .s qqc=$p(Arg1," ",q4)
 .i qW.GG("CxWoc","X712",qqc)=1 q:qARM.Message("Перекодировать понятие "_qqc_" невозможно. Коды значимы.")  q
 .s res=res_qqc_" "
 .n qqcN,code,codeOLD,new
 .m ^Qtmp2(1,qqc)=^Q(1,qqc)
 .m ^Qtmp2(1,"C"_qqc)=^Q(1,"C"_qqc)
 .s code=""
 .s codeOLD=""
 .f  s codeOLD=$O(^Qtmp2(1,"C"_qqc,codeOLD)) q:codeOLD=""  d
 ..s new=^Qtmp2(1,"C"_qqc,codeOLD)
 ..s num=0
 ..s ^Qtt1(1,qqc,codeOLD)=num
 ..s qN=""
 ..f  s qN=$O(^Qtmp2(1,qqc,new,qN)) q:qN=""  d
 ...s qqN=""
 ...f  s qqN=$O(^Qtmp2(1,qqc,new,qN,qqN)) q:qqN=""  d
 ....s num=num+1
 ....s ^Qtt1(1,qqc,codeOLD)=num
 .s qN=""
 .f  s qN=$O(^Qtt1(1,qqc,qN)) q:qN=""  d
 ..m ^Qtmp2(1,"C"_qqc," ",^Qtt1(1,qqc,qN),qN)=^Qtmp2(1,"C"_qqc,qN)
 ..s ^Qtmp3(1,"C"_qqc," ",^Qtt1(1,qqc,qN),qN)=^Qtmp2(1,"C"_qqc,qN)

 s res=$E(res,1,$L(res)-1) // отрезаем пробел в конце

 f q5=1:1:$L(res," ")  d:par1=1
 .s qqc=$p(res," ",q5)
 .i qW.GG("CxWoc","X712",qqc)=1 q  d qARM.Message("Перекодировать понятие "_qqc_" невозможно. Коды значимы.")
 .i $E(qqc,1)="D" q  d qARM.Message("Перекодировать понятие "_qqc_" невозможно. Некодируемое понятие.")
 .i $E(qqc,1)="@" q  d qARM.Message("Перекодировать понятие "_qqc_" невозможно. Обобщение.")
 .i $E(qqc,1)="X"||"x" q  d qARM.Message("Перекодировать понятие "_qqc_" невозможно. Системное.")
 .n qqcN,code,codeOLD,new
 .m ^Qtmp1(1,qqc)=^Qtmp2(1,qqc)
 .m ^Qtmp1(1,"C"_qqc)=^Qtmp2(1,"C"_qqc)
 .s sum=" "
 .s code=""
 .f  s sum=$O(^Qtmp3(1,"C"_qqc," ",sum),-1) q:sum=""  d
 ..s codeOLD=""
 ..f  s codeOLD=$O(^Qtmp1(1,"C"_qqc," ",sum,codeOLD)) q:codeOLD=""  d
 ...s code=$$rCodeWoc1(code)
 ...m ^QtmpN(1,"C"_qqc,code)=^Qtmp1(1,"C"_qqc," ",sum,codeOLD)
 ...s new=^QtmpN(1,"C"_qqc,code)
 ...s ^QtmpN(1,qqc,new)=code
 ...s qN=""
 ...f  s qN=$O(^Qtmp1(1,qqc,new,qN)) q:qN=""  d
 ....s qqN=""
 ....f  s qqN=$O(^Qtmp1(1,qqc,new,qN,qqN)) q:qqN=""  d
 .....s ^QtmpN(1,qN,qqN,qqc)=$s($D(^QtmpN(1,qN,qqN,qqc))[0:" "_$g(^Q(1,qN,qqN,qqc))_" ",1:^QtmpN(1,qN,qqN,qqc))
 .....f qq2=1:1:$L(^QtmpN(1,qN,qqN,qqc)," ") d
 ......s q2=$p(^QtmpN(1,qN,qqN,qqc)," ",qq2)
 ......i q2=codeOLD d
 .......s line1=$F(^QtmpN(1,qN,qqN,qqc)," "_q2_" ")-$L(" "_q2_" ")
 .......s line2=line1+$L(codeOLD)
 .......s ^QtmpN(1,qN,qqN,qqc)=$E(^QtmpN(1,qN,qqN,qqc),1,line1)_code_"@"_$E(^QtmpN(1,qN,qqN,qqc),line2+1,$L(^QtmpN(1,qN,qqN,qqc)))
 .......s ^Qtt(1,qN,qqN,qqc)=^QtmpN(1,qN,qqN,qqc)
 ...k ^Q(1,"C"_qqc,codeOLD)
 .s ^QtmpN(1,qqc)=code

 s q3="^Qtt" // убираем пробелы в начале и в конце и удаляем знак @
 f  s q3=$Q(@q3) q:q3=""  d
 .s a="^QtmpN"_$E(q3,5,$L(q3))
 .s @a=$TR($E(@a,2,$L(@a)-1),"@")   
 m ^Q=^QtmpN

 k ^Qtt,^Qtmp2,^Qtt1,^QtmpN,^Qtmp1,^Qtmp3 

 d:res'="" qARM.Message("Понятия "_res_" перекодированы")
 d qARM.wcre()
 q


rCodeWoc1(qqpar1)  ;функция добавляет +1 к коду qqpar1. A-Z,a-z
 I $E(qqw)="W" Q:qqpar1="" $C(65) D  Q qqpar1 ;компактный код (задействованы русские буквы)
 .N i,% F i=$L(qqpar1):-1:1 S %=$A(qqpar1,i)+1,$E(qqpar1,i)=$C($S(%<91:%,%<97:97,%<123:%,%<192:192,%>255:65,1:%)) Q:%'>255  I i=1 S qqpar1="A"_qqpar1 Q
 Q:qqpar1="" "A" Q:qqpar1?1.N qqpar1+1
 N i,% F i=$L(qqpar1):-1:1 S %=$A(qqpar1,i)+1,$E(qqpar1,i)=$C($S(%<91:%,%<97:97,%>122:65,1:%)) Q:%'>122  I i=1 S qqpar1="A"_qqpar1 Q
 Q qqpar1
]]></Implementation>
</Method>

<Method name="rCopy">
<Description>
Копирование экземпляров
qqo - код объекта
qqc - код экземпляра
qqofrom - код копируемого объекта
qqcfrom - код экземпляра копирумого объекта
qqwlist - список кодов копируемых понятий (через пробел). Код может задаваться из двух частей (через запятую) вида qqw,qqwfrom
qqwlist="" - копирование всех понятий 
qqmovcor =1 - копировать даты, время коррекции (только если qqwlist="")
qqwnoc - список (через пробел) некопируемых понятий
NoJ=1 - без триггеров и журнала (qW) ;@Dol 21.01.11</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqc:%Library.String,qqofrom:%Library.String,qqcfrom:%Library.String,qqwlist:%Library.String,qqmovcor:%Library.String,qqwnoc:%Library.String,nsp:%Library.String,NoJ</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqw,qqwfrom,qqwi,qrCopy I $G(nsp)'="" N nspt S nspt=$ZU(5) ZN nsp
 S qrCopy=1 S:$E(qqo)="v" qqo=$E(qqo,3,255) S:$E($G(qqofrom))="v" qqofrom=$E(qqofrom,3,255) ;@dol 18.05.04
 S:$G(qqofrom)="" qqofrom=qqo S qqwlist=$G(qqwlist)
 I qqwlist=""  D  S qqwlist=$E(qqwlist,2,32000) I 1
 .S qqw="" F  S qqw=$O(^Q(1,qqofrom,qqcfrom,qqw)) Q:qqw=""  I $S(qqw="X"||(qqw="Xc")||(qqw="Xd"):$G(qqmovcor),$G(qqwnoc)'="":" "_qqwnoc_" "'[(" "_qqw_" "),1:1) S W(qqw)=..GG(qqofrom,qqw,qqcfrom),qqwlist=qqwlist_" "_qqw I qqw="YT" S W(qqw)=0 K Vt(qqnump,"ZTmpYT") M Vt(qqnump,"ZTmpYT")=W(qqw) // TDV 11.05.04 - иначе не переписывалось YT ; tdv 20080604 добавлена обработка даты логического удаления (Xd)
 E  D  S qqwlist=$E(qqwlist,2,32000)
 .N qqwlist1 S qqwlist1=qqwlist,qqwlist="" F qqwi=1:1:$L(qqwlist1," ") S qqw=$P(qqwlist1," ",qqwi) I qqw'="" S qqwfrom=$P(qqw,",",2),qqw=$P(qqw,",",1) S:qqwfrom="" qqwfrom=qqw S qqwlist=qqwlist_" "_qqw,W(qqw)=..GG(qqofrom,qqwfrom,qqcfrom) D
 ..I $E(qqwfrom)="T",qqw'=qqwfrom K W(qqw) M W(qqw)=W(qqwfrom) K W(qqwfrom)
 ..I (qqwfrom="YT")&&(qqw="YT") S W(qqwfrom)=0 K Vt(qqnump,"ZTmpYT") M Vt(qqnump,"ZTmpYT")=W(qqwfrom)     ;@Dol 7.04.05 ??было I (qqwform вместо qqwfrom// TDV 11.05.04 - иначе не переписывалось YT
 I qqwlist="" Q:$Q "" Q
 I $G(nsp)'="" ZN nspt
 D ..rCor(qqo,qqc,qqwlist,,,,,,$G(NoJ)) Q:$Q qqwlist Q  ;@Dol 21.01.11
]]></Implementation>
</Method>

<Method name="rCopyTree">
<Description>
Копирование поддеревьев (пока только для одного объекта)
qqo - код объекта вершины
qqc - код экземпляра вершины
qqofrom - пока не задействован ( код копируемого объекта (вершины))
qqcfrom - код экземпляра копирумого объекта (вершины)
qqwlist - пока не задействован
add=0 - заместить, 1 - добавить, -1 - перенести в пустой экземпляр (включая дату,время,пользователь создания,коререкции)
Массив W не изменяется
CopyCom=1 - копировать связанные с qqo (если qqo - объект документ или объект между объектом-документом и
объектом-вершиной) объекты общих сведений
qqwnocone - список (через пробел) некопируемых ДЛЯ ВЕРШИНЫ понятий. Для add=1 значения этих понятий не изменятся, в остальных случаях БУДУТ ПУСТЫМИ.
qqmovcor -  копировать дату, время создания, коррекции (0 или "" - не копировать, 1 - для всего поддерева, 2 - только для вершины, 3 - для поддерева без вершины)</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqc:%Library.String,qqofrom:%Library.String,qqcfrom:%Library.String,qlist:%Library.String,add:%Library.String=0,CopyCom:%Library.String=0,qqwnocone:%Library.String,qqmovcor:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqcNew,qrCopyTree S qrCopyTree=1 K WS("rCopyTree") M WS("rCopyTree")=W
 S:$E(qqo)="v" qqo=$E(qqo,3,255) S:$E($G(qqofrom))="v" qqofrom=$E(qqofrom,3,255) ;@dol 18.05.04
 I 'add D ..rDel(qqo,qqc,,1),..rCor(qqo,qqc,"*")
 N TempList S TempList=$G(^Q(1,"XBase",0,"XBTempList"))  // группы темпоральности
 N BaseObjType S BaseObjType=0
 K YT
 D rCopyTr(qqo,qqc,qqcfrom,1) D:add=-1 ..rDel(qqo,qqcfrom) K W M W=WS("rCopyTree") K WS("rCopyTree")
 Q:$Q "" Q

rCopyTr(qqo,qqc1,qqc0,one) ;копирование экземпляров на заданное начало и потомков. Или одного экземпляра с заданным кодом (one=1)
 N qqolst,qqolsti,qqc,qqc2 I $G($$$Tree) M ^Q(1,qqo,qqc1)=^Q(1,qqo,qqc0) Q  ;@dol 13.1.04

 N Orefqqo S Orefqqo=$G(^Q(1,"CxObj",qqo,"XORef"))
 N TempGroup S TempGroup=""
 N Doc,OrefDoc S (Doc,OrefDoc)=""
 N Top,qqcTopLen S (Top,qqcTopLen)=""
 N ComList,Com,qqcCom,qqcDop S (ComList,Com,qqcCom,qqcDop)=""
 N ObjType S ObjType=0
 N i S i=0

 // обходим группы темпоральности и определяем тип объекта
 // 1 - документ, 2 - объект-вершина, 3 - общие сведения, 4 - между вершиной и документом, 0 - другой
 F i=1:1:$L(TempList," ") D  Q:ObjType'=0
 .S TempGroup=$P(TempList," ",i) Q:TempGroup=""
 .S Doc=$P(TempGroup,":",1) Q:Doc=""
 .S Top=$P(TempGroup,":",2) Q:Top=""
 .S qqcTopLen=$G(^Q(1,"CxObj",Top,"X50")) Q:qqcTopLen=""
 .S ComList=$P(TempGroup,":",3) Q:ComList=""
 .I Doc=qqo S ObjType=1 Q
 .I Top=qqo S ObjType=2 Q
 .I (","_ComList_",")[(","_qqo_",") S ObjType=3 Q
 .Q:Orefqqo=""
 .S OrefDoc=$G(^Q(1,"CxObj",Doc,"XORef")) Q:OrefDoc=""
 .I ((","_Orefqqo_",")[(","_Top_","))&&((","_OrefDoc_",")[(","_qqo_",")) S ObjType=4

 // базовые объекты: объект-вершина, объект-документ, объект между вершиной и документом
 N IsBaseObj S IsBaseObj=(ObjType=2)||((CopyCom)&&(one=1)&&((ObjType=1)||(ObjType=4)))
 I IsBaseObj=1 S BaseObjType=ObjType K YT

 S qqc2=qqc1,qqolst=$G(^Q(1,"CxObj",qqo,"xObj")) ;объекты-потомки
 S qqc=qqc0 D:one  Q:one  F  S qqc=$O(^Q(1,qqo,qqc)) Q:$E(qqc,1,$L(qqc0))'=qqc0  D
 .I 'one S qqc1=$P(..rNew(qqo,qqc2_$E(qqc,$L(qqc2)+1,30000))," ") ;@Dol 01.11.07 сохранение кодов экземпляров источника
 .D ..rCopy(qqo,qqc1,qqo,qqc,,$S(add=-1:1,'$G(qqmovcor):0,qqmovcor=1:1,qqmovcor=2:one,qqmovcor=3:'one,1:0),$S('one:"",1:$G(qqwnocone))) ;@Dol 2.07.05 qqwnocone,@tdv 03.03.08 - qqmovcor
 .// если это объект общих сведений, то запоминаем соответствие ссылок в YT(Doc,"YT",Com,qqcDopOld)=qqcDopNew
 .I (BaseObjType'=0)&&(ObjType=3) S YT(Doc,"YT",qqo,$E(qqc,qqcTopLen+1,$L(qqc)))=$E(qqc1,qqcTopLen+1,$L(qqc1))
 .// если это объект-документ, то запоминаем код нового экземпляра в YT(qqoDoc,"Сode",qqcDoc)=1
 .I (BaseObjType'=0)&&(ObjType=1) S YT(Doc,"Code",qqc1)=1
 .// потомки
 .F qqolsti=1:1:$L(qqolst," ") D:$P(qqolst," ",qqolsti)'="" rCopyTr($P(qqolst," ",qqolsti),qqc1,qqc,0)
 .// если копируется поддерево объекта-документа или объекта между вершиной и документом,
 .// то необходимо скопировать связанные с документами объекты общих сведений (при CopyCom=1)
 .I (CopyCom=1)&&(ObjType=1)&&((BaseObjType=1)||(BaseObjType=4)) D
 ..S Com="" F  S Com=$O(^Q(1,Doc,qqc,"YT",Com)) Q:Com=""  D
 ...S qqcDop=$G(^Q(1,Doc,qqc,"YT",Com)) Q:qqcDop=""  S qqcCom=$E(qqc,1,qqcTopLen)_qqcDop Q:'$D(^Q(1,Com,qqcCom))
 ...D rCopyTr(Com,$P(..rNew(Com,$E(qqc1,1,qqcTopLen))," "),qqcCom,1)
 .I IsBaseObj=1 D SetLinks()
 Q

SetLinks()
 // если копировались темпоральные объекты, то изменяем ссылки в объектах-документах
 // коды объектов-документов YT(Doc,"Сode",qqcDoc)=1
 // ссылки YT(Doc,"YT",Com,qqcDopOld)=qqcDopNew
 N Doc,qqcDoc,Com,qqcDop S (Doc,qqcDoc,Com,qqcDop)=""

 I $D(YT)>1 S Doc="" F  S Doc=$O(YT(Doc)) Q:Doc=""  D
 .S qqcDoc="" F  S qqcDoc=$O(YT(Doc,"Code",qqcDoc)) Q:qqcDoc=""  D
 ..S Com="" F  S Com=$O(^Q(1,Doc,qqcDoc,"YT",Com)) Q:Com=""  D
 ...S qqcDop=$G(^Q(1,Doc,qqcDoc,"YT",Com)) Q:qqcDop=""
 ...S:$G(YT(Doc,"YT",Com,qqcDop))'="" ^Q(1,Doc,qqcDoc,"YT",Com)=YT(Doc,"YT",Com,qqcDop)
 K YT
 Q
]]></Implementation>
</Method>

<Method name="rCor">
<Description>
Коррекция экземпляра объекта. Сборка мусра в словарях не производится (отложенная)
qqlw - список корректируемых понятий (если пуст - удаление экземпляра, если * - очистка - удаление значений всех понятий)
q=1 создавать массивы старых значений ( Wo, No) для внутренннего журналирования (пока не используется)
cordtu=1 записывать информацию о коррекции (qqtime) если есть обновления (cordtu=2 - всегда)
Если qqwl="" - удаление текущего экземпляра. W(qqw) для понятий текущего объекта удаляется (!!!).
NoVir=1 - игнорировать виртуальность объекта (используется в преобразовании - метод qW.qObjConv)
NoW=1 - не изменять W. Актуально при удалении.
NoJr=1 - блокировка журналирования и согласованных изменений</Description>
<Internal/>
<FormalSpec>qqo:%String,qqc:%String,qqlw:%String,q:%String=0,cordtu:%String=1,Hrolog:%Library.String,NoVir:%Library.String,NoW:%Library.String,NoJr:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 i $G(qTRAN)&&($tl=0) n qTRAN,qRSLT ts  s qRSLT=..rCor(.qqo,.qqc,.qqlw,.q,.cordtu,.Hrolog,.NoVir,.NoW,.NoJr) tc  q:$Q "" q      ;Vol@sasha 20061026 правка 141206 ;@pav 20.04.2011
 S W("Zbasmod")=1 ;признак модификации базы
 N fJUser,qqw,qqlz,qqz,i,j,qqlwmod,qqqq2,qqoo,qqwH,x711,Wo,No S qqoo=qqo,qqwH="" S:$E(qqoo)="v" qqo=$E(qqoo,3,255) ;синоним
 I qqc="" D qARM.Message("qW.rCor. Пустой код экземпляра qqo="_qqoo) Q:$Q "" Q  ;@Dol 31.08.10
 I $G(Vo(qqnump,qqoo,2))<3 S i=$G($$$ObjLqqc(qqoo)) I i,i'=255,$L(qqc)'=i D qARM.Message("qW.rCor. Ошибка длины кода экземпляра qqo="_qqoo_" qqc="_qqc_" ( "_$L(qqc)_" вместо "_i_" )") Q:$Q "" Q  ;@Dol 10.12.09
 S fJUser=$G(qqXFJUser) ;@Dol 16.11.04 $G(^Q(1,"XBase",0,"XFJUser"),0) // флаг формирования пользовательского журнала - TDV 06.09.2004
 I '$D(Vo(qqnump,qqo,243)) S Vo(qqnump,qqo,243)=qARM.GetPar("X5243",,qqo),Vo(qqnump,qqo,248)=qARM.GetPar("X5248",,qqo),Vo(qqnump,qqo,247)=$G(^Q(1,"CxObj",qqo,"X5247")) ;@Dol 8.03.05 согласованные изменения ОСНОВНОГО объекта ;;@Dol 20/03/06 счетчик поддеревьев
 I Vo(qqnump,qqo,248)'="" N qqend X Vo(qqnump,qqo,248) I $G(qqend) Q:$Q "" Q  ;@Dol 29.05.06 триггер ДО
 I 'q,'$G(NoJr),$G(qJRN)||fJUser||(Vo(qqnump,qqo,243)'="") S q=1 ;@Dol 13.03.06 NoJr
 ;@Dol 04.05.06 ;K:q Wo,No ;ПЕРЕНЕСЕНО в New !!!! если вызов rCor в соглавованных изменениях - катастрофа - исчезали Wo для журнала
 S qqlwmod="",qqtime="" G:$G($$$Tree) rCorTree I '$G(NoVir),$G(Vo(qqnump,qqoo,2))>2 G:$G(Vo(qqnump,qqoo,2))=6 rCorV6 Q:$Q "" Q
 ;логическое дерево (Слой ??????)
 I $G(Vo(qqnump,qqoo,2))=1 N qqc1 S qqc1=$P($$$ObjRef(qqoo),",",$L($$$ObjRef(qqoo),",")-1) S qqo=$S($E(qqc1)'="v":qqc1,1:$E(qqc1,3,255)) ;предыдущий объект для встроенного
 I cordtu S:'$D(Vo(qqnump,qqoo,32)) Vo(qqnump,qqoo,32)=+qARM.GetPar("x532",,qqoo) S:$G(Hrolog)="" Hrolog=$H ;создание-коррекция
 N qql S qql=1 ;????? 
 ;oldlock ;ZA ^Q(qql,qqo,qqc):20 ;можно сильно влипнуть? (проверять в цикле??)
 ZA ^Q(qql_qqo_" "_qqc):20 ;newlock
 ;
 I qqlw'="",qqlw'="*" F i=1:1:$L(qqlw," ") S (qqwv,qqw)=$P(qqlw," ",i) D:qqw'="" rCorDo
 I qqlw=""||(qqlw="*") N qqww S qqww="" F  S qqww=$O(^Q(qql,qqo,qqc,qqww)) Q:qqww=""  I $S(qqlw="":1,qqww="X":0,qqww="Xc":0,1:1) S (qqwv,qqw)=qqww D
 .I '$G(NoW) K W(qqw),N(qqw) D rCorDo Q
 .K NoW M NoW=W(qqw) K W(qqw),N(qqw) D rCorDo M W(qqw)=NoW S NoW=1 ;@dol 20.03.03
 I $G($$$ObjLqqc(qqoo))'=255 D  L -^Q(qql_qqo_" "_qqc)#"I" G rCorEnD ;@Dol 10.12.09 qqoo вместо qqo ;oldlock ZD ^Q(qql,qqo,qqc)
 .I qqlw="" S qqtime=$I(^Q(qql,qqo),-1),qqtime="" K ^Q(qql,qqo,qqc) D:$G(Vo(qqnump,qqo,247))'="" ..rX5247(qqo,-1,qqc) Q  ;удаление; @Dol 20.03.06 ..rX5247 - счетчик поддеревьев
 .I cordtu,Vo(qqnump,qqoo,32)+1#2," "_qqlw_" "'[(" X "),qqlwmod'=""||(cordtu=2) S qqtime=$S(((Hrolog\(256**2)>0)||($P(Hrolog,",")=0)):$C(0,0),1:"")_$RE($E($ZLC(Hrolog),1,$S(((Hrolog\(256**2)>0)||($P(Hrolog,",")=0)):3,1:2)))_$RE($E($ZLC($P(Hrolog,",",2)),1,3))_$G(quser),^Q(qql,qqo,qqc,"X")=qqtime Q  ;@ank 20101101 Новый алгоритм запаковки\распаковки дат ;@dol 10.02.02 " "_qqlw_" "'[(" X ") для возможности переноса даты коррекции в rCopy;30.10.03 ||(cordtu=2)
 .S qqtime="" S:'$D(^Q(qql,qqo,qqc)) ^Q(qql,qqo,qqc)="" ;чтобы случайно не удалить пустой экземпляр при коррекции
 I " "_qqlw_" "[(" CC "),$G(W("CC"))'=""  D  L -^Q(qql_qqo_" "_qqc)#"I" S qqlwmod=qqlwmod_" CC"  G:q rCorJRN Q:$Q qqlwmod Q  ;модификация словарей ;oldlock ZD ^Q(qql,qqo,qqc)
 .;<oleg> 15.09.2005 при изменении словаря учитывается значение свойства x711 (%Организация соваря) </oleg>
 .I $E(qqo)="C" D  Q  ;кодируемое понятие
 ..S qqz=$G(^Q(qql,qqo,qqc)) Q:qqz=W("CC")  S qqw=$E(qqo,2,255) I qqz=""  S ^Q(qql,qqw,W("CC"))=qqc,^Q(qql,qqo,qqc)=W("CC") Q   ;новое значение в прямом словаре
 ..S qqlz=$G(^Q(qql,qqw,W("CC"))) ;qqlz'="" - слово существовало с другим кодом
 ..I qqlz="" M ^Q(qql,qqw,W("CC"))=^Q(qql,qqw,qqz) S ^Q(qql,qqw,W("CC"))=qqc,^Q(qql,qqo,qqc)=W("CC") K ^Q(qql,qqw,qqz) Q  ;замена значение на несуществовавшее новое
 ..;слияние с существующим значением и удаление текущего
 ..D rCorCjn K ^Q(qql,qqo,qqc)
 .I $E(qqo)="D" S qqw=qqo,qqz=qqc,qqlz=W("CC") S:'$D(^Q(qql,qqw,qqlz)) ^(qqlz)="" D rCorCjn  Q  ;понятия на D* - некодируемые
 .S ^Q(qql,qqo,qqc)=W("CC")
 I qqlw'="" D
 .I cordtu,Vo(qqnump,qqoo,32)+1#2 S qqtime=$S(((Hrolog\(256**2)>0)||($P(Hrolog,",")=0)):$C(0,0),1:"")_$RE($E($ZLC(Hrolog),1,$S(((Hrolog\(256**2)>0)||($P(Hrolog,",")=0)):3,1:2)))_$RE($E($ZLC($P(Hrolog,",",2)),1,3))_$G(quser),^Q(qql,qqo,qqc,"X")=qqtime Q  ;@ank 20101101 Новый алгоритм запаковки\распаковки дат
 .S qqtime=""
 I qqlw="" D  ;$D(^Q(qql,qqo,qqc))<10 D
 .I $E(qqo)="C",$G(^Q(qql,qqo,qqc))'="" K ^Q(qql,$E(qqo,2,255),^Q(qql,qqo,qqc)) ;qqlang? ссылки?
 .S:"XCD"[$E(qqo)!(qqo?1.N) qqtime=$I(^Q(qql,qqo),-1) S qqtime="" K ^Q(qql,qqo,qqc)
 L -^Q(qql_qqo_" "_qqc)#"I" ;oldlock ^Q(qql,qqo,qqc)
rCorEnD I $G(qqwH)'="" D  S qqlwmod=qqlwmod_" "_qqwH ;Обработка введенных характеристик (а многоязычность???) ;@dol 12.11.02 ;20.12.07 добавить в qqlwmod
 .N qqwp F i=2:1:$L(qqwH," ") S qqw=$P(qqwH," ",i),qqwp=$S($E(qqw,2)?1N:$E(qqw,2),$E(qqw,2)="T":"T",1:""),qqz=$G(^Q(1,qqo,qqc,$E(qqw,2+(qqwp'=""),255))) D:qqz'=""
 ..I qqwp="T" K ^Q(1,"C"_$E(qqw,2+(qqwp'=""),255),qqz,"Thlp") M ^Q(1,"C"_$E(qqw,2+(qqwp'=""),255),qqz,"Thlp")=W(qqw) Q  ;@Dol 6.12.06 Thlp словаря
 ..I $L(qqz," ")=1 S ^Q(1,"C"_$E(qqw,2+(qqwp'=""),255),qqz,"XRef"_qqwp)=$G(W(qqw)) Q  ;@Dol 26.04.05 характеристика с пробелами для одного слова
 ..F j=1:1:$L(qqz," ") S ^Q(1,"C"_$E(qqw,2+(qqwp'=""),255),$P(qqz," ",j),"XRef"_qqwp)=$P($G(W(qqw))," ",j) ;@dol 17.09.04 "~",j)
 I 'q Q:$Q qqlwmod Q
 D:$G(Vo(qqnump,qqo,243))'=""  ;@Dol 8.03.05 Согласованные изменения (триггер После)
 .I Vo(qqnump,qqo,243)["(" X Vo(qqnump,qqo,243) Q  ;@Dol 28.02.06 пользовательский метод обработки согласованных изменений
 .N qqoi,qqoL,qqzL,qqwL,qqoc0,qqwLyes,qqwLno F qqoi=1:1:$L(Vo(qqnump,qqo,243)," ") S qqoL=$P(Vo(qqnump,qqo,243)," ",qqoi) D:qqoL'=""
 ..I $P(qqoL,";",6)'="" S qqoc0=0 D  Q:'qqoc0   ;@Dol 01.10.09 условие
 ...I qqlw="*" N qqlw S qqlw="" ;;@Dol 21.02.10 чтобы работала проверка qqwl'=""
 ...I @$P(qqoL,";",6) S qqoc0=1
 ..S qqwLyes=$P(qqoL,";",4),qqwLno=$P(qqoL,";",5) ;@Dol 01.10.09 списки корректируемых\некорректируемых
 ..S qqoc0=$P(qqoL,";",3) S:qqoc0'="" qqoc0=$E(qqc,1,$$$ObjLget(qqoc0))
 ..S qqzL=$P($P(qqoL,";",1),":",2),qqwL=$P(qqoL,";",2) S:qqwL="" qqwL=qqzL Q:qqzL=""  S qqzL=$TR(qqzL,",","~")
 ..F qqoc=1:1:$L(qqzL,"~") S $P(qqzL,"~",qqoc)=$S(" "_qqlwmod_" "[(" "_$P(qqzL,"~",qqoc)_" "):$G(Wo($P(qqzL,"~",qqoc))),1:..G($P(qqzL,"~",qqoc)))
 ..Q:$TR(qqzL,"~")=""  I qqlw'="" S qqwLyes=$S(qqwLyes="":qqlw,1:$TR(qqwLyes,","," ")) S:qqwLno'="" qqwLyes=..zReplace(qqwLyes,$TR(qqwLno,","," "),"",1,1) ;@Dol 01.10.09
 ..S qqoc="" F  S qqoc=..FastKey($P(qqoL,":"),qqwL,qqoc,1,qqzL,qqoc0) Q:qqoc=""  D:qqlw'="" ..rCor($P(qqoL,":"),qqoc,qqwLyes) D:qqlw="" ..rDel($P(qqoL,":"),qqoc) ;D qARM.Message(qqoc_"-"_qqlw_"-"_qqwLyes)
 ;запись в журнал (qqw=CC ???)
rCorJRN I "X"=$E(qqo)||("Cx"=$E(qqo,1,2)) Q:$Q qqlwmod Q  ;блокировка журналирования системных объектов
 S:$G(Hrolog)="" Hrolog=$H
 I fJUser=1 D rCorJrnU
 I '$G(qJRN) Q:$Q qqlwmod Q
 S q=$I(^QJ(1,"XJrn")),^QJ(1,"XJrn",q,"XJC")=qqc,^("xObj")=qqo,^("XJu")=quser,^("xWoc")=$E(qqlwmod,2,30000),^("xObj")=qqo,^("XJcom")=$S(qqlw="":"K",1:"C"),^("XJdt")=Hrolog
 M ^QJ(1,"XJrn",q,"Xold",1)=Wo I qqlw'="" F i=2:1:$L(qqlwmod," ") S qqw=$P(qqlwmod," ",i) M ^QJ(1,"XJrn",q,"Xnew",1,qqw)=W(qqw)
 Q:$Q qqlwmod Q
rCorJrnU
 // формирование пользовательского журнала - TDV 30.08.2004; удалена проверка существования метода - TDV - 20.01.2005
 N method S method=$G(^Q(1,"XBase",0,"XMJUser")) Q:method=""
 S method=$P(method,"(")
 X "D "_method_"("""_$S(qqlw="":"K",1:"C")_""","""_qqo_""","""_qqc_""","""_Hrolog_""")"
 Q
 ;Коррекция понятия
rCorDo
 Q:qqw="C"!(qqw="CC")  Q:"Z@"[$E(qqw)  I $E(qqw)="C"," "_qqlw_" "'[(" "_$E(qqw,2,255)_" ") S qqwv=$E(qqw,2,255) N qqw S qqw=qqwv S W(qqw)=..GetWoc("C"_qqw,$G(W("C"_qqw))) ;@Dol 5.06.07 есть код, но значение не редактируется
 If "TYCMDRLXHO"[$E(qqw) S qqwv=$S($E(qqw)="O":$E(qqw,2,255),$E(qqw)="D":qqw,$E(qqw)="R":$E(qqw,3+($E(qqw,3)="O"),255),1:"") I "TMLXYH"[$E(qqw)||($E(qqwv)="O") D  Q  ;@dol 9.08.04 "O";@Ninel 10.11.05 ="R":$E(qqw,3+($E(qqw,3)="O") ?rWoc 
 .I $E(qqw)="H" S:qqw'="H" qqwH=qqwH_" "_qqw Q  ;список вводимых характеристик ;@dol 25.11.02 :qqw="H" - грубая ошибка
 .I "MLXO"[$E(qqw)||($E(qqwv)="O") D   Q  ;@dol 9.08.04 OO*-понятия
 ..I $E(qqw)="X",$D(W(qqw))>1 K ^Q(qql,qqo,qqc,qqw) M ^Q(qql,qqo,qqc,qqw)=W(qqw) S qqlwmod=qqlwmod_" "_qqw Q
 ..S qqz=$G(^Q(qql,qqo,qqc,qqw)) Q:qqz=$G(W(qqw))  S qqlwmod=qqlwmod_" "_qqw  I q,qqz'="" Set Wo(qqw)=qqz ;qqw'="X",qqw'="Xc" чтобы X и Xc не попали в журнал ??? ;10.12.09 I qqw'="X",qqw'="Xc" убрано, чтобы менялась дата коррекции
 ..I $G(W(qqw))="" K ^Q(qql,qqo,qqc,qqw) Q
 ..S ^Q(qql,qqo,qqc,qqw)=W(qqw)
 .I $E(qqw)="Y" N qqlang S qqlang=1 I qqw="YT" D  Q  ;@dol 8.11.02 понятие темпоральной связанности
 ..Q:$G(Vt(qqnump,"ZTmpYT"))=1  ;ничего не изменилось
 ..S qqlwmod=qqlwmod_" "_qqw M:q Wo(qqw)=^Q(qqlang,qqo,qqc,qqw)
 ..K ^Q(qqlang,qqo,qqc,qqw) I $D(Vt(qqnump,"ZTmpYT")) S Vt(qqnump,"ZTmpYT")=1 M ^Q(qqlang,qqo,qqc,qqw)=Vt(qqnump,"ZTmpYT") K W(qqw) M W(qqw)=Vt(qqnump,"ZTmpYT") ;@dol 30.04.04
 .S qqlwmod=qqlwmod_" "_qqw I $E(qqw,1,2)="TB" D  Q  ;TB в отдельный массив
 ..M:q Wo(qqw)=^QT($E(qqw,2,255),qqlang,qqo,qqc)
 ..K ^QT($E(qqw,2,255),qqlang,qqo,qqc),^Q(1,qqo,qqc,qqw) I $D(W(qqw)) M ^QT($E(qqw,2,255),qqlang,qqo,qqc)=W(qqw) S ^Q(1,qqo,qqc,qqw)="" ;@Dol 16.01.04 ^Q(1,qqo,qqc,qqw)="" Признак наличия значения у TB*
 .M:q Wo(qqw)=^Q(qqlang,qqo,qqc,qqw) ;@dol 9.11.02 ???было ^Q(qqlang,qqw,qqo,qqc)
 .K ^Q(qqlang,qqo,qqc,qqw) I $D(W(qqw)) M ^Q(qqlang,qqo,qqc,qqw)=W(qqw)
 ;Q:qqwv=""  S:$G(N(qqw))=""!($E(qqwv)="D") qqqq1=..rWoc(1) S qqlz=$G(^Q(qql,qqo,qqc,qqw)) Q:N(qqw)=qqlz  S qqlwmod=qqlwmod_" "_qqw ;$E(qqwv)="D" ???
 Q:qqwv=""  S:'$D(Vx713(qqwv)) Vx713(qqwv)=+$G(^Q(1,"CxWoc",qqwv,"x713")) I Vx713(qqwv)=2 D  Q  ;@Dol 14.11.06 модификация словаря
 .S qqz=$G(^Q(qql,qqo,qqc,qqw)) Q:qqz=$G(W(qqw))  S qqlwmod=qqlwmod_" "_qqw I q,qqz'="" Set Wo(qqw)=qqz
 .I $G(W(qqw))="" K ^Q(qql,qqo,qqc,qqw) Q
 .S ^Q(qql,qqo,qqc,qqw)=W(qqw)
 S qqqq1=..rWoc(1) S:'$D(Vqqwt(qqw)) Vqqwt(qqw)=$G(^Q(1,"CxWoc",qqw,"xGrCol"))=1 ZA:Vqqwt(qqw) ^Q(1_qqw) ;разрешена немедленная сборка мусора;;oldlock ^Q(1,qqw)
 S qqlz=$G(^Q(qql,qqo,qqc,qqw)) I N(qqw)=qqlz L:Vqqwt(qqw) -^Q(1_qqw)#"I" Q  ;@Dol 30.01.06 Было забыто ZD  ;oldlock ^Q(1,qqw)
 S qqlwmod=qqlwmod_" "_qqw,qqqq2=$ZR
 s x711=$S($E(qqwv)="x":1,1:..rWocx711(qqwv,qqo)) ;@Dol 10.11.05 x ;<oleg> 05.09.2005 определяем способ организации словаря (x711) </oleg>
 ;<oleg> 05.09.2005
 ;добавлена проверка на тип организации словаря (x711):
 ;если x711=1 (словарь без ссылок), то не удаляем ссылку на код объекта в словаре и не выполняется немедленная сборка мусора
 ;</oleg>
 ;;@Dol 23.12.04
 I qqlz'="" S:q No(qqw)=qqlz K:N(qqw)="" @qqqq2 i 'x711 F j=1:1:$L(qqlz," ") S qqz=$P(qqlz," ",j) I qqz'="" S:$E(qqwv)'="D" qqz=$G(^Q(1,"C"_qqwv,qqz)) I qqz'="" S:q $P(Wo(qqw)," ",j)=qqz D:" "_$G(W(qqw))_" "'[(" "_qqz_" ")
 .I $E(qqw)'="R" ZK ^Q(1,qqwv,qqz,qqo,qqc) ;@Dol 21.08.06 был K, но если есть R* аналог, то его ссылки удалялись тоже
 .E   K ^Q(1,qqwv,qqz,qqo,qqc,$E(qqw,2))
 .I $G(Vqqwt(qqw)),$D(^Q(1,qqw,qqz))=1 D  ;немедленная сборка мусора
 ..K ^(qqz) I $E(qqw)="D"||(Vx713(qqw)=1) Q:$I(^Q(1,qqw),-1)  Q  ;??R*
 ..K ^Q(1,"C"_qqw,$P(qqlz," ",j)) Q:$I(^Q(1,"C"_qqw),-1)
 ;<oleg> 05.09.2005 добавлена проверка x711 при формировании словаря </oleg>
 I N(qqw)'="" S ^Q(qql,qqo,qqc,qqw)=N(qqw) F j=$L(N(qqw)," "):-1:1 I $P(W(qqw)," ",j)'="" S qqz=$S(qqllang=""||(qqlang=1):$P(W(qqw)," ",j),1:^Q(1,"C"_qqwv,$P(N(qqw)," ",j))) D
 .i x711 s ^Q(1,qqwv,qqz,qqo)="" q  ;;@oleg 05.09.2005
 .I $E(qqw)'="R" S ^Q(1,qqwv,qqz,qqo,qqc)=$S(j=1:"",1:j-1) Q
 .S ^Q(1,qqwv,qqz,qqo,qqc,$E(qqw,2))=$S(j=1:"",1:j-1)
 L:Vqqwt(qqw) -^Q(1_qqw)#"I" Q  ;oldlock ^Q(1,qqw)
 ;;Старый текст
 I qqlz'="" S:q No(qqw)=qqlz K:N(qqw)="" @qqqq2 F j=1:1:$L(qqlz," ") S qqz=$P(qqlz," ",j) I qqz'="" S:$E(qqwv)'="D" qqz=$G(^Q(1,"C"_qqwv,qqz)) I qqz'="" S:q $P(Wo(qqw)," ",j)=qqz K ^Q(1,qqwv,qqz,qqo,qqc) I $G(Vqqwt(qqw))," "_$G(W(qqw))_" "'[(" "_qqz_" "),$D(^Q(1,qqw,qqz))=1 D  ;немедленная сборка мусора
 .K ^(qqz) I $E(qqw)="D" Q:$I(^Q(1,qqw),-1)  Q  ;??R*
 .K ^Q(1,"C"_qqw,$P(qqlz," ",j)) Q:$I(^Q(1,"C"_qqw),-1)
 I N(qqw)'="" S ^Q(qql,qqo,qqc,qqw)=N(qqw) F j=1:1:$L(N(qqw)," ") I $P(W(qqw)," ",j)'="" N qqz S qqz=$S(qqllang=""!(qqlang=1):$P(W(qqw)," ",j),1:^Q(1,"C"_qqwv,$P(N(qqw)," ",j))),^Q(1,qqwv,qqz,qqo,qqc)=$S(j=1:"",1:j-1)
 L:Vqqwt(qqw) -^Q(1_qqw)#"I" Q  ;oldlock ^Q(1,qqw)
 ;физическое дерево
rCorTree ZA ^Q(1_qqo_" "_qqc):20 ;oldlock @$$$GloRef@(qqo,qqc):20
 I qqlw="" D  Q:$Q "" Q  ;удаление физического дерева
 .K @$$$GloRef@(qqo,qqc) I $D(@$$$GloRef@(qqo))>1 S qqtime=$I(@$$$GloRef@(qqo),-1) K qqtime Q
 .K @$$$GloRef@(qqo)
 F i=1:1:$L(qqlw," ") S (qqwv,qqw)=$P(qqlw," ",i) D:qqw'="" rCorDoT
 I $D(@$$$GloRef@(qqo,qqc))<10 S qqlw="" G rCorTree+1
 ;S:cordtu (@$$$GloRef@(qqo,qqc),qqtime)=$RE($E($ZLC($H),1,2))_$RE($E($ZLC($P($H,",",2)),1,3))_$G(quser)
 I " "_qqlw_" "[(" C "),$G(W("C"))'="" M @$$$GloRef@(qqo,W("C"))=@$$$GloRef@(qqo,qqc) K @$$$GloRef@(qqo,qqc) ;перенос поддерева
 L -^Q(1_qqo_" "_qqc)#"I" Q:$Q qqlwmod Q  ;oldlock @$$$GloRef@(qqo,qqc)
 ;Коррекция понятия
rCorDoT
 I $E($$$GloRef,1,4)="^QS(" D  Q  ;понятия потока
 .I $E(qqw)="T" S qqlwmod=qqlwmod_" "_qqw K @$$$GloRef@(qqo,qqc,qqw) M:$D(W(qqw)) ^(qqw)=W(qqw) Q
 .S qqz=$G(@$$$GloRef@(qqo,qqc,qqw)) Q:qqz=$G(W(qqw))  S qqlwmod=qqlwmod_" "_qqw
 .I $G(W(qqw))="" K @$$$GloRef@(qqo,qqc,qqw) Q
 .S @$$$GloRef@(qqo,qqc,qqw)=W(qqw)
 Q:qqw="C"!(qqw="CC")  Q:"Z@"[$E(qqw)
 If "TYCMDRLX"[$E(qqw) S qqwv=$S($E(qqw)="D":qqw,$E(qqw)="R":$E(qqw,3,255),1:"") I "TMLYX"[$E(qqw) D  Q
 .I "MLX"[$E(qqw) D   Q
 ..S qqz=$G(@$$$GloRef@(qqo,qqc,qqw)) Q:qqz=$G(W(qqw))  S qqlwmod=qqlwmod_" "_qqw I q,qqz'="" Set Wo(qqw)=qqz
 ..I $G(W(qqw))="" K @$$$GloRef@(qqo,qqc,qqw) Q
 ..S @$$$GloRef@(qqo,qqc,qqw)=W(qqw)
 .;текстовые и структуры
 .S qqlwmod=qqlwmod_" "_qqw M:q Wo(qqw)=@$$$GloRef@(qqo,qqc,qqw)
 .K @$$$GloRef@(qqo,qqc,qqw) I $D(W(qqw)) M ^(qqw)=W(qqw) 
 Q:qqwv=""  S qqqq1=..rWoc(1) S qqlz=$G(@$$$GloRef@(qqo,qqc,qqw)) Q:N(qqw)=qqlz  S qqlwmod=qqlwmod_" "_qqw
 S qqqq2=$ZR ;ссылок не бывает (Старое состояние?)
 I qqlz'="" S:q No(qqw)=qqlz K:N(qqw)="" @qqqq2 ;F j=1:1:$L(qqlz," ") S qqz=$P(qqlz," ",j) S:$E(qqwv)'="D" qqz=$S($D(QW(1,qqwv)):$G(QW(1,qqwv,1,qqz)),1:$G(^%QW(1,qqwv,1,qqz))) I qqz'="" S:q $P(Wo(qqw)," ",j)=qqz K ^Q(1,qqwv,qqz,qqo,qqc)
 I N(qqw)'="" S @qqqq2=N(qqw) ;F j=1:1:$L(N(qqw)," ") I $P(W(qqw)," ",j)'="" N qqz S qqz=$S(qqllang=""!(qqlang=1):$P(W(qqw)," ",j),1:^Q(1,"C"_qqwv,$P(N(qqw)," ",j))),^Q(1,qqwv,qqz,qqo,qqc)=$S(j=1:"",1:j-1)
 Q
rCorV6 ;для массивов (в "чистом") варианте
 S:'$D(Vo(qqnump,qqo,33)) Vo(qqnump,qqo,33)=qARM.GetPar("X533",,qqo)
 ZA:$E($NA(@Vo(qqnump,qqo,33)))="^" @Vo(qqnump,qqo,33)@(qqc):20
 I qqlw="" K @Vo(qqnump,qqo,33)@(qqc) L -@Vo(qqnump,qqo,33)@(qqc)#"I" Q:$Q "" Q  ;удаление
 I " "_qqlw_" "[(" C "),$G(W("C"))'="" M @Vo(qqnump,qqo,33)@(W("C"))=@Vo(qqnump,qqo,33)@(qqc) K @Vo(qqnump,qqo,33)@(qqc) L -@Vo(qqnump,qqo,33)@(qqc)#"I" S qqc=W("C") ;@Dol 31.05.05 перенос поддерева
 F i=1:1:$L(qqlw," ") S (qqwv,qqw)=$P(qqlw," ",i) I qqw'="",qqw'="C" D rCorV6do
 I $D(@Vo(qqnump,qqo,33)@(qqc))<10,$G(@Vo(qqnump,qqo,33)@(qqc))="",$S(" "_qqlw_" "[(" C "):$G(W("C"))="",1:1) S qqlw="" K @Vo(qqnump,qqo,33)@(qqc) L -@Vo(qqnump,qqo,33)@(qqc)#"I" Q:$Q "" Q
 ;;I " "_qqlw_" "[(" C "),$G(W("C"))'="" M @Vo(qqnump,qqo,33)@(W("C"))=@Vo(qqnump,qqo,33)@(qqo,qqc) K @Vo(qqnump,qqo,33)@(qqc) ;перенос поддерева
 L -@Vo(qqnump,qqo,33)@(qqc)#"I"
 X:$G(Vo(qqnump,qqo,243))'="" Vo(qqnump,qqo,243) ;@Dol 19.10.06 Триггер после
 Q:$Q qqlwmod Q
 ;
rCorV6do S:'$D(Vt(qqnump,"mas",qqo,qqw)) Vt(qqnump,"mas",qqo,qqw)=qARM.GetPar("X753",,qqo,qqw)
 N qqqq1 I $E(qqw)="x",$G(W(qqw))'="" S qqqq1=..rWoc(1),qqqq1=N(qqw) ;@Dol 25.03.05 для кодируемых понятий ;@Dol 28.03.05 - только x ;"TYCMDRLXHO"'[
 I qqw="CC" S @(Vo(qqnump,qqo,33))@(qqc)=$G(W(qqw)) Q
 I $G(Vt(qqnump,"mas",qqo,qqw))="" D   Q  ;@dol 28.07.04 код понятия-индекс узла
 .I $E(qqw)="T" K @(Vo(qqnump,qqo,33))@(qqc,qqw) M @(Vo(qqnump,qqo,33))@(qqc,qqw)=W(qqw) Q
 .S @(Vo(qqnump,qqo,33))@(qqc,$S($E(qqw)'="X":qqw,$G(Vo(qqnump))["XXXXNV":qqw,1:$E(qqw,2,255)))=$G(qqqq1,$G(W(qqw)))
 I $L($G(Vt(qqnump,"mas",qqo,qqw))," ")=1,Vt(qqnump,"mas",qqo,qqw)'["(" D   Q  ;задан индекс узла
 .I $E(qqw)="T" K @(Vo(qqnump,qqo,33))@(qqc,Vt(qqnump,"mas",qqo,qqw)) M @(Vo(qqnump,qqo,33))@(qqc,Vt(qqnump,"mas",qqo,qqw))=W(qqw) Q
 .S @(Vo(qqnump,qqo,33))@(qqc,Vt(qqnump,"mas",qqo,qqw))=$G(qqqq1,$G(W(qqw)))
 I Vt(qqnump,"mas",qqo,qqw)?1.n1" "1.e N qsp S qsp=$P(Vt(qqnump,"mas",qqo,qqw)," ",2) S:qsp?1.N qsp=$C(qsp) S:$G(W("O"_qqo))'=qqc W("CC")=$G(@(Vo(qqnump,qqo,33))@(qqc)),W("O"_qqo)=qqc S $P(W("CC"),qsp,+Vt(qqnump,"mas",qqo,qqw))=$G(qqqq1,$G(W(qqw))),@(Vo(qqnump,qqo,33))@(qqc)=$G(W("CC")) Q  ;значение в узле через разделитель
 Q
rCorCjn ;@oleg 19.09.2005
 ;объединение значений при корректировке словарей
 ;qqw - код_понятия
 ;qqc - старый код значения; qqz - старое значение понятия (для понятий на D* qqc и qqz совпадают)
 ;qqlz - новый код значения; W("CC") - новое значение понятия (для понятий на D* qqlz и W("CC") совпадают)
 N qqoo,qqcc,refqwlst,flag,qt S (qqoo,refqwlst)="" F  S qqoo=$O(^Q(qql,qqw,qqz,qqoo)) Q:qqoo=""  S x711=..rWocx711(qqw,qqoo) D
 .I 'x711 D  Q  ;замена ссылок в словаре со ссылками на экземпляры
 ..S qqcc="" F  S qqcc=$O(^Q(qql,qqw,qqz,qqoo,qqcc)) Q:qqcc=""  D  ;обход старых ссылок
 ...S qqqq2=" "_$G(^Q(qql,qqoo,qqcc,qqw))_" " D:qqqq2[(" "_qqc_" ")  ;если старый код есть в значении экземпляра, то заменяем его на новый код
 ....S ^Q(qql,qqw,W("CC"),qqoo,qqcc)=^Q(qql,qqw,qqz,qqoo,qqcc) ;замена ссылок
 ....F  S j=$F(qqqq2," "_qqc_" ") Q:'j  S $E(qqqq2,j-1-$L(qqc),j-2)=qqlz
 ....S ^Q(qql,qqoo,qqcc,qqw)=$E(qqqq2,2,$L(qqqq2)-1)
 ...Q:$D(^Q(qql,qqw,qqz,qqoo,qqcc))<10  ;если нет ссылок на понятия на R*, то выход
 ...S qt="" F  S qt=$O(^Q(qql,qqw,qqz,qqoo,qqcc,qt)) Q:qt=""  S qqqq2=" "_$G(^Q(qql,qqoo,qqcc,"R"_qt_qqw))_" " D:qqqq2[(" "_qqc_" ")
 ....S ^Q(qql,qqw,W("CC"),qqoo,qqcc,qt)=^Q(qql,qqw,qqz,qqoo,qqcc,qt) ;замена ссылок
 ....F  S j=$F(qqqq2," "_qqc_" ") Q:'j  S $E(qqqq2,j-1-$L(qqc),j-2)=qqlz
 ....S ^Q(qql,qqoo,qqcc,"R"_qt_qqw)=$E(qqqq2,2,$L(qqqq2)-1)
 .;если тип словаря - "словарь без ссылок", то проход по всем экземплярам объекта qqoo
 .S:refqwlst="" refqwlst=..rWocRefLst(qqw) S qqcc="",flag=0
 .F  S qqcc=$O(^Q(qql,qqoo,qqcc)) Q:qqcc=""  F i=1:1:$L(refqwlst," ") S qqqq2=" "_$G(^Q(qql,qqoo,qqcc,$P(refqwlst," ",i)))_" " D:qqqq2[(" "_qqc_" ")
 ..F  S j=$F(qqqq2," "_qqc_" ") Q:'j  S $E(qqqq2,j-1-$L(qqc),j-2)=qqlz
 ..S ^Q(qql,qqoo,qqcc,$P(refqwlst," ",i))=$E(qqqq2,2,$L(qqqq2)-1),flag=1
 .S:flag ^Q(qql,qqw,W("CC"),qqoo)=""
 K ^Q(qql,qqw,qqz)
 Q
]]></Implementation>
</Method>

<Method name="rCorSQL">
<Description>
Корректирование/создание записей в SQL-таблицах (виртуальные объекты типа 7)
qqo - код виртуального объекта
qqwc - код ключевого понятия (в таблице соответствует первичному ключу)
qqwcz - значение ключевого понятия
qqwl - список обновляемых понятий (через пробел)
qqwz - список значений обновляемых понятий (через ~)

Если qqwc="" - создание новой записи</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqwc:%Library.String,qqwcz:%Library.String,qqwl:%Library.String,qqwz:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qq,qqq,error,add,qqwi,qqw  D
 .I $G(Vt(qqnump,"sql",qqo))'="",$G(Vt(qqnump,"sql",qqo))'="",$ZF(-3,"","DropStatement",Vt(qqnump,"sql",qqo))
 .I '$D(Vt(qqnump,"sql")) S error=qSYS.SQLini() I $G(error)'="" Q  ;K Vt(qqnump,"sql") Q
 .S qq=$$GetConnection^%apiGTW(Vt(qqnump,"sql",qqo,"con")) I (qq=-1)!(qq=0)!($l(qq)=0) S error="Нет соединения "_qq Q             
 .S Vt(qqnump,"sql",qqo)=$ZF(-3,"","AllocStatement",qq) I Vt(qqnump,"sql",qqo)=-1 S error="AllocStatement="_Vt(qqnump,"sql",qqo) Q  ; "chstmt=-1" I SQLCODE'=0 Q "Alloc SQLCODE'=0"
 .I $G(qqwc)'="" D  Q:$G(error)'=""  ;коррекция
 ..S qq="" F qqwi=1:1:$L(qqwl," ") S qq=qq_","_Vt(qqnump,"sql",qqo,"qqw",$P(qqwl," ",qqwi))_"='"_$P(qqwz,"~",qqwi)_"'"
 ..S qq="UPDATE "_Vt(qqnump,"sql",qqo,"tab")_" SET "_$E(qq,2,32000),error=$ZF(-3,"","PrepareW",Vt(qqnump,"sql",qqo),qq_" where "_Vt(qqnump,"sql",qqo,"qqw",qqwc)_"='"_qqwcz_"'") I error S error="PrepareW="_error_" "_qq Q
 ..K error
 .I $G(qqwc)="" D  Q:$G(error)'=""  ;включение новой записи
 ..S qq="",qqwc="" F qqwi=1:1:$L(qqwl," ") S qqwc=qqwc_","_Vt(qqnump,"sql",qqo,"qqw",$P(qqwl," ",qqwi)),qq=qq _",'"_$P(qqwz,"~",qqwi)_"'"
 ..S qq="INSERT INTO "_Vt(qqnump,"sql",qqo,"tab")_" ("_$E(qqwc,2,32000)_") VALUES ("_$E(qq,2,32000)_")",error=$ZF(-3,"","PrepareW",Vt(qqnump,"sql",qqo),qq) I error S error="PrepareW="_error_" "_qq Q
 ..K error
 .S error=$ZF(-3,"","Execute",Vt(qqnump,"sql",qqo)) I error S error=$ZF(-3,"","DropStatement",Vt(qqnump,"sql",qqo)),Vt(qqnump,"sql",qqo)="" Q  ;S error="Execute="_error_" "_qq Q
 .K error
 I $G(error)="" Q:$Q "" Q
 I $G(Vt(qqnump,"sql",qqo))=""  Q:$Q "" Q
 Q:'$Q  Q "SQLCODE="_$G(SQLCODE)_" "_error
 ;INSERT INTO tab (qqw,) VALUES ('',
]]></Implementation>
</Method>

<Method name="rDel">
<Description>
Удаление поддерева экземпляра qqc объекта qqo.
Для физического дерева $$$GloRef должна существовать.
Если Rel=1, удаление всех экземпляров из перечня релевантных объекта qqo.
Ch=1 - удалить только потомков. В этом случае - lqqoch - список (через пробел) кодов объектов удаляемых потомков. Если не задан - удаляются потомки всех объектов из описания объекта qqo (в CxObj).)

Возвращает 1 - удален только текущий, 2 - удалялись потомки

qqc0 - общая часть удаляемых кодов (в этом случае qqc не учитывается)
qqcond - условие, при выполнении которого производится удаление. qqc0 обязан быть задан (хотя бы "").
savW=1 - не изменять W. Иначе удаляются все W(qqw) для qqw из удаляемых экземпляров
Nolog=1 - блокировка логического удаления (всегда физически удаляется из базы)

Метод может вызываться вне контекста окна. Тогда присваивается qqnump="D". ссылки на классы %qWORD и %TqARM (qW, qARM) должны быть.</Description>
<Internal/>
<FormalSpec>qqo:%String,qqc:%String,Rel:%String=0,Ch:%Library.String=0,lqqoch:%Library.String,qqc0:%Library.String,qqcond:%Library.String,savW:%Library.String,Nolog:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 i $G(qTRAN)&&($tl=0) n qTRAN,qRSLT ts  s qRSLT=..rDel(.qqo,.qqc,.Rel,.Ch,.lqqoch,.qqc0,.qqcond,.savW,.Nolog) tc  q:$Q qRSLT q      ;Vol@sasha 20061026 правка 141206  ;@Pav 20.04.2011
 N qqoo S qqoo=qqo I $E(qqoo)="v" S qqo=$E(qqoo,3,255) ;синоним. Если есть релевантные - перечень релевантных удаляется некорректно для ссылочных
 I $G(qqnump)="" N qqnump S qqnump="D",$$$Tree=0 ;@dol 26.11.03
 I $G($$$Tree) K @$$$GloRef@(qqo,qqc)  Q:$Q "" Q  ;для физического дерева
 I $G(Vo(qqnump,qqoo,2))>2 Q:$G(Vo(qqnump,qqoo,2))'=6 "" S:'$D(Vo(qqnump,qqo,33)) Vo(qqnump,qqo,33)=qARM.GetPar("X533",,qqo),Vo(qqnump,qqo,33)=$S($E(Vo(qqnump,qqo,33),1,2)'="@@":Vo(qqnump,qqo,33),1:qARM.Value($E(Vo(qqnump,qqo,33),3,30000))) D  Q:$Q "" Q
 .I '$D(Vo(qqnump,qqo,243)) S Vo(qqnump,qqo,243)=qARM.GetPar("X5243",,qqo),Vo(qqnump,qqo,248)=qARM.GetPar("X5248",,qqo)
 .I Vo(qqnump,qqo,33)="^Q"||(Vo(qqnump,qqo,33)="^Q(1)") D qARM.Message("qqo="_qqo_" "_"qqc="_qqc_" Попытка удаления массива базы: "_Vo(qqnump,qqo,33),"qW.rDel") Q  ;@Dol 20.07.07
 .I Vo(qqnump,qqo,248)'="" N qqend,qqlw S qqlw="" X Vo(qqnump,qqo,248) I $G(qqend) Q  ;@Dol 19.10.06 триггер ДО
 .K @Vo(qqnump,qqo,33)@(qqc)
 .I Vo(qqnump,qqo,243)'="" N qqlw S qqlw="" X Vo(qqnump,qqo,243)
 I $G(Vo(qqnump,qqoo,2))=1 N qqc1 S qqc1=$P($$$ObjRef(qqoo),",",$L($$$ObjRef(qqoo),",")-1) S qqo=$S($E(qqc1)'="v":qqc1,1:$E(qqc1,3,255)) ;предыдущий объект для встроенного
 N qqrn,end S end=0,qqrn=$S('$G($$$RelNum):"",1:$$$Relind_qview) ;было $P(qview," "))
 I '$G(Nolog),qARM.GetPar("X5222",,qqo)'="",@Vo(qqnump,qqo,222) D  Q:$Q 10 Q  ;@Dol 04.01.06 логическое удаление
 .S ^Q(1,qqo,qqc,"Xd")=$S((($H\(256**2)>0)||($P($H,",")=0)):$C(0,0),1:"")_$RE($E($ZLC($H),1,$S((($H\(256**2)>0)||($P($H,",")=0)):3,1:2)))_$RE($E($ZLC($P($H,",",2)-1),1,3))_$G(quser) ;@ank 20101101 Новый алгоритм запаковки\распаковки дат
 I 'Rel,'$D(qqc0) D rDelT(qqo,qqc,1) Q:$Q end Q  ;для логического дерева
 ;перечень релевантных текущего объекта
 N qql S qql=$S($D(qqc0)&&'Rel:1,qqrn="":1,1:qqrn),qqcond=$G(qqcond),qqc0=$G(qqc0) S:qqcond="" qqcond=1
 S qqc=qqc0 F  S qqc=$O(^Q(qql,qqoo,qqc)) Q:qqc=""  Q:$E(qqc,1,$L(qqc0))'=qqc0  I @qqcond D rDelT(qqo,qqc,1)
 Q:$Q end Q
rDelT(qqo,qqc0,one) ;удаление экземпляров на заданное начало и потомков. Или одного экземпляра с заданным кодом (one=1)
 N qqolst,qqolsti,qqc S qqolst=$S('one:$G(^Q(1,"CxObj",qqo,"xObj")),Ch&&($G(lqqoch)'=""):lqqoch,1:$G(^Q(1,"CxObj",qqo,"xObj"))) ;@dol 6.8.03 объекты-потомки
 S qqc=qqc0 D:one  I 'one  F  S qqc=$O(^Q(1,qqo,qqc)) Q:$E(qqc,1,$L(qqc0))'=qqc0  D
 .I $S(one:'Ch,1:1) D ..rCor(qqo,qqc,"",,,,,$G(savW)) S end='one+1 D:qqrn'=""
 ..I one,qqo'=qqoo N qqo S qqo=qqoo ;не очень удачный вариант разборки с релевантными для синонимов
 ..I $D(^Q(qqrn,qqo,qqc)) K ^(qqc) K:'$I(^Q(qqrn,qqo),-1) ^(qqo)
 F qqolsti=1:1:$L(qqolst," ") D:$P(qqolst," ",qqolsti)'="" rDelT($P(qqolst," ",qqolsti),qqc0,0) ;@dol30.04.03 qqc0 вместо qqc
 Q
]]></Implementation>
</Method>

<Method name="rDelAll">
<Description>
Быстрое удаление всех экземпляров объекта и объектов-потомков (если сh=1)
Nogr=1 - НЕ собирать мусор в словарях - ускоряет работу</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,ch:%Library.String=0,Nogr:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 i $G(qTRAN)&&($tl=0) n qTRAN,qRSLT ts  s qRSLT=..rDelAll(.qqo,.ch,.Nogr) tc  q:$Q "" q   ;Vol@sasha 20061026  ;@Pav 20.04.2011
 N qqolst,qqolsti,qqw,qqz,qqzz,qqgr,qqwi,qqwiL I $D(^Q(1,qqo))>1||1 K ^Q(1,qqo) S qqolst=$G(^Q(1,"CxObj",qqo,"xWoc")) F qqolsti=1:1:$L(qqolst," ") S qqw=$P(qqolst," ",qqolsti) I qqw'="",$S($E(qqw)'="R":"CMY@LXZx"'[$E(qqw),1:"CMYLXZx"'[$E(qqw,3)) D  I $E(qqw)'="T",$G(qqgr) S:qqwi ^Q(1,$S($E(qqw)="D":qqw,1:"C"_qqw))=qqwi I 'qqwi K ^Q(1,qqw) K:$E(qqw)'="D" ^Q(1,"C"_qqw) ;@Dol 10.11.05 счетчик слов закатывался на место последнего кода !!!! и R*-понятия обрабатывались не совсем хорошо (если в объекте определено только R*) ;@Dol 12.01.08 учет R $E(qqw,3)
 .I $E(qqw)="T" D:$E(qqw,1,2)="TB"  Q
 ..K ^QT($E(qqw,2,255),1,qqo) I qqllang'="" F qqwiL=1:1:$L(qqllang," ") I $P(qqllang," ",qqwiL)'="" K ^QT($E(qqw,2,255),$P(qqllang," ",qqwiL),qqo)
 .S:'$G(Nogr) qqgr=+$G(^Q(1,"CxWoc",qqw,"xGrCol")),qqgr=$S($G(^Q(1,"CxWoc",qqw,"Xsys")):0,1:qqgr'=2) ;разрешена сборка мусора
 .S:$E(qqw)="R" qqw=$E(qqw,3,255) S qqz="" F qqwi=0:1 S qqz=$O(^Q(1,qqw,qqz)) Q:qqz=""  K ^Q(1,qqw,qqz,qqo) I '$G(Nogr),qqgr,$D(^Q(1,qqw,qqz))=1 S qqzz=^(qqz) K ^(qqz) S qqwi=qqwi-1 I $E(qqw)'="D",qqzz'="" K ^Q(1,"C"_qqw,qqzz) D:qqllang'=""
 ..F qqwiL=1:1:$L(qqllang," ") I $P(qqllang," ",qqwiL)'="",$D(^Q($P(qqllang," ",qqwiL),"C"_qqw,qqzz)) K:^(qqzz)'="" ^Q($P(qqllang," ",qqwiL),qqw,^(qqzz)) K ^Q($P(qqllang," ",qqwiL),"C"_qqw,qqzz)
 I 'ch Q:$Q "" Q
 S qqolst=$G(^Q(1,"CxObj",qqo,"xObj")) ;объекты-потомки
 F qqolsti=1:1:$L(qqolst," ") D:$P(qqolst," ",qqolsti)'="" ..rDelAll($P(qqolst," ",qqolsti),1,$G(Nogr))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="rDelAllView">
<Description>
Удаление экземпляров всех объектов отображения Arg1</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqo S qqo=-1 F  S qqo=$O(^Q(1,"XView",Arg1,"CxObj",qqo)) Q:qqo=""  D ..rDelAll($S($E(qqo)'="v":qqo,1:$E(qqo,3,255)))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="rDelBeg">
<Description>
Быстрое удаление экземпляров объекта (qqo) на заданное начало (qqc0)
Nogr=1 - НЕ собирать мусор в словарях

Если используются счетчи групп, после метода лучше вызвать qW.qObjNum(qqo) для конкретного объекта или для всех qW.qObjNum()</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqc0:%Library.String,Nogr:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqolst,qqolsti,qqw,qqz,qqzz,qqgr,qqwi,qqwiL,qqc ;I $D(^Q(1,qqo))<10 Q:$Q "" Q ;@Dol 19.07.05 если остался мусор в словарях
 S qqc="" F qqwi=0:1 S qqc=$$$UserOrd(1,qqo,qqc,qqc0) Q:qqc=""  K ^Q(1,qqo,qqc)
 S ^Q(1,qqo)=$G(^Q(1,qqo))-qqwi
 S qqolst=$G(^Q(1,"CxObj",qqo,"xWoc")) F qqolsti=1:1:$L(qqolst," ") S qqw=$P(qqolst," ",qqolsti) I qqw'="",$S($E(qqw)'="R":"CMY@LXZx"'[$E(qqw),1:"CMYLXZx"'[$E(qqw,3)) D  I $E(qqw)'="T",$G(qqgr) S:qqwi ^Q(1,$S($E(qqw)="D":qqw,1:"C"_qqw))=qqwi I 'qqwi K ^Q(1,qqw) K:$E(qqw)'="D" ^Q(1,"C"_qqw) ;@Dol 10.11.05 счетчик слов закатывался на место последнего кода !!!! и R*-понятия обрабатывались не совсем хорошо (если в объекте определено только R*)
 .I $E(qqw)="T" D:$E(qqw,1,2)="TB"  Q
 ..S qqc=qqc0 F  S qqc=$O(^QT($E(qqw,2,255),1,qqo,qqc)) Q:$E(qqc,1,$L(qqc0))'=qqc0  K ^QT($E(qqw,2,255),1,qqo,qqc) 
 ..;I qqllang'="" F qqwiL=1:1:$L(qqllang," ") I $P(qqllang," ",qqwiL)'="" K ^QT($E(qqw,2,255),$P(qqllang," ",qqwiL),qqo)
 .S:'$G(Nogr) qqgr=+$G(^Q(1,"CxWoc",qqw,"xGrCol")),qqgr=$S($G(^Q(1,"CxWoc",qqw,"Xsys")):0,1:qqgr'=2) ;разрешена сборка мусора
 .S:$E(qqw)="R" qqw=$E(qqw,3,255) S qqz="" F qqwi=0:1 S qqz=$O(^Q(1,qqw,qqz)) Q:qqz=""  D
 ..S qqc=qqc0 F  S qqc=$O(^Q(1,qqw,qqz,qqo,qqc)) Q:$E(qqc,1,$L(qqc0))'=qqc0  K ^Q(1,qqw,qqz,qqo,qqc)
 ..I '$G(Nogr),qqgr,$D(^Q(1,qqw,qqz))=1 S qqzz=^(qqz) K ^(qqz) S qqwi=qqwi-1 I $E(qqw)'="D",qqzz'="" K ^Q(1,"C"_qqw,qqzz) ;D:qqllang'=""
 ..;F qqwiL=1:1:$L(qqllang," ") I $P(qqllang," ",qqwiL)'="",$D(^Q($P(qqllang," ",qqwiL),"C"_qqw,qqzz)) K:^(qqzz)'="" ^Q($P(qqllang," ",qqwiL),qqw,^(qqzz)) K ^Q($P(qqllang," ",qqwiL),"C"_qqw,qqzz)
 ;I 'ch Q:$Q "" Q
 S qqolst=$G(^Q(1,"CxObj",qqo,"xObj")) ;объекты-потомки
 F qqolsti=1:1:$L(qqolst," ") D:$P(qqolst," ",qqolsti)'="" ..rDelBeg($P(qqolst," ",qqolsti),qqc0,$G(Nogr))
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="rDelTree">
<Description>
Удаление поддерева экземпляра qqcH объекта qqoH.
Если Rel=1, удаление всех экземпляров из перечня релевантных объекта qqoH.
Ch=1 - удалить только потомков

Информация о процессе удаления в ^mtempKill($j,"ATime")</Description>
<Internal/>
<FormalSpec>qqoH:%String,qqcH:%String,Rel:%String=0,Ch:%Library.String=0</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 n startH0 s startH0=$h
 k ^mtempKill($j)
 s ^mtempKill($j,"ATime")="Идет удаление экземпляров..."

 n sppon,ip,pond,codd,izn,zni,zn
 ;Удаление поддерева одного экземпляра
 i $g(Rel)'=1
 {
 ;Удаляем экземпляры объектов нижнего уровня
 d delObj(qqoH)
 ;Удаляем текущий экземпляр
 d:$g(Ch)'=1 clear(qqoH,qqcH)
 }

 ;Удаление по релевантным  
 i $g(Rel)=1 
 {
 ;Удаляем экземпляры объектов
 n qqcR,delE s qqcR=""
 f  {
 s qqcR=$o(^Q(Vs(qqnump,"Relind")_qview,qqoH,qqcR))
 q:qqcR=""
 s qqcH=qqcR
 d delObj(qqoH)
 d:$g(Ch)'=1 clear(qqoH,qqcH)
 s ^mtempKill($j,"ATime")="Идет удаление релевантных..."_"Удалено "_$i(delE)_" из "_$g(^Q(Vs(qqnump,"Relind")_qview,qqoH))
 }
 }

 s ^mtempKill($j,"ATime",1)="Время удаления "_$$time(startH0,$h)

 ;Удаление по временному массиву
 n startH1 s startH1=$h
 d delM()
 s ^mtempKill($j,"ATime",2)="Время удаления ссылок "_$$time(startH1,$h)

 s ^mtempKill($j,"ATime")="ОК! за "_$$time(startH0,$h)

 q ""

delObj(Obj) ;Удаляем экземпляры объектов
 n qqcDel   
 s qqcDel=qqcH
 f  {
 s qqcDel=$o(^Q(1,Obj,qqcDel))
 q:(qqcDel="")!($e(qqcDel,1,$g(^Q(1,"CxObj",qqoH,"X50")))'=qqcH) 
 ;Формируем массив удаления для словарей и удаляем экземпляр
 d clear(Obj,qqcDel)
 }

 n tree,it 
 s tree=$g(^Q(1,"CxObj",Obj,"xObj"))
 q:tree="" ""
 f it=1:1:$l(tree," ") d delObj($p(tree," ",it))
 q ""

clear(ObjLd,qqcObjLd)
 ;s ^mtempKill($j,"Kill",$na(^Q(1,ObjLd,qqcObjLd)))="",^mtempKill($j)=$i(^mtempKill($j))
 ;s ^Q(1,ObjLd)=(^Q(1,ObjLd)-1) 
 ;Обходим понятия данного объекта
 s sppon=$g(^Q(1,"CxObj",ObjLd,"xWoc"))
 f ip=1:1:$l(sppon," ") 
 {
 s pond=$p(sppon," ",ip)
 i pond'=""
 {
 s codd=$g(^Q(1,ObjLd,qqcObjLd,pond))
 i codd'=""
 {
 f izn=1:1:$l(codd," ")
 {
 s zni=$p(codd," ",izn)
 i zni'=""
 {
 ;Если некодируемое        
 i $e(pond)="D" s ^mtempKill($j,"Kill",$na(^Q(1,pond,zni,ObjLd,qqcObjLd)))="",^mtempKill($j)=$i(^mtempKill($j))
 ;Если кодируемое понятие
 e  s zn=$g(^Q(1,"C"_pond,zni)) i zn'="" s ^mtempKill($j,"Kill",$na(^Q(1,pond,zn,ObjLd,qqcObjLd)))="",^mtempKill($j)=$i(^mtempKill($j))
 }
 }
 }
 }  
 }
 ;Удаляем экземпляр
 k ^Q(1,ObjLd,qqcObjLd) s ^Q(1,ObjLd)=(^Q(1,ObjLd)-1)

 q ""


delM()  
 k delE s r=""
 f  {
 s r=$o(^mtempKill($j,"Kill",r))
 q:r=""
 k @r
 s ^mtempKill($j,"ATime")="Идет удаление ссылок..."_"Удалено "_$i(delE)_" из "_^mtempKill($j)
 }
 k ^mtempKill($j,"Kill")
 q ""

time(startH,endH)
 n period,day,min,sek,ost,chas
 q:$g(startH)="" ""
 s:$g(endH)="" endH=$h
 s sek=($p(endH,",")*3600*24)+$p(endH,",",2)-(($p(startH,",")*3600*24)+$p(startH,",",2))
 s chas=sek\3600
 s ost=sek#3600
 s min=ost\60
 s sek=ost#60
 q $s($l(chas)=1:"0"_chas,1:chas)_":"_$s($l(min)=1:"0"_min,1:min)_":"_$s($l(sek)=1:"0"_sek,1:sek)
]]></Implementation>
</Method>

<Method name="rIncM">
<Description>
Добавить к M* -понятию (!!!) qqw экземпляра объекта qObj с кодом qqct значение Zadd и вернуть полученный результат.
Если Zadd не задано - то +1
Если qqct не задано, то вычисляется
Если qObj не задано - текущий.
!!! Дата/времякоррекции не изменяются
nominus=1 не допускать отрицательных значений при ВЫЧИТАНИИ
Возвращается: Zadd - если столько можно отнять или сколько можно отнять до 0</Description>
<Internal/>
<FormalSpec>qqw:%Library.String,Zadd:%Library.String,qObj:%Library.String,qqct:%Library.String,nominus:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N ret I $E(qqw)'="M" Q:$Q "" ;только для M*-понятий
 S:'$D(qObj) qObj=$G(qqo) S:'$D(Zadd) Zadd=1 G:$G(qqct)'="" rIncMend I $G(Vs(qqnump,"Virt",qObj))'="" S qqct=Vs(qqnump,"Virt",qObj) G rIncMend
 D:'$D($$$ObjLqqc(qObj)) qARM.GetPar("X50",,qObj) S qqct=$E(qqc,1,$$$ObjLqqc(qObj))
rIncMend S ret=$I(^Q(1,qObj,qqct,qqw),Zadd) Q:'$G(nominus)||(Zadd>0) ret Q:ret'<0 -Zadd
 S ret=-ret,Zadd=-Zadd I ret>Zadd S ret=$I(^Q(1,qObj,qqct,qqw),Zadd) Q 0 ;уже был минус
 I $I(^Q(1,qObj,qqct,qqw),ret) ;будет 0 и если даже не ноль - ничего страшного (см. строку выше)
 Q Zadd-ret ;столько реально можно отнять
]]></Implementation>
</Method>

<Method name="rIns">
<Description>
Вставка в объекте Arg1 нового экземпляра после кода Arg2. РАБОТАЕТ ТОЛЬКО ДЛЯ ЯВНО ОПРЕДЕЛЕННЫХ СПОСОБОВ ФОРМИРОВАНИЯ КОДА (x534 задано или пусто - тогда 52)
Возвращает новый код или пусто, если ошибка
Nomes=1 - не выдавать сообщений
Arg3=1 - вставить перед текущим
Arg4 - qqci в массиве Vc(qqnump). если задан, то правка Vc. !!! ИНАЧЕ ПОСЛЕ rIns НУЖЕН ПЕРЕВЫВОД!!!</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Nomes:%Library.String,Arg3:%Library.String,Arg4:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqco,qqcc,qqi,qqi0,qqib,qqie,qqoo G:$G(Vo(qqnump,Arg1,2))>2 rInsEr1
 S qqoo=Arg1 S:$E(Arg1)="v" Arg1=$E(Arg1,3,255) S:$G(Vo(qqnump,Arg1,0))="" Vo(qqnump,Arg1,0)=$$$ObjLget(Arg1) G:$$$ObjLqqc(Arg1)=255 rInsEr1
 G:$$$ObjLqqc(Arg1)'=$L(Arg2) rInsEr2 S qqco=$G(^Q(1,"CxObj",Arg1,"XORef")),qqco=$P(qqco,",",$L(qqco,",")-1) S:qqco'="" qqco=$E(Arg2,1,$$$ObjLget(qqco)) ;код вершины
 S qqi=$E(Arg2,$L(qqco)+1,255),qqi0=$L(qqi),qqib=..CodObj(Arg1,qqi,1)+$S('$G(Arg3):1,1:0) F qqi=qqib:1:$S(Vo(qqnump,Arg1,34):Vo(qqnump,Arg1,34),1:52)**qqi0 S qqcc=qqco_..CodObj(Arg1,qqi,0,qqi0) I '$D(^Q(1,Arg1,qqcc)) S qqie=qqi Q
 I '$G(qqie) D:'$G(Nomes) qARM.Message("Исчерпан диапазон кодов") Q:$Q "" Q
 I $P(..rNew(Arg1,qqcc)," ")'=qqcc D:'$G(Nomes) qARM.Message("Введен новый код другим пользователем") Q:$Q "" Q
 I '$G(Arg3),qqib+1=qqie Q qqcc  ;@Dol 22.05.08 'Arg3
 F qqi=qqie:-1:qqib+1 S qqcc=qqco_..CodObj(Arg1,qqi-1,0,qqi0) D ..rCopyTree(Arg1,qqco_..CodObj(Arg1,qqi,0,qqi0),Arg1,qqcc,"",0)
 D ..rDel(Arg1,qqcc,,1),..rCor(Arg1,qqcc,"*")
 I $G(Arg4)'="" D   ;@Dol 21.05.08 Правка Vc
 .N qqci,qqcce,qqcii,qqccc S qqcce=qqco_..CodObj(Arg1,qqie,0,qqi0) ;последний преобразованный код
 .S qqci=Arg4 F  S qqci=$O(Vc(qqnump,qqci_"яяяяяяяяяяяяя")) Q:qqci=""  Q:Vc(qqnump,qqci,0)'=qqoo  S qqccc=Vc(qqnump,qqci) Q:qqccc]qqcce  S Vc(qqnump,qqci)=qqco_..CodObj(Arg1,..CodObj(Arg1,$E(qqccc,$L(qqco)+1,255),1)+1,0,qqi0) D
 ..S Vc(qqnump,qqci,5)=$G(^Q(1,Arg1,Vc(qqnump,qqci),"X"))
 ..S qqcii=qqci F  S qqcii=$O(Vc(qqnump,qqcii)) Q:$E(qqcii,1,$L(qqci))'=qqci  I $E(Vc(qqnump,qqcii),1,$L(qqccc))=qqccc S $E(Vc(qqnump,qqcii),1,$L(qqccc))=Vc(qqnump,qqci),Vc(qqnump,qqcii,5)=$G(^Q(1,$S($E(Vc(qqnump,qqcii,0))="v":$E(Vc(qqnump,qqcii,0),3,255),1:Vc(qqnump,qqcii,0)),Vc(qqnump,qqcii),"X"))
 Q:$Q qqcc Q
rInsEr1 D:'$G(Nomes) qARM.Message("Только для хранимых объектов с фиксированной длиной кода") Q:$Q "" Q
rInsEr2 D:'$G(Nomes) qARM.Message("Длина кода экземпляра не соответствует требуемой по описанию") Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="rJrn">
<Description>
Восстановление журнала.
mas - ссылка на запись в журнале. если число - ^QJ(1,"XJrn",число)
all=1 - восстановление всего массива. в этом случае mas - ссылка на массив.</Description>
<Internal/>
<FormalSpec>mas:%Library.String,all:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N com,qqc,qqo,quser,qqnump,qJRN S qqnump="J"  ;"J" - псевдо-окно для локальной среды восстановления журнала, N qJRN - защита от журналирования
 I mas=+mas S mas="^QJ(1,""XJrn"","_mas_")" ;если число
 ;;misuno 20080806
 //флаг восстановления пользовательского журнала $G(^Q(1,"XBase",0,XFJRUser),0)
 S fJRUser=$G(qqXFJRUser) 
 
 S:'$D(qqllang) qqllang=$G(^Q(1,"XBase",0,"xLang")),qqlang=$S(qqllang="":1,1:$P(qqllang," ")) ;список поддерживаемых языков (через пробел) qqlang ;основной язык (Q(qqlang, ссылка на словари)
 I '$G(all) S all=$$rJrnD() Q:$Q "" Q
 S mas=$E(mas,1,$L(mas)-1)_",all)",all="" F  S all=$O(@mas) Q:all=""  I $$rJrnD()
 Q:$Q "" Q
rJrnD() S com=@mas@("XJcom"),qqc=@mas@("XJC"),qqo=@mas@("xObj"),quser=@mas@("XJu")
 I '$D(Vo(qqnump,qqo)) S $$$Tree=0,Vo(qqnump,qqo)=$G(^Q(1,"CxObj",qqo,"X50"),255),Vo(qqnump,qqo,32)=+$G(^Q(1,"CxObj",qqo,"x532")),Vo(qqnump,qqo,36)="",Vo(qqnump,qqo,37)="" ;длина кода и признак записи даты создания и коррекции
 ;;misuno 20080806 Вызов метода восстановления пользовательского журнала
 S qJRN=1
 I fJRUser=1 D rJrnU
 I '$G(qJRN) Q:$Q "" Q
 
 I com="N" D ..rNew(qqo,qqc,,@mas@("XJdt")) Q "" ;новый экземпляр (пока без контроля на существование???)
 I com="K" D ..rCor(qqo,qqc,"",0,,@mas@("XJdt")) Q "" ;удаление
 N qqw,qqlw,qqwi S qqlw=@mas@("xWoc") Q:qqlw="" "" F qqwi=1:1:$L(qqlw," ") S qqw=$P(qqlw," ",qqwi) K W(qqw) M W(qqw)=@mas@("Xnew",1,qqw)
 D ..rCor(qqo,qqc,qqlw,0,,@mas@("XJdt")) Q "" ;коррекция
rJrnU
 //Восстановление пользовательского журнала misuno 20080806
 N method S method=$G(^Q(1,"XBase",0,"XMJRUser")) Q:method=""
 S method=$P(method,"(")
 X "D "_method_"("""_com_""","""_qqo_""","""_qqc_""","""_@mas@("XJdt")_""")" Q
]]></Implementation>
</Method>

<Method name="rNew">
<Description>
Запись нового экземпляра объекта.
функция добавляет +шаг к коду qqpar1. A-z -диапазон цифр кода -------
Arg1 - код объекта.
Arg2 - желаемый код экземпляра (можно задавать код объекта предыдущего уровня)
Arg3 - шаг кода (если не задан, то проверка отсутствия желаемого)
NoVir=1 - игнорировать виртуальность объекта (используется в преобразовании - метод qW.qObjConv)
Возвращает новый код и, через пробел, код, к которому добавлен шаг</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%String,Arg3:%String,Hrolog:%Library.String,NoVir:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    /*
    20110407 kokarev - (1) qqnump = "N" при вызове метода вне контекста окна (по аналогии с rDel)
                       (2) вызов $$$Tree заменен на $g($$$Tree)
    */
 i $G(qTRAN)&&($tl=0) n qTRAN,qRSLT ts  s qRSLT=..rNew(.Arg1,.Arg2,.Arg3,.Hrolog,.NoVir) tc  q:$Q qRSLT q   ;Vol@sasha 20061026  ;@Pav 20.04.2011
 N fJUser S fJUser=$G(qqXFJUser) ;@Dol 16.11.04 $G(^Q(1,"XBase",0,"XFJUser"),0)  // флаг формирования пользовательского журнала - TDV 06.09.2004
 N qqcpre,qqcl,qqc2,Arg2beg,qqoo,q36,q37 S qqoo=Arg1,Arg2=$TR(Arg2," ") I $E(qqoo)="v" N:0 Arg1 S Arg1=$E(qqoo,3,255) ;синоним
 I $G(qqnump)="" N qqnump S qqnump="N",$$$Tree=0 ;20110407 kokarev (1)
 ;
 S:'$D(Vo(qqnump,Arg1,34)) Vo(qqnump,Arg1,34)=$G(^Q(1,"CxObj",Arg1,"x534")) ;@Dol 03.09.08 x534 - основание исчисления
 S:'$D(Vo(qqnump,Arg1,243)) Vo(qqnump,Arg1,243)=qARM.GetPar("X5243",,Arg1),Vo(qqnump,Arg1,248)=qARM.GetPar("X5248",,Arg1)
 I Vo(qqnump,Arg1,248)'="" N qqend,qqendRet D  I $G(qqend) Q:$Q $g(qqendRet) Q  ;@Dol 29.05.06 триггер ДО
 .N qqc,qqo,qqlw,qqlwmod S qqlw="-",qqlwmod="",qqc=Arg2,qqo=Arg1 X Vo(qqnump,Arg1,248)
 .S Arg2=$G(qqc) ; tdv 22.02.2007 в триггере ДО можно поменять qqc
 ;
 I '$G(NoVir),$G(Vo(qqnump,qqoo,2))>2 Q:$G(Vo(qqnump,qqoo,2))'=6 Arg2 S:'$D(Vo(qqnump,qqoo,33)) Vo(qqnump,qqoo,33)=qARM.GetPar("X533",,qqoo) S:Arg2[" " Arg2=$O(@Vo(qqnump,qqoo,33)@(""),-1)+1 S @Vo(qqnump,qqoo,33)@(Arg2)="" D:$G(Vo(qqnump,Arg1,243))'=""  Q Arg2 ;???? для виртуальных типа массив ;@Dol 19.04.05 Arg2[" "
 .N qqc,qqo,qqlw,qqlwmod S qqlw="-",qqlwmod="",qqc=Arg2,qqo=Arg1 X Vo(qqnump,Arg1,243) ;@Dol 19.10.06 триггер После для массивов
 I $G(Vo(qqnump,qqoo,2))=1 S qqc1=$P($$$ObjRef(qqoo),",",$L($$$ObjRef(qqoo),",")-1) S Arg1=$S($E(qqc1)'="v":qqc1,1:$E(qqc1,3,255)) ;предыдущий объект для встроенного
 S Arg2beg=$G(Arg2) ;временно, чтобы корректно задать поиск последнего кода. см. I qqc2="",$L(Arg2beg)<$L(Arg2) S qqc2=Arg2beg
 D:'$g($$$Tree)
 .S:'$D(Vo(qqnump,qqoo,32)) Vo(qqnump,qqoo,32)=+qARM.GetPar("x532",,qqoo) D:'$D(Vo(qqnump,qqoo,36)) qARM.GetPar("X536",,qqoo),qARM.GetPar("X537",,qqoo) S:'$D(Vo(qqnump,Arg1,247)) Vo(qqnump,Arg1,247)=$G(^Q(1,"CxObj",Arg1,"X5247")) ;@Dol 20/03/06 счетчик поддеревьев ;..rX5247(Arg1,+1)
 .S qqcl=$S($D($$$ObjLqqc(qqoo))#2:$$$ObjLqqc(qqoo),1:$G(^Q(1,"CxObj",Arg1,"X50"),255)) ;длина кода (????для синонима наследуется от основного объекта)
 .S q36=Vo(qqnump,qqoo,36) S:$E(q36)="@" q36="q36="_$E(q36,2,30000),@q36 S q37=Vo(qqnump,qqoo,37) S:$E(q37)="@" q37="q37="_$E(q37,2,30000),@q37 ;@dol 27.04.03
 .D:q36'=""
 ..S:$E(q36)="*" q36=$E(Arg2,1,$L(q36,"*")-1)_$TR(q36,"*")
 ..S:$E(q37)="*" q37=$E(Arg2,1,$L(q37,"*")-1)_$TR(q37,"*")
 ..I $L(Arg2)<$L(q36) S Arg2=q36,Arg3=0 Q  ;переустановка начального кода, если он короче @dol 27.04.03 Arg3=0 - чтобы можно было задать код через диапазон
 ..I q36]]Arg2 S Arg2=q36,Arg3=0 Q  ;переустановка начального кода, если он перед диапазоном
 .I q37'="",Arg2'="",Arg2]](q37_"я") S Arg2=q36,Arg3=0 ;D gadderr ;начальный код за границей диапазона
 .I qqcl'=255,$L(Arg2)'=qqcl S Arg2=$E(Arg2,1,qqcl),Arg2=Arg2_$TR($J("",qqcl-$L(Arg2))," ","A")
 ;oldlock ;ZA @$S('$$$Tree:$NA(^Q(1,Arg1)),1:$NA(@$$$GloRef@(Arg1))):20 ;вроде можно и не так грубо???
 ;oldlock ;S Arg3=+$G(Arg3),qqcpre=Arg2 S:Arg2="" Arg2=0 I 'Arg3 G gaddend:$S('$$$Tree:'$D(^Q(1,Arg1,Arg2)),1:'$D(@$$$GloRef@(Arg1,Arg2))) S:'Arg3 Arg3=1
 S Arg3=+$G(Arg3),qqcpre=Arg2 S:Arg2="" Arg2=0 I 'Arg3 ZA ^Q(1_Arg1_" "_Arg2):0 G:$T gaddend:$S('$g($$$Tree):'$D(^Q(1,Arg1,Arg2)),1:'$D(@$$$GloRef@(Arg1,Arg2))) L -^Q(1_Arg1_" "_Arg2)#"I" S:'Arg3 Arg3=1 ;newlock
 ;
 N i,%,qqcnum S qqcnum=$S(Arg2?1.N:1,Arg2?1E1.N:2,1:0)
gaddbeg D
 .I qqcnum S Arg2=$S(qqcnum=1:Arg2+Arg3,1:$E(Arg2)_$TR($J($E(Arg2,2,255)+Arg3,$L(Arg2)-1)," ",0)) Q
 .I Vo(qqnump,Arg1,34)>52 D:'$D(qqc2) rNewqqc2 S qqcpre=$E(Arg2,$L(qqc2)+1,2550),Arg2=qqc2_$S(Vo(qqnump,Arg1,34)>116:..Cod154(qW.Cod154(qqcpre,1)+1,0,$L(qqcpre)),1:..Cod116(qW.Cod116(qqcpre,1)+1,0,$L(qqcpre))) Q  ;@Dol 03.09.08 x534 - основание исчисления ;sasha 20080904 (.. заменено на qW., для компиляции в версиях каше младше 5.
 .F i=$L(Arg2):-1:1 S %=$A(Arg2,i)+Arg3,Arg3=1,$E(Arg2,i)=$C($S(%<91:%,%<97:97,%>122:65,1:%)) Q:%'>122  I i=1 S Arg2="A"_Arg2 Q
 ;
 ;oldlock ;G:$S('$$$Tree:'$D(^Q(1,Arg1,Arg2)),1:'$D(@$$$GloRef@(Arg1,Arg2))) gaddend
 ZA ^Q(1_Arg1_" "_Arg2):0 I $T G:$S('$g($$$Tree):'$D(^Q(1,Arg1,Arg2)),1:'$D(@$$$GloRef@(Arg1,Arg2))) gaddend L -^Q(1_Arg1_" "_Arg2)#"I" ;newlock
 ;
 I $g($$$Tree) S (qqcpre,Arg2)=$O(@$$$GloRef@(Arg1,qqcpre),-1) G gaddbeg
 D:'$D(qqc2) rNewqqc2
 S qqcpre=qqc2_"я" I Arg2]]qqcpre D gadderr Q ""
 S (Arg2,qqcpre)=$O(^Q(1,Arg1,qqcpre),-1) I qqcl=255,$E(q36)'="",$E($G(Vo(qqnump,qqoo,36)))="*" S (Arg2,qqcpre)=$E(Arg2,1,$L(q36)) ;@Dol 22.05.05 неявная длина кода
 I qqcl'=255,$L(Arg2)'=qqcl S Arg2=$E(Arg2,1,qqcl),Arg2=Arg2_$TR($J("",qqcl-$L(Arg2))," ","A") ;@Dol 5.12.06 доп.контроль
 G gaddbeg
 ;S qqcpre=$S($$$Tree:"",qqcnum=1:"99999999999999",1:$E(Arg2,1,$L(Arg2)-1)_$C(255)),(qqcpre,Arg2)=$S('$$$Tree:$O(^Q(1,Arg1,qqcpre),-1),1:$O(@$$$GloRef@(Arg1,qqcpre),-1)) G gaddbeg
gaddend K qqtime I '$g($$$Tree)  D  L -^Q(1_Arg1_" "_Arg2)#"I" I $I(^Q(1,Arg1))!1 D:Vo(qqnump,Arg1,247)'="" ..rX5247(Arg1,+1,Arg2) Q:(fJUser=0&&'$G(qJRN))||("X"=$E(Arg1))||("Cx"=$E(Arg1,1,2)) Arg2_" "_qqcpre S:$G(Hrolog)="" Hrolog=$H D:fJUser=1 rNewJrnU S:$G(qJRN)=1 ^QJ(1,"XJrn",$I(^QJ(1,"XJrn")),"XJC")=Arg2,^("xObj")=Arg1,^("XJu")=quser,^("xObj")=Arg1,^("XJcom")="N",^("XJdt")=Hrolog Q Arg2_" "_qqcpre ;журналирование для несистемных объектов ;oldlock ZD ^Q(1,Arg1)
 .D
 ..I Vo(qqnump,qqoo,32)=3 S ^(Arg2)="" Q  ;нет коррекци, создания
 ..I Vo(qqnump,qqoo,32)+1\2=1 S:$G(Hrolog)="" Hrolog=$H S ^(Arg2,"Xc")=$S(((Hrolog\(256**2)>0)||($P(Hrolog,",")=0)):$C(0,0),1:"")_$RE($E($ZLC(Hrolog),1,$S(((Hrolog\(256**2)>0)||($P(Hrolog,",")=0)):3,1:2)))_$RE($E($ZLC($P(Hrolog,",",2)),1,3))_$G(quser) Q  ;;@ank 20101101 Новый алгоритм запаковки\распаковки дат ;есть создание
 ..S ^(Arg2,"X")="" ;только коррекция
 .I $G(Vo(qqnump,Arg1,243))'="",Vo(qqnump,Arg1,243)["(" N qqc,qqo,qqlw,qqlwmod S qqlw="-",qqlwmod="",qqc=Arg2,qqo=Arg1 X Vo(qqnump,Arg1,243) ;@Dol 04.05.06 триггер После
 S ^(Arg2)="" L -^Q(1_Arg1_" "_Arg2)#"I" Q:$I(@$$$GloRef@(Arg1)) Arg2_" "_qqcpre ;oldlock ZD @$NA(@$$$GloRef@(Arg1))
 ///выделение фрагмента вершины
rNewqqc2 I q37'="" S qqc2=q37 Q
 I $G(Vo(qqnump,qqoo,2))=2,'$D(Vt(qqnump,529,qqoo)),$G(Vo(qqnump,qqoo,29))'="",$P(Vo(qqnump,qqoo,29)," ")'["(" D  Q  ;обработка для некоторых вариантов ссылочных (для остальных - что получится???)
 .I $P(Vo(qqnump,qqoo,29)," ",2)'="" N qqc,qqo S qqc=Arg2,qqo=qqoo,@("qqc2="_$P(Vo(qqnump,qqoo,29)," ",2,255)) Q  ;@dol 10.02.03 было $P(Vo(qqnump,qqo,29)," ",2)'=""
 .N qqcc1 S qqcc1=$P(Vo(qqnump,qqoo,29)," ") S:'($D($$$ObjLqqc(qqcc1))#2) $$$ObjLqqc(qqcc1)=$G(^Q(1,"CxObj",qqcc1,"X50"),255) S qqc2=$E(Arg2,1,$$$ObjLqqc(qqcc1)) ;длина кода
 ;S qqc2=$S($G(Vo(qqnump,qqoo,2))'=2:$G($$$ObjRef(qqoo),-1),1:$G(^Q(1,"CxObj",Arg1,"XORef"),-1)),qqc2=$S(qqc2=-1:"",qqc2'[",":"",1:$E(Arg2,1,$$$ObjLget($P(qqc2,",",$L(qqc2,",")-1)))) I qqc2="",$L(Arg2beg)<$L(Arg2) S qqc2=Arg2beg ;@Dol 10.04.05 исправлена ошибка при вводе ссылочных
 S qqc2=$G(^Q(1,"CxObj",Arg1,"XORef"),-1),qqc2=$S(qqc2=-1:"",qqc2'[",":"",1:$E(Arg2,1,$$$ObjLget($P(qqc2,",",$L(qqc2,",")-1)))) I qqc2="",$L(Arg2beg)<$L(Arg2) S qqc2=Arg2beg ;@Dol 03.09.08 - объект вершины из описания 
 Q
rNewJrnU
 // формирование пользовательского журнала - TDV 30.08.2004; удалена проверка существования метода - TDV - 20.01.2005
 N method S method=$G(^Q(1,"XBase",0,"XMJUser")) Q:method=""
 S method=$P(method,"(")
 X "D "_method_"(""N"","""_Arg1_""","""_Arg2_""","""_Hrolog_""")"
 Q
gadderr D qARM.Message("qW.rNew. Исчерпан диапазон кодов qqo="_Arg1_" qqc="_Arg2_" (относительно "_qqcpre_")") Q
 ;!!!
 ;!!! для ввода нового экземпляра объекта, не существующего в текущем отображении оставлен старый вариант формирования последего кода. См. $G($$$ObjRef(Arg1),-1)
]]></Implementation>
</Method>

<Method name="rNewPr">
<Description>
Недиалоговое порождение поддерева экземпляра объекта.
qqo - код объекта
qqc - код экземпляра  текущего или верхнего уровня.
Num - кол-во порождаемых (если пусто, то сколько указано в описании объекта)
NoVer=1 - не выполнять проверку перед вводом.
Возвращает код порожденного экземпляра (вершины поддерева) или пусто, если не прошла
проверка.
qqwchg - список (через пробел) кодов вводимых понятий. Соответствующие значения из W
в этом случае попадут в первую (!!!) запись.
viewpr - отображение ввода. Если задано, то описания типов порождения объектов берутся
из него. Если viewpr="XXXsysO" то описание объекта qqo берется из описания структуры базы.

HrologPr - желаемые дата, время в формате $Hrolog. Если не заданы - текущие
При задании qqc НЕ забывать о возможных отсутствующих уровнях. Необходимо задать
именно код физически предыдущего уровня (или любой код текущего).</Description>
<Internal/>
<FormalSpec>qqo:%String,qqc:%String,Num:%String=1,NoVer:%String=1,qqwchg:%String,viewpr:%String,HrologPr:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 s:$g(viewpr)="XXXsysO" viewpr="XXXsysO"_$g(qqo)    ;@pav 20070309
 i $G(qTRAN)&&($tl=0) n qTRAN,qRSLT ts  s qRSLT=..rNewPr(.qqo,.qqc,.Num,.NoVer,.qqwchg,.viewpr,.HrologPr) tc  q:$Q qRSLT q       ;Vol@sasha 20061026  ;@Pav 20.04.2011
 N qnumber,qqtime
 I $D(viewpr) N qqnumpold S qqnumpold=$G(qqnump,"?") N qqnump S qqnump="P" K Vs(qqnump) D  S Vs(qqnump,"Relind")=+$G(Vs(qqnumpold,"Relind")),Vs(qqnump,"ReFind")=+$G(Vs(qqnumpold,"ReFind")),Vs(qqnump,"RelNum")=+$G(Vs(qqnumpold,"RelNum")) ;@Dol 16.05.06 qview
 .I $E(viewpr,4,6)="sys" D qSYS.sysView($E(viewpr,4,7),$E(viewpr,8,255)) Q
 .D qSYS.CreVo(viewpr,1)
 S qnumber=$S(Num="":qARM.GetPar(520,,qqo),1:Num) ;количество объектов
 I 'NoVer I qARM.RecVer(1,qqo)'="" Q:$Q "" Q  ;правило проверки перед вводом
 S:qnumber="" qnumber=1 F qnumber=1:1:qnumber D
 .S qqc=$P(..rNew(qqo,qqc,0,$G(HrologPr))," ")
 .D qARM.RecNewD(qqo,qqc)
 .D qARM.RecNewP(qqo,"",qqc,1)
 Q:$Q qqc Q
]]></Implementation>
</Method>

<Method name="rSort">
<Description>
Пересортировка поддерева экземпляров объекта qqo. !!! ПЕРЕДЕЛАН @Dol 14.02.09 !!!
qqctop - код экземпляра обьекта верхнего уровня
qqwsort - код понятия (объекта qqo) по которому делается пересортировка
qXc=1 - менять дату коррекции на значение понятия qqwsort (оно обязано быть нормализованной датой).
Beg=1 - переместить коды экземпляра "в начало" (относительно qqctop) и убрать дырки !!! ЕСЛИ КОДИРОВКА ОБЪЕКТА ЯВНО ЗАДАНА. Если не установлен, коды пересортированных объектов сдвигаются за последний существующий.
!!! Beg=2 - убрать все "дырки" !!! ЕСЛИ КОДИРОВКА ОБЪЕКТА ЯВНО ЗАДАНА
order=-1 обратная сортировка
Возвращает:
"" - нечего сортировать
0  - все и так в правильном порядке
число - номер экземпляра, с которого произведено переупорядочивание

Если текущий объект (qqo=$$$CurObj), то текущеее значение qqc изменяется на новое (полученное в результате пересортировки)
Метод пригоден для использования в постдействии, например:
D:qW.rSort($E(qqc,1,7),174,"pAE",1) qARM.wcre()</Description>
<Internal/>
<FormalSpec>qqctop:%Library.String,qqo:%Library.String,qqwsort:%Library.String,qXc:%Library.String=0,Mas:%Library.String,Beg:%Library.String,order:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqcs,qqz,qqflg,qqcnew,qqci,qqcsav,qqdt,qqctop1 S:$E(qqo)="v" qqo=$E(qqo,3,255)
 ;S qqctop1=$G(^Q(1,"CxObj",qqo,"XORef")),qqctop1=$P(qqctop1,",",$L(qqctop1,",")-1) S:qqctop1'="" qqctop1=$E(qqc,1,$$$ObjLget(qqctop1)) ;код вершины
 ;;sas 20090415, если qqc="" просто переприсваиваю qqctop1=$G(qqctop)  
 i $G(qqc)'="" S qqctop1=$G(^Q(1,"CxObj",qqo,"XORef")),qqctop1=$P(qqctop1,",",$L(qqctop1,",")-1) S:qqctop1'="" qqctop1=$E(qqc,1,$$$ObjLget(qqctop1)) ;код вершины
 s:$G(qqc)="" qqctop1=$G(qqctop)
 I $D(qqctop),qqctop'=qqctop1 D qARM.Message("qW.rSort Несовпадение заданной вершины поддерева сортировки ( "_qqctop_" ) с требуемой по описанию объекта ( "_qqctop1_" )") Q:$Q "" Q  ;@Dol 14.02.09
 I '$D(qqctop) S qqctop=qqctop1
 S qqcsav=$S($G($$$CurObj)=qqo:$G(qqc),1:"") ;чтобы вернуть правильный (новый) qqc 
 S:$G(Mas)="" Mas="qTmP" K @Mas
 ;сортировка (qqcnew - последний код)
 S qqflg=0,qqcs=qqctop F qqci=1:1 S qqcs=$O(^Q(1,qqo,qqcs)) Q:qqcs=""  Q:$E(qqcs,1,$L(qqctop))'=qqctop  S qqcnew=qqcs,qqz=..GG(qqo,qqwsort,qqcs) S:qqz="" qqz="???" S @Mas@(qqz,qqcs)=qqci
 I '$D(@Mas) Q:$Q "" Q  ;нечего сортировать
 S qqz="",qqci=0 F  Q:qqflg  s qqz=$O(@Mas@(qqz),$s($g(order)=-1:-1,1:1)) Q:qqz=""  S qqcs="" F  s qqcs=$O(@Mas@(qqz,qqcs)) Q:qqcs=""  S qqci=qqci+1,qqflg=@Mas@(qqz,qqcs)'=qqci Q:qqflg
 I 'qqflg Q:$Q 0 Q  ;все и так расположено правильно
 F  D:qqcs'=""  S qqcs=$O(@Mas@(qqz,qqcs)) I qqcs="" s qqz=$O(@Mas@(qqz),$s($g(order)=-1:-1,1:1)) Q:qqz=""
 .S qqcnew=$P(..rNew(qqo,qqcnew)," ") D ..rCopyTree(qqo,qqcnew,qqo,qqcs,,-1) S:qqcsav=qqcs qqcsav=qqcnew Q:'qXc
 .I qqz="???" K ^Q(1,qqo,qqcnew,"Xc") Q  ;непонятно, что делать
 .S qqdt=$E($G(^Q(1,qqo,qqcnew,"Xc")),6,256) ;взяли код пользователя
 .S ^Q(1,qqo,qqcnew,"Xc")=..zCnv(1,$ZDH(qqz,8)_","_$G(@Mas@(qqz)),qqdt) I $I(@Mas@(qqz),10) ;записали новую дату и передвинули немного время (вдруг несколько на одну дату?)
 I qqcsav'="" S qqc=qqcsav ;переустановим qqc чтобы можно было сделать ..wcre()
 ;@Dol 14.02.09 I $G(Beg)=1 S qqcs=$$$UserOrd(1,qqo,qqctop,qqctop) I $TR($E(qqcs,$L(qqctop)+1,1000),"A")'="" D  K @Mas Q:$Q qqci Q  ;@Dol 4.02.05 сдвиг кодов вверх
 ;.S qqcnew=qqctop F  D  S qqcs=$$$UserOrd(1,qqo,qqcs,qqctop) Q:qqcs=""
 ;..S qqcnew=$P(..rNew(qqo,qqcnew)," ") D ..rCopyTree(qqo,qqcnew,qqo,qqcs,,-1) S:qqcsav=qqcs qqcsav=qqcnew
 ;.I qqcsav'="" S qqc=qqcsav
 I $G(Beg) S:'$G(Vo(qqnump,qqo,34)) Vo(qqnump,qqo,34)=$G(^Q(1,"CxObj",qqo,"x534")) I 'Vo(qqnump,qqo,34) S Vo(qqnump,qqo,34)=52 ;@Dol 23.03.09 D qARM.Message("qW.rSort Способ Формирования кода (x534) для объекта "_qqo_" явно не задан. Сдвиг кодов не может быть выполнен") Q:$Q qqci Q  ;@Dol 14.02.09
 I $G(Beg) D  K @Mas Q:$Q qqci  Q  ;@Dol 26.04.06 сдвиг кодов вверх при наличии любой дырки !!! Кодировка задана в описании объекта ..CodObj(Arg1, ;@Misuno 04.08.10
 .S qqcs="" F qqci=0:1 S qqcs=$$$UserOrd(1,qqo,qqcs,qqctop) Q:qqcs=""  S qqz=$E(qqcs,$L(qqctop)+1,1000) Q:..CodObj(qqo,qqci,0,$L(qqz))'=qqz  S qqdt=qqcs ;@Dol 14.02.09 ..CodObj(Arg1,
 .Q:qqcs=""  ;нет дырок
 .S:$G(qqdt)="" qqdt=qqctop Q:$L(qqdt)<$L(qqctop)  ;@Dol 22.04.09 если сразу дырка (нет певого кода)
 .S qqcnew=qqdt F  D  S qqcs=$$$UserOrd(1,qqo,qqcs,qqctop) Q:qqcs=""
 ..S qqcnew=$P(..rNew(qqo,qqcnew)," ") D ..rCopyTree(qqo,qqcnew,qqo,qqcs,,-1) S:qqcsav=qqcs qqcsav=qqcnew  ;@Misuno 04.08.10 было $P(..rNew(qqo,qqcnew,1)," ")
 .I qqcsav'="" S qqc=qqcsav 
 K @Mas Q:$Q qqci Q
 ;I $G(Beg) D  K @Mas Q:$Q qqci Q  ;@Dol 26.04.06 сдвиг кодов вверх при наличии любой дырки !!! Кодировка задана в описании объекта ..CodObj(Arg1,
 ;.S qqcs="" F qqci=0:1 S qqcs=$$$UserOrd(1,qqo,qqcs,qqctop) Q:qqcs=""  S qqz=$E(qqcs,$L(qqctop)+1,1000) Q:..CodObj(qqo,qqci,0,$L(qqz))'=qqz  S qqdt=qqcs  ;@Dol 14.02.09 ..CodObj(Arg1,
 ;.Q:qqcs=""  ;нет дырок
 ;.S:$G(qqdt)="" qqdt=qqctop Q:$L(qqdt)<$L(qqctop)  ;@Dol 22.04.09 если сразу дырка (нет певого кода)
 ;.S qqcnew=qqdt F  D  S qqcs=$$$UserOrd(1,qqo,qqcs,qqctop) Q:qqcs=""
 ;..S qqcnew=$P(..rNew(qqo,qqcnew,1)," ") D ..rCopyTree(qqo,qqcnew,qqo,qqcs,,-1) S:qqcsav=qqcs qqcsav=qqcnew
 ;.I qqcsav'="" S qqc=qqcsav
 ;K @Mas Q:$Q qqci Q
]]></Implementation>
</Method>

<Method name="rTest">
<Description>
Метод возвращает (через пробел):
- признак наличия значений понятий (кроме создания/коррекции);
- признак наличия экземпляров объектов-потомков</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqc:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqw,end,qqolst,qqolsti,qqc0 S:$E(qqo)="v" qqo=$E(qqo,3,255) ;@dol 18.05.04
 S end="",qqw="" F  S qqw=$O(^Q(1,qqo,qqc,qqw)) Q:qqw=""  I qqw'="X",qqw'="Xc" S $P(end," ",1)=1 Q
 S qqolst=$G(^Q(1,"CxObj",qqo,"xObj")) Q:qqolst="" end ;объекты-потомки
 F qqolsti=1:1:$L(qqolst," ") I $E($O(^Q(1,$P(qqolst," ",qqolsti),qqc)),1,$L(qqc))=qqc S $P(end," ",2)=1 Q
 Q end
]]></Implementation>
</Method>

<Method name="rTmpVer">
<Description>
Проверка условия темпоральности коррекции (понятие X5280)
Возвращает qqo_" "_qqc экземпляра объекта, для которого необходимо выполнить темпоральную коррекцию
;
; Обработка темпоральности перед вводом/коррекцией/удалением (qqt=1/2/3).</Description>
<Internal/>
<FormalSpec>qqo:%Library.String,qqc:%Library.String,qqt:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 S:'$D(Vo(qqnump,qqo,280)) Vo(qqnump,qqo,280)=qARM.GetPar("X5280",,qqo) Q:Vo(qqnump,qqo,280)="" ""
 I $E(Vo(qqnump,qqo,280))="@",Vo(qqnump,qqo,280)'="@" S qqo=$E(Vo(qqnump,qqo,280),2,255) S:'$D(Vo(qqnump,qqo,280)) Vo(qqnump,qqo,280)=qARM.GetPar("X5280",,qqo) S qqc=$E(qqc,1,$S($D($$$ObjLqqc(qqo))#2:$$$ObjLqqc(qqo),1:$G(^Q(1,"CxObj",qqo,"X50"),255))) ;ссылка на вершину
 I $E(qqc,$L(qqc))=" " Q ""
 I Vo(qqnump,qqo,280)="@" D  Q qqo ;глобальное условие темпоральности
 .I qqXBaseX5280="" S qqo=$S($$rTmpVer0($E(qqc,1,$$$ObjLqqc($P(Vo(qqnump,qqo,29)," ")))):qqo_" "_qqc,1:"") Q  ;встроенное условие
 .I @qqXBaseX5280 S qqo=qqo_" "_qqc Q
 .S qqo=""
 I @Vo(qqnump,qqo,280) Q qqo_" "_qqc
 Q ""
rTmpVer0(qqc0)  N test,qqoo,iobj,qqcc,ndoc,ndocny S ndoc=0,ndocny=0,test=0 D  Q test ;@Dol 26.01.06  $S(test:test,ndoc=ndocny:0,ndoc=1:0,1:1) ;тестирование на привязку к документу
 .F iobj=1:1:$L(Vt(qqnump,"ZTmpObjList")," ") S qqoo=$P($P(Vt(qqnump,"ZTmpObjList")," ",iobj),":") D  Q:test
 ..S qqcc="" F  S qqcc=$$$UserOrd(-1,qqoo,qqcc,qqc0) Q:qqcc=""  S ndoc=ndoc+1 I $D(^Q(1,qqoo,qqcc,"YT",qqo)) S ndocny=ndocny+1 I $S(qqoo=$G(Vt(qqnump,"ZTmpqqo")):qqcc'=$G(Vt(qqnump,"ZTmpqqc")),1:1)  S test=qqc0_$G(^Q(1,qqoo,qqcc,"YT",qqo))=qqc Q:test
]]></Implementation>
</Method>

<Method name="rVer">
<Description>
Проверка наличия экземпляра Arg2 объекта Arg1.
Используется в правиле проверки понятия C.</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $G(Arg3) Q:$D(^Q(1,"CxObj",Arg2)) "Существует Объект "_Arg2_" "_^Q(1,"CxObj",Arg2) Q:$D(^Q(1,"CxWoc",Arg2)) "Существует Понятие "_Arg2_" "_^Q(1,"CxWoc",Arg2) Q ""
 I Arg1="XView" Q:$E(Arg2,1,3)="sys" "sys* зарезервировано для порождаемых отображений" Q:$L(Arg2)<3 "Не менее трех символов" Q:$E(Arg2,1,3)="XXX"&&('W("Zadm")) "XXX* зарезервировано для системных отображений"
 Q:$S('$$$Tree:$D(^Q(1,Arg1,Arg2)),1:$D(@$$$GloRef@(Arg1,Arg2))) "Экземпляр существует" Q ""
]]></Implementation>
</Method>

<Method name="rWoc">
<Internal/>
<ClassMethod>1</ClassMethod>
<FormalSpec>qqpar1:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qqwv S qqpar1=+$G(qqpar1),qqwv=$S($E(qqw)'="R":qqw,1:$E(qqw,3,255)) I $E(qqwv)="O" S N(qqw)=W(qqw) Q:$Q 0 Q
 I "TCMDRYVX"[$E(qqwv),$E(qqwv)'="D" Q:$Q 0 Q  ;1????
 ;K N(qqw) ???есть тонкости ???
 I $G(W(qqw))="" S N(qqw)="" Q:$Q 0 Q
 I qqllang'="",'$D(^Q($P(qqllang," "),qqwv)) N qqlang,qqllang S qqlang=1,qqllang=""
 N qqz,qqzz,qqzzz,j S qqlz="",qqzzz=0 F j=1:1:$L(W(qqw)," ") S (qqzz,qqz)=$P(W(qqw)," ",j) I qqz'="" S qqz=$G(^Q(qqlang,qqwv,qqz)) D:'$D(^(qqzz))  Q:qqzzz  S qqlz=qqlz_" "_$S($E(qqwv)="D"||($G(Vx713(qqwv))=1):qqzz,1:qqz)
 .I 'qqpar1 S qqzzz=1 Q
 .I $E(qqwv)="D"||($G(Vx713(qqwv))=1) S:$I(^Q(1,qqwv)) ^Q(qqlang,qqwv,qqzz)="" Q
 .ZA ^Q(1_qqwv):5 S (^Q(1,qqwv),qqz)=$S($P($G(W("C"_qqw))," ",j)'="":$P(W("C"_qqw)," ",j),1:$$gadd($G(^Q(1,qqwv),"A"))),^Q(qqlang,qqwv,qqzz)=qqz,^Q(qqlang,"C"_qqwv,qqz)=qqzz I $I(^Q(1,"C"_qqwv)) ;newlock
 .D:qqllang'=""  L -^Q(1_qqwv)#"I" Q  ;newlock
 ..N qll,qll1,qli S qll=1_" "_qqllang F qli=1:1:$L(qll," ") S qll1=$P(qll," ",qli) S:qll1'=qqlang ^Q(qll1,qqwv,"??"_qqzz)=qqz,^Q(qll1,"C"_qqwv,qqz)="??"_qqzz
 I qqzzz Q:$Q 1 Q
 S N(qqw)=$E(qqlz,2,32000) ;@Dol 3.04.06 было 4096
 D:$L(N(qqw)," ")'=$L(W(qqw)," ")  ;нужна нормализация значения
 .S qqlz="" F j=1:1:$L(W(qqw)," ") S qqz=$P(W(qqw)," ",j) S:qqz'="" qqlz=qqlz_" "_qqz
 .S W(qqw)=$E(qqlz,2,32000) ;@Dol 3.04.06 было 4096
 Q:$Q qqzzz Q
gadd(qqpar1)    ;добавлена для ужесточения контроля (вдруг полученный код существует???)
 S qqpar1=$$gadd1(qqpar1) G:$D(^Q(qqlang,"C"_qqwv,qqpar1)) gadd+1 Q qqpar1
gadd1(qqpar1)  ;функция добавляет +1 к коду qqpar1. A-Z,a-z
 I $E(qqw)="W" Q:qqpar1="" $C(65) D  Q qqpar1 ;компактный код (задействованы русские буквы)
 .N i,% F i=$L(qqpar1):-1:1 S %=$A(qqpar1,i)+1,$E(qqpar1,i)=$C($S(%<91:%,%<97:97,%<123:%,%<192:192,%>255:65,1:%)) Q:%'>255  I i=1 S qqpar1="A"_qqpar1 Q
 Q:qqpar1="" "A" Q:qqpar1?1.N qqpar1+1
 N i,% F i=$L(qqpar1):-1:1 S %=$A(qqpar1,i)+1,$E(qqpar1,i)=$C($S(%<91:%,%<97:97,%>122:65,1:%)) Q:%'>122  I i=1 S qqpar1="A"_qqpar1 Q
 Q qqpar1
]]></Implementation>
</Method>

<Method name="rWocNew">
<Description>
Запись в словарь Arg1 значения Arg2 с кодом Arg3.
Возвращает - 0 -все нормально;
1 - есть значение
2 - есть код</Description>
<Internal/>
<FormalSpec>Arg1:%String,Arg2:%String,Arg3:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 K:$L(Arg2," ")'=1 ^Q(1,Arg1),^Q(1,"C"_Arg1) N q,i S Arg3=$G(Arg3)
 F i=1:1:$L(Arg2," ") D  Q:q 
 .S q=$G(^Q(1,Arg1,$P(Arg2," ",i)))'="" Q:q
 .I $E(Arg1)'="D" S q=$G(^Q(1,"C"_Arg1,$P(Arg3," ",i)))'=""*2 Q:q  S ^Q(1,"C"_Arg1,$P(Arg3," ",i))=$P(Arg2," ",i)
 .S ^Q(1,Arg1,$P(Arg2," ",i))=$P(Arg3," ",i)
 Q:$Q q_" "_i Q
]]></Implementation>
</Method>

<Method name="rWocRefLst">
<Description>
Возвращает список (через пробел) ссылочных понятий (на R*) для понятия qw.
Первое значение в списке - код понятия qw.</Description>
<Internal/>
<FormalSpec>qw:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 n lst,qt s lst=qw,qt="R" f  s qt=$o(^Q(1,"CxWoc",qt)) q:$e(qt)'="R"  s:$e(qt,3,255)=qw lst=lst_" "_qt
 q lst
]]></Implementation>
</Method>

<Method name="rWocx711">
<Description>
Возвращает значение x711 ("%Организация словаря") понятия qw для объекта qo.

Значение x711 определяется следующим образом:
- если узел Vx711(qw,qo) не равен "", то возвращается значение этого узла
- если ^Q(1,"CxObj",qo,"CxWoc",qw,"x711") не равен "", то возвращается это значение
- берется значение +^Q(1,"CxWoc",qw,"x711")

Параметры:
qw  - код понятия
qo   - код объекта
refr - признак обновления; если равен 1, то игнорируется текущее значение Vx711(qw,qo)</Description>
<Internal/>
<FormalSpec>qw:%Library.String,qo:%Library.String,refr:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 i '$g(refr),$g(Vx711(qw,qo))'="" q Vx711(qw,qo)
 n val s val=$g(^Q(1,"CxObj",qo,"CxWoc",qw,"x711")) s:val="" val=$g(^Q(1,"CxWoc",qw,"x711"))
 s Vx711(qw,qo)=+val q +val
]]></Implementation>
</Method>

<Method name="rX5247">
<Description>
Добавление add к счетчикам групп</Description>
<Internal/>
<FormalSpec>Obj:%Library.String,add:%Library.String,qqcObj:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N obj,iobj I 'add D  Q  ;обнуление счетчиков
 .F iobj=1:1:$L(Vo(qqnump,Obj,247)," ") S obj=$P(Vo(qqnump,Obj,247)," ",iobj) S qqcObj="" F  S qqcObj=$O(^Q(1,obj,qqcObj)) Q:qqcObj=""  K ^(qqcObj,"McO"_Obj)
 F iobj=1:1:$L(Vo(qqnump,Obj,247)," ") S obj=$P(Vo(qqnump,Obj,247)," ",iobj) S:'$D($$$ObjLqqc(obj)) $$$ObjLqqc(obj)=$$$ObjLget(obj) I $D(^Q(1,obj,$E(qqcObj,1,$$$ObjLqqc(obj)))),$I(^($E(qqcObj,1,$$$ObjLqqc(obj)),"McO"_Obj),add)
 Q
]]></Implementation>
</Method>

<Method name="rZTMP">
<Description>
Запись (в релевантные) значения ZTMP-понятия
qqot - код объекта (не задан - текущий qqo)
qqct - код экземпляра объекта (не задан - текущий qqc)
qqwt - ZTMP*-понятие (не задано - текущее qqw)
Zt - записываемое значение (не задано - текущее Z)

Если объекта нет в перечне релевантных, он туда заносится </Description>
<Internal/>
<FormalSpec>qqot:%Library.String,qqct:%Library.String,qqwt:%Library.String,Zt:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 D:'..gRel("",$G(qqot,qqo),$G(qqct,qqc)) ..gRel("+",$G(qqot,qqo),$G(qqct,qqc),$G(Vc(qqnump)))
 S ^Q($$$Relind_qview,$G(qqot,qqo),$G(qqct,qqc),$G(qqwt,qqw))=$G(Zt,Z)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="scalePicSize">
<Internal/>
<FormalSpec>realSize:%String,rectSize:%String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 if ($extract(rectSize) = ">") set rectSize = $extract(rectSize, 2, $length(rectSize))
 set rectSize = $translate(rectSize, ",", " ")  
    
 new realHeight set realHeight = $piece(realSize, " ", 1)
 new realWidth set realWidth = $piece(realSize, " ", 2)
 
 new rectHeight set rectHeight = $piece(rectSize, " ", 1)
 new rectWidth set rectWidth = $piece(rectSize, " ", 2)
 
 new resSize set resSize = ""
 new resWidth
 new resHeight
 new widthRatio
 new heightRatio
    
 if (rectSize [ "-1") {
     if (rectWidth = -1) {
         set resWidth = (realWidth * rectHeight) \ realHeight
         set resHeight = rectHeight
     }
     else {
         set resHeight = (realHeight * rectWidth) \ realWidth
         set resWidth = rectWidth
     }
 }
 else {
     set widthRatio = realWidth / rectWidth
     set heightRatio = realHeight / rectHeight
     
     if (widthRatio < 0) && (heigthRatio < 0) {
         set resWidth = realWidth
         set resHeight = realHeight
     }
     elseif (widthRatio > heightRatio) {
         set resWidth = rectWidth
         set resHeight = (realHeight * rectWidth) \ realWidth
     } 
     else {
         set resHeight = rectHeight
         set resWidth = (realWidth * rectHeight) \ realHeight
     } 
 }
 
 set resSize = resHeight _ " " _ resWidth
 
 quit resSize
]]></Implementation>
</Method>

<Method name="tagSequenceControl">
<Description>
@Mike 30.05.11 Попытка исправления последовательности тэгов.</Description>
<Internal/>
<FormalSpec>str:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	
	Q:$G(str)="" ""
	N openTags,closeTags,openSubsts,closeSubsts 
	
	S openTags="<p>,<p align='center'>,<p align='right'>,<p align='left'>,<p_align='center'>,<p_align='right'>,<p_align='left'>,<b>,<i>,<u>,<sub>,<sup>"
	S closeTags="</p>,</p>,</p>,</p>,</p>,</p>,</p>,</b>,</i>,</u>,</sub>,</sup>"
	
	S openSubsts=$TR(openTags,"<>",$C(17)_$C(16))
	S closeSubsts=$TR(closeTags,"<>",$C(17)_$C(16))
	;S substs=openSubsts_","_closeSubsts
	
	;S openTagList=$LFS(openTags), closeTagList=$LFS(closeTags)
	;S openSubstList=$LFS(openSubsts), closeSubstList=$LFS(closeSubsts)
	
	N n F n=1:1:$L(openTags,",") S str=qW.zReplace(str,$P(openTags,",",n),$P(openSubsts,",",n)), str=qW.zReplace(str,$P(closeTags,",",n),$P(closeSubsts,",",n))
	
	N z S z=0 F z=1:1:20 Q:(str'[$C(16)&(str'[$C(17)))  D
	.N openSubst,closeSubst S n=0 F n=1:1:$L(openTags,",") D 
	..S openSubst=$P(openSubsts,",",n), closeSubst=$P(closeSubsts,",",n)
	..F l=2:1 Q:l>$L(str,openSubst)  D  ;:$L(str,openSubst)
	...S subStr=$P($P(str,openSubst,l,9999),closeSubst,1)
	...N openPresent,closePresent S (openPresent,closePresent)=0 F m=1:1:$L(openSubsts,",") D
	....I subStr[$P(openSubsts,",",m) S openPresent=$I(openPresent) 
	....I subStr[$P(closeSubsts,",",m) S closePresent=$I(closePresent)
	...I openPresent+closePresent=0 S str=$P(str,openSubst,1,(l-1))_$P(openTags,",",n)_$P($P(str,openSubst,l,9999),closeSubst,1)_$P(closeTags,",",n)_$P($P(str,openSubst,l,9999),closeSubst,2,9999) ;S str=$P(str,openSubst,1,(l-1))_$P(openTags,",",n)_$P(str,openSubst,l,9999), str=$P(str,closeSubst,1,(l-1))_$P(closeTags,",",n)_$P(str,closeSubst,l,9999) S l=l-1 ;S str=$P(str,openSubst,1,(l-1))_$P(openTags,",",n)_$P($P(str,openSubst,l,9999),closeSubst,1)_$P(closeTags,",",n)_$P($P(str,openSubst,l,9999),closeSubst,2,9999)
	...I openPresent=1,closePresent=0 D
	....N k,openWrong,kk S kk=0 S openWrong=0 F k=1:1:$L(openSubsts,",") Q:openWrong'=0  D
	.....I subStr[$P(openSubsts,",",k) S openWrong=$I(openWrong) S kk=k Q
	....S str=$P(str,openSubst,1,(l-1))_$P(openTags,",",n)_$P($P(str,openSubst,l,9999),closeSubst,1)_$P(closeSubsts,",",kk)_$P(closeTags,",",n)_$P($P(str,openSubst,l,9999),closeSubst,2,9999) ;_$P(str,openSubst,1,(l-1))_$P(openTags,",",k)_$P(str,openSubst,l,9999)
	...I closePresent=1,openPresent=0 D
	....N k,closeWrong,kk S kk=0 S closeWrong=0 F k=1:1:$L(closeSubsts,",") Q:closeWrong'=0  D
	.....I subStr[$P(closeSubsts,",",k) S closeWrong=$I(closeWrong) S kk=k Q
	....S str=$P(str,openSubst,1,(l-1))_$P(openTags,",",n)_qW.zReplace($P($P(str,openSubst,l,9999),closeSubst,1),$P(closeSubsts,",",kk))_$P(closeTags,",",n)_$P(str,closeSubst,2,9999)
	
	N p F p=1:1:$L(openSubsts,",") S str=qW.zReplace(str,$P(openSubsts,",",p)), str=qW.zReplace(str,$P(closeSubsts,",",p))
	
	Q str
]]></Implementation>
</Method>

<Method name="windos">
<Description><![CDATA[
Перекодировка строки Arg1 из DOS->Win (Arg2)=0 или Win->DOS если Arg2=1]]></Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 I '$G(Arg2) Q $TR(Arg1,$C(169,230,227,170,165,173,163,232,233,167,229,234,228,235,162,160,175,224,174,171,164,166,237,239,231,225,172,168,226,236,161,238,137,150,147,138,133,141,131,152,153,135,149,154,148,155,130,128,143,144,142,139,132,134,157,159,151,145,140,136,146,156,129,158,147,0,118,119,120),$C(233,246,243,234,229,237,227,248,249,231,245,250,244,251,226,224,239,240,238,235,228,230,253,255,247,241,236,232,242,252,225,254,201,214,211,202,197,205,195,216,217,199,213,218,212,219,194,192,207,208,206,203,196,198,221,223,215,209,204,200,210,220,193,222,39))
 Q $TR(Arg1,$C(233,246,243,234,229,237,227,248,249,231,245,250,244,251,226,224,239,240,238,235,228,230,253,255,247,241,236,232,242,252,225,254,201,214,211,202,197,205,195,216,217,199,213,218,212,219,194,192,207,208,206,203,196,198,221,223,215,209,204,200,210,220,193,222),$C(169,230,227,170,165,173,163,232,233,167,229,234,228,235,162,160,175,224,174,171,164,166,237,239,231,225,172,168,226,236,161,238,137,150,147,138,133,141,131,152,153,135,149,154,148,155,130,128,143,144,142,139,132,134,157,159,151,145,140,136,146,156,129,158))
]]></Implementation>
</Method>

<Method name="zAge">
<Description>
             Вычисление текущего возраста по дате рождения.</Description>
<Internal/>
<FormalSpec>Arg1:%String=$G(Z)</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 Q:Arg1="" "" I Arg1'?4.N Q:$E(Arg1)'="@" "???" S Arg1=..GG(,$E(Arg1,2,20)) Q:Arg1="" "" Q:Arg1'?4.N "???" 
 N curdat S curdat=$ZD($H,8)
 Q $E(curdat,1,4)-$E(Arg1,1,4)-$S($E(curdat,5,8)<$E(Arg1_"0000000",5,8):1,1:0)
]]></Implementation>
</Method>

<Method name="zChSym">
<Description>
замена в строке str подстроки sym1 на подстроку sym2</Description>
<Internal/>
<FormalSpec>str:%Library.String,sym1:%Library.String,sym2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N iii S iii=1 F  S iii=$F(str,sym1,iii) Q:'iii  S $E(str,iii-$L(sym1),iii-1)=sym2,iii=iii+$L(sym2)-$L(sym1)
 Q str
]]></Implementation>
</Method>

<Method name="zCnv">
<Description>
Преобразование даты, времени, кода пользователя коррекции.
Если Arg1=0 - распаковка. Возврашает дату, время в формате $Hrolog и, через пробел, код пользователя.
qqtm - упакованное значение (понятия X или Xc).
Если Arg1=1 - упаковка. Возвращает упакованное значение
qqtm - дата, время в формате $Hrolog;
quser - код пользователя.
Для дополнительного преобразования в формат нормализованной даты можно воспользоваться
функциями   $ZDT($H,8), $ZDTH("ГГГГММДД ЧЧ:ММ:СС",8)
@ank 20101101 Изменён алгоритм запаковки\распаковки дат</Description>
<Internal/>
<FormalSpec>Arg1:%String=0,qqtm:%String,quser:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I 'Arg1 S:$L(qqtm)&($L(qqtm)<$S($E(qqtm,1,2)=$C(0,0):8,1:5)) qqtm=$E(qqtm_$C(0,0,0,0),1,$S($E(qqtm,1,2)=$C(0,0):8,1:5)) Q $S($G(qqtm)'="":$ZLA($RE($S($E(qqtm,1,2)=$C(0,0):$E(qqtm,3,5),1:$E(qqtm,1,2)))_$S($E(qqtm,1,2)=$C(0,0):$C(0),1:$C(0,0)))_","_$ZLA($RE($S($E(qqtm,1,2)=$C(0,0):$E(qqtm,6,8),1:$E(qqtm,3,5)))_$C(0))_" "_$E(qqtm,$S($E(qqtm,1,2)=$C(0,0):9,1:6),255),1:"")
 Q $S($G(qqtm)'="":$S(((qqtm\(256**2)>0)||($P(qqtm,",")=0)):$C(0,0),1:"")_$RE($E($ZLC(qqtm),1,$S(((qqtm\(256**2)>0)||($P(qqtm,",")=0)):3,1:2)))_$RE($E($ZLC($P(qqtm,",",2)),1,3))_$G(quser),1:"")
]]></Implementation>
</Method>

<Method name="zConvAdr">
<Description>
Расшифровка (раскладывание на понятия в массиве W) строки адреса
!!!Работает пока только для населенных пунков типа ГОРОД

n- строка
qqwl - список (через пробел) двенадцати понятий адреса ("pCountry pM pN pnmreg pO pnmnp pCc pP pnmul pQ pR pS" - умолчание)
1 (pCountry) - страна;
2 ( pM) - индекс;
3 ( pN) - регион;
4 ( pnmreg) - тип региона
5 ( pO) - населенный пункт
6 ( pnmnp) - тип населенного пункта
7 ( pCc) - район города
8 ( pP) - улица
9 ( pnmul) - тип улицы
10 ( pQ) - дом
11 ( pR) - корпус
12 ( pS) -квартира

r - разделитель полей адреса (по умолчанию - запятая)

Возвращает qqwl</Description>
<Internal/>
<FormalSpec>n:%Library.String,qqwl:%Library.String,r:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqwi,a,aa S:$G(r)="" r="," 
 S:$G(qqwl)="" qqwl="pCountry pM pN pnmreg pO pnmnp pCc pP pnmul pQ pR pS"
 ;                   1        2  3  4      5  6     7   8  9     10 11 12
 F qqwi=1:1:$L(qqwl," ") S W($P(qqwl," ",qqwi))=""
 S:$E(n)="""" @("n="_n)
 I $ZSTRIP($P(n,r,2),"<>W")?1.6N S W($P(qqwl," ",1))=$P(n,r),n=$P(n,r,2,255) I 1 ;СТРАНА
 E  S W($P(qqwl," ",1))="Россия"
 S W($P(qqwl," ",2))=$ZSTRIP($P(n,r),"<>W") I W($P(qqwl," ",2))'?1.6n S W($P(qqwl," ",2))="" I 1 ;ИНДЕКС
 E  S n=$P(n,r,2,255)
 s a=$ZSTRIP($P(n,r,1),"<>W") D  ;город/область
 .I a["г" S W($P(qqwl," ",5))=$P(a,"г.",2,255),W($P(qqwl," ",6))="город",n=$P(n,r,2,255) Q
 .S W($P(qqwl," ",3))=$P(a,"обл.",2,255),W($P(qqwl," ",4))="область"
 .S W($P(qqwl," ",5))=$P($ZSTRIP($P(n,r,2),"<>W"),"г.",2,255),W($P(qqwl," ",6))="город",n=$P(n,r,3,255)
 s a=$ZSTRIP($P(n,",",1),"<>W") D  ;улица
 .S aa="ул." I a[aa S W($P(qqwl," ",9))="улица" Q
 .S aa="пр." I a[aa S W($P(qqwl," ",9))="проспект" Q
 .S aa="пер." I a[aa S W($P(qqwl," ",9))="переулок" Q
 .S aa="",W($P(qqwl," ",9))=""
 S W($P(qqwl," ",8))=$S(aa="":a,$E(a,1,$L(aa))=aa:$P(a,aa,2),1:$P(a,aa,1))
 I aa'="",$E(a,1,$L(aa))'=aa,$P(a,aa,2)'="" S W($P(qqwl," ",7))=$P(a,aa,2) ;район города
 S (W($P(qqwl," ",10)),n)=$ZSTRIP($P(n,r,2,255),"<>W")
 I n["д." S n=$ZSTRIP($P(n,"д.",2,255),"<>W"),W($P(qqwl," ",10))=$P(n,$S(n["кор.":"кор.",n["к.":"к.",1:"кв.")),n=$ZSTRIP($E(n,$L(W($P(qqwl," ",10)))+1,1000),"<>W")
 I n["к." S n=$ZSTRIP($P(n,"к.",2,255),"<>W"),W($P(qqwl," ",11))=$P(n,"кв."),n=$ZSTRIP($E(n,$L(W($P(qqwl," ",11)))+1,1000),"<>W")
 I n["кор." S n=$ZSTRIP($P(n,"кор.",2,255),"<>W"),W($P(qqwl," ",11))=$P(n,"кв."),n=$ZSTRIP($E(n,$L(W($P(qqwl," ",11)))+1,1000),"<>W")
 I n["кв." S W($P(qqwl," ",12))=$P(n,"кв.",2,255)
 Q:'$Q  Q qqwl
]]></Implementation>
</Method>

<Method name="zDW">
<Description>
Возвращает день недели.
Arg1 - дата в формате $Hrolog (если нормализованная, преобразовать через $ZDH(дата,8))
Arg2=0 (или не задан) - номер дня
Arg2=1 - два символа (Пн ...)
Arg2=3 - полное название</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 ;S:$L(Arg1)=8 Arg1=$ZDH(Arg1,8) S Arg1=$ZD(Arg1,10) S:'Arg1 Arg1=7 ;далее @Misuno
 i $ZV'["GT.M" S:$L(Arg1)=8 Arg1=$ZDH(Arg1,8) S Arg1=$ZD(Arg1,10) S:'Arg1 Arg1=7
 i $ZV["GT.M" d:$L(Arg1)=8  s Arg1=(Arg1#7+3)#7+1
 .n (Arg1)
 .s %DS=$e(Arg1,5,6)_"/"_$e(Arg1,7,8)_"/"_$e(Arg1,1,4)
 .d INT^%DATE
 .s Arg1=%DN
 Q $S('$G(Arg2):Arg1,Arg2=1:$P("Пн Вт Ср Чт Пт Сб Вс"," ",Arg1),1:$P("Понедельник Вторник Среда Четверг Пятница Суббота Воскресенье"," ",Arg1))
]]></Implementation>
</Method>

<Method name="zDatBE">
<Description>
Проверка даты на диапазон</Description>
<Internal/>
<FormalSpec>date:%Library.String,dateBeg:%Library.String,dateEnd:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I date'<$E(dateBeg_"00000000",1,8),date'>$E($G(dateEnd)_"99999999",1,8) Q 1
 Q 0
]]></Implementation>
</Method>

<Method name="zDbl">
<Description>
Возвращает задвоенные символы в строке String в виде этих символов через пробел.
Reg=1 - учтиывать регистр
Например, 
qW.zDbl("ААлекксей") вернет "АА KK"
qW.zDbl("ААлекксей",1) вернет "АА кк"
!!но qW.zDbl("Аалекксей",1) вернет "кк"</Description>
<Internal/>
<FormalSpec>String:%Library.String,Reg:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:'$G(Reg) String=$ZCVT(String,"U") N istr0,istr1,str S str=""
 F istr0=1:1:$L(String)-1 D
 .F istr1=istr0+1:1 Q:$E(String,istr0)'=$E(String,istr1)
 .I istr1-istr0>1 S str=str_" "_$TR($J("",istr1-istr0)," ",$E(String,istr0)),istr0=istr1-1
 Q $E(str,2,32000)
]]></Implementation>
</Method>

<Method name="zFIO">
<Description>
Нормализация ФИО (с большой буквы)
Arg1 - ФИО (через пробел или подчерк)
Arg2=1 - только инициалы

Список ФИО (через пробел) обрабатывается. Фамилия, Имя, Отчество должны быть в этом случае через подчерк</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I Arg1[" ",Arg1'["_" Q $$zFIOf(Arg1," ")
 I Arg1["_",Arg1'[" " Q $$zFIOf(Arg1,"_")
 N zzi F zzi=1:1:$L(Arg1," ") S $P(Arg1," ",zzi)=$$zFIOf($P(Arg1," ",zzi),"_")
 Q Arg1
zFIOf(Arg,ra)   N zi,z F zi=1:1:$L(Arg,ra) S z=$P(Arg,ra,zi) S:z'["." $P(Arg,ra,zi)=$ZCVT($E(z),"U")_$S('$G(Arg2)||(zi=1):$ZCVT($E(z,2,1000),"L"),1:".")
 S zi=1 F  S zi=$F(Arg,"-",zi) Q:'zi  I $E(Arg,zi)'=ra,$E(Arg,zi)'="" S $E(Arg,zi)=$ZCVT($E(Arg,zi),"U") ;@Dol 16.06.10 составные имена (через - )
 Q Arg
]]></Implementation>
</Method>

<Method name="zL">
<Description>
Преобразование имен собственных из больших букв в маленькие.
Arg2=1 - преобразование похожих</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $ZCVT(Arg1,"U")'=Arg1 Q Arg1
 N aaaz S aaaz=$TR($E(Arg1)_$ZCVT($E(Arg1,2,30000),"L")," _.-",$C(0,0,0,0,0,0)) Q:aaaz'[$C(0) aaaz
 N aaazi S aaazi=1 F  S aaazi=$F(aaaz,$C(0),aaazi) Q:'aaazi  S $E(aaaz,aaazi-1)=$E(Arg1,aaazi-1) I $S($E(Arg1,aaazi-1)'="-":1,1:$E(Arg1,aaazi-2)'?1n) S $E(aaaz,aaazi)=$ZCVT($E(aaaz,aaazi),"U")
 S:$G(Arg2)=1 aaaz=..LikeSymb(aaaz)
 Q aaaz
]]></Implementation>
</Method>

<Method name="zList">
<Description>
Список значений понятий для объекта, подчиненного текущему.
qqwl - список кодов понятий объекта Obj (через пробел).
Rel=1 учет режима уточнения, если есть релевантные
sep - разделитель значений возвращаемого списка (для экземпляров).
RealObj - если задан, то код реального объекта, относительно которого необходимо выдать список. В этом случае виртуалная структура текущего отображения не учитывается!!!
seplist - разделитель значений в списке понятий экземпляра.
var=1 - qqwl трактуется как выражение (в нем можно использовать qqo qqc)</Description>
<Internal/>
<FormalSpec>Obj:%Library.String,qqwl:%Library.String,Rel:%Library.String=0,sep:%Library.String,RealObj:%Library.String,seplist:%Library.String,var:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 ;I $G(RealObj)="",Obj=$G(qqo) Q ..G(qqw) ;Q:$G($$$ObjRef(Obj))="" "???"_Obj
 I $G(qqo)="" N qqc,qqo S qqc="",qqo=$P($$$ObjRef(Obj),",")
 I Rel,$$$ReFind N qql S qql=$S('$D(qFindDO):$$$Relind,1:'$$$Relind)_qview ;учет режима уточнения
 N q S q=0 I $G(RealObj)'="",qqo'=RealObj N qqo S q=1,qqo=RealObj ;@dol 14.01.03
 N qqw,qqco,list,qqwi S sep=$G(sep," "),seplist=$G(seplist," ")
 I $G(RealObj)="",Obj=$G(qqo) D zListG(qqc) Q $G(list) ;@dol 22.02.03
 I '$D(Vt(qqnump,111))||($G(RealObj)'="")||'$D($$$ObjRef(Obj)) D  Q $G(list)
 .I q S qqco=qqc N qqc S qqc=$$$UserOrd(-1,qqo,qqco,"") Q:qqc'=$E(qqco,1,$L(qqc))
 .S qqco=qqc F  S qqco=$O(^Q(qql,Obj,qqco)) Q:qqco=""  Q:$E(qqco,1,$L(qqc))'=qqc  D zListG(qqco)
 N ObjRef,Num S ObjRef=$P(","_$$$ObjRef(Obj)_",",","_qqo_",",2) Q:ObjRef="" "???"_Obj
 F Num=1:1:$L(ObjRef,",")-1 I $G(Vo(qqnump,$P(ObjRef,",",Num),2))>1 S qqco=1 Q
 I '$G(qqco) D  Q $G(list)
 .I q S qqco=qqc N qqc S qqc=$$$UserOrd(-1,qqo,qqco,"") Q:qqc'=$E(qqco,1,$L(qqc))
 .S qqco=qqc F  S qqco=$O(^Q(qql,Obj,qqco)) Q:qqco=""  Q:$E(qqco,1,$L(qqc))'=qqc  D zListG(qqco)
 D zListre(1,qqc) Q $G(list)
zListG(qqccc)   I $G(var) N qqo,qqc S qqo=Obj,qqc=qqccc,@("qqwi="_qqwl),list=$S('$D(list):"",1:list_sep)_qqwi Q  ;@dol 21.11.05
 F qqwi=1:1:$L(qqwl," ") S list=$S('$D(list):"",qqwi=1:list_sep,1:list_seplist)_..GG(Obj,$P(qqwl," ",qqwi),qqccc)
 Q
zListre(qqoi,qqco)  N qqon,qqcoo S qqon=$P(ObjRef,",",qqoi),qqcoo="" F  S qqcoo=..gOrder(1,qqon,qqcoo,qqco) Q:qqcoo=""   D:qqon'=Obj zListre(qqoi+1,qqcoo) D:qqon=Obj zListG(qqcoo)
 Q
]]></Implementation>
</Method>

<Method name="zMLine">
<Description>
Индексы поддерева в виде списка
mas - ссылка на поддерева
num - желаемое кол-во.
NoI - значение, возвращаемое при отсутствии индексов
I1 - если задано, то возвращается при наличии только одного индекса
sep - разделитель списка индексов (по умолчанию - пробел) ;@Dol 19.08.09
vval - выражение для обработки значений индексов (относительно Z) ;@Dol 19.04.10</Description>
<Internal/>
<FormalSpec>mas:%Library.String,num:%Library.String,NoI:%Library.String,I1:%Library.String,sep,val,vval</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N ind,ss,indi,Z,$ET S $ET="S $ET="""" Q:'$Q  Q $G(NoI)" I $D(@mas)
 S:$G(sep)="" sep=" " S ss="",ind="" S:$G(num)="" num=99999999 F indi=1:1:num S ind=$O(@mas@(ind)) Q:ind=""  S:$G(val) Z=$G(@mas@(ind)) S:$G(val)&&($G(vval)'="") @("Z="_vval) S ss=ss_sep_$S('$G(val):ind,val=1:Z,1:$TR(ind_" "_Z," ","_"))
 S:ind="" indi=indi-1
 Q $S('indi:$G(NoI),indi>1||num=1:$E(ss,$L(sep)+1,32000),$G(I1)'="":I1,1:$E(ss,$L(sep)+1,32000))
]]></Implementation>
</Method>

<Method name="zNameCase">
<Description>
Метод преобразуют ФИО заданые в именительном падеже в другой падеж.
Параметры:
SurName - фамилия
FirstName - имя
PatronymicName - отчество
Case - падеж:
0 - родительный
1 - дательный
2 - винительный
3 - творительный
4 - предложный
(по умолчанию Case = 0)
Sex - пол:
0 - мужской
1 - жеский
Если ReturnSex=1 - возвращает пол (МУЖСКОЙ или ЖЕНСКИЙ). Определяется по отчеству, если не задано - по фамилии
        ReturnSex=2 - аналогично 1, но возвращает ( Мужской или Женский)</Description>
<Internal/>
<FormalSpec>SurName:%Library.String,FirstName:%Library.String,PatronymicName:%Library.String,Case:%Library.String=0,Sex:%Library.String="",ReturnSex:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S FirstName=$G(FirstName),SurName=$G(SurName),PatronymicName=$G(PatronymicName) ;@dol 22.02.03
 q:(FirstName="")&&(SurName="")&&(PatronymicName="") ""

 ;I FirstName = "",$g(ReturnSex)'=1 Q "NoFirstNameError"

 ;I SurName = "",$g(ReturnSex)'=1 Q "NoSurNameError"

 I ((Case < 0) || (Case > 4)),$g(ReturnSex)'=1 Q "NoCaseError"

 // большие буквы
 N NoUpSN S NoUpSN=$TR(SurName,"_ -")'?.U  // oleg & sasha 20080616
 //N NoUpSN S NoUpSN=SurName'?.U ;@dol
 S SurName=$ZCVT(SurName,"U") ;@dol Большие буквы
 N NoUpFN S NoUpFN=$TR(FirstName,"_ -")'?.U  // oleg & sasha 20080616
 S FirstName=$ZCVT(FirstName,"U") 
 N NoUpPN
 I (PatronymicName '= "") D
 .S NoUpPN=$TR(PatronymicName,"_ -")'?.U   // oleg & sasha 20080616
 .S PatronymicName=$ZCVT(PatronymicName,"U") 

 n PatronymicNameError // oleg & sasha 20080616
 S PatronymicNameError = 0

 N SexError S SexError = 0

 I $G(ReturnSex),PatronymicName="" S Sex=$S(" ОВ ЕВ ЁВ ИЙ ИН "[(" "_$E(SurName,$L(SurName)-1,255)_" "):0," АЯ "[(" "_$E(SurName,$L(SurName)-1,255)_" "):1," ОВА ЁВА ЕВА ИНА "[(" "_$E(SurName,$L(SurName)-2,255)_" "):1,1:"") Q $S(ReturnSex=1:$s(Sex=0:"МУЖСКОЙ",Sex=1:"ЖЕНСКИЙ",1:""),1:$s(Sex=0:"Мужской",Sex=1:"Женский",1:"")) ;@Dol 10.01.08

 I ($G(Sex) '= "") D
 .I ((Sex < 0) || (Sex > 1)) S SexError = 1
 
 //I $G(PatronymicName) '= "",$L(PatronymicName)>1 D
 //исправлено 20080602 sasha
 I ($G(PatronymicName) '= "")&&($L(PatronymicName)>1)&&($G(Sex)="") D
 .S LastLetter =  $E(PatronymicName, $L(PatronymicName))
 .S PatronymicNameError  = (LastLetter '= "А") && (LastLetter '= "Ч")
 .I PatronymicNameError = 1 Q
 .S Sex = $S(LastLetter = "А":1,1:0)
 ;E  S Sex = 0

 Q:SexError=1 $S($g(ReturnSex):"",1:"SexError")
 Q:PatronymicNameError=1 $S($g(ReturnSex):"",1:"PatronymicNameError")

 I $g(ReturnSex) Q $S(ReturnSex=1:$s(Sex=0:"МУЖСКОЙ",Sex=1:"ЖЕНСКИЙ",1:""),1:$s(Sex=0:"Мужской",Sex=1:"Женский",1:"")) ;@Dol 10.01.08
 
 I (PatronymicNameError = 1) Q "PatronymicNameError"

 // фамилия
 I ($F(SurName, "-") '= 0) S SurNameOut = $$MakeF($P(SurName, "-"))_"-"_$$MakeF($P(SurName, "-", 2)) I 1
 E  S SurNameOut = $$MakeF(SurName)
 S SurNameOut = $$ReturnedName(SurNameOut, NoUpSN)
 // имя
 I FirstName'="" D
 .S FirstNameOut = $$MakeN(FirstName)
 .S FirstNameOut = $$ReturnedName(FirstNameOut, NoUpFN)
 // отчество
 I (PatronymicName '= "") D
 .S PatronymicNameOut = $$MakeOT(PatronymicName)
 .S PatronymicNameOut = $$ReturnedName(PatronymicNameOut, NoUpPN)

 ;Q SurNameOut_$S(FirstName="":"",1:" "_FirstNameOut)_$S(PatronymicName '= "": " "_PatronymicNameOut, 1: "")
 
 N Res S Res = $S(SurName="":"",1:SurNameOut)
 S Res = Res _ $S(FirstName="":"",1:$S(Res="":"",1:" ")_FirstNameOut)
 S Res = Res _ $S(PatronymicName="":"",1:$S(Res="":"",1:" ")_PatronymicNameOut)

 Q Res

ReturnedName(NameOut, NoUp)
 Q $S('NoUp:NameOut,1:$ZCVT($E(NameOut),"U")_$ZCVT($E(NameOut,2,30000),"L")) ;@dol

IsSogl(c)
 I (c = "") Q 0
 S Sogl = "БВГДЖЗКЛМНПРСТФХЦЧШЩ"
 Q $S($F(Sogl, c) '= 0: 1, 1: 0)


MakeF(F)
 S FOut = F
 S Len = $L(F)                  // длина
 S OKF1 = $E(F, Len)            // последняя буква
 S OKF2 = $E(F, Len - 1)        // предпоследняя буква
 S OKF3 = $E(F, Len - 2)        // 3-я буква с конца
 S OKF12 = $E(F, Len - 1, Len)  // последние 2 буквы
 S OKF123 = $E(F, Len - 2, Len) // последние 3 буквы

 I (F = "БОБЁР") && (Sex = 0) D
 .S FOut = "БОБР"_$S(Case = 0: "А", Case = 1: "У", Case = 2: "А", Case = 3: "ОМ", Case = 4: "Е")
 E  I (F = "ЗАЯЦ") && (Sex = 0) D
 .S FOut = "ЗАЙЦ"_$S(Case = 0: "А", Case = 1: "У", Case = 2: "А", Case = 3: "ЕМ", Case = 4: "Е")
 E  I (F = "ОРЁЛ") && (Sex = 0) D
 .S FOut = "ОРЛ"_$S(Case = 0: "А", Case = 1: "У", Case = 2: "А", Case = 3: "ОМ", Case = 4: "Е")
 E  I (F = "СОЛОВЕЙ") && (Sex = 0) D
 .S FOut = "СОЛОВЬ"_$S(Case = 0: "Я", Case = 1: "Ю", Case = 2: "Я", Case = 3: "ЁМ", Case = 4: "Е")
 E  I (OKF12 = "ОК") && (Len > 3) && (Sex = 0) D  // АЗАРЕНОК
 .S $E(FOut, Len - 1, Len) = $S(Case = 0: "КА", Case = 1: "КУ", Case = 2: "КА", Case = 3: "КОМ", Case = 4: "КЕ")
 E  I (OKF123 = "ЛЕЦ") && (Sex = 0) D              // МАЛЕЦ
 .S $E(FOut, Len - 1, Len) = $S(Case = 0: "ЬЦА", Case = 1: "ЬЦУ", Case = 2: "ЬЦА", Case = 3: "ЬЦОМ", Case = 4: "ЬЦЕ")
 E  I (OKF12 = "ЕЦ") && ($$IsSogl(OKF3) = 1) && (Len > 4) && (Sex = 0) D   // ГОЛУБЕЦ, но КОЛОМИЕЦ, БЕЦ, ШВЕЦ
 .S $E(FOut, Len - 1, Len) = $S(Case = 0: "ЦА", Case = 1: "ЦУ", Case = 2: "ЦА", Case = 3: "ЦОМ", Case = 4: "ЦЕ")
 E  I ($$IsSogl(OKF1) = 1) && (OKF12 '= "ЫХ") && (OKF12 '= "ИХ") && (Sex = 0) D  // ПЕТРОВ
 .I (Case = 3) D
 ..I ((OKF12 = "ЕВ") || (OKF12 = "ЁВ") || (OKF12 = "ОВ") || (OKF12 = "ИН")) D
 ...S FOut = F_"ЫМ"
 ..E  S FOut = F_"ОМ"
 .E  S FOut = F_$S(Case = 0: "А", Case = 1: "У", Case = 2: "А", Case = 4: "Е")
 E  I ((OKF12 = "НА") ||  (OKF12 = "ВА")) && (Sex = 1) D  // ПЕТРОВА
 .S $E(FOut, Len) = $S(Case = 2: "У", 1: "ОЙ")
 E  I (OKF1 = "А") && (Sex = 0) D   // БУГА, БАЙДА
 .I (Case = 0) D
 ..I (OKF2 = "Г") || (OKF2 = "Ж") || (OKF2 = "К") || (OKF2 = "Х") || (OKF2 = "Ч") || (OKF2 = "Ш") || (OKF2 = "Щ") D
 ...S $E(FOut, Len) = "И"
 ..E  S $E(FOut, Len) = "Ы"
 .E  S $E(FOut, Len) = $S(Case = 1: "Е", Case = 2: "У", Case = 3: "ОЙ", Case = 4: "Е")
 E  I ((OKF123 = "ЧАЯ") || (OKF123 = "ШАЯ") || (OKF123 = "ЩАЯ") || (OKF123 = "ЖАЯ") || (OKF123 = "ЦАЯ")) && (Sex = 1) D  // НЕПОМНЯЩАЯ
 .S $E(FOut, Len - 1, Len) = $S(Case = 2: "УЮ", 1: "ЕЙ")
 E  I (OKF12 = "АЯ") && (Sex = 1) D   // БЕЛАЯ
 .S $E(FOut, Len - 1, Len) = $S(Case = 2: "УЮ", 1: "ОЙ")
 E  I ((OKF123 = "ЧИЙ") || (OKF123 = "ШИЙ") || (OKF123 = "ЩИЙ") || (OKF123 = "ЖИЙ") || (OKF123 = "ЦЫЙ")) && (Sex = 0) D  // НЕПОМНЯЩИЙ
 .I (Case = 3) D
 ..I (OKF123 = "ЦЫЙ") D
 ...S $E(FOut, Len - 1, Len) = "ЫМ"
 ..E  S $E(FOut, Len - 1, Len) = "ИМ"
 .E  S $E(FOut, Len - 1, Len) = $S(Case = 0: "ЕГО", Case = 1: "ЕМУ", Case = 2: "ЕГО", Case = 4: "ЕМ")
 E  I ((OKF12 = "ЫЙ") || (OKF12 = "ОЙ") || (OKF12 = "ИЙ")) && (Len > 3) && (Sex = 0) D  // БЕЛЫЙ
 .I (Case = 3) D
 ..I (OKF12 = "ЫЙ") || ((OKF12 = "ОЙ") && (OKF3 '= "Г") && (OKF3 '= "Ж") && (OKF3 '= "К") && (OKF3 '= "Х") && (OKF3 '= "Ч") && (OKF3 '= "Ш") && (OKF3 '= "Щ")) D
 ...S $E(FOut, Len - 1, Len) = "ЫМ"
 ..E  S $E(FOut, Len - 1, Len) = "ИМ"
 .E  S $E(FOut, Len - 1, Len) = $S(Case = 0: "ОГО", Case = 1: "ОМУ", Case = 2: "ОГО", Case = 4: "ОМ")
 E  I ((OKF1 = "Ь") || (OKF1 = "Й")) && (Sex = 0) D   // ДОВГАНЬ, ЦОЙ
 .S $E(FOut, Len) = $S(Case = 0: "Я", Case = 1: "Ю", Case = 2: "Я", Case = 3: "ЕМ", Case = 4: "Е")
 E  I (OKF12 = "ИЯ") && (Sex = 0) D   // ДАНЕЛИЯ
 .S $E(FOut, Len) = $S(Case = 0: "И", Case = 1: "И", Case = 2: "Ю", Case = 3: "ЕЙ", Case = 4: "И")
 E  I (OKF1 = "Я") && (Sex = 0) D     // ЗОЗУЛЯ
 .S $E(FOut, Len) = $S(Case = 0: "И", Case = 1: "Е", Case = 2: "Ю", Case = 3: "ЕЙ", Case = 4: "Е")

 Q FOut 


MakeN(N)
 S NOut = N
 S Len = $L(N)                  // длина
 S OKN = $E(N, Len)             // последняя буква
 S OKN12 = $E(N, Len - 1, Len)  // последние 2 буквы

 I (N = "ПАВЕЛ") D
 .S NOut = "ПАВЛ"_$S(Case = 0: "А", Case = 1: "У", Case = 2: "А", Case = 3: "ОМ", Case = 4: "Е")
 E  I (N = "ЛЕВ") D
 .S NOut = "ЛЬВ"_$S(Case = 0: "А", Case = 1: "У", Case = 2: "А", Case = 3: "ОМ", Case = 4: "Е")
 E  I (OKN12 = "ГА")!(OKN12 = "КА") D   // ИНГА,ОЛЬГА,ВЕРОНИКА И ПРОЧЕЕ
 .S $E(NOut, Len) = $S(Case = 0: "И", Case = 1: "Е", Case = 2: "У", Case = 3: "ОЙ", Case = 4: "Е")
 E  I (OKN = "А") D   // КУЗЬМА, ИРИНА
 .S $E(NOut, Len) = $S(Case = 0: "Ы", Case = 1: "Е", Case = 2: "У", Case = 3: "ОЙ", Case = 4: "Е")
 E  I (OKN12 = "ИЯ") D   // КСЕНИЯ
 .S $E(NOut, Len) = $S(Case = 0: "И", Case = 1: "И", Case = 2: "Ю", Case = 3: "ЕЙ", Case = 4: "И")
 E  I ((OKN = "Ь") && (Sex = 1)) D  // ЛЮБОВЬ
 .S $E(NOut, Len) = $S(Case = 0: "И", Case = 1: "И", Case = 2: "Ь", Case = 3: "ЬЮ", Case = 4: "И")
 E  I (OKN = "Я") D   // ИЛЬЯ, ЗОЯ
 .S $E(NOut, Len) = $S(Case = 0: "И", Case = 1: "Е", Case = 2: "Ю", Case = 3: "ЕЙ", Case = 4: "Е")
 E  I (OKN = "Й") || ((OKN = "Ь") && (Sex = 0)) D  // АНАТОЛИЙ, ИГОРЬ
 .S $E(NOut, Len) = $S(Case = 0: "Я", Case = 1: "Ю", Case = 2: "Я", Case = 3: "ЕМ", Case = 4: "Е")
 E  I ($$IsSogl(OKN) = 1) && (Sex = 0) D   // АНТОН
 .S NOut = N_$S(Case = 0: "А", Case = 1: "У", Case = 2: "А", Case = 3: "ОМ", Case = 4: "Е")

 Q NOut


MakeOT(OT)
 S OTOut = OT
 S Len = $L(OT)                  // длина
 S OKOT = $E(OT, Len)            // последняя буква

 I (OKOT = "Ч") D    // АНАТОЛЬЕВИЧ
 .S OTOut = OT_$S(Case = 0: "А", Case = 1: "У", Case = 2: "А", Case = 3: "ЕМ", Case = 4: "Е")
 E  I (OKOT = "А") D  // АНАТОЛЬЕВНА
 .S $E(OTOut, Len) = $S(Case = 0: "Ы", Case = 1: "Е", Case = 2: "У", Case = 3: "ОЙ", Case = 4: "Е")

 Q OTOut
]]></Implementation>
</Method>

<Method name="zNday">
<Description>
Кол - во дней для интервала дат форматов ГГГГMMДД, ДД.ММ.ГГГГ, ДД.ММ.ГГ</Description>
<Internal/>
<FormalSpec>datBeg:%Library.String,datEnd:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(datBeg)=""||($G(datEnd)="") Q "???"
 S:datBeg["." datBeg=$$zNdayD(datBeg) S:datEnd["." datEnd=$$zNdayD(datEnd)
 I $L(datEnd)'=8||($L(datBeg)'=8) Q datBeg
 S datBeg=$ZDH(datEnd,8)-$ZDH(datBeg,8)+1
 S datEnd=$E(datBeg,$L(datBeg)-1,$L(datBeg)) S:$L(datEnd)=1 datEnd=0_datEnd
 S datEnd=$S($E(datEnd)=1:"дней",$E(datEnd,2)="1":"день","234"[$E(datEnd,2):"дня",1:"дней")
 Q datBeg_" "_datEnd
zNdayD(dat) S:$L($P(dat,".",3))=2 $P(dat,".",3)=$S($P(dat,".",3)<50:19,1:20)_$P(dat,".",3)
 Q $P(dat,".",3)_$E(100+$P(dat,".",2),2,3)_$E(100+$P(dat,".",1),2,3)
]]></Implementation>
</Method>

<Method name="zNoLeer">
<Description>
Убрать "малозначащие" пробелы (после цифры, после точки, задвоенные\ведущие\завершающие пробелы</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N pos S Arg1=$ZSTRIP(Arg1,"<>W"),pos=1 F  S pos=$F(Arg1," ",pos) Q:'pos  S:$E(Arg1,pos)=" " $E(Arg1,pos)="" S:$E(Arg1,pos-2)="."||($E(Arg1,pos-2)?1n) $E(Arg1,pos-1)="",pos=pos-1
 Q Arg1
]]></Implementation>
</Method>

<Method name="zNum">
<Description>
Кол-во экземпляров объекта Arg1 подчиненных текущему.
Rel=1 учет режима уточнения, если есть релевантные

RealObj - если задан, то код реального объекта, относительно которого необходимо подсчитать кол-во. В этом случае виртуалная структура текущего отображения не учитывается!!!</Description>
<Internal/>
<FormalSpec>Obj:%String,Rel:%Library.String=0,RealObj:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 I $G(qqo)="" N qqc,qqo S qqc="",qqo=$P($$$ObjRef(Obj),",")
 I Rel,$$$ReFind N qql S qql=$S('$D(qFindDO):$$$Relind,1:'$$$Relind)_qview ;учет режима уточнения
 N q S q=0 I $G(RealObj)'="",qqo'=RealObj N qqo S q=1,qqo=RealObj ;@dol 14.01.03
 I Obj=qqo N qqo S qqo=$P($$$ObjRef(Obj),",",$L($$$ObjRef(Obj),",")-1),q=1 Q:qqo="" 0
 I '$D(Vt(qqnump,111))||($G(RealObj)'="")||'$D($$$ObjRef(Obj)) N qqco,qnumqqc S qnumqqc=0 D  Q qnumqqc
 .I q S qqco=qqc N qqc S qqc=$$$UserOrd(-1,qqo,qqco,"") Q:qqc'=$E(qqco,1,$L(qqc))
 .S qqco=qqc F qnumqqc=0:1 S qqco=$O(^Q(qql,Obj,qqco)) Q:qqco=""  Q:$E(qqco,1,$L(qqc))'=qqc
 N ObjRef,qnumqqc,qqco S ObjRef=$P(","_$$$ObjRef(Obj)_",",","_qqo_",",2) Q:ObjRef="" "???"_Obj
 F qnumqqc=1:1:$L(ObjRef,",")-1 I $G(Vo(qqnump,$P(ObjRef,",",qnumqqc),2))>1 S qqco=1 Q
 I '$G(qqco) D  Q qnumqqc
 .I q S qqco=qqc N qqc S qqc=$$$UserOrd(-1,qqo,qqco,"") Q:qqc'=$E(qqco,1,$L(qqc))
 .S qqco=qqc F qnumqqc=0:1 S qqco=$O(^Q(qql,Obj,qqco)) Q:qqco=""  Q:$E(qqco,1,$L(qqc))'=qqc
 Q:q 0 S qnumqqc=0 D zNumre(1,qqc) Q qnumqqc
zNumre(qqoi,qqco)   N qqon,qqcoo S qqon=$P(ObjRef,",",qqoi),qqcoo="" F  S qqcoo=..gOrder(1,qqon,qqcoo,qqco) Q:qqcoo=""  D
 .I qqon=Obj,$I(qnumqqc) Q
 .D zNumre(qqoi+1,qqcoo)
 Q
]]></Implementation>
</Method>

<Method name="zNumDay">
<Description>
Кол-во дней в интервале с прописью. Месяц считается за 30 дней, год - за 365, неделя - за 7 ;@Dol 09.08.10</Description>
<Internal/>
<FormalSpec>stri</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ S stri=$ZCVT(stri,"L") Q stri*$S(stri["нед":7,stri["мес":30,stri["год":365,1:1)
]]></Implementation>
</Method>

<Method name="zNumPr">
<Description>
Число qqpar1 прописью.
Если задан qqpar2, то имена для целои и дробной части через пробел. По умолчанию - руб. коп.</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N L,N,N1,O,S,T,I,%S,R,%1 S %1=$P(qqpar1,".",2),%S=$S(qqpar1<0:"минус ",1:""),qqpar1=$P(qqpar1,".") S:qqpar1<0 qqpar1=-qqpar1 I +qqpar1=0 Q "=00 руб."
 S L=$L(qqpar1)+2\3,R=$L(qqpar1)#3 S:'R R=3
 F I=L:-1:3 S N=$E(qqpar1,$S(I=L:1,1:L-I*3-2+R),$S(I=L:R,1:L-I*3+R)),T=0 I N S M=$S(I=4:"миллиард",1:$P("  мил  трил квадрил квинтил секстил септил окта нона дека ундека додека"," ",I)_"лион") D 3,O S %S=%S_S_M_O_" "
 S N=$E(qqpar1,$L(qqpar1)-5,$L(qqpar1)-3),T=1 I N D 3,O S %S=%S_S_"тысяч"_O_" "
 S N=$E(qqpar1,$L(qqpar1)-2,$L(qqpar1)),T=0 I N D 3 S %S=%S_S
 S %s1=$E(qqpar1,$L(qqpar1)),%s2=$E(qqpar1,$L(qqpar1)-1) S:%s2=1 %S1="лей" S:%s2'=1 %S1=$S(%s1=1:"ль",%s1<5&(%s1>1):"ля",1:"лей")
 S:$G(qqpar2)="" %S=%S_"руб"_%S1_" "_$E(%1_"00",1,2)_" копeeк" S:$G(qqpar2)'="" %S=%S_$P(qqpar2," ")_$S($P(qqpar2," ",2)="":"",1:" "_$E(%1_00,1,2)_" "_$P(qqpar2," ",2)) Q ..qConv($E(%S),,,,1)_$E(%S,2,1000)
3       S S="",N1=N\100 I N1 S S=$P("сто,двести,триста,четыреста,пятьсот,шестьсот,семьсот,восемьсот,девятьсот",",",N1)_" "
 S N1=N\10#10 I N1>1 S S=S_$P(",двадцать,тридцать,сорок,пятьдесят,шестьдесят,семьдесят,восемьдесят,девяносто",",",N1)_" "
 S N1=N#10+(N1=1*10) I N1 S S=S_$P("один,два,три,четыре,пять,шесть,семь,восемь,девять,десять,одиннадцать,двенадцать,тринадцать,четырнадцать,пятнадцать,шестнадцать,семнадцать,восемнадцать,девятнадцать",",",N1)_" "
 I N1,T,N1<3 S:N1=1 $E(S,$L(S)-2,$L(S)-1)="на" S:N1=2 $E(S,$L(S)-1)="е"
 Q
O       S N1=N#10 I T S O="" Q:N\10#10=1  S O=$S(N1=1:"а",N1=2!(N1=3)!(N1=4):"и",1:"") Q
 S O="ов" Q:N\10#10=1  S O=$S(N1=1:"",N1=2!(N1=3)!(N1=4):"а",1:"ов") Q
]]></Implementation>
</Method>

<Method name="zPr">
<Description>
Число с прописью. var=0 - Дни, =1 разы ;@Dol 09.08.10</Description>
<Internal/>
<FormalSpec>num,var,nonum</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ Q $S($G(nonum):"",1:num_" ")_$S($G(var)=1:$S(num=1:"раз",num<5:"раза",1:"раз"),1:$S(num=1:"день",num<5:"дня",1:"дней"))
]]></Implementation>
</Method>

<Method name="zRcvt">
<Description>
Преобразование регистра только для русских букв
Arg2="U" - в большие, "L" - в маленькие</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[ Q $S(Arg2="U":$TR(Arg1,"йцукенгшщзхъфывапролджэячсмитьбюё","ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮЁ"),1:$TR(Arg1,"ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮЁ","йцукенгшщзхъфывапролджэячсмитьбюё"))
]]></Implementation>
</Method>

<Method name="zRep">
<Description>
Убрать повторяющиеся слова в Arg1</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S Arg1=$ZSTRIP(Arg1,"<>W") Q:$L(Arg1," ")=1 Arg1
 N qqz,qqzi F qqzi=2:1 Q:qqzi>$L(Arg1," ")  S qqz=$P(Arg1," ",qqzi) S:qqz=""||(" "_$P(Arg1," ",1,qqzi-1)_" "[(" "_qqz_" ")) Arg1=$P(Arg1," ",1,qqzi-1)_$S($L(Arg1," ")=qqzi:"",1:" "_$P(Arg1," ",qqzi+1,30000)),qqzi=qqzi-1 ;убрали пустые или повторы
 Q Arg1
]]></Implementation>
</Method>

<Method name="zReplace">
<Description><![CDATA[
Метод заменяет в строке String подстроку From на подстроку To.
<br>По умолчанию To="", т.е.  подстроки From удаляются из  String.
<br> ReplSeries=1 - заменять последовательность подстрок From (серия) на одну подстроку To.
<br> DelEnds=1 - удалять подстроку From (или последовательность подстрок From при ReplSeries=1),
находящую в начале или конце исходной строки String.
<br>
<br> Например, 
<br> >S a=";;ПЕРВЫЙ;;ВТОРОЙ;ТРЕТИЙ;;;"
<br> >W qUSER.zReplace(a,";",";",1,1)
<br> >"ПЕРВЫЙ;ВТОРОЙ;ТРЕТИЙ"]]></Description>
<Internal/>
<ClassMethod>1</ClassMethod>
<FormalSpec>String:%Library.String="",From:%Library.String="",To:%Library.String="",ReplSeries:%Library.String=0,DelEnds:%Library.String=0</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
#DEFINE CacheVersion $p($p($zv,") ",2)," ",1)
#IF $$$CacheVersion>2008

 q:'ReplSeries&&'DelEnds $replace(String,From,To)
 n str0,s2From
 if DelEnds { ; серия в начале строки убирается всегда, даже если серии не сжимаются (так оно и раньше было)
    while ($e(String,1)=From) { 
        s String=$e(String,2,*)
    }
    if ReplSeries {
        while ($e(String,*)=From) {
          s String=$e(String,1,*-1)
        }
    } elseif $e(String,*)=From {
        s String=$e(String,1,*-1)
    }
 }
 if ReplSeries {
    s s2From=From_From
    do {
        s str0=String,String=$replace(String,s2From,From)
    } while (String'=str0)
 }
 s String=$replace(String,From,To)
 q String

#ELSE

 I ($G(String)="")||($G(From)="") Q ""

 N FromLen S FromLen=$L(From)              // длина заменяемой подстроки
 N DelLen                                  // длина заменяемой серии или подстроки, если нет серий 
 N i S i=0
 N j S j=0
 N Flag                                    // Flag=1, если есть серия

 // обходим строку
 F  S i=$F(String,From,i) Q:'i  D
 .S DelLen=FromLen
 .I $G(ReplSeries)=1 D                     // если ReplSeries=1, проверяем наличие серии 
 ..S Flag=1
 ..// движемся по строке, пока есть серия
 ..F  S j=$F(String,From,i) Q:Flag=0  D
 ...I j=(i+FromLen) D                      // если j=(i+FromLen), значит, есть серия
 ....S DelLen=DelLen+FromLen               // накапливаем длину серии
 ....S i=i+FromLen               
 ....S Flag=1                              // устанавливаем флаг серии
 ...E  S Flag=0                            // иначе, сбрасываем флаг серии
 .// если DelEnds=1, удаляем концы
 .I ($G(DelEnds)=1)&&((i=(DelLen+1))||(i=($L(String)+1))) D
 ..S $E(String,i-DelLen,i-1) = ""
 ..S i=i-DelLen                            // изменяем i для продолжения поиска после места вставки
 .E  D
 ..S $E(String, i-DelLen,i-1) = $G(To)     // иначе, заменяем
 ..S i=i-DelLen+$L($G(To))                 // изменяем i для продолжения поиска после места вставки

 Q String
 
#ENDIF
]]></Implementation>
</Method>

<Method name="zSum">
<Description>
Сумма понятия для объекта, подчиненного текущему.
Rel=1 учет режима уточнения, если есть релевантные
RealObj - если задан, то код реального объекта, относительно которого необходимо подсчитать сумму.
!!! В этом случае виртуалная структура текущего отображения не учитывается!!!
Cond - Условие на суммирование (относительно qqo и qqc). Суммируется, если подчиненный объект удовлетворяет условию ;@Dol 07.12.09</Description>
<Internal/>
<FormalSpec>Obj:%String,qqw:%String,Rel:%Library.String=0,RealObj:%Library.String,Cond</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 Q:Obj=$G(qqo) ..G(qqw) ;Q:$G($$$ObjRef(Obj))="" "???"_Obj
 I $G(qqo)="" N qqc,qqo S qqc="",qqo=$P($$$ObjRef(Obj),",")
 I Rel,$$$ReFind N qql S qql=$S('$D(qFindDO):$$$Relind,1:'$$$Relind)_qview ;учет режима уточнения
 N q S q=0 I $G(RealObj)'="",qqo'=RealObj N qqo S q=1,qqo=RealObj
 I '$D(Vt(qqnump,111))||($G(RealObj)'="")||'$D($$$ObjRef(Obj)) N Num,qqco,Sum D  Q Sum
 .I q S qqco=qqc N qqc S qqc=$$$UserOrd(-1,qqo,qqco,"") Q:qqc'=$E(qqco,1,$L(qqc))
 .S Sum=0,qqco=qqc F Num=0:1 S qqco=$O(^Q(qql,Obj,qqco)) Q:qqco=""  Q:$E(qqco,1,$L(qqc))'=qqc  S:'$D(Cond)||$$zSumCond(Obj,qqco) Sum=Sum+$ZSTRIP(..GG(Obj,qqw,qqco),"<>W")
 N ObjRef,Num,qqco,Sum S ObjRef=$P(","_$$$ObjRef(Obj)_",",","_qqo_",",2) Q:ObjRef="" "???"_Obj
 F Num=1:1:$L(ObjRef,",")-1 I $G(Vo(qqnump,$P(ObjRef,",",Num),2))>1 S qqco=1 Q
 S Sum=0 I '$G(qqco) D  Q Sum
 .I q S qqco=qqc N qqc S qqc=$$$UserOrd(-1,qqo,qqco,"") Q:qqc'=$E(qqco,1,$L(qqc))
 .S qqco=qqc F Num=0:1 S qqco=$O(^Q(qql,Obj,qqco)) Q:qqco=""  Q:$E(qqco,1,$L(qqc))'=qqc  S:'$D(Cond)||$$zSumCond(Obj,qqco) Sum=Sum+$ZSTRIP(..GG(Obj,qqw,qqco),"<>W")
 S Num=0 D zSumre(1,qqc) Q Sum
zSumre(qqoi,qqco)   N qqon,qqcoo S qqon=$P(ObjRef,",",qqoi),qqcoo="" F Num=Num:1 S qqcoo=..gOrder(1,qqon,qqcoo,qqco) Q:qqcoo=""   D:qqon'=Obj zSumre(qqoi+1,qqcoo) S:qqon=Obj&&('$D(Cond)||$$zSumCond(Obj,qqcoo)) Sum=Sum+$ZSTRIP(..GG(Obj,qqw,qqcoo),"<>W")
 Q
zSumCond(qqo,qqc) I @Cond Q 1  ;@Dol 07.12.09
 Q 0
]]></Implementation>
</Method>

<Method name="zTLine">
<Description>
Свертка текста в строку.
mas - ссылка на массив строк

Возвращает строку с убранными переносами</Description>
<Internal/>
<FormalSpec>mas:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N istr,s,ss S ss="",istr="" F  S istr=$O(@mas@(istr)) Q:istr=""  S s=$ZSTRIP($G(@mas@(istr)),"<>W") I s'="" S ss=$S(ss="":ss_s,$E(ss,$L(ss))'="-":ss_" "_s,$E(ss,$L(ss)-1)'=" ":$E(ss,1,$L(ss)-1)_s,1:ss_" "_s)
 Q ss
]]></Implementation>
</Method>

<Method name="zTime">
<Description>
Операции с временем. Возвращает:
задано время t1 - Кол-во минут
             t1 и t2 - длительность интервала t2-t1 в минутах
             t1 как интервал (ЧЧ:ММ-ЧЧ:ММ) - длительность интервала в минутах
Если неверен формат времени, возвращае знак вопроса (?)
tp=1 - для преобразования получившейся длительности интервала в ЧЧ:ММ
tp="+" - добавить к t1 t2. В этом случае t2 может задаваться в минутах (число) или в формате ЧЧ:ММ. Возвращается получившееся время в формате ЧЧ:ММ</Description>
<Internal/>
<FormalSpec>t1:%Library.String,t2:%Library.String,tp</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 N $ET S $ET="S:$ZE'[""CLASS REC"" $EC="""" Q:$Q ""?"" Q"
 S:$G(t2)="" t2=$P(t1,"-",2),t1=$P(t1,"-",1) S t1=$S(t1="":0,1:$ZTH(t1)) S:t2'="" t1=$S($G(tp)="+":t1+$S(t2[":":$ZTH(t2),1:t2*60),1:$ZTH(t2)-t1) S:$G(tp)="+" tp=1
 Q $S('$G(tp):t1\60,1:$P($ZT(t1),":",1,2))
]]></Implementation>
</Method>

<Method name="zTmp">
<Description>
УЖЕ НЕ ИСПОЛЬЗУЕТСЯ

Вычисляет для текущего экземпляра объекта условие темпоральной коррекции.
MainObj - код объекта (главного). 
ObjList - список (через пробел) вида qqo0:qqo1:qqwqqo1
Ini - вариант использования

Параметры инициализации:
Arg1=1 - не учитывать дату закрытия (факт закрытия) при подборе общих сведений
Arg2=1 - не записывать привязку (YT) для документа, если ничего не изменилось а ее раньше не было.</Description>
<Internal/>
<FormalSpec>MainObj:%Library.String,ObjList:%Library.String,Ini:%Library.String,Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 N qqoo,iobj,qqcmain,test,qqcc,qqww
 S:'$G(Vt(qqnump,"ZTmpL")) Vt(qqnump,"ZTmpL")=$S($D($$$ObjLqqc(MainObj))#2:$$$ObjLqqc(MainObj),1:$G(^Q(1,"CxObj",MainObj,"X50"),255))
 S qqcmain=$E(qqc,1,Vt(qqnump,"ZTmpL"))
 I '$G(Ini) N ndoc,ndocny S ndoc=0,ndocny=0,test=0 D  Q $S(test:test_" "_qqoo_" "_qqcc,ndoc=ndocny:0,ndoc=1:0,1:1) ;тестирование на привязку к документу
 .F iobj=1:1:$L(ObjList," ") S qqoo=$P($P(ObjList," ",iobj),":") D  Q:test
 ..S qqcc="" F  S qqcc=$$$UserOrd(-1,qqoo,qqcc,qqcmain) Q:qqcc=""  S ndoc=ndoc+1 I $D(^Q(1,qqoo,qqcc,"YT",qqo)) S ndocny=ndocny+1 I $S(qqoo=$G(Vt(qqnump,"ZTmpqqo")):qqcc'=$G(Vt(qqnump,"ZTmpqqc")),1:1)  S test=qqcmain_$G(^Q(1,qqoo,qqcc,"YT",qqo))=qqc Q:test
 I $G(Ini)=1 S qqcc="" D  Q:qqcc'="" 1 K Vt(qqnump,"ZTmpqqc") Q 0  ;инициализация темпоральности (если нет документов, то первый подходящий)
 .I $G(Vt(qqnump,"ZTmpqqc"))'="",$G(W("ZBtred")),$G(Vt(qqnump,"ZTmpYT"))'=1,Vt(qqnump,"ZTmpqqc")'[" ",'Vt(qqnump,"ZTmp2") D ..rCor(Vt(qqnump,"ZTmpqqo"),Vt(qqnump,"ZTmpqqc"),"YT",,0) ;автокоррекция предыдущего??? без изменения даты ;$P($G(Vt(qqnump,"ZTmpYT"))," ",2)-что-то изменено
 .I " "_$TR(ObjList,":"," ")_" "[(" "_$G(qqo)_" ") S qqoo=qqo,qqcc=qqc,qqww=$P($P(" "_$TR(ObjList,":"," ")_" "," "_qqo_" ",2)," ") I 1 ;текущий объект в списке тепоральных
 .E  F iobj=1:1:$L(ObjList," ") S qqoo=$P(ObjList," ",iobj),qqww=$P(qqoo,":",2,255),qqoo=$P(qqoo,":") I $D(Vo(qqnump,qqoo)) S qqcc=$$$UserOrd(1,qqoo,qqc,qqc) Q:qqcc'=""  ;если есть в отображении и в наличии экземпляр
 .I qqcc="" F iobj=1:1:$L(ObjList," ") S qqoo=$P(ObjList," ",iobj),qqww=$P(qqoo,":",2,255),qqoo=$P(qqoo,":"),qqcc=$$$UserOrd(1,qqoo,qqc,qqc) Q:qqcc'=""  ;если даже нет в отображении и в наличии экземпляр
 .Q:qqcc=""
 .S Vt(qqnump,"ZTmp1")=+$G(Arg1),Vt(qqnump,"ZTmp2")=+$G(Arg2),Vt(qqnump,"ZTmp3")=+$G(Arg3)
 .S Vt(qqnump,"ZTmpqqc")=qqcc,Vt(qqnump,"ZTmpqqo")=qqoo,Vt(qqnump,"ZTmpdat")=$S(qqww="":"",1:..GG(qqoo,qqww,qqcc))
 .K Vt(qqnump,"ZTmpYT") M Vt(qqnump,"ZTmpYT")=^Q(1,qqoo,qqcc,"YT")
 .S Vt(qqnump,"ZTmpYT")=''$D(Vt(qqnump,"ZTmpYT")) ;будет признаком, что состояние есть
 .K Vt(qqnump,"ZTmpYTnew") ;изменения состояния для незакрытого документа (если будут более поздние экземпляры)
 ;Ini=2
 N qqw,qqT S test=0 D  Q test ;Условие вывода на автоматическое (когда нет привязки) определение темпоральности текущего объекта по датам создания
 .N qqT,qqTD,qqTDD S qqT=$$zTmpXc(qqo,qqc) ;берем дату создания (или коррекции) с точность до дня
 .I qqT="" S test=1 Q  ;нет никаких дат (берем последний)
 .S qqTD=$$zTmpXc(Vt(qqnump,"ZTmpqqo"),Vt(qqnump,"ZTmpqqc")) ;берем дату создания (или коррекции) текущего документа
 .I qqTD="" S test=$S(Vt(qqnump,"ZTmpdat")="":1,Vt(qqnump,"ZTmp1"):1,1:qqT'>Vt(qqnump,"ZTmpdat")) Q  ;нет никаких дат у документа
 .S test=qqT'>qqTD_" "_qqT_" "_qqTD Q:test  ;общие сведения созданы не позже документа
 .S test=1 F iobj=1:1:$L(ObjList," ") S qqoo=$P($P(ObjList," ",iobj),":") D  Q:'test
 ..S qqcc="" F  S qqcc=$$$UserOrd(-1,qqoo,qqcc,qqcmain) Q:qqcc=""    I $S(qqoo=$G(Vt(qqnump,"ZTmpqqo")):qqcc'=$G(Vt(qqnump,"ZTmpqqc")),1:1) S qqTDD=$$zTmpXc(qqoo,qqcc) I qqTDD>qqTD,qqT'<qqTDD S test=0_" "_qqoo_" "_qqcc Q  ;есть более поздний документ с подходящими общими сведениями
 .I test S test="1 "_qqT_" "_qqTD_" "_$G(qqDD) I 'Vt(qqnump,"ZTmp1"),Vt(qqnump,"ZTmpdat")'="",qqT>Vt(qqnump,"ZTmpdat") S test="0 "_qqT
 Q ""
zTmpXc(qqop,qqcp)   N qqw,qq F qqw="Xc","X" S qq=$G(^Q(1,qqop,qqcp,qqw)) I qq'="" S qq=$ZD($P(..zCnv(0,qq)," "),8) Q
 Q qq
]]></Implementation>
</Method>

<Method name="zTmpI">
<Description>
Проверка даты date (не задана - берется из W("Zdatenow"), если нет - текуая)
in=0 - Не совпадает в пределах дня с датой коррекции (X) или создания (Xc), если Xd=1 ;???? @Dol 22.10.09 почему-то всегда проверялась X
       NoAdm=1 - вне зависимости от режима Администратор ;29.10.09
in=1 - попадает в интервал от Xc до Xd (если параметр Xd не задан, берется из понятия Xd)
qqoo, qqcc - код объекта и экземпляра. Не заданы - используется текущие qqo и qqc
Возвращает 1 или 0.</Description>
<Internal/>
<FormalSpec>in:%Library.String,date:%Library.String,Xd:%Library.String,qqoo,qqcc,NoAdm</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 I $G(qqoo)'="" N qqo,qqc S qqo=qqoo,qqc=qqcc
 S:$G(date)="" date=$G(W("Zdatenow")) S date=$S(date="":$H,1:$ZDH(date,8)) S:date'["," date=date_","_(24*3600-1)
 S date=$TR(date,",",".")
 N qq I '$G(in) Q:($G(W("Zadm"))&&'$G(NoAdm))||(qqc[" ")||(qqc="") 0 S qq=$S('$G(Xd):$G(^Q(1,qqo,qqc,"X")),1:$G(^Q(1,qqo,qqc,"Xc"))) Q:qq="" 0 Q $P(..zCnv(0,qq),",")'=$P(date,".") ;создана не в текущий день (по дате коррекции)
 S qq=$G(^Q(1,qqo,qqc,"Xc")) I qq'="" Q:$TR(..zCnv(0,qq),",",".")>date 0  ;дата создания
 I $G(Xd)'="",Xd=+Xd S Xd=$TR($ZDTH(Xd,8),",",".") I date>Xd Q 0 ;дата удаления
 S qq=$G(^Q(1,qqo,qqc,"Xd")) Q:qq="" 1 Q date'>$TR(..zCnv(0,qq),",",".")
]]></Implementation>
</Method>

<Method name="zTraspisan">
<Description>
Преобразование текстового понятия описания расписания (Arg1, по умолчанию "Traspisan") в понятие W("Y"_$E(Arg1,2,255),Arg4) и обратно (Arg2=1)

Если задан Arg3 - то это qqnump окна, в котором находится W(Arg1)

Arg4 - для хранения истории изменения расписания</Description>
<Internal/>
<FormalSpec>Arg1:%Library.String,Arg2:%Library.String,Arg3:%Library.String,Arg4:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 S:$G(Arg1)="" Arg1="Traspisan"
 N in,iz,jn,jz,iin,izz,qw I $G(Arg2) D  Q:$Q "" Q
 .K:$G(Arg3)="" W(Arg1) K:$G(Arg3)'="" WS(Arg3,Arg1)
 .S in="" F iin=0:1 S in=$O(W("Y"_$E(Arg1,2,255),Arg4,in)) Q:in=""  S iz=$G(W("Y"_$E(Arg1,2,255),Arg4,in)),iz=$S(iz="":" ",1:$TR($P(iz,"~",1)," ")_" "_$P(iz,"~",2,255)) D
 ..S jn="" F  S jn=$O(W("Y"_$E(Arg1,2,255),Arg4,in,jn)) Q:jn=""  D
 ...S izz=$TR(W("Y"_$E(Arg1,2,255),Arg4,in,jn)," ","_") Q:izz=""  S qw=$P(izz,"~"),izz=$P(izz,"~",2,255) S:qw[":" qw=$E(100+qw,2,3)_":"_$P(qw,":",2,255)
 ...S iz=iz_" "_qw_$S(izz="":"",1:"~"_izz)
 ..I $TR(iz,"~ ")="" S iin=iin-1 Q
 ..I $G(Arg3)="" S W(Arg1,iin)=iz Q
 ..S WS(Arg3,Arg1,iin)=iz
 K W("Y"_$E(Arg1,2,255),Arg4) S in="" F  S in=$S($G(Arg3)'="":$O(WS(Arg3,Arg1,in)),1:$O(W(Arg1,in))) Q:in=""  S iz=$S($G(Arg3)'="":$G(WS(Arg3,Arg1,in)),1:$G(W(Arg1,in))) D
 .S (inn,jn)=$P(iz," ") I jn'="" S inn="" F  S inn=$S(inn="":"",1:inn_" ") D  Q:jn=""
 ..I "#N"'[$E(jn) S inn=inn_$E(jn),jn=$E(jn,2,255) Q
 ..S inn=inn_$E(jn,1,2),jn=$E(jn,3,255) F  Q:$E(jn)=""  Q:$E(jn)'?1N  S inn=inn_$E(jn),jn=$E(jn,2,255)
 .S W("Y"_$E(Arg1,2,255),Arg4,in)=inn_"~"_$P(iz," ",2),iz=$P(iz," ",3,30000)
 .F jn=1:1:$L(iz," ") S W("Y"_$E(Arg1,2,255),Arg4,in,jn)=$P(iz," ",jn)
 Q:$Q "" Q
]]></Implementation>
</Method>

<Method name="zZod">
<Description>
Расчет знака зодиака по нормализованной дате (qqpar1)
qqpar2 - язык (1 - русский)</Description>
<Internal/>
<FormalSpec>qqpar1:%String,qqpar2:%String</FormalSpec>
<Language>cache</Language>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 N qqx S:'$D(qqpar2) qqpar2=qqlang S qqpar2=$S(qqpar2=1:1,1:2)
 S qqx=$E(qqpar1,5,8) Q:'qqx!($L(qqx)'=4) "" S qqx=1_qqx
 Q $P($S(qqx<10120:"Козерог,Capricornus",qqx<10219:"Водолей,Aquarius",qqx<10321:"Рыбы,Pisces",qqx<10421:"Овен,Aries",qqx<10522:"Телец,Taurus",qqx<10622:"Близнецы,Gemini",qqx<10723:"Рак,Cancer",qqx<10823:"Лев,Leo",qqx<10923:"Дева,Virgo",qqx<11023:"Весы,Libra",qqx<11123:"Скорпион,Scorpius",qqx<11221:"Стрелец,Sagittarius",1:"Козерог,Capricornus"),",",qqpar2)
]]></Implementation>
</Method>

<Method name="zaddm">
<Description>
Добавление целого числа месяцев к базовой дате
Параметры:

BaseDate - базовая дата
addmm - количество месяцев, добавляем к базовой дата, м.б. отрицательное число
SetDay - установаить определённый день в месяце
1 - первый
2 - последний

Возвращаемое значение: дата в формате yyyymmdd
Если $G(BaseDate)="", то в качестве базовой берётся текущая дата</Description>
<Internal/>
<FormalSpec>BaseDate:%Library.String,addmm:%Library.String,SetDay:%Library.String</FormalSpec>
<Language>cache</Language>
<Implementation><![CDATA[
 // Если $G(BaseDate)="", то в качестве базовой берётся текущая дата
 Q:$G(addmm)="" ""
 N dd,mm,yyyy
 N ddres,mmres,yyyyres

 S:$G(BaseDate)="" BaseDate=$ZD($H,8)

 S (ddres,dd)=$E(BaseDate,7,8)
 S (mmres,mm)=$E(BaseDate,5,6)
 S (yyyyres,yyyy)=$E(BaseDate,1,4)


 // если прибавляем (отнимаем) больше года
 I ($ZABS(addmm\12)>0) D
 .S yyyyres=yyyyres+(addmm\12)
 .S addmm=addmm-((addmm\12)*12)

 I ((mm+addmm)>12) D      // если переходим в следующий год
 .S yyyyres=yyyyres+1
 .S mmres=(mm+addmm)-12
 E  I ((mm+addmm)<1) D    // если переходим в предыдущий год
 .S yyyyres=yyyyres-1
 .S mmres=(mm+addmm)+12
 E  S mmres=mm+addmm

 I ($G(SetDay)=1) S ddres=1  // установить первое число месяца
 E  D
 .I ($G(SetDay)=2) S (ddres,dd)=31   // установить последнее число месяца
 .// если переходим в месяц с количеством дней < 31
 .I (mmres=2) D     // февраль
 ..I (dd>28) D
 ...I ((yyyyres#4)=0) S ddres=29
 ...E  S ddres=28
 .E  I ((mmres=4)||(mmres=6)||(mmres=9)||(mmres=11)) D   // апрель,июнь,сентябрь,ноябрь
 ..I (dd=31) S ddres=30

 N Date
 S Date=$ZDH(ddres_"/"_mmres_"/"_yyyyres,4)
 Q $ZD(Date,8)
]]></Implementation>
</Method>

<Method name="zsymbol">
<Description>
Убрать в строке все символы, кроме цифр и букв</Description>
<Internal/>
<FormalSpec>str:%Library.String</FormalSpec>
<Language>cache</Language>
<ReturnType>%Library.String</ReturnType>
<Implementation><![CDATA[
 n nstr,sym S nstr="" f i=1:1:$l(str) S sym=$a($e(str,i)),nstr=nstr_$S(sym>47&(sym<58):$e(str,i),sym>64&(sym<91):$e(str,i),sym>64&(sym<91):$e(str,i),sym>91&(sym<123):$e(str,i),sym>191&(sym<224):$e(str,i),sym>223&(sym<256):$e(str,i),1:"") 
 q nstr
]]></Implementation>
</Method>
</Class>


<Class name="%Library.qccServer">
<Description><![CDATA[
This class is used internally by Cach&eacute;. You should not make direct use of it within your applications. There is no guarantee made about either the behavior or future operation of this class.<p>]]></Description>
<IncludeCode>%systemInclude</IncludeCode>
<System>3</System>
<TimeCreated>59241,41416</TimeCreated>

<Method name="Run">
<ClassMethod>1</ClassMethod>
<FormalSpec>action:%String,arg1:%String,arg2:%String,arg3:%String</FormalSpec>
<PublicList>serialized</PublicList>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If '$system.Security.Check("%Development","USE") Quit $$ErrorText^%qccServer($$$ERROR($$$SecurityNotDeveloper))
	If action="GetClassIndex"              Set output=$$GetClassIndex^%qccServer(.arg1,.arg2)
	If action="GetSpecialList"             Set output=$$GetSpecialList^%qccServer(.arg1,.arg2)
	If action="GetClassTimestamp"          Set output=$$GetClassTimestamp^%qccServer(.arg1)
	If action="GetClassDefinition"         Set output=$$GetClassDefinition^%qccServer(.arg1,.serialized)
	If action="GetClassDefinitionCP"       Set output=$$GetClassDefinitionCP^%qccServer(.arg1,,.serialized)
	If action="GetClassDefinitionExcess"   Set output=$$GetClassDefinitionExcess^%qccServer(.arg1,.serialized)
	If action="SaveClassDefinitionPrepare" Set output=$$SaveClassDefinitionPrepare^%qccServer(.arg1,.arg2,.serialized)
	If action="SaveClassDefinition"        Do SaveClassDefinitionPrepare^%qccServer(.arg1,.arg2,.serialized) Set output=$$SaveClassDefinition^%qccServer(.serialized)
	If action="DeleteClassDefinition"      Set output=$$DeleteClassDefinition^%qccServer(.arg1)
	If action="GetSchemaDefinition"        Set output=$$GetSchemaDefinition^%qccServer(.arg1,.arg2,0,.serialized)
	If action="LockClass"                  Set output=$$LockClass^%qccServer(.arg1)
	If action="UnlockClass"                Set output=$$UnlockClass^%qccServer(.arg1)
	If action="IsClassnameConflict"        Set output=$$IsClassnameConflict^%qccServer(.arg1)
	If action="OutputLog"                  Set output=$$OutputLog^%qccServer(.arg1)
	If action="SupportFeature"             Set output=$$SupportFeature^%qccServer(.arg1)
	If action="GetMacroList"			   Set output=$$GetMacroList^%qccServer(.arg1,.arg2,.arg3)
	If action="GetMacroSignature"		   Set output=$$GetMacroSignature^%qccServer(.arg1,.arg2)
	If action="GetMacroLocation"           Set output=$$GetMacroLocation^%qccServer(.arg1,.arg2)
	If action="GetMacroDefinition"         Set output=$$GetMacroDefinition^%qccServer(.arg1,.arg2) 
	If action="GetMacroExpansion"          Set output=$$GetMacroExpansion^%qccServer(.arg1,.arg2,.arg3)
	If action="CheckSchemaCacheUpToDate"   Set output=$$CheckSchemaCacheUpToDate^%qccServer(.arg1)
	If $data(output) Quit output 
	Quit $$ErrorText^%qccServer($$$ERROR($$$GeneralError,"Invalid function for %qccServer"))
]]></Implementation>
</Method>
</Class>
</Export>
